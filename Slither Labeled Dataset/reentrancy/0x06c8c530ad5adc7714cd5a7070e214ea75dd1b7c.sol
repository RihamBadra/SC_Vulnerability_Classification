


pragma solidity 0.8.3;


contract Ownable {
    address internal _owner;

    event OwnershipTransferred(address previousOwner, address newOwner);

    
    constructor (address addr) {
        require(addr != address(0), "non-zero address required");
        require(addr != address(1), "ecrecover address not allowed");
        _owner = addr;
        emit OwnershipTransferred(address(0), addr);
    }

    
    modifier onlyOwner() {
        require(isOwner(msg.sender), "Only owner requirement");
        _;
    }

    
    function transferOwnership (address addr) public onlyOwner {
        require(addr != address(0), "non-zero address required");
        emit OwnershipTransferred(_owner, addr);
        _owner = addr;
    }

    
    function destroy(address payable addr) public virtual onlyOwner {
        require(addr != address(0), "non-zero address required");
        require(addr != address(1), "ecrecover address not allowed");
        selfdestruct(addr);
    }

    
    function owner() public view returns (address) {
        return _owner;
    }

    
    function isOwner(address addr) public view returns (bool) {
        return addr == _owner;
    }
}


contract Controllable is Ownable {
    
    address internal _controllerAddress;

    
    constructor (address ownerAddr, address controllerAddr) Ownable (ownerAddr) {
        require(controllerAddr != address(0), "Controller address required");
        require(controllerAddr != ownerAddr, "Owner cannot be the Controller");
        _controllerAddress = controllerAddr;
    }

    
    modifier onlyController() {
        require(msg.sender == _controllerAddress, "Unauthorized controller");
        _;
    }

    
    modifier onlyOwnerOrController() {
        require(msg.sender == _controllerAddress || msg.sender == _owner, "Only owner or controller");
        _;
    }

    
    function setController (address controllerAddr) public onlyOwner {
        
        require(controllerAddr != address(0), "Controller address required");
        require(controllerAddr != _owner, "Owner cannot be the Controller");
        require(controllerAddr != _controllerAddress, "Controller already set");

        
        _controllerAddress = controllerAddr;
    }

    
    function getControllerAddress () public view returns (address) {
        return _controllerAddress;
    }
}


interface IAddressWhitelist {
    
    function enableAddress (address addr) external;

    
    function disableAddress (address addr) external;

    
    function isWhitelistedAddress (address addr) external view returns (bool);

    
    event OnAddressEnabled(address addr);

    
    event OnAddressDisabled(address addr);
}


contract CrosschainProviderConfigManager is Controllable {
    
    struct ConfigSetting {
        address routerAddress;
        bytes routingInfo;
    }

    
    mapping (bytes32 => ConfigSetting) private _routingData;

    
    constructor (address ownerAddr, address controllerAddr) Controllable (ownerAddr, controllerAddr) { 
    }

    
    function setRoute (bytes32 key, address routerAddress, bytes memory routingInfo) public onlyOwnerOrController {
        require(key != bytes32(0), "Key required");
        require(routerAddress != address(0), "Router address required");
        require(routingInfo.length > 0, "Routing info required");

        _routingData[key] = ConfigSetting(routerAddress, routingInfo);
    }

    
    function buildKey (address tokenAddr, bytes32 provider, bytes32 foreignNetwork) public pure returns (bytes32) {
        return keccak256(abi.encodePacked(provider, foreignNetwork, tokenAddr));
    }

    
    function getRoute (bytes32 key) public view returns (address routerAddress, bytes memory routingInfo) {
        routerAddress = _routingData[key].routerAddress;
        routingInfo = _routingData[key].routingInfo;
    }
}


contract AddressWhitelist is IAddressWhitelist, Ownable {
    mapping (address => bool) internal whitelistedAddresses;

    
    constructor (address ownerAddr) Ownable (ownerAddr) { 
    }

    
    function enableAddress (address addr) public override onlyOwner {
        require(!whitelistedAddresses[addr], "Already enabled");
        whitelistedAddresses[addr] = true;
        emit OnAddressEnabled(addr);
    }

    
    function disableAddress (address addr) public override onlyOwner {
        require(whitelistedAddresses[addr], "Already disabled");
        whitelistedAddresses[addr] = false;
        emit OnAddressDisabled(addr);
    }

    
    function isWhitelistedAddress (address addr) public view override returns (bool) {
        return whitelistedAddresses[addr];
    }
}


interface IERC20 {
    
    function transfer(address to, uint256 value) external returns (bool);

    
    function transferFrom(address from, address to, uint256 value) external returns (bool);

    
    function approve(address spender, uint256 value) external returns (bool);

    
    function totalSupply() external view returns (uint256);

    function decimals() external view returns (uint8);
    function name() external view returns (string memory);
    function symbol() external view returns (string memory);

    
    function balanceOf(address addr) external view returns (uint256);

    
    function allowance(address owner, address spender) external view returns (uint256);

    
    event Transfer(address indexed from, address indexed to, uint256 value);

    
    event Approval(address indexed owner, address indexed spender, uint256 value);
}


abstract contract BaseProvider is Controllable {
    CrosschainProviderConfigManager public configManager;
    AddressWhitelist internal _whitelist;
    
    event OnCrosschainTransfer (address routerAddress, uint256 destinationChainId, address fromAddress, address toAddress, uint256 amount);

    
    constructor (address ownerAddr, address controllerAddr, CrosschainProviderConfigManager newConfigManager, AddressWhitelist newWhitelist) Controllable (ownerAddr, controllerAddr) {
        configManager = newConfigManager;
        _whitelist = newWhitelist;
    }

    
    modifier onlyIfWhitelistedSender () {
        require(address(_whitelist) != address(0), "Whitelist not set");
        require(_whitelist.isWhitelistedAddress(msg.sender), "Sender not whitelisted");
        _;
    }

    
    function approveRouter (IERC20 tokenInterface, address routerAddr, uint256 spenderAmount) public onlyController {
        require(tokenInterface.approve(routerAddr, spenderAmount), "Approval failed");
    }

    
    function revokeRouter (IERC20 tokenInterface, address routerAddr) public onlyController {
        require(tokenInterface.approve(routerAddr, 0), "Revoke failed");
    }

    
    function executeTransfer (IERC20 underlyingTokenInterface, address destinationAddr, uint256 transferAmount, bytes32 foreignNetwork) public virtual;

    
    function getProviderHash() public pure virtual returns (bytes32);
}


library Utils {
    
    function isContract (address addr) internal view returns (bool) {
        bytes32 eoaHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;

        bytes32 codeHash;

        
        assembly { codeHash := extcodehash(addr) }

        return (codeHash != eoaHash && codeHash != 0x0);
    }
}

interface IDeployable {
    function deployCapital (uint256 deploymentAmount, bytes32 foreignNetwork) external;
    function claim (uint256 dailyInterestAmount) external;
}


contract YieldReserve is IDeployable, Controllable {
    struct ProviderData {
        BaseProvider providerContractInterface;
        address recipientAddress;
    }

    uint256 public deployedCapital;

    
    uint8 private _reentrancyMutexForCapital;

    
    uint8 private _reentrancyMutexForTransfers;

    
    IAddressWhitelist private immutable _whitelistInterface;

    
    address public vaultAddress;

    
    IERC20 public immutable tokenInterface;

    
    mapping (bytes32 => ProviderData) private _providers;

    
    event OnCapitalDeployed (address toAddress, address throughAddress, uint256 amount, bytes32 targetNetwork);

    constructor (address ownerAddr, address controllerAddr, IERC20 eip20Interface, IAddressWhitelist whitelistInterface) Controllable (ownerAddr, controllerAddr) {
        tokenInterface = eip20Interface;
        _whitelistInterface = whitelistInterface;
    }

    
    modifier vaultOnly() {
        require(vaultAddress != address(0) && msg.sender == vaultAddress, "Unauthorized caller");
        _;
    }

    
    modifier ifNotReentrantCapitalLock() {
        require(_reentrancyMutexForCapital == 0, "Reentrant capital lock rejected");
        _;
    }

    
    modifier ifNotTransferringFunds() {
        require(_reentrancyMutexForTransfers == 0, "Transfer in progress");
        _;
    }

    
    function setVaultAddress (address addr) public onlyOwnerOrController {
        require(addr != address(0) && addr != address(this), "Invalid vault address");
        require(Utils.isContract(addr), "The address must be a contract");

        vaultAddress = addr;
    }

    function setProvider (bytes32 foreignNetwork, BaseProvider xChainProvider, address recipientAddress) public onlyOwnerOrController {
        _providers[foreignNetwork] = ProviderData(xChainProvider, recipientAddress);
    }

    
    function transferToMultipleAddresses (address[] memory addresses, uint256[] memory amounts) public onlyOwnerOrController ifNotTransferringFunds {
        
        require(addresses.length > 0, "Addresses list required");
        require(amounts.length > 0, "Amounts required");
        require(addresses.length == amounts.length, "Invalid length for pairs");
        require(addresses.length < 11, "Max addresses limit reached");

        
        _reentrancyMutexForTransfers = 1;

        uint256 maxTransferAmount = tokenInterface.balanceOf(address(this));
        require(maxTransferAmount > 0, "Insufficient balance");

        uint256 total = 0;
        for (uint256 i = 0; i < addresses.length; i++) {
            require(addresses[i] != address(0) && addresses[i] != address(this), "Invalid address for transfer");
            require(amounts[i] > 0 && amounts[i] <= maxTransferAmount, "Invalid transfer amount");
            require(_whitelistInterface.isWhitelistedAddress(addresses[i]), "Address not whitelisted");
            total += amounts[i];
        }

        require(total <= maxTransferAmount, "Maximum transfer amount exceeded");

        
        for (uint256 i = 0; i < addresses.length; i++) {
            require(tokenInterface.transfer(addresses[i], amounts[i]), "Transfer failed");
        }

        
        _reentrancyMutexForTransfers = 0; 
    }

    function deployCapital (uint256 deploymentAmount, bytes32 foreignNetwork) public override onlyOwnerOrController ifNotReentrantCapitalLock {
        require(deploymentAmount > 0, "Deployment amount required");

        
        _reentrancyMutexForCapital = 1;

        deployedCapital += deploymentAmount;

        address recipientAddress = _providers[foreignNetwork].recipientAddress;
        address providerAddress = address(_providers[foreignNetwork].providerContractInterface);
        
        require(tokenInterface.transfer(providerAddress, deploymentAmount), "Provider transfer failed");

        
        _providers[foreignNetwork].providerContractInterface.executeTransfer(tokenInterface, recipientAddress, deploymentAmount, foreignNetwork);

        emit OnCapitalDeployed(recipientAddress, providerAddress, deploymentAmount, foreignNetwork);

        
        _reentrancyMutexForCapital = 0; 
    }

    function claim (uint256 dailyInterestAmount) public override vaultOnly {
        require(dailyInterestAmount > 0, "Amount required");

        address senderAddr = msg.sender;

        uint256 currentBalance = tokenInterface.balanceOf(address(this));
        require(currentBalance >= dailyInterestAmount, "Insufficient funds");

        require(tokenInterface.transfer(senderAddr, dailyInterestAmount), "Token transfer failed");
    }
}