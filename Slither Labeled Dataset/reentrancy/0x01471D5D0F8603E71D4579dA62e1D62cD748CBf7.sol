








pragma solidity ^0.8.0;


interface IERC165Upgradeable {
    
    function supportsInterface(bytes4 interfaceId) external view returns (bool);
}







pragma solidity ^0.8.0;


interface IERC721Upgradeable is IERC165Upgradeable {
    
    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);

    
    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);

    
    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);

    
    function balanceOf(address owner) external view returns (uint256 balance);

    
    function ownerOf(uint256 tokenId) external view returns (address owner);

    
    function safeTransferFrom(
        address from,
        address to,
        uint256 tokenId
    ) external;

    
    function transferFrom(
        address from,
        address to,
        uint256 tokenId
    ) external;

    
    function approve(address to, uint256 tokenId) external;

    
    function getApproved(uint256 tokenId) external view returns (address operator);

    
    function setApprovalForAll(address operator, bool _approved) external;

    
    function isApprovedForAll(address owner, address operator) external view returns (bool);

    
    function safeTransferFrom(
        address from,
        address to,
        uint256 tokenId,
        bytes calldata data
    ) external;
}







pragma solidity ^0.8.0;


interface IERC721Receiver {
    
    function onERC721Received(
        address operator,
        address from,
        uint256 tokenId,
        bytes calldata data
    ) external returns (bytes4);
}







pragma solidity ^0.8.0;


interface IERC721MetadataUpgradeable is IERC721Upgradeable {
    
    function name() external view returns (string memory);

    
    function symbol() external view returns (string memory);

    
    function tokenURI(uint256 tokenId) external view returns (string memory);
}







pragma solidity ^0.8.1;


library Address {
    
    function isContract(address account) internal view returns (bool) {
        
        
        

        return account.code.length > 0;
    }

    
    function sendValue(address payable recipient, uint256 amount) internal {
        require(address(this).balance >= amount, "Address: insufficient balance");

        (bool success, ) = recipient.call{value: amount}("");
        require(success, "Address: unable to send value, recipient may have reverted");
    }

    
    function functionCall(address target, bytes memory data) internal returns (bytes memory) {
        return functionCall(target, data, "Address: low-level call failed");
    }

    
    function functionCall(
        address target,
        bytes memory data,
        string memory errorMessage
    ) internal returns (bytes memory) {
        return functionCallWithValue(target, data, 0, errorMessage);
    }

    
    function functionCallWithValue(
        address target,
        bytes memory data,
        uint256 value
    ) internal returns (bytes memory) {
        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");
    }

    
    function functionCallWithValue(
        address target,
        bytes memory data,
        uint256 value,
        string memory errorMessage
    ) internal returns (bytes memory) {
        require(address(this).balance >= value, "Address: insufficient balance for call");
        require(isContract(target), "Address: call to non-contract");

        (bool success, bytes memory returndata) = target.call{value: value}(data);
        return verifyCallResult(success, returndata, errorMessage);
    }

    
    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {
        return functionStaticCall(target, data, "Address: low-level static call failed");
    }

    
    function functionStaticCall(
        address target,
        bytes memory data,
        string memory errorMessage
    ) internal view returns (bytes memory) {
        require(isContract(target), "Address: static call to non-contract");

        (bool success, bytes memory returndata) = target.staticcall(data);
        return verifyCallResult(success, returndata, errorMessage);
    }

    
    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {
        return functionDelegateCall(target, data, "Address: low-level delegate call failed");
    }

    
    function functionDelegateCall(
        address target,
        bytes memory data,
        string memory errorMessage
    ) internal returns (bytes memory) {
        require(isContract(target), "Address: delegate call to non-contract");

        (bool success, bytes memory returndata) = target.delegatecall(data);
        return verifyCallResult(success, returndata, errorMessage);
    }

    
    function verifyCallResult(
        bool success,
        bytes memory returndata,
        string memory errorMessage
    ) internal pure returns (bytes memory) {
        if (success) {
            return returndata;
        } else {
            
            if (returndata.length > 0) {
                

                assembly {
                    let returndata_size := mload(returndata)
                    revert(add(32, returndata), returndata_size)
                }
            } else {
                revert(errorMessage);
            }
        }
    }
}







pragma solidity ^0.8.1;


library AddressUpgradeable {
    
    function isContract(address account) internal view returns (bool) {
        
        
        

        return account.code.length > 0;
    }

    
    function sendValue(address payable recipient, uint256 amount) internal {
        require(address(this).balance >= amount, "Address: insufficient balance");

        (bool success, ) = recipient.call{value: amount}("");
        require(success, "Address: unable to send value, recipient may have reverted");
    }

    
    function functionCall(address target, bytes memory data) internal returns (bytes memory) {
        return functionCall(target, data, "Address: low-level call failed");
    }

    
    function functionCall(
        address target,
        bytes memory data,
        string memory errorMessage
    ) internal returns (bytes memory) {
        return functionCallWithValue(target, data, 0, errorMessage);
    }

    
    function functionCallWithValue(
        address target,
        bytes memory data,
        uint256 value
    ) internal returns (bytes memory) {
        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");
    }

    
    function functionCallWithValue(
        address target,
        bytes memory data,
        uint256 value,
        string memory errorMessage
    ) internal returns (bytes memory) {
        require(address(this).balance >= value, "Address: insufficient balance for call");
        require(isContract(target), "Address: call to non-contract");

        (bool success, bytes memory returndata) = target.call{value: value}(data);
        return verifyCallResult(success, returndata, errorMessage);
    }

    
    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {
        return functionStaticCall(target, data, "Address: low-level static call failed");
    }

    
    function functionStaticCall(
        address target,
        bytes memory data,
        string memory errorMessage
    ) internal view returns (bytes memory) {
        require(isContract(target), "Address: static call to non-contract");

        (bool success, bytes memory returndata) = target.staticcall(data);
        return verifyCallResult(success, returndata, errorMessage);
    }

    
    function verifyCallResult(
        bool success,
        bytes memory returndata,
        string memory errorMessage
    ) internal pure returns (bytes memory) {
        if (success) {
            return returndata;
        } else {
            
            if (returndata.length > 0) {
                

                assembly {
                    let returndata_size := mload(returndata)
                    revert(add(32, returndata), returndata_size)
                }
            } else {
                revert(errorMessage);
            }
        }
    }
}







pragma solidity ^0.8.0;


abstract contract Initializable {
    
    bool private _initialized;

    
    bool private _initializing;

    
    modifier initializer() {
        
        
        
        require(_initializing ? _isConstructor() : !_initialized, "Initializable: contract is already initialized");

        bool isTopLevelCall = !_initializing;
        if (isTopLevelCall) {
            _initializing = true;
            _initialized = true;
        }

        _;

        if (isTopLevelCall) {
            _initializing = false;
        }
    }

    
    modifier onlyInitializing() {
        require(_initializing, "Initializable: contract is not initializing");
        _;
    }

    function _isConstructor() private view returns (bool) {
        return !AddressUpgradeable.isContract(address(this));
    }
}







pragma solidity ^0.8.0;


abstract contract ContextUpgradeable is Initializable {
    function __Context_init() internal onlyInitializing {
    }

    function __Context_init_unchained() internal onlyInitializing {
    }
    function _msgSender() internal view virtual returns (address) {
        return msg.sender;
    }

    function _msgData() internal view virtual returns (bytes calldata) {
        return msg.data;
    }

    
    uint256[50] private __gap;
}







pragma solidity ^0.8.0;


library Strings {
    bytes16 private constant _HEX_SYMBOLS = "0123456789abcdef";

    
    function toString(uint256 value) internal pure returns (string memory) {
        
        

        if (value == 0) {
            return "0";
        }
        uint256 temp = value;
        uint256 digits;
        while (temp != 0) {
            digits++;
            temp /= 10;
        }
        bytes memory buffer = new bytes(digits);
        while (value != 0) {
            digits -= 1;
            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));
            value /= 10;
        }
        return string(buffer);
    }

    
    function toHexString(uint256 value) internal pure returns (string memory) {
        if (value == 0) {
            return "0x00";
        }
        uint256 temp = value;
        uint256 length = 0;
        while (temp != 0) {
            length++;
            temp >>= 8;
        }
        return toHexString(value, length);
    }

    
    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {
        bytes memory buffer = new bytes(2 * length + 2);
        buffer[0] = "0";
        buffer[1] = "x";
        for (uint256 i = 2 * length + 1; i > 1; --i) {
            buffer[i] = _HEX_SYMBOLS[value & 0xf];
            value >>= 4;
        }
        require(value == 0, "Strings: hex length insufficient");
        return string(buffer);
    }
}







pragma solidity ^0.8.0;



abstract contract ERC165Upgradeable is Initializable, IERC165Upgradeable {
    function __ERC165_init() internal onlyInitializing {
    }

    function __ERC165_init_unchained() internal onlyInitializing {
    }
    
    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {
        return interfaceId == type(IERC165Upgradeable).interfaceId;
    }

    
    uint256[50] private __gap;
}














pragma solidity 0.8.13;








error ApprovalCallerNotOwnerNorApproved();
error ApprovalQueryForNonexistentToken();
error ApproveToCaller();
error ApprovalToCurrentOwner();
error BalanceQueryForZeroAddress();
error MintToZeroAddress();
error MintZeroQuantity();
error OwnerQueryForNonexistentToken();
error TransferCallerNotOwnerNorApproved();
error TransferFromIncorrectOwner();
error TransferToNonERC721ReceiverImplementer();
error TransferToZeroAddress();
error URIQueryForNonexistentToken();
error AllOwnershipsHaveBeenSet();
error QuantityMustBeNonZero();
error NoTokensMintedYet();
error InvalidQueryRange();


contract ERC721ASBUpgradable is
    Initializable,
    ContextUpgradeable,
    ERC165Upgradeable,
    IERC721Upgradeable,
    IERC721MetadataUpgradeable
{
    using Address for address;
    using Strings for uint256;

    
    struct TokenOwnership {
        
        address addr;
        
        uint64 startTimestamp;
        
        bool burned;
    }

    
    struct AddressData {
        
        uint64 balance;
        
        uint64 numberMinted;
        
        uint64 numberBurned;
        
        
        
        uint64 aux;
    }

    
    uint256 internal _currentIndex;

    
    uint256 internal _burnCounter;

    
    string private _name;

    
    string private _symbol;

    
    
    mapping(uint256 => TokenOwnership) internal _ownerships;

    
    mapping(address => AddressData) private _addressData;

    
    mapping(uint256 => address) private _tokenApprovals;

    
    mapping(address => mapping(address => bool)) private _operatorApprovals;

    uint256 public nextOwnerToExplicitlySet;

    
    function setOwnersExplicit(uint256 quantity) public {
        if (quantity == 0) revert QuantityMustBeNonZero();
        if (_currentIndex == _startTokenId()) revert NoTokensMintedYet();
        uint256 _nextOwnerToExplicitlySet = nextOwnerToExplicitlySet;
        if (_nextOwnerToExplicitlySet == 0) {
            _nextOwnerToExplicitlySet = _startTokenId();
        }
        if (_nextOwnerToExplicitlySet >= _currentIndex)
            revert AllOwnershipsHaveBeenSet();

        
        
        unchecked {
            uint256 endIndex = _nextOwnerToExplicitlySet + quantity - 1;

            
            if (endIndex + 1 > _currentIndex) {
                endIndex = _currentIndex - 1;
            }

            for (uint256 i = _nextOwnerToExplicitlySet; i <= endIndex; i++) {
                if (
                    _ownerships[i].addr == address(0) && !_ownerships[i].burned
                ) {
                    TokenOwnership memory ownership = _ownershipOf(i);
                    _ownerships[i].addr = ownership.addr;
                    _ownerships[i].startTimestamp = ownership.startTimestamp;
                }
            }

            nextOwnerToExplicitlySet = endIndex + 1;
        }
    }

    
    function explicitOwnershipOf(uint256 tokenId)
        public
        view
        returns (TokenOwnership memory)
    {
        TokenOwnership memory ownership;
        if (tokenId < _startTokenId() || tokenId >= _currentIndex) {
            return ownership;
        }
        ownership = _ownerships[tokenId];
        if (ownership.burned) {
            return ownership;
        }
        return _ownershipOf(tokenId);
    }

    
    function explicitOwnershipsOf(uint256[] memory tokenIds)
        external
        view
        returns (TokenOwnership[] memory)
    {
        unchecked {
            uint256 tokenIdsLength = tokenIds.length;
            TokenOwnership[] memory ownerships = new TokenOwnership[](
                tokenIdsLength
            );
            for (uint256 i; i != tokenIdsLength; ++i) {
                ownerships[i] = explicitOwnershipOf(tokenIds[i]);
            }
            return ownerships;
        }
    }

    
    function tokensOfOwnerIn(
        address owner,
        uint256 start,
        uint256 stop
    ) external view returns (uint256[] memory) {
        unchecked {
            if (start >= stop) revert InvalidQueryRange();
            uint256 tokenIdsIdx;
            uint256 stopLimit = _currentIndex;
            
            if (start < _startTokenId()) {
                start = _startTokenId();
            }
            
            if (stop > stopLimit) {
                stop = stopLimit;
            }
            uint256 tokenIdsMaxLength = balanceOf(owner);
            
            
            if (start < stop) {
                uint256 rangeLength = stop - start;
                if (rangeLength < tokenIdsMaxLength) {
                    tokenIdsMaxLength = rangeLength;
                }
            } else {
                tokenIdsMaxLength = 0;
            }
            uint256[] memory tokenIds = new uint256[](tokenIdsMaxLength);
            if (tokenIdsMaxLength == 0) {
                return tokenIds;
            }
            
            
            TokenOwnership memory ownership = explicitOwnershipOf(start);
            address currOwnershipAddr;
            
            
            if (!ownership.burned) {
                currOwnershipAddr = ownership.addr;
            }
            for (
                uint256 i = start;
                i != stop && tokenIdsIdx != tokenIdsMaxLength;
                ++i
            ) {
                ownership = _ownerships[i];
                if (ownership.burned) {
                    continue;
                }
                if (ownership.addr != address(0)) {
                    currOwnershipAddr = ownership.addr;
                }
                if (currOwnershipAddr == owner) {
                    tokenIds[tokenIdsIdx++] = i;
                }
            }
            
            assembly {
                mstore(tokenIds, tokenIdsIdx)
            }
            return tokenIds;
        }
    }

    
    function tokensOfOwner(address owner)
        public
        view
        returns (uint256[] memory)
    {
        unchecked {
            uint256 tokenIdsIdx;
            address currOwnershipAddr;
            uint256 tokenIdsLength = balanceOf(owner);
            uint256[] memory tokenIds = new uint256[](tokenIdsLength);
            TokenOwnership memory ownership;
            for (
                uint256 i = _startTokenId();
                tokenIdsIdx != tokenIdsLength;
                ++i
            ) {
                ownership = _ownerships[i];
                if (ownership.burned) {
                    continue;
                }
                if (ownership.addr != address(0)) {
                    currOwnershipAddr = ownership.addr;
                }
                if (currOwnershipAddr == owner) {
                    tokenIds[tokenIdsIdx++] = i;
                }
            }
            return tokenIds;
        }
    }

    function __ERC721A_init(string memory name_, string memory symbol_)
        public
    {
        __Context_init_unchained();
        __ERC165_init_unchained();
        _name = name_;
        _symbol = symbol_;
        _currentIndex = _startTokenId();
    }

    
    function _startTokenId() internal view virtual returns (uint256) {
        return 1; 
    }

    
    function totalSupply() public view returns (uint256) {
        
        
        unchecked {
            return _currentIndex - _burnCounter - _startTokenId();
        }
    }

    
    function _totalMinted() internal view returns (uint256) {
        
        
        unchecked {
            return _currentIndex - _startTokenId();
        }
    }

    
    function supportsInterface(bytes4 interfaceId)
        public
        view
        virtual
        override(ERC165Upgradeable, IERC165Upgradeable)
        returns (bool)
    {
        return
            interfaceId == type(IERC721Upgradeable).interfaceId ||
            interfaceId == type(IERC721MetadataUpgradeable).interfaceId ||
            super.supportsInterface(interfaceId);
    }

    
    function balanceOf(address owner) public view override returns (uint256) {
        if (owner == address(0)) revert BalanceQueryForZeroAddress();
        return uint256(_addressData[owner].balance);
    }

    
    function _numberMinted(address owner) internal view returns (uint256) {
        return uint256(_addressData[owner].numberMinted);
    }

    
    function _numberBurned(address owner) internal view returns (uint256) {
        return uint256(_addressData[owner].numberBurned);
    }

    
    function _getAux(address owner) internal view returns (uint64) {
        return _addressData[owner].aux;
    }

    
    function _setAux(address owner, uint64 aux) internal {
        _addressData[owner].aux = aux;
    }

    
    function _ownershipOf(uint256 tokenId)
        internal
        view
        returns (TokenOwnership memory)
    {
        uint256 curr = tokenId;

        unchecked {
            if (_startTokenId() <= curr && curr < _currentIndex) {
                TokenOwnership memory ownership = _ownerships[curr];
                if (!ownership.burned) {
                    if (ownership.addr != address(0)) {
                        return ownership;
                    }
                    
                    
                    
                    
                    while (true) {
                        curr--;
                        ownership = _ownerships[curr];
                        if (ownership.addr != address(0)) {
                            return ownership;
                        }
                    }
                }
            }
        }
        revert OwnerQueryForNonexistentToken();
    }

    
    function ownerOf(uint256 tokenId) public view override returns (address) {
        return _ownershipOf(tokenId).addr;
    }

    
    function name() public view virtual override returns (string memory) {
        return _name;
    }

    
    function symbol() public view virtual override returns (string memory) {
        return _symbol;
    }

    
    function tokenURI(uint256 tokenId)
        public
        view
        virtual
        override
        returns (string memory)
    {
        if (!_exists(tokenId)) revert URIQueryForNonexistentToken();

        string memory baseURI = _baseURI();
        return
            bytes(baseURI).length != 0
                ? string(abi.encodePacked(baseURI, tokenId.toString()))
                : "";
    }

    
    function _baseURI() internal view virtual returns (string memory) {
        return "";
    }

    
    function approve(address to, uint256 tokenId) public override {
        address owner = ownerOf(tokenId);
        if (to == owner) revert ApprovalToCurrentOwner();

        if (_msgSender() != owner && !isApprovedForAll(owner, _msgSender())) {
            revert ApprovalCallerNotOwnerNorApproved();
        }

        _approve(to, tokenId, owner);
    }

    
    function getApproved(uint256 tokenId)
        public
        view
        override
        returns (address)
    {
        if (!_exists(tokenId)) revert ApprovalQueryForNonexistentToken();

        return _tokenApprovals[tokenId];
    }

    
    function setApprovalForAll(address operator, bool approved)
        public
        virtual
        override
    {
        if (operator == _msgSender()) revert ApproveToCaller();

        _operatorApprovals[_msgSender()][operator] = approved;
        emit ApprovalForAll(_msgSender(), operator, approved);
    }

    
    function isApprovedForAll(address owner, address operator)
        public
        view
        virtual
        override
        returns (bool)
    {
        return _operatorApprovals[owner][operator];
    }

    
    function transferFrom(
        address from,
        address to,
        uint256 tokenId
    ) public virtual override {
        _transfer(from, to, tokenId);
    }

    
    function safeTransferFrom(
        address from,
        address to,
        uint256 tokenId
    ) public virtual override {
        safeTransferFrom(from, to, tokenId, "");
    }

    
    function safeTransferFrom(
        address from,
        address to,
        uint256 tokenId,
        bytes memory _data
    ) public virtual override {
        _transfer(from, to, tokenId);
        if (
            to.isContract() &&
            !_checkContractOnERC721Received(from, to, tokenId, _data)
        ) {
            revert TransferToNonERC721ReceiverImplementer();
        }
    }

    
    function _exists(uint256 tokenId) internal view returns (bool) {
        return
            _startTokenId() <= tokenId &&
            tokenId < _currentIndex &&
            !_ownerships[tokenId].burned;
    }

    
    function _safeMint(address to, uint256 quantity) internal {
        _safeMint(to, quantity, "");
    }

    
    function _safeMint(
        address to,
        uint256 quantity,
        bytes memory _data
    ) internal {
        uint256 startTokenId = _currentIndex;
        if (to == address(0)) revert MintToZeroAddress();
        if (quantity == 0) revert MintZeroQuantity();

        _beforeTokenTransfers(address(0), to, startTokenId, quantity);

        
        
        
        unchecked {
            _addressData[to].balance += uint64(quantity);
            _addressData[to].numberMinted += uint64(quantity);

            _ownerships[startTokenId].addr = to;
            _ownerships[startTokenId].startTimestamp = uint64(block.timestamp);

            uint256 updatedIndex = startTokenId;
            uint256 end = updatedIndex + quantity;

            if (to.isContract()) {
                do {
                    emit Transfer(address(0), to, updatedIndex);
                    if (
                        !_checkContractOnERC721Received(
                            address(0),
                            to,
                            updatedIndex++,
                            _data
                        )
                    ) {
                        revert TransferToNonERC721ReceiverImplementer();
                    }
                } while (updatedIndex != end);
                
                if (_currentIndex != startTokenId) revert();
            } else {
                do {
                    emit Transfer(address(0), to, updatedIndex++);
                } while (updatedIndex != end);
            }
            _currentIndex = updatedIndex;
        }
        _afterTokenTransfers(address(0), to, startTokenId, quantity);
    }

    
    function _mint(address to, uint256 quantity) internal {
        uint256 startTokenId = _currentIndex;
        if (to == address(0)) revert MintToZeroAddress();
        if (quantity == 0) revert MintZeroQuantity();

        _beforeTokenTransfers(address(0), to, startTokenId, quantity);

        
        
        
        unchecked {
            _addressData[to].balance += uint64(quantity);
            _addressData[to].numberMinted += uint64(quantity);

            _ownerships[startTokenId].addr = to;
            _ownerships[startTokenId].startTimestamp = uint64(block.timestamp);

            uint256 updatedIndex = startTokenId;
            uint256 end = updatedIndex + quantity;

            do {
                emit Transfer(address(0), to, updatedIndex++);
            } while (updatedIndex != end);

            _currentIndex = updatedIndex;
        }
        _afterTokenTransfers(address(0), to, startTokenId, quantity);
    }

    
    function _transfer(
        address from,
        address to,
        uint256 tokenId
    ) private {
        TokenOwnership memory prevOwnership = _ownershipOf(tokenId);

        if (prevOwnership.addr != from) revert TransferFromIncorrectOwner();

        bool isApprovedOrOwner = (_msgSender() == from ||
            isApprovedForAll(from, _msgSender()) ||
            getApproved(tokenId) == _msgSender());

        if (!isApprovedOrOwner) revert TransferCallerNotOwnerNorApproved();
        if (to == address(0)) revert TransferToZeroAddress();

        _beforeTokenTransfers(from, to, tokenId, 1);

        
        _approve(address(0), tokenId, from);

        
        
        
        unchecked {
            _addressData[from].balance -= 1;
            _addressData[to].balance += 1;

            TokenOwnership storage currSlot = _ownerships[tokenId];
            currSlot.addr = to;
            currSlot.startTimestamp = uint64(block.timestamp);

            
            
            uint256 nextTokenId = tokenId + 1;
            TokenOwnership storage nextSlot = _ownerships[nextTokenId];
            if (nextSlot.addr == address(0)) {
                
                
                if (nextTokenId != _currentIndex) {
                    nextSlot.addr = from;
                    nextSlot.startTimestamp = prevOwnership.startTimestamp;
                }
            }
        }

        emit Transfer(from, to, tokenId);
        _afterTokenTransfers(from, to, tokenId, 1);
    }

    
    function _burn(uint256 tokenId) internal virtual {
        _burn(tokenId, false);
    }

    
    function _burn(uint256 tokenId, bool approvalCheck) internal virtual {
        TokenOwnership memory prevOwnership = _ownershipOf(tokenId);

        address from = prevOwnership.addr;

        if (approvalCheck) {
            bool isApprovedOrOwner = (_msgSender() == from ||
                isApprovedForAll(from, _msgSender()) ||
                getApproved(tokenId) == _msgSender());

            if (!isApprovedOrOwner) revert TransferCallerNotOwnerNorApproved();
        }

        _beforeTokenTransfers(from, address(0), tokenId, 1);

        
        _approve(address(0), tokenId, from);

        
        
        
        unchecked {
            AddressData storage addressData = _addressData[from];
            addressData.balance -= 1;
            addressData.numberBurned += 1;

            
            TokenOwnership storage currSlot = _ownerships[tokenId];
            currSlot.addr = from;
            currSlot.startTimestamp = uint64(block.timestamp);
            currSlot.burned = true;

            
            
            uint256 nextTokenId = tokenId + 1;
            TokenOwnership storage nextSlot = _ownerships[nextTokenId];
            if (nextSlot.addr == address(0)) {
                
                
                if (nextTokenId != _currentIndex) {
                    nextSlot.addr = from;
                    nextSlot.startTimestamp = prevOwnership.startTimestamp;
                }
            }
        }

        emit Transfer(from, address(0), tokenId);
        _afterTokenTransfers(from, address(0), tokenId, 1);

        
        unchecked {
            _burnCounter++;
        }
    }

    
    function _approve(
        address to,
        uint256 tokenId,
        address owner
    ) private {
        _tokenApprovals[tokenId] = to;
        emit Approval(owner, to, tokenId);
    }

    
    function _checkContractOnERC721Received(
        address from,
        address to,
        uint256 tokenId,
        bytes memory _data
    ) private returns (bool) {
        try
            IERC721Receiver(to).onERC721Received(
                _msgSender(),
                from,
                tokenId,
                _data
            )
        returns (bytes4 retval) {
            return retval == IERC721Receiver(to).onERC721Received.selector;
        } catch (bytes memory reason) {
            if (reason.length == 0) {
                revert TransferToNonERC721ReceiverImplementer();
            } else {
                assembly {
                    revert(add(32, reason), mload(reason))
                }
            }
        }
    }

    
    function _beforeTokenTransfers(
        address from,
        address to,
        uint256 startTokenId,
        uint256 quantity
    ) internal virtual {}

    
    function _afterTokenTransfers(
        address from,
        address to,
        uint256 startTokenId,
        uint256 quantity
    ) internal virtual {}
}







pragma solidity ^0.8.0;


interface IAccessControl {
    
    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);

    
    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);

    
    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);

    
    function hasRole(bytes32 role, address account) external view returns (bool);

    
    function getRoleAdmin(bytes32 role) external view returns (bytes32);

    
    function grantRole(bytes32 role, address account) external;

    
    function revokeRole(bytes32 role, address account) external;

    
    function renounceRole(bytes32 role, address account) external;
}







pragma solidity ^0.8.0;


abstract contract Context {
    function _msgSender() internal view virtual returns (address) {
        return msg.sender;
    }

    function _msgData() internal view virtual returns (bytes calldata) {
        return msg.data;
    }
}







pragma solidity ^0.8.0;


interface IERC165 {
    
    function supportsInterface(bytes4 interfaceId) external view returns (bool);
}







pragma solidity ^0.8.0;


abstract contract ERC165 is IERC165 {
    
    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {
        return interfaceId == type(IERC165).interfaceId;
    }
}







pragma solidity ^0.8.0;





abstract contract AccessControl is Context, IAccessControl, ERC165 {
    struct RoleData {
        mapping(address => bool) members;
        bytes32 adminRole;
    }

    mapping(bytes32 => RoleData) private _roles;

    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;

    
    modifier onlyRole(bytes32 role) {
        _checkRole(role);
        _;
    }

    
    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {
        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);
    }

    
    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {
        return _roles[role].members[account];
    }

    
    function _checkRole(bytes32 role) internal view virtual {
        _checkRole(role, _msgSender());
    }

    
    function _checkRole(bytes32 role, address account) internal view virtual {
        if (!hasRole(role, account)) {
            revert(
                string(
                    abi.encodePacked(
                        "AccessControl: account ",
                        Strings.toHexString(uint160(account), 20),
                        " is missing role ",
                        Strings.toHexString(uint256(role), 32)
                    )
                )
            );
        }
    }

    
    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {
        return _roles[role].adminRole;
    }

    
    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {
        _grantRole(role, account);
    }

    
    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {
        _revokeRole(role, account);
    }

    
    function renounceRole(bytes32 role, address account) public virtual override {
        require(account == _msgSender(), "AccessControl: can only renounce roles for self");

        _revokeRole(role, account);
    }

    
    function _setupRole(bytes32 role, address account) internal virtual {
        _grantRole(role, account);
    }

    
    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {
        bytes32 previousAdminRole = getRoleAdmin(role);
        _roles[role].adminRole = adminRole;
        emit RoleAdminChanged(role, previousAdminRole, adminRole);
    }

    
    function _grantRole(bytes32 role, address account) internal virtual {
        if (!hasRole(role, account)) {
            _roles[role].members[account] = true;
            emit RoleGranted(role, account, _msgSender());
        }
    }

    
    function _revokeRole(bytes32 role, address account) internal virtual {
        if (hasRole(role, account)) {
            _roles[role].members[account] = false;
            emit RoleRevoked(role, account, _msgSender());
        }
    }
}










pragma solidity 0.8.13;

contract Lighthouse is AccessControl {
    bytes32 public constant DEPLOYER_ROLE = keccak256("DEPLOYER");
    string public constant MODEL = "SBII-Lighthouse-test";

    event newContract(address ad, string name, string contractType);
    mapping(string => mapping(string => address)) public projectAddress;
    mapping(string => address) public nameOwner;
    mapping(address => string[]) private registeredProject;

    constructor() {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
    }

    function listRegistered(address wallet)
        public
        view
        returns (string[] memory)
    {
        return registeredProject[wallet];
    }

    function registerContract(
        string memory name,
        address target,
        string memory contractType,
        address requester
    ) public onlyRole(DEPLOYER_ROLE) {
        if (nameOwner[name] == address(0)) {
            nameOwner[name] = requester;
            registeredProject[requester].push(name);
        } else {
            require(nameOwner[name] == requester, "taken");
        }
        require(projectAddress[name][contractType] == address(0), "taken");
        projectAddress[name][contractType] = target;
        emit newContract(target, name, contractType);
    }

    function giveUpContract(string memory name, string memory contractType)
        public
    {
        require(nameOwner[name] == msg.sender, "not your name");
        projectAddress[name][contractType] = address(0);
    }

    function giveUpName(string memory name) public {
        require(nameOwner[name] == msg.sender, "not your name");
        nameOwner[name] = address(0);
    }

    function yeetContract(string memory name, string memory contractType)
        public
        onlyRole(DEFAULT_ADMIN_ROLE)
    {
        projectAddress[name][contractType] = address(0);
    }

    function yeetName(string memory name) public onlyRole(DEFAULT_ADMIN_ROLE) {
        nameOwner[name] = address(0);
    }
}







pragma solidity ^0.8.0;


interface IERC20 {
    
    event Transfer(address indexed from, address indexed to, uint256 value);

    
    event Approval(address indexed owner, address indexed spender, uint256 value);

    
    function totalSupply() external view returns (uint256);

    
    function balanceOf(address account) external view returns (uint256);

    
    function transfer(address to, uint256 amount) external returns (bool);

    
    function allowance(address owner, address spender) external view returns (uint256);

    
    function approve(address spender, uint256 amount) external returns (bool);

    
    function transferFrom(
        address from,
        address to,
        uint256 amount
    ) external returns (bool);
}







pragma solidity ^0.8.0;



library SafeERC20 {
    using Address for address;

    function safeTransfer(
        IERC20 token,
        address to,
        uint256 value
    ) internal {
        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));
    }

    function safeTransferFrom(
        IERC20 token,
        address from,
        address to,
        uint256 value
    ) internal {
        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));
    }

    
    function safeApprove(
        IERC20 token,
        address spender,
        uint256 value
    ) internal {
        
        
        
        require(
            (value == 0) || (token.allowance(address(this), spender) == 0),
            "SafeERC20: approve from non-zero to non-zero allowance"
        );
        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));
    }

    function safeIncreaseAllowance(
        IERC20 token,
        address spender,
        uint256 value
    ) internal {
        uint256 newAllowance = token.allowance(address(this), spender) + value;
        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
    }

    function safeDecreaseAllowance(
        IERC20 token,
        address spender,
        uint256 value
    ) internal {
        unchecked {
            uint256 oldAllowance = token.allowance(address(this), spender);
            require(oldAllowance >= value, "SafeERC20: decreased allowance below zero");
            uint256 newAllowance = oldAllowance - value;
            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
        }
    }

    
    function _callOptionalReturn(IERC20 token, bytes memory data) private {
        
        
        

        bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");
        if (returndata.length > 0) {
            
            require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");
        }
    }
}










pragma solidity 0.8.13;


library paymentUtil {
    using SafeERC20 for IERC20;

    function processPayment(address token, uint256 amount) public {
        if (token == address(0)) {
            require(msg.value >= amount, "invalid payment");
        } else {
            IERC20(token).safeTransferFrom(msg.sender, address(this), amount);
        }
    }
}










pragma solidity 0.8.13;

contract Quartermaster is AccessControl {
    bytes32 public constant QUATERMASTER_ROLE = keccak256("QUATERMASTER");
    string public constant MODEL = "SBII-Quartermaster-test";

    struct Fees {
        uint128 onetime;
        uint128 bip;
        address token;
    }
    event updateFees(uint128 onetime, uint128 bip, address token);
    mapping(bytes32 => Fees) serviceFees;

    constructor() {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setupRole(QUATERMASTER_ROLE, msg.sender);
    }

    function setFees(
        string memory key,
        uint128 _onetime,
        uint128 _bip,
        address _token
    ) public onlyRole(QUATERMASTER_ROLE) {
        serviceFees[keccak256(abi.encode(key))] = Fees({
            onetime: _onetime,
            bip: _bip,
            token: _token
        });
        emit updateFees(_onetime, _bip, _token);
    }

    function getFees(string memory key) public view returns (Fees memory) {
        return serviceFees[keccak256(abi.encode(key))];
    }
}







pragma solidity ^0.8.0;


interface IERC721ReceiverUpgradeable {
    
    function onERC721Received(
        address operator,
        address from,
        uint256 tokenId,
        bytes calldata data
    ) external returns (bytes4);
}







pragma solidity ^0.8.0;


library StringsUpgradeable {
    bytes16 private constant _HEX_SYMBOLS = "0123456789abcdef";

    
    function toString(uint256 value) internal pure returns (string memory) {
        
        

        if (value == 0) {
            return "0";
        }
        uint256 temp = value;
        uint256 digits;
        while (temp != 0) {
            digits++;
            temp /= 10;
        }
        bytes memory buffer = new bytes(digits);
        while (value != 0) {
            digits -= 1;
            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));
            value /= 10;
        }
        return string(buffer);
    }

    
    function toHexString(uint256 value) internal pure returns (string memory) {
        if (value == 0) {
            return "0x00";
        }
        uint256 temp = value;
        uint256 length = 0;
        while (temp != 0) {
            length++;
            temp >>= 8;
        }
        return toHexString(value, length);
    }

    
    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {
        bytes memory buffer = new bytes(2 * length + 2);
        buffer[0] = "0";
        buffer[1] = "x";
        for (uint256 i = 2 * length + 1; i > 1; --i) {
            buffer[i] = _HEX_SYMBOLS[value & 0xf];
            value >>= 4;
        }
        require(value == 0, "Strings: hex length insufficient");
        return string(buffer);
    }
}







pragma solidity ^0.8.0;









contract ERC721Upgradeable is Initializable, ContextUpgradeable, ERC165Upgradeable, IERC721Upgradeable, IERC721MetadataUpgradeable {
    using AddressUpgradeable for address;
    using StringsUpgradeable for uint256;

    
    string private _name;

    
    string private _symbol;

    
    mapping(uint256 => address) private _owners;

    
    mapping(address => uint256) private _balances;

    
    mapping(uint256 => address) private _tokenApprovals;

    
    mapping(address => mapping(address => bool)) private _operatorApprovals;

    
    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {
        __ERC721_init_unchained(name_, symbol_);
    }

    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {
        _name = name_;
        _symbol = symbol_;
    }

    
    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165Upgradeable) returns (bool) {
        return
            interfaceId == type(IERC721Upgradeable).interfaceId ||
            interfaceId == type(IERC721MetadataUpgradeable).interfaceId ||
            super.supportsInterface(interfaceId);
    }

    
    function balanceOf(address owner) public view virtual override returns (uint256) {
        require(owner != address(0), "ERC721: balance query for the zero address");
        return _balances[owner];
    }

    
    function ownerOf(uint256 tokenId) public view virtual override returns (address) {
        address owner = _owners[tokenId];
        require(owner != address(0), "ERC721: owner query for nonexistent token");
        return owner;
    }

    
    function name() public view virtual override returns (string memory) {
        return _name;
    }

    
    function symbol() public view virtual override returns (string memory) {
        return _symbol;
    }

    
    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {
        require(_exists(tokenId), "ERC721Metadata: URI query for nonexistent token");

        string memory baseURI = _baseURI();
        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : "";
    }

    
    function _baseURI() internal view virtual returns (string memory) {
        return "";
    }

    
    function approve(address to, uint256 tokenId) public virtual override {
        address owner = ERC721Upgradeable.ownerOf(tokenId);
        require(to != owner, "ERC721: approval to current owner");

        require(
            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),
            "ERC721: approve caller is not owner nor approved for all"
        );

        _approve(to, tokenId);
    }

    
    function getApproved(uint256 tokenId) public view virtual override returns (address) {
        require(_exists(tokenId), "ERC721: approved query for nonexistent token");

        return _tokenApprovals[tokenId];
    }

    
    function setApprovalForAll(address operator, bool approved) public virtual override {
        _setApprovalForAll(_msgSender(), operator, approved);
    }

    
    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {
        return _operatorApprovals[owner][operator];
    }

    
    function transferFrom(
        address from,
        address to,
        uint256 tokenId
    ) public virtual override {
        
        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: transfer caller is not owner nor approved");

        _transfer(from, to, tokenId);
    }

    
    function safeTransferFrom(
        address from,
        address to,
        uint256 tokenId
    ) public virtual override {
        safeTransferFrom(from, to, tokenId, "");
    }

    
    function safeTransferFrom(
        address from,
        address to,
        uint256 tokenId,
        bytes memory _data
    ) public virtual override {
        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: transfer caller is not owner nor approved");
        _safeTransfer(from, to, tokenId, _data);
    }

    
    function _safeTransfer(
        address from,
        address to,
        uint256 tokenId,
        bytes memory _data
    ) internal virtual {
        _transfer(from, to, tokenId);
        require(_checkOnERC721Received(from, to, tokenId, _data), "ERC721: transfer to non ERC721Receiver implementer");
    }

    
    function _exists(uint256 tokenId) internal view virtual returns (bool) {
        return _owners[tokenId] != address(0);
    }

    
    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {
        require(_exists(tokenId), "ERC721: operator query for nonexistent token");
        address owner = ERC721Upgradeable.ownerOf(tokenId);
        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));
    }

    
    function _safeMint(address to, uint256 tokenId) internal virtual {
        _safeMint(to, tokenId, "");
    }

    
    function _safeMint(
        address to,
        uint256 tokenId,
        bytes memory _data
    ) internal virtual {
        _mint(to, tokenId);
        require(
            _checkOnERC721Received(address(0), to, tokenId, _data),
            "ERC721: transfer to non ERC721Receiver implementer"
        );
    }

    
    function _mint(address to, uint256 tokenId) internal virtual {
        require(to != address(0), "ERC721: mint to the zero address");
        require(!_exists(tokenId), "ERC721: token already minted");

        _beforeTokenTransfer(address(0), to, tokenId);

        _balances[to] += 1;
        _owners[tokenId] = to;

        emit Transfer(address(0), to, tokenId);

        _afterTokenTransfer(address(0), to, tokenId);
    }

    
    function _burn(uint256 tokenId) internal virtual {
        address owner = ERC721Upgradeable.ownerOf(tokenId);

        _beforeTokenTransfer(owner, address(0), tokenId);

        
        _approve(address(0), tokenId);

        _balances[owner] -= 1;
        delete _owners[tokenId];

        emit Transfer(owner, address(0), tokenId);

        _afterTokenTransfer(owner, address(0), tokenId);
    }

    
    function _transfer(
        address from,
        address to,
        uint256 tokenId
    ) internal virtual {
        require(ERC721Upgradeable.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");
        require(to != address(0), "ERC721: transfer to the zero address");

        _beforeTokenTransfer(from, to, tokenId);

        
        _approve(address(0), tokenId);

        _balances[from] -= 1;
        _balances[to] += 1;
        _owners[tokenId] = to;

        emit Transfer(from, to, tokenId);

        _afterTokenTransfer(from, to, tokenId);
    }

    
    function _approve(address to, uint256 tokenId) internal virtual {
        _tokenApprovals[tokenId] = to;
        emit Approval(ERC721Upgradeable.ownerOf(tokenId), to, tokenId);
    }

    
    function _setApprovalForAll(
        address owner,
        address operator,
        bool approved
    ) internal virtual {
        require(owner != operator, "ERC721: approve to caller");
        _operatorApprovals[owner][operator] = approved;
        emit ApprovalForAll(owner, operator, approved);
    }

    
    function _checkOnERC721Received(
        address from,
        address to,
        uint256 tokenId,
        bytes memory _data
    ) private returns (bool) {
        if (to.isContract()) {
            try IERC721ReceiverUpgradeable(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {
                return retval == IERC721ReceiverUpgradeable.onERC721Received.selector;
            } catch (bytes memory reason) {
                if (reason.length == 0) {
                    revert("ERC721: transfer to non ERC721Receiver implementer");
                } else {
                    assembly {
                        revert(add(32, reason), mload(reason))
                    }
                }
            }
        } else {
            return true;
        }
    }

    
    function _beforeTokenTransfer(
        address from,
        address to,
        uint256 tokenId
    ) internal virtual {}

    
    function _afterTokenTransfer(
        address from,
        address to,
        uint256 tokenId
    ) internal virtual {}

    
    uint256[44] private __gap;
}







pragma solidity ^0.8.0;


interface IERC721EnumerableUpgradeable is IERC721Upgradeable {
    
    function totalSupply() external view returns (uint256);

    
    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256);

    
    function tokenByIndex(uint256 index) external view returns (uint256);
}







pragma solidity ^0.8.0;




abstract contract ERC721EnumerableUpgradeable is Initializable, ERC721Upgradeable, IERC721EnumerableUpgradeable {
    function __ERC721Enumerable_init() internal onlyInitializing {
    }

    function __ERC721Enumerable_init_unchained() internal onlyInitializing {
    }
    
    mapping(address => mapping(uint256 => uint256)) private _ownedTokens;

    
    mapping(uint256 => uint256) private _ownedTokensIndex;

    
    uint256[] private _allTokens;

    
    mapping(uint256 => uint256) private _allTokensIndex;

    
    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165Upgradeable, ERC721Upgradeable) returns (bool) {
        return interfaceId == type(IERC721EnumerableUpgradeable).interfaceId || super.supportsInterface(interfaceId);
    }

    
    function tokenOfOwnerByIndex(address owner, uint256 index) public view virtual override returns (uint256) {
        require(index < ERC721Upgradeable.balanceOf(owner), "ERC721Enumerable: owner index out of bounds");
        return _ownedTokens[owner][index];
    }

    
    function totalSupply() public view virtual override returns (uint256) {
        return _allTokens.length;
    }

    
    function tokenByIndex(uint256 index) public view virtual override returns (uint256) {
        require(index < ERC721EnumerableUpgradeable.totalSupply(), "ERC721Enumerable: global index out of bounds");
        return _allTokens[index];
    }

    
    function _beforeTokenTransfer(
        address from,
        address to,
        uint256 tokenId
    ) internal virtual override {
        super._beforeTokenTransfer(from, to, tokenId);

        if (from == address(0)) {
            _addTokenToAllTokensEnumeration(tokenId);
        } else if (from != to) {
            _removeTokenFromOwnerEnumeration(from, tokenId);
        }
        if (to == address(0)) {
            _removeTokenFromAllTokensEnumeration(tokenId);
        } else if (to != from) {
            _addTokenToOwnerEnumeration(to, tokenId);
        }
    }

    
    function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {
        uint256 length = ERC721Upgradeable.balanceOf(to);
        _ownedTokens[to][length] = tokenId;
        _ownedTokensIndex[tokenId] = length;
    }

    
    function _addTokenToAllTokensEnumeration(uint256 tokenId) private {
        _allTokensIndex[tokenId] = _allTokens.length;
        _allTokens.push(tokenId);
    }

    
    function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {
        
        

        uint256 lastTokenIndex = ERC721Upgradeable.balanceOf(from) - 1;
        uint256 tokenIndex = _ownedTokensIndex[tokenId];

        
        if (tokenIndex != lastTokenIndex) {
            uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];

            _ownedTokens[from][tokenIndex] = lastTokenId; 
            _ownedTokensIndex[lastTokenId] = tokenIndex; 
        }

        
        delete _ownedTokensIndex[tokenId];
        delete _ownedTokens[from][lastTokenIndex];
    }

    
    function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {
        
        

        uint256 lastTokenIndex = _allTokens.length - 1;
        uint256 tokenIndex = _allTokensIndex[tokenId];

        
        
        
        uint256 lastTokenId = _allTokens[lastTokenIndex];

        _allTokens[tokenIndex] = lastTokenId; 
        _allTokensIndex[lastTokenId] = tokenIndex; 

        
        delete _allTokensIndex[tokenId];
        _allTokens.pop();
    }

    
    uint256[46] private __gap;
}







pragma solidity ^0.8.0;


abstract contract ReentrancyGuardUpgradeable is Initializable {
    
    
    
    
    

    
    
    
    
    
    uint256 private constant _NOT_ENTERED = 1;
    uint256 private constant _ENTERED = 2;

    uint256 private _status;

    function __ReentrancyGuard_init() internal onlyInitializing {
        __ReentrancyGuard_init_unchained();
    }

    function __ReentrancyGuard_init_unchained() internal onlyInitializing {
        _status = _NOT_ENTERED;
    }

    
    modifier nonReentrant() {
        
        require(_status != _ENTERED, "ReentrancyGuard: reentrant call");

        
        _status = _ENTERED;

        _;

        
        
        _status = _NOT_ENTERED;
    }

    
    uint256[49] private __gap;
}







pragma solidity ^0.8.0;


interface IAccessControlUpgradeable {
    
    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);

    
    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);

    
    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);

    
    function hasRole(bytes32 role, address account) external view returns (bool);

    
    function getRoleAdmin(bytes32 role) external view returns (bytes32);

    
    function grantRole(bytes32 role, address account) external;

    
    function revokeRole(bytes32 role, address account) external;

    
    function renounceRole(bytes32 role, address account) external;
}







pragma solidity ^0.8.0;


interface IAccessControlEnumerableUpgradeable is IAccessControlUpgradeable {
    
    function getRoleMember(bytes32 role, uint256 index) external view returns (address);

    
    function getRoleMemberCount(bytes32 role) external view returns (uint256);
}







pragma solidity ^0.8.0;






abstract contract AccessControlUpgradeable is Initializable, ContextUpgradeable, IAccessControlUpgradeable, ERC165Upgradeable {
    function __AccessControl_init() internal onlyInitializing {
    }

    function __AccessControl_init_unchained() internal onlyInitializing {
    }
    struct RoleData {
        mapping(address => bool) members;
        bytes32 adminRole;
    }

    mapping(bytes32 => RoleData) private _roles;

    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;

    
    modifier onlyRole(bytes32 role) {
        _checkRole(role, _msgSender());
        _;
    }

    
    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {
        return interfaceId == type(IAccessControlUpgradeable).interfaceId || super.supportsInterface(interfaceId);
    }

    
    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {
        return _roles[role].members[account];
    }

    
    function _checkRole(bytes32 role, address account) internal view virtual {
        if (!hasRole(role, account)) {
            revert(
                string(
                    abi.encodePacked(
                        "AccessControl: account ",
                        StringsUpgradeable.toHexString(uint160(account), 20),
                        " is missing role ",
                        StringsUpgradeable.toHexString(uint256(role), 32)
                    )
                )
            );
        }
    }

    
    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {
        return _roles[role].adminRole;
    }

    
    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {
        _grantRole(role, account);
    }

    
    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {
        _revokeRole(role, account);
    }

    
    function renounceRole(bytes32 role, address account) public virtual override {
        require(account == _msgSender(), "AccessControl: can only renounce roles for self");

        _revokeRole(role, account);
    }

    
    function _setupRole(bytes32 role, address account) internal virtual {
        _grantRole(role, account);
    }

    
    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {
        bytes32 previousAdminRole = getRoleAdmin(role);
        _roles[role].adminRole = adminRole;
        emit RoleAdminChanged(role, previousAdminRole, adminRole);
    }

    
    function _grantRole(bytes32 role, address account) internal virtual {
        if (!hasRole(role, account)) {
            _roles[role].members[account] = true;
            emit RoleGranted(role, account, _msgSender());
        }
    }

    
    function _revokeRole(bytes32 role, address account) internal virtual {
        if (hasRole(role, account)) {
            _roles[role].members[account] = false;
            emit RoleRevoked(role, account, _msgSender());
        }
    }

    
    uint256[49] private __gap;
}







pragma solidity ^0.8.0;


library EnumerableSetUpgradeable {
    
    
    
    
    
    
    
    

    struct Set {
        
        bytes32[] _values;
        
        
        mapping(bytes32 => uint256) _indexes;
    }

    
    function _add(Set storage set, bytes32 value) private returns (bool) {
        if (!_contains(set, value)) {
            set._values.push(value);
            
            
            set._indexes[value] = set._values.length;
            return true;
        } else {
            return false;
        }
    }

    
    function _remove(Set storage set, bytes32 value) private returns (bool) {
        
        uint256 valueIndex = set._indexes[value];

        if (valueIndex != 0) {
            
            
            
            

            uint256 toDeleteIndex = valueIndex - 1;
            uint256 lastIndex = set._values.length - 1;

            if (lastIndex != toDeleteIndex) {
                bytes32 lastvalue = set._values[lastIndex];

                
                set._values[toDeleteIndex] = lastvalue;
                
                set._indexes[lastvalue] = valueIndex; 
            }

            
            set._values.pop();

            
            delete set._indexes[value];

            return true;
        } else {
            return false;
        }
    }

    
    function _contains(Set storage set, bytes32 value) private view returns (bool) {
        return set._indexes[value] != 0;
    }

    
    function _length(Set storage set) private view returns (uint256) {
        return set._values.length;
    }

    
    function _at(Set storage set, uint256 index) private view returns (bytes32) {
        return set._values[index];
    }

    
    function _values(Set storage set) private view returns (bytes32[] memory) {
        return set._values;
    }

    

    struct Bytes32Set {
        Set _inner;
    }

    
    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {
        return _add(set._inner, value);
    }

    
    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {
        return _remove(set._inner, value);
    }

    
    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {
        return _contains(set._inner, value);
    }

    
    function length(Bytes32Set storage set) internal view returns (uint256) {
        return _length(set._inner);
    }

    
    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {
        return _at(set._inner, index);
    }

    
    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {
        return _values(set._inner);
    }

    

    struct AddressSet {
        Set _inner;
    }

    
    function add(AddressSet storage set, address value) internal returns (bool) {
        return _add(set._inner, bytes32(uint256(uint160(value))));
    }

    
    function remove(AddressSet storage set, address value) internal returns (bool) {
        return _remove(set._inner, bytes32(uint256(uint160(value))));
    }

    
    function contains(AddressSet storage set, address value) internal view returns (bool) {
        return _contains(set._inner, bytes32(uint256(uint160(value))));
    }

    
    function length(AddressSet storage set) internal view returns (uint256) {
        return _length(set._inner);
    }

    
    function at(AddressSet storage set, uint256 index) internal view returns (address) {
        return address(uint160(uint256(_at(set._inner, index))));
    }

    
    function values(AddressSet storage set) internal view returns (address[] memory) {
        bytes32[] memory store = _values(set._inner);
        address[] memory result;

        assembly {
            result := store
        }

        return result;
    }

    

    struct UintSet {
        Set _inner;
    }

    
    function add(UintSet storage set, uint256 value) internal returns (bool) {
        return _add(set._inner, bytes32(value));
    }

    
    function remove(UintSet storage set, uint256 value) internal returns (bool) {
        return _remove(set._inner, bytes32(value));
    }

    
    function contains(UintSet storage set, uint256 value) internal view returns (bool) {
        return _contains(set._inner, bytes32(value));
    }

    
    function length(UintSet storage set) internal view returns (uint256) {
        return _length(set._inner);
    }

    
    function at(UintSet storage set, uint256 index) internal view returns (uint256) {
        return uint256(_at(set._inner, index));
    }

    
    function values(UintSet storage set) internal view returns (uint256[] memory) {
        bytes32[] memory store = _values(set._inner);
        uint256[] memory result;

        assembly {
            result := store
        }

        return result;
    }
}







pragma solidity ^0.8.0;





abstract contract AccessControlEnumerableUpgradeable is Initializable, IAccessControlEnumerableUpgradeable, AccessControlUpgradeable {
    function __AccessControlEnumerable_init() internal onlyInitializing {
    }

    function __AccessControlEnumerable_init_unchained() internal onlyInitializing {
    }
    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.AddressSet;

    mapping(bytes32 => EnumerableSetUpgradeable.AddressSet) private _roleMembers;

    
    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {
        return interfaceId == type(IAccessControlEnumerableUpgradeable).interfaceId || super.supportsInterface(interfaceId);
    }

    
    function getRoleMember(bytes32 role, uint256 index) public view virtual override returns (address) {
        return _roleMembers[role].at(index);
    }

    
    function getRoleMemberCount(bytes32 role) public view virtual override returns (uint256) {
        return _roleMembers[role].length();
    }

    
    function _grantRole(bytes32 role, address account) internal virtual override {
        super._grantRole(role, account);
        _roleMembers[role].add(account);
    }

    
    function _revokeRole(bytes32 role, address account) internal virtual override {
        super._revokeRole(role, account);
        _roleMembers[role].remove(account);
    }

    
    uint256[49] private __gap;
}







pragma solidity ^0.8.0;


library ECDSA {
    enum RecoverError {
        NoError,
        InvalidSignature,
        InvalidSignatureLength,
        InvalidSignatureS,
        InvalidSignatureV
    }

    function _throwError(RecoverError error) private pure {
        if (error == RecoverError.NoError) {
            return; 
        } else if (error == RecoverError.InvalidSignature) {
            revert("ECDSA: invalid signature");
        } else if (error == RecoverError.InvalidSignatureLength) {
            revert("ECDSA: invalid signature length");
        } else if (error == RecoverError.InvalidSignatureS) {
            revert("ECDSA: invalid signature 's' value");
        } else if (error == RecoverError.InvalidSignatureV) {
            revert("ECDSA: invalid signature 'v' value");
        }
    }

    
    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {
        
        
        
        if (signature.length == 65) {
            bytes32 r;
            bytes32 s;
            uint8 v;
            
            
            assembly {
                r := mload(add(signature, 0x20))
                s := mload(add(signature, 0x40))
                v := byte(0, mload(add(signature, 0x60)))
            }
            return tryRecover(hash, v, r, s);
        } else if (signature.length == 64) {
            bytes32 r;
            bytes32 vs;
            
            
            assembly {
                r := mload(add(signature, 0x20))
                vs := mload(add(signature, 0x40))
            }
            return tryRecover(hash, r, vs);
        } else {
            return (address(0), RecoverError.InvalidSignatureLength);
        }
    }

    
    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {
        (address recovered, RecoverError error) = tryRecover(hash, signature);
        _throwError(error);
        return recovered;
    }

    
    function tryRecover(
        bytes32 hash,
        bytes32 r,
        bytes32 vs
    ) internal pure returns (address, RecoverError) {
        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);
        uint8 v = uint8((uint256(vs) >> 255) + 27);
        return tryRecover(hash, v, r, s);
    }

    
    function recover(
        bytes32 hash,
        bytes32 r,
        bytes32 vs
    ) internal pure returns (address) {
        (address recovered, RecoverError error) = tryRecover(hash, r, vs);
        _throwError(error);
        return recovered;
    }

    
    function tryRecover(
        bytes32 hash,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) internal pure returns (address, RecoverError) {
        
        
        
        
        
        
        
        
        
        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {
            return (address(0), RecoverError.InvalidSignatureS);
        }
        if (v != 27 && v != 28) {
            return (address(0), RecoverError.InvalidSignatureV);
        }

        
        address signer = ecrecover(hash, v, r, s);
        if (signer == address(0)) {
            return (address(0), RecoverError.InvalidSignature);
        }

        return (signer, RecoverError.NoError);
    }

    
    function recover(
        bytes32 hash,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) internal pure returns (address) {
        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);
        _throwError(error);
        return recovered;
    }

    
    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {
        
        
        return keccak256(abi.encodePacked("\x19Ethereum Signed Message:\n32", hash));
    }

    
    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked("\x19Ethereum Signed Message:\n", Strings.toString(s.length), s));
    }

    
    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked("\x19\x01", domainSeparator, structHash));
    }
}







pragma solidity ^0.8.0;


interface IERC1271 {
    
    function isValidSignature(bytes32 hash, bytes memory signature) external view returns (bytes4 magicValue);
}







pragma solidity ^0.8.0;




library SignatureChecker {
    
    function isValidSignatureNow(
        address signer,
        bytes32 hash,
        bytes memory signature
    ) internal view returns (bool) {
        (address recovered, ECDSA.RecoverError error) = ECDSA.tryRecover(hash, signature);
        if (error == ECDSA.RecoverError.NoError && recovered == signer) {
            return true;
        }

        (bool success, bytes memory result) = signer.staticcall(
            abi.encodeWithSelector(IERC1271.isValidSignature.selector, hash, signature)
        );
        return (success && result.length == 32 && abi.decode(result, (bytes4)) == IERC1271.isValidSignature.selector);
    }
}







pragma solidity ^0.8.0;


library MerkleProof {
    
    function verify(
        bytes32[] memory proof,
        bytes32 root,
        bytes32 leaf
    ) internal pure returns (bool) {
        return processProof(proof, leaf) == root;
    }

    
    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {
        bytes32 computedHash = leaf;
        for (uint256 i = 0; i < proof.length; i++) {
            bytes32 proofElement = proof[i];
            if (computedHash <= proofElement) {
                
                computedHash = _efficientHash(computedHash, proofElement);
            } else {
                
                computedHash = _efficientHash(proofElement, computedHash);
            }
        }
        return computedHash;
    }

    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {
        assembly {
            mstore(0x00, a)
            mstore(0x20, b)
            value := keccak256(0x00, 0x40)
        }
    }
}










pragma solidity 0.8.13;

interface ISBMintable {
    function mintNext(address reciever, uint256 amount) external;

    function mintTarget(address reciever, uint256 target) external;
}










pragma solidity 0.8.13;

interface ISBRandomness {
    function getRand(bytes32 seed) external returns (bytes32);
}










pragma solidity 0.8.13;

interface ISBShipable {
    function initialize(
        bytes calldata initArg,
        uint128 bip,
        address feeReceiver
    ) external;
}










pragma solidity 0.8.13;












contract SBII721 is
    Initializable,
    ContextUpgradeable,
    ERC721Upgradeable,
    ERC721EnumerableUpgradeable,
    ReentrancyGuardUpgradeable,
    AccessControlEnumerableUpgradeable,
    ISBMintable,
    ISBShipable
{
    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.AddressSet;
    using StringsUpgradeable for uint256;
    using SafeERC20 for IERC20;

    bytes32 public constant MINTER_ROLE = keccak256("MINTER_ROLE");
    string public constant MODEL = "SBII-721-test";
    uint256 private lastID;

    struct Round {
        uint128 price;
        uint32 quota;
        uint16 amountPerUser;
        bool isActive;
        bool isPublic;
        bool isMerkleMode; 
        bool exist;
        address tokenAddress; 
    }

    struct Conf {
        bool allowNFTUpdate;
        bool allowConfUpdate;
        bool allowContract;
        bool allowPrivilege;
        bool randomAccessMode;
        bool allowTarget;
        bool allowLazySell;
        uint64 maxSupply;
    }

    Conf public config;
    string[] roundNames;

    mapping(bytes32 => EnumerableSetUpgradeable.AddressSet) private walletList;
    mapping(bytes32 => bytes32) private merkleRoot;
    mapping(bytes32 => Round) private roundData;
    mapping(uint256 => bool) private nonceUsed;

    mapping(bytes32 => mapping(address => uint256)) mintedInRound;

    string private _baseTokenURI;
    address private feeReceiver;
    uint256 private bip;
    address public beneficiary;

    ISBRandomness public randomness;

    function listRole()
        external
        pure
        returns (string[] memory names, bytes32[] memory code)
    {
        names = new string[](2);
        code = new bytes32[](2);

        names[0] = "MINTER";
        names[1] = "ADMIN";

        code[0] = MINTER_ROLE;
        code[1] = DEFAULT_ADMIN_ROLE;
    }

    function grantRoles(bytes32 role, address[] calldata accounts) public {
        for (uint256 i = 0; i < accounts.length; i++) {
            super.grantRole(role, accounts[i]);
        }
    }

    function revokeRoles(bytes32 role, address[] calldata accounts) public {
        for (uint256 i = 0; i < accounts.length; i++) {
            super.revokeRole(role, accounts[i]);
        }
    }

    function setBeneficiary(address _beneficiary)
        public
        onlyRole(DEFAULT_ADMIN_ROLE)
    {
        require(beneficiary == address(0), "already set");
        
        beneficiary = _beneficiary;
    }

    function setMaxSupply(uint64 _maxSupply)
        public
        onlyRole(DEFAULT_ADMIN_ROLE)
    {
        require(config.maxSupply == 0, "already set");
        
        config.maxSupply = _maxSupply;
    }

    function listRoleWallet(bytes32 role)
        public
        view
        returns (address[] memory roleMembers)
    {
        uint256 count = getRoleMemberCount(role);
        roleMembers = new address[](count);
        for (uint256 i = 0; i < count; i++) {
            roleMembers[i] = getRoleMember(role, i);
        }
    }

    function listToken(address wallet)
        public
        view
        returns (uint256[] memory tokenList)
    {
        tokenList = new uint256[](balanceOf(wallet));
        for (uint256 i = 0; i < balanceOf(wallet); i++) {
            tokenList[i] = tokenOfOwnerByIndex(wallet, i);
        }
    }

    function listRounds() public view returns (string[] memory) {
        return roundNames;
    }

    function roundInfo(string memory roundName)
        public
        view
        returns (Round memory)
    {
        return roundData[keccak256(abi.encodePacked(roundName))];
    }

    function massMint(address[] calldata wallets, uint256[] calldata amount)
        public
    {
        require(config.allowPrivilege, "df");
        require(hasRole(MINTER_ROLE, msg.sender), "require permission");
        for (uint256 i = 0; i < wallets.length; i++) {
            _mintNext(wallets[i], amount[i]);
        }
    }

    function mintNext(address reciever, uint256 amount) public override {
        require(config.allowPrivilege, "df");
        require(hasRole(MINTER_ROLE, msg.sender), "require permission");
        _mintNext(reciever, amount);
    }

    function _mintNext(address reciever, uint256 amount) internal {
        if (config.maxSupply != 0) {
            require(totalSupply() + amount <= config.maxSupply);
        }
        if (!config.randomAccessMode) {
            for (uint256 i = 0; i < amount; i++) {
                _mint(reciever, lastID + 1 +i);
            }
            lastID += amount;

        } else {
            for (uint256 i = 0; i < amount; i++) {
                _mint(reciever, _random(msg.sender, i));
            }
        }
    }

    function _random(address ad, uint256 num) internal returns (uint256) {
        return
            uint256(randomness.getRand(keccak256(abi.encodePacked(ad, num))));
    }

    function updateURI(string memory newURI)
        public
        onlyRole(DEFAULT_ADMIN_ROLE)
    {
        
        require(config.allowNFTUpdate, "not available");
        _baseTokenURI = newURI;
    }

    function mintTarget(address reciever, uint256 target) public override {
        require(config.allowPrivilege, "df");
        require(hasRole(MINTER_ROLE, msg.sender), "require permission");
        _mintTarget(reciever, target);
    }

    function _mintTarget(address reciever, uint256 target) internal {
        require(config.allowTarget, "df");
        require(config.randomAccessMode, "df");
        if (config.maxSupply != 0) {
            require(totalSupply() + 1 <= config.maxSupply);
        }
        _mint(reciever, target);
    }

    function requestMint(Round storage thisRound, uint256 amount) internal {
        require(thisRound.isActive, "not active");
        require(thisRound.quota >= amount, "out of stock");
        if (!config.allowContract) {
            require(tx.origin == msg.sender, "not allow contract");
        }
        thisRound.quota -= uint32(amount);
    }

    

    function mint(string memory roundName, uint256 amount)
        public
        payable
        nonReentrant
    {
        bytes32 key = keccak256(abi.encodePacked(roundName));
        Round storage thisRound = roundData[key];

        requestMint(thisRound, amount);

        
        
        
        
        
        

        require(!thisRound.isMerkleMode, "wrong data");

        if (!thisRound.isPublic) {
            require(walletList[key].contains(msg.sender));
            require(
                mintedInRound[key][msg.sender] + amount <=
                    thisRound.amountPerUser,
                "out of quota"
            );
            mintedInRound[key][msg.sender] += amount;
        } else {
            require(amount <= thisRound.amountPerUser, "nope"); 
        }

        paymentUtil.processPayment(
            thisRound.tokenAddress,
            thisRound.price * amount
        );

        _mintNext(msg.sender, amount);
    }

    function mint(
        string memory roundName,
        address wallet,
        uint256 amount,
        uint256 tokenID,
        uint256 nonce,
        uint256 pricePerUnit,
        address denominatedAsset,
        bytes32[] memory proof
    ) public payable {
        bytes32 key = keccak256(abi.encodePacked(roundName));

        Round storage thisRound = roundData[key];

        requestMint(thisRound, amount);

        
        
        

        require(thisRound.isMerkleMode, "invalid");

        bytes32 data = hash(
            wallet,
            amount,
            tokenID,
            nonce,
            pricePerUnit,
            denominatedAsset,
            address(this),
            block.chainid
        );
        require(_merkleCheck(data, merkleRoot[key], proof), "fail merkle");

        _useNonce(nonce);
        if (wallet != address(0)) {
            require(wallet == msg.sender, "nope");
        }

        require(amount * tokenID == 0, "pick one"); 

        if (amount > 0) {
            paymentUtil.processPayment(denominatedAsset, pricePerUnit * amount);
            _mintNext(wallet, amount);
        } else {
            paymentUtil.processPayment(denominatedAsset, pricePerUnit);
            _mintTarget(wallet, tokenID);
        }
    }

    function mint(
        address wallet,
        uint256 amount,
        uint256 tokenID,
        uint256 nonce,
        uint256 pricePerUnit,
        address denominatedAsset,
        bytes memory signature
    ) public payable {
        bytes32 data = hash(
            wallet,
            amount,
            tokenID,
            nonce,
            pricePerUnit,
            denominatedAsset,
            address(this),
            block.chainid
        );

        require(config.allowLazySell, "not available");
        require(config.allowPrivilege, "not available");

        require(_verifySig(data, signature));

        _useNonce(nonce);
        if (wallet != address(0)) {
            require(wallet == msg.sender, "nope");
        }

        require(amount * tokenID == 0, "pick one"); 

        if (amount > 0) {
            paymentUtil.processPayment(denominatedAsset, pricePerUnit * amount);
            _mintNext(wallet, amount);
        } else {
            paymentUtil.processPayment(denominatedAsset, pricePerUnit);
            _mintTarget(wallet, tokenID);
        }
    }

    

    
    
    
    
    
    

    function hash(
        address wallet,
        uint256 amount,
        uint256 tokenID,
        uint256 nonce,
        uint256 pricePerUnit,
        address denominatedAsset,
        address refPorject,
        uint256 chainID
    ) public pure returns (bytes32) {
        return
            keccak256(
                abi.encodePacked(
                    wallet,
                    amount,
                    tokenID,
                    nonce,
                    pricePerUnit,
                    denominatedAsset,
                    refPorject,
                    chainID
                )
            );
    }

    function _toSignedHash(bytes32 data) internal pure returns (bytes32) {
        return ECDSA.toEthSignedMessageHash(data);
    }

    function _verifySig(bytes32 data, bytes memory signature)
        public
        view
        returns (bool)
    {
        return
            hasRole(MINTER_ROLE, ECDSA.recover(_toSignedHash(data), signature));
    }

    function _merkleCheck(
        bytes32 data,
        bytes32 root,
        bytes32[] memory merkleProof
    ) internal pure returns (bool) {
        return MerkleProof.verify(merkleProof, root, data);
    }

    

    function newRound(
        string memory roundName,
        uint128 _price,
        uint32 _quota,
        uint16 _amountPerUser,
        bool _isActive,
        bool _isPublic,
        bool _isMerkle,
        address _tokenAddress
    ) public onlyRole(DEFAULT_ADMIN_ROLE) {
        
        bytes32 key = keccak256(abi.encodePacked(roundName));

        require(!roundData[key].exist, "already exist");
        roundNames.push(roundName);
        roundData[key] = Round({
            price: _price,
            quota: _quota,
            amountPerUser: _amountPerUser,
            isActive: _isActive,
            isPublic: _isPublic,
            isMerkleMode: _isMerkle,
            tokenAddress: _tokenAddress,
            exist: true
        });
    }

    function triggerRound(string memory roundName, bool _isActive)
        public
        onlyRole(DEFAULT_ADMIN_ROLE)
    {
        
        bytes32 key = keccak256(abi.encodePacked(roundName));
        roundData[key].isActive = _isActive;
    }

    function setMerkleRoot(string memory roundName, bytes32 root)
        public
        onlyRole(DEFAULT_ADMIN_ROLE)
    {
        
        bytes32 key = keccak256(abi.encodePacked(roundName));
        merkleRoot[key] = root;
    }

    function updateRound(
        string memory roundName,
        uint128 _price,
        uint32 _quota,
        uint16 _amountPerUser,
        bool _isPublic
    ) public onlyRole(DEFAULT_ADMIN_ROLE) {
        
        bytes32 key = keccak256(abi.encodePacked(roundName));
        roundData[key].price = _price;
        roundData[key].quota = _quota;
        roundData[key].amountPerUser = _amountPerUser;
        roundData[key].isPublic = _isPublic;
    }

    function addRoundWallet(string memory roundName, address[] memory wallets)
        public
        onlyRole(DEFAULT_ADMIN_ROLE)
    {
        
        bytes32 key = keccak256(abi.encodePacked(roundName));
        for (uint256 i = 0; i < wallets.length; i++) {
            walletList[key].add(wallets[i]);
        }
    }

    function removeRoundWallet(
        string memory roundName,
        address[] memory wallets
    ) public onlyRole(DEFAULT_ADMIN_ROLE) {
        
        bytes32 key = keccak256(abi.encodePacked(roundName));
        for (uint256 i = 0; i < wallets.length; i++) {
            walletList[key].remove(wallets[i]);
        }
    }

    function getRoundWallet(string memory roundName)
        public
        view
        returns (address[] memory)
    {
        return walletList[keccak256(abi.encodePacked(roundName))].values();
    }

    function isQualify(address wallet, string memory roundName)
        public
        view
        returns (bool)
    {
        Round memory x = roundInfo(roundName);
        if (!x.isActive) {
            return false;
        }
        if (x.quota == 0) {
            return false;
        }
        bytes32 key = keccak256(abi.encodePacked(roundName));
        if (!x.isPublic && !walletList[key].contains(wallet)) {
            return false;
        }
        if (mintedInRound[key][wallet] >= x.amountPerUser) {
            return false;
        }
        return true;
    }

    function listQualifiedRound(address wallet)
        public
        view
        returns (string[] memory)
    {
        string[] memory valid = new string[](roundNames.length);
        for (uint256 i = 0; i < roundNames.length; i++) {
            if (isQualify(wallet, roundNames[i])) {
                valid[i] = roundNames[i];
            }
        }
        return valid;
    }

    function burnNonce(uint256[] calldata nonces)
        external
        onlyRole(DEFAULT_ADMIN_ROLE)
    {
        
        require(config.allowPrivilege, "df");

        for (uint256 i = 0; i < nonces.length; i++) {
            nonceUsed[nonces[i]] = true;
        }
    }

    function resetNonce(uint256[] calldata nonces)
        external
        onlyRole(DEFAULT_ADMIN_ROLE)
    {
        
        require(config.allowPrivilege, "df");

        for (uint256 i = 0; i < nonces.length; i++) {
            nonceUsed[nonces[i]] = false;
        }
    }

    function _useNonce(uint256 nonce) internal {
        require(!nonceUsed[nonce], "used");
        nonceUsed[nonce] = true;
    }

    

    function initialize(
        bytes calldata initArg,
        uint128 _bip,
        address _feeReceiver
    ) public initializer {
        feeReceiver = _feeReceiver;
        bip = _bip;

        (
            string memory name,
            string memory symbol,
            string memory baseTokenURI,
            address owner,
            bool _allowNFTUpdate,
            bool _allowConfUpdate,
            bool _allowContract,
            bool _allowPrivilege,
            bool _randomAccessMode,
            bool _allowTarget,
            bool _allowLazySell
        ) = abi.decode(
                initArg,
                (
                    string,
                    string,
                    string,
                    address,
                    bool,
                    bool,
                    bool,
                    bool,
                    bool,
                    bool,
                    bool
                )
            );

        __721Init(name, symbol);
        _setupRole(DEFAULT_ADMIN_ROLE, owner);
        _setupRole(MINTER_ROLE, owner);

        _baseTokenURI = baseTokenURI;
        config = Conf({
            allowNFTUpdate: _allowNFTUpdate,
            allowConfUpdate: _allowConfUpdate,
            allowContract: _allowContract,
            allowPrivilege: _allowPrivilege,
            randomAccessMode: _randomAccessMode,
            allowTarget: _allowTarget,
            allowLazySell: _allowLazySell,
            maxSupply: 0
        });
    }

    function updateConfig(
        bool _allowNFTUpdate,
        bool _allowConfUpdate,
        bool _allowContract,
        bool _allowPrivilege,
        bool _allowTarget,
        bool _allowLazySell
    ) public onlyRole(DEFAULT_ADMIN_ROLE) {
        require(config.allowConfUpdate);
        
        config.allowNFTUpdate = _allowNFTUpdate;
        config.allowConfUpdate = _allowConfUpdate;
        config.allowContract = _allowContract;
        config.allowPrivilege = _allowPrivilege;
        config.allowTarget = _allowTarget;
        config.allowLazySell = _allowLazySell;
    }

    function withdraw(address tokenAddress) public nonReentrant {
        address reviver = beneficiary;
        if (beneficiary == address(0)) {
            require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender), "admin only");
            reviver = msg.sender;
        }
        if (tokenAddress == address(0)) {
            payable(feeReceiver).transfer(
                (address(this).balance * bip) / 10000
            );
            payable(reviver).transfer(address(this).balance);
        } else {
            IERC20 token = IERC20(tokenAddress);
            token.safeTransfer(
                feeReceiver,
                (token.balanceOf(address(this)) * bip) / 10000
            );
            token.safeTransfer(reviver, token.balanceOf(address(this)));
        }
    }

    function setRandomness(address _randomness)
        public
        onlyRole(DEFAULT_ADMIN_ROLE)
    {
        
        randomness = ISBRandomness(_randomness);
    }

    function contractURI() external view returns (string memory) {
        string memory baseURI = _baseURI();
        return string(abi.encodePacked(baseURI, "contract_uri"));
    }

    function tokenURI(uint256 tokenId)
        public
        view
        virtual
        override
        returns (string memory)
    {
        require(_exists(tokenId), "nonexistent token");

        string memory baseURI = _baseURI();
        return string(abi.encodePacked(baseURI, "uri/", tokenId.toString()));
    }

    

    function __721Init(string memory name, string memory symbol) internal {
        __Context_init_unchained();
        __ERC165_init_unchained();
        __ReentrancyGuard_init_unchained();
        __ERC721_init_unchained(name, symbol);
        __ERC721Enumerable_init_unchained();
        __AccessControlEnumerable_init_unchained();
    }

    function _baseURI() internal view virtual override returns (string memory) {
        return _baseTokenURI;
    }

    function _beforeTokenTransfer(
        address from,
        address to,
        uint256 tokenId
    )
        internal
        virtual
        override(ERC721Upgradeable, ERC721EnumerableUpgradeable)
    {
        super._beforeTokenTransfer(from, to, tokenId);
    }

    function supportsInterface(bytes4 interfaceId)
        public
        view
        virtual
        override(
            ERC721Upgradeable,
            ERC721EnumerableUpgradeable,
            AccessControlEnumerableUpgradeable
        )
        returns (bool)
    {
        return super.supportsInterface(interfaceId);
    }
}










pragma solidity 0.8.13;











contract SBII721A is
    Initializable,
    ERC721ASBUpgradable,
    ReentrancyGuardUpgradeable,
    AccessControlEnumerableUpgradeable,
    ISBMintable,
    ISBShipable
{
    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.AddressSet;
    using StringsUpgradeable for uint256;
    using SafeERC20 for IERC20;

    bytes32 public constant MINTER_ROLE = keccak256("MINTER_ROLE");
    string public constant MODEL = "SBII-721A-EARLYACCESS";

    struct Round {
        uint128 price;
        uint32 quota;
        uint16 amountPerUser;
        bool isActive;
        bool isPublic;
        bool isMerkleMode; 
        bool exist;
        address tokenAddress; 
    }

    struct Conf {
        bool allowNFTUpdate;
        bool allowConfUpdate;
        bool allowContract;
        bool allowPrivilege;
        bool randomAccessMode;
        bool allowTarget;
        bool allowLazySell;
        uint64 maxSupply;
    }

    Conf public config;
    string[] public roundNames;

    mapping(bytes32 => EnumerableSetUpgradeable.AddressSet) private walletList;
    mapping(bytes32 => bytes32) private merkleRoot;
    mapping(bytes32 => Round) private roundData;
    mapping(uint256 => bool) private nonceUsed;

    mapping(bytes32 => mapping(address => uint256)) mintedInRound;

    string private _baseTokenURI;
    address private feeReceiver;
    uint256 private bip;
    address public beneficiary;

    function listRole()
        public
        pure
        returns (string[] memory names, bytes32[] memory code)
    {
        names = new string[](2);
        code = new bytes32[](2);

        names[0] = "MINTER";
        names[1] = "ADMIN";

        code[0] = MINTER_ROLE;
        code[1] = DEFAULT_ADMIN_ROLE;
    }

    function grantRoles(bytes32 role, address[] calldata accounts) public {
        for (uint256 i = 0; i < accounts.length; i++) {
            super.grantRole(role, accounts[i]);
        }
    }

    function revokeRoles(bytes32 role, address[] calldata accounts) public {
        for (uint256 i = 0; i < accounts.length; i++) {
            super.revokeRole(role, accounts[i]);
        }
    }

    function setBeneficiary(address _beneficiary)
        public
        onlyRole(DEFAULT_ADMIN_ROLE)
    {
        require(beneficiary == address(0), "already set");
        
        beneficiary = _beneficiary;
    }

    
    function setMaxSupply(uint64 _maxSupply)
        public
        onlyRole(DEFAULT_ADMIN_ROLE)
    {
        require(config.maxSupply == 0, "already set");
        
        config.maxSupply = _maxSupply;
    }

    function listRoleWallet(bytes32 role)
        public
        view
        returns (address[] memory roleMembers)
    {
        uint256 count = getRoleMemberCount(role);
        roleMembers = new address[](count);
        for (uint256 i = 0; i < count; i++) {
            roleMembers[i] = getRoleMember(role, i);
        }
    }

    function listToken(address wallet)
        public
        view
        returns (uint256[] memory tokenList)
    {
        return tokensOfOwner(wallet);
    }

    function listRounds() public view returns (string[] memory) {
        return roundNames;
    }

    function roundInfo(string memory roundName)
        public
        view
        returns (Round memory)
    {
        return roundData[keccak256(abi.encodePacked(roundName))];
    }

    function massMint(address[] calldata wallets, uint256[] calldata amount)
        public
    {
        require(config.allowPrivilege, "disabled feature");
        require(hasRole(MINTER_ROLE, msg.sender), "require permission");
        for (uint256 i = 0; i < wallets.length; i++) {
            mintNext(wallets[i], amount[i]);
        }
    }

    function mintNext(address reciever, uint256 amount) public override {
        require(config.allowPrivilege, "disabled feature");
        require(hasRole(MINTER_ROLE, msg.sender), "require permission");
        _mintNext(reciever, amount);
    }

    function _mintNext(address reciever, uint256 amount) internal {
        if (config.maxSupply != 0) {
            require(totalSupply() + amount <= config.maxSupply);
        }
        _safeMint(reciever, amount); 
    }

    function _random(address ad, uint256 num) internal returns (uint256) {
        revert("not supported by 721a la");
    }

    function updateURI(string memory newURI)
        public
        onlyRole(DEFAULT_ADMIN_ROLE)
    {
        
        require(config.allowNFTUpdate, "not available");
        _baseTokenURI = newURI;
    }

    function mintTarget(address reciever, uint256 target) public override {
        revert("not supported by 721a la");
    }

    function requestMint(Round storage thisRound, uint256 amount) internal {
        require(thisRound.isActive, "not active");
        require(thisRound.quota >= amount, "out of stock");
        if (!config.allowContract) {
            require(tx.origin == msg.sender, "not allow contract");
        }
        thisRound.quota -= uint32(amount);
    }

    

    function mint(string memory roundName, uint256 amount)
        public
        payable
        nonReentrant
    {
        bytes32 key = keccak256(abi.encodePacked(roundName));
        Round storage thisRound = roundData[key];

        requestMint(thisRound, amount);

        
        
        
        
        
        

        require(!thisRound.isMerkleMode, "wrong data");

        if (!thisRound.isPublic) {
            require(walletList[key].contains(msg.sender));
            require(
                mintedInRound[key][msg.sender] + amount <=
                    thisRound.amountPerUser,
                "out of quota"
            );
            mintedInRound[key][msg.sender] += amount;
        } else {
            require(amount <= thisRound.amountPerUser, "nope"); 
        }

        paymentUtil.processPayment(
            thisRound.tokenAddress,
            thisRound.price * amount
        );

        _mintNext(msg.sender, amount);
    }

    function mint(
        string memory roundName,
        address wallet,
        uint256 amount,
        uint256 tokenID,
        uint256 nonce,
        uint256 pricePerUnit,
        address denominatedAsset,
        bytes32[] memory proof
    ) public payable {
        bytes32 key = keccak256(abi.encodePacked(roundName));
        Round storage thisRound = roundData[key];

        requestMint(thisRound, amount);

        
        
        

        require(thisRound.isMerkleMode, "invalid");

        bytes32 data = hash(
            wallet,
            amount,
            tokenID,
            nonce,
            pricePerUnit,
            denominatedAsset,
            address(this),
            block.chainid
        );
        require(_merkleCheck(data, merkleRoot[key], proof), "fail merkle");

        _useNonce(nonce);
        if (wallet != address(0)) {
            require(wallet == msg.sender, "nope");
        }

        require(amount > 0, "pick one"); 
        require(tokenID == 0, "nope"); 

        paymentUtil.processPayment(denominatedAsset, pricePerUnit * amount);
        _mintNext(wallet, amount);
    }

    function mint(
        address wallet,
        uint256 amount,
        uint256 tokenID,
        uint256 nonce,
        uint256 pricePerUnit,
        address denominatedAsset,
        bytes memory signature
    ) public payable {
        bytes32 data = hash(
            wallet,
            amount,
            tokenID,
            nonce,
            pricePerUnit,
            denominatedAsset,
            address(this),
            block.chainid
        );
        require(config.allowLazySell, "not available");
        require(config.allowPrivilege, "not available");

        require(_verifySig(data, signature));

        _useNonce(nonce);
        if (wallet != address(0)) {
            require(wallet == msg.sender, "nope");
        }

        require(amount > 0, "pick one"); 
        require(tokenID == 0, "nope"); 

        paymentUtil.processPayment(denominatedAsset, pricePerUnit * amount);
        _mintNext(wallet, amount);
    }

    

    
    
    
    
    
    

    function hash(
        address wallet,
        uint256 amount,
        uint256 tokenID,
        uint256 nonce,
        uint256 pricePerUnit,
        address denominatedAsset,
        address refPorject,
        uint256 chainID
    ) public pure returns (bytes32) {
        return
            keccak256(
                abi.encodePacked(
                    wallet,
                    amount,
                    tokenID,
                    nonce,
                    pricePerUnit,
                    denominatedAsset,
                    refPorject,
                    chainID
                )
            );
    }

    function _toSignedHash(bytes32 data) internal pure returns (bytes32) {
        return ECDSA.toEthSignedMessageHash(data);
    }

    function _verifySig(bytes32 data, bytes memory signature)
        public
        view
        returns (bool)
    {
        return
            hasRole(MINTER_ROLE, ECDSA.recover(_toSignedHash(data), signature));
    }

    function _merkleCheck(
        bytes32 data,
        bytes32 root,
        bytes32[] memory merkleProof
    ) internal pure returns (bool) {
        return MerkleProof.verify(merkleProof, root, data);
    }

    

    function newRound(
        string memory roundName,
        uint128 _price,
        uint32 _quota,
        uint16 _amountPerUser,
        bool _isActive,
        bool _isPublic,
        bool _isMerkle,
        address _tokenAddress
    ) public onlyRole(DEFAULT_ADMIN_ROLE) {
        
        bytes32 key = keccak256(abi.encodePacked(roundName));

        require(!roundData[key].exist, "already exist");
        roundNames.push(roundName);
        roundData[key] = Round({
            price: _price,
            quota: _quota,
            amountPerUser: _amountPerUser,
            isActive: _isActive,
            isPublic: _isPublic,
            isMerkleMode: _isMerkle,
            tokenAddress: _tokenAddress,
            exist: true
        });
    }

    function triggerRound(string memory roundName, bool _isActive)
        public
        onlyRole(DEFAULT_ADMIN_ROLE)
    {
        
        bytes32 key = keccak256(abi.encodePacked(roundName));
        roundData[key].isActive = _isActive;
    }

    function setMerkleRoot(string memory roundName, bytes32 root)
        public
        onlyRole(DEFAULT_ADMIN_ROLE)
    {
        
        bytes32 key = keccak256(abi.encodePacked(roundName));
        merkleRoot[key] = root;
    }

    function updateRound(
        string memory roundName,
        uint128 _price,
        uint32 _quota,
        uint16 _amountPerUser,
        bool _isPublic
    ) public onlyRole(DEFAULT_ADMIN_ROLE) {
        
        bytes32 key = keccak256(abi.encodePacked(roundName));
        roundData[key].price = _price;
        roundData[key].quota = _quota;
        roundData[key].amountPerUser = _amountPerUser;
        roundData[key].isPublic = _isPublic;
    }

    function addRoundWallet(string memory roundName, address[] memory wallets)
        public
        onlyRole(DEFAULT_ADMIN_ROLE)
    {
        
        bytes32 key = keccak256(abi.encodePacked(roundName));
        for (uint256 i = 0; i < wallets.length; i++) {
            walletList[key].add(wallets[i]);
        }
    }

    function removeRoundWallet(
        string memory roundName,
        address[] memory wallets
    ) public onlyRole(DEFAULT_ADMIN_ROLE) {
        
        bytes32 key = keccak256(abi.encodePacked(roundName));
        for (uint256 i = 0; i < wallets.length; i++) {
            walletList[key].remove(wallets[i]);
        }
    }

    function getRoundWallet(string memory roundName)
        public
        view
        returns (address[] memory)
    {
        return walletList[keccak256(abi.encodePacked(roundName))].values();
    }

    function isQualify(address wallet, string memory roundName)
        public
        view
        returns (bool)
    {
        Round memory x = roundInfo(roundName);
        if (!x.isActive) {
            return false;
        }
        if (x.quota == 0) {
            return false;
        }
        bytes32 key = keccak256(abi.encodePacked(roundName));
        if (!x.isPublic && !walletList[key].contains(wallet)) {
            return false;
        }
        if (mintedInRound[key][wallet] >= x.amountPerUser) {
            return false;
        }
        return true;
    }

    function listQualifiedRound(address wallet)
        public
        view
        returns (string[] memory)
    {
        string[] memory valid = new string[](roundNames.length);
        for (uint256 i = 0; i < roundNames.length; i++) {
            if (isQualify(wallet, roundNames[i])) {
                valid[i] = roundNames[i];
            }
        }
        return valid;
    }

    function burnNonce(uint256[] calldata nonces)
        external
        onlyRole(DEFAULT_ADMIN_ROLE)
    {
        
        require(config.allowPrivilege, "disabled feature");

        for (uint256 i = 0; i < nonces.length; i++) {
            nonceUsed[nonces[i]] = true;
        }
    }

    function resetNonce(uint256[] calldata nonces)
        external
        onlyRole(DEFAULT_ADMIN_ROLE)
    {
        
        require(config.allowPrivilege, "disabled feature");

        for (uint256 i = 0; i < nonces.length; i++) {
            nonceUsed[nonces[i]] = false;
        }
    }

    function _useNonce(uint256 nonce) internal {
        require(!nonceUsed[nonce], "used");
        nonceUsed[nonce] = true;
    }

    

    function initialize(
        bytes calldata initArg,
        uint128 _bip,
        address _feeReceiver
    ) public initializer {
        feeReceiver = _feeReceiver;
        bip = _bip;

        (
            string memory name,
            string memory symbol,
            string memory baseTokenURI,
            address owner,
            bool _allowNFTUpdate,
            bool _allowConfUpdate,
            bool _allowContract,
            bool _allowPrivilege,
            bool _randomAccessMode,
            bool _allowTarget,
            bool _allowLazySell
        ) = abi.decode(
                initArg,
                (
                    string,
                    string,
                    string,
                    address,
                    bool,
                    bool,
                    bool,
                    bool,
                    bool,
                    bool,
                    bool
                )
            );

        __721AInit(name, symbol);
        _setupRole(DEFAULT_ADMIN_ROLE, owner);
        _setupRole(MINTER_ROLE, owner);

        _baseTokenURI = baseTokenURI;
        config = Conf({
            allowNFTUpdate: _allowNFTUpdate,
            allowConfUpdate: _allowConfUpdate,
            allowContract: _allowContract,
            allowPrivilege: _allowPrivilege,
            randomAccessMode: _randomAccessMode,
            allowTarget: _allowTarget,
            allowLazySell: _allowLazySell,
            maxSupply: 0
        });
    }

    function updateConfig(
        bool _allowNFTUpdate,
        bool _allowConfUpdate,
        bool _allowContract,
        bool _allowPrivilege,
        bool _allowTarget,
        bool _allowLazySell
    ) public onlyRole(DEFAULT_ADMIN_ROLE) {
        require(config.allowConfUpdate);
        
        config.allowNFTUpdate = _allowNFTUpdate;
        config.allowConfUpdate = _allowConfUpdate;
        config.allowContract = _allowContract;
        config.allowPrivilege = _allowPrivilege;
        config.allowTarget = _allowTarget;
        config.allowLazySell = _allowLazySell;
    }

    function withdraw(address tokenAddress) public nonReentrant {
        address reviver = beneficiary;
        if (beneficiary == address(0)) {
            require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender), "admin only");
            reviver = msg.sender;
        }
        if (tokenAddress == address(0)) {
            payable(feeReceiver).transfer(
                (address(this).balance * bip) / 10000
            );
            payable(reviver).transfer(address(this).balance);
        } else {
            IERC20 token = IERC20(tokenAddress);
            token.safeTransfer(
                feeReceiver,
                (token.balanceOf(address(this)) * bip) / 10000
            );
            token.safeTransfer(reviver, token.balanceOf(address(this)));
        }
    }

    function contractURI() external view returns (string memory) {
        string memory baseURI = _baseURI();
        return string(abi.encodePacked(baseURI, "contract_uri"));
    }

    function tokenURI(uint256 tokenId)
        public
        view
        virtual
        override
        returns (string memory)
    {
        require(_exists(tokenId), "nonexistent token");

        string memory baseURI = _baseURI();
        return string(abi.encodePacked(baseURI, "uri/", tokenId.toString()));
    }

    

    function __721AInit(string memory name, string memory symbol) internal {
        __ReentrancyGuard_init_unchained();
        __ERC721A_init(name, symbol);
        __AccessControlEnumerable_init_unchained();
    }

    function _baseURI() internal view virtual override returns (string memory) {
        return _baseTokenURI;
    }

    function supportsInterface(bytes4 interfaceId)
        public
        view
        virtual
        override(AccessControlEnumerableUpgradeable, ERC721ASBUpgradable)
        returns (bool)
    {
        return
            interfaceId == type(IERC721Upgradeable).interfaceId ||
            interfaceId == type(IERC721MetadataUpgradeable).interfaceId ||
            super.supportsInterface(interfaceId);
    }
}







pragma solidity ^0.8.0;


interface IERC20Upgradeable {
    
    function totalSupply() external view returns (uint256);

    
    function balanceOf(address account) external view returns (uint256);

    
    function transfer(address to, uint256 amount) external returns (bool);

    
    function allowance(address owner, address spender) external view returns (uint256);

    
    function approve(address spender, uint256 amount) external returns (bool);

    
    function transferFrom(
        address from,
        address to,
        uint256 amount
    ) external returns (bool);

    
    event Transfer(address indexed from, address indexed to, uint256 value);

    
    event Approval(address indexed owner, address indexed spender, uint256 value);
}







pragma solidity ^0.8.0;



library SafeERC20Upgradeable {
    using AddressUpgradeable for address;

    function safeTransfer(
        IERC20Upgradeable token,
        address to,
        uint256 value
    ) internal {
        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));
    }

    function safeTransferFrom(
        IERC20Upgradeable token,
        address from,
        address to,
        uint256 value
    ) internal {
        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));
    }

    
    function safeApprove(
        IERC20Upgradeable token,
        address spender,
        uint256 value
    ) internal {
        
        
        
        require(
            (value == 0) || (token.allowance(address(this), spender) == 0),
            "SafeERC20: approve from non-zero to non-zero allowance"
        );
        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));
    }

    function safeIncreaseAllowance(
        IERC20Upgradeable token,
        address spender,
        uint256 value
    ) internal {
        uint256 newAllowance = token.allowance(address(this), spender) + value;
        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
    }

    function safeDecreaseAllowance(
        IERC20Upgradeable token,
        address spender,
        uint256 value
    ) internal {
        unchecked {
            uint256 oldAllowance = token.allowance(address(this), spender);
            require(oldAllowance >= value, "SafeERC20: decreased allowance below zero");
            uint256 newAllowance = oldAllowance - value;
            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
        }
    }

    
    function _callOptionalReturn(IERC20Upgradeable token, bytes memory data) private {
        
        
        

        bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");
        if (returndata.length > 0) {
            
            require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");
        }
    }
}







pragma solidity ^0.8.0;





contract PaymentSplitterUpgradeable is Initializable, ContextUpgradeable {
    event PayeeAdded(address account, uint256 shares);
    event PaymentReleased(address to, uint256 amount);
    event ERC20PaymentReleased(IERC20Upgradeable indexed token, address to, uint256 amount);
    event PaymentReceived(address from, uint256 amount);

    uint256 private _totalShares;
    uint256 private _totalReleased;

    mapping(address => uint256) private _shares;
    mapping(address => uint256) private _released;
    address[] private _payees;

    mapping(IERC20Upgradeable => uint256) private _erc20TotalReleased;
    mapping(IERC20Upgradeable => mapping(address => uint256)) private _erc20Released;

    
    function __PaymentSplitter_init(address[] memory payees, uint256[] memory shares_) internal onlyInitializing {
        __PaymentSplitter_init_unchained(payees, shares_);
    }

    function __PaymentSplitter_init_unchained(address[] memory payees, uint256[] memory shares_) internal onlyInitializing {
        require(payees.length == shares_.length, "PaymentSplitter: payees and shares length mismatch");
        require(payees.length > 0, "PaymentSplitter: no payees");

        for (uint256 i = 0; i < payees.length; i++) {
            _addPayee(payees[i], shares_[i]);
        }
    }

    
    receive() external payable virtual {
        emit PaymentReceived(_msgSender(), msg.value);
    }

    
    function totalShares() public view returns (uint256) {
        return _totalShares;
    }

    
    function totalReleased() public view returns (uint256) {
        return _totalReleased;
    }

    
    function totalReleased(IERC20Upgradeable token) public view returns (uint256) {
        return _erc20TotalReleased[token];
    }

    
    function shares(address account) public view returns (uint256) {
        return _shares[account];
    }

    
    function released(address account) public view returns (uint256) {
        return _released[account];
    }

    
    function released(IERC20Upgradeable token, address account) public view returns (uint256) {
        return _erc20Released[token][account];
    }

    
    function payee(uint256 index) public view returns (address) {
        return _payees[index];
    }

    
    function release(address payable account) public virtual {
        require(_shares[account] > 0, "PaymentSplitter: account has no shares");

        uint256 totalReceived = address(this).balance + totalReleased();
        uint256 payment = _pendingPayment(account, totalReceived, released(account));

        require(payment != 0, "PaymentSplitter: account is not due payment");

        _released[account] += payment;
        _totalReleased += payment;

        AddressUpgradeable.sendValue(account, payment);
        emit PaymentReleased(account, payment);
    }

    
    function release(IERC20Upgradeable token, address account) public virtual {
        require(_shares[account] > 0, "PaymentSplitter: account has no shares");

        uint256 totalReceived = token.balanceOf(address(this)) + totalReleased(token);
        uint256 payment = _pendingPayment(account, totalReceived, released(token, account));

        require(payment != 0, "PaymentSplitter: account is not due payment");

        _erc20Released[token][account] += payment;
        _erc20TotalReleased[token] += payment;

        SafeERC20Upgradeable.safeTransfer(token, account, payment);
        emit ERC20PaymentReleased(token, account, payment);
    }

    
    function _pendingPayment(
        address account,
        uint256 totalReceived,
        uint256 alreadyReleased
    ) private view returns (uint256) {
        return (totalReceived * _shares[account]) / _totalShares - alreadyReleased;
    }

    
    function _addPayee(address account, uint256 shares_) private {
        require(account != address(0), "PaymentSplitter: account is the zero address");
        require(shares_ > 0, "PaymentSplitter: shares are 0");
        require(_shares[account] == 0, "PaymentSplitter: account already has shares");

        _payees.push(account);
        _shares[account] = shares_;
        _totalShares = _totalShares + shares_;
        emit PayeeAdded(account, shares_);
    }

    
    uint256[43] private __gap;
}










pragma solidity 0.8.13;




contract SBIIPayment is Initializable, PaymentSplitterUpgradeable, ISBShipable {
    string public constant MODEL = "SBII-paymentSplitterU-test";
    bool public allowUpdate;

    function initialize(
        bytes memory initArg,
        uint128 bip,
        address feeReceiver
    ) public override initializer {
        (address[] memory payee, uint256[] memory share) = abi.decode(
            initArg,
            (address[], uint256[])
        );
        __PaymentSplitter_init(payee, share);
        
    }
}







pragma solidity ^0.8.0;


library ClonesUpgradeable {
    
    function clone(address implementation) internal returns (address instance) {
        assembly {
            let ptr := mload(0x40)
            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)
            mstore(add(ptr, 0x14), shl(0x60, implementation))
            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)
            instance := create(0, ptr, 0x37)
        }
        require(instance != address(0), "ERC1167: create failed");
    }

    
    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {
        assembly {
            let ptr := mload(0x40)
            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)
            mstore(add(ptr, 0x14), shl(0x60, implementation))
            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)
            instance := create2(0, ptr, 0x37, salt)
        }
        require(instance != address(0), "ERC1167: create2 failed");
    }

    
    function predictDeterministicAddress(
        address implementation,
        bytes32 salt,
        address deployer
    ) internal pure returns (address predicted) {
        assembly {
            let ptr := mload(0x40)
            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)
            mstore(add(ptr, 0x14), shl(0x60, implementation))
            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf3ff00000000000000000000000000000000)
            mstore(add(ptr, 0x38), shl(0x60, deployer))
            mstore(add(ptr, 0x4c), salt)
            mstore(add(ptr, 0x6c), keccak256(ptr, 0x37))
            predicted := keccak256(add(ptr, 0x37), 0x55)
        }
    }

    
    function predictDeterministicAddress(address implementation, bytes32 salt)
        internal
        view
        returns (address predicted)
    {
        return predictDeterministicAddress(implementation, salt, address(this));
    }
}







pragma solidity ^0.8.0;


abstract contract Ownable is Context {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    
    constructor() {
        _transferOwnership(_msgSender());
    }

    
    function owner() public view virtual returns (address) {
        return _owner;
    }

    
    modifier onlyOwner() {
        require(owner() == _msgSender(), "Ownable: caller is not the owner");
        _;
    }

    
    function renounceOwnership() public virtual onlyOwner {
        _transferOwnership(address(0));
    }

    
    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), "Ownable: new owner is the zero address");
        _transferOwnership(newOwner);
    }

    
    function _transferOwnership(address newOwner) internal virtual {
        address oldOwner = _owner;
        _owner = newOwner;
        emit OwnershipTransferred(oldOwner, newOwner);
    }
}










pragma solidity 0.8.13;






contract Shipyard is Ownable {
    event NewShip(string reserveName, address newShip, string shipType);

    mapping(bytes32 => address) public shipImplementation;
    mapping(bytes32 => string) public shipTypes;

    Quartermaster public quarterMaster;
    Lighthouse public lighthouse;

    string public constant MODEL = "SBII-shipyard-test";

    constructor() {}

    function setSail(
        string calldata shipType,
        string calldata reserveName,
        bytes calldata initArg
    ) external payable returns (address) {
        bytes32 key = keccak256(abi.encodePacked(shipType));
        require(shipImplementation[key] != address(0), "not exist");
        Quartermaster.Fees memory fees = quarterMaster.getFees(shipType);

        paymentUtil.processPayment(fees.token, fees.onetime);

        address clone = ClonesUpgradeable.clone(shipImplementation[key]);
        ISBShipable(clone).initialize(initArg, fees.bip, address(this));
        lighthouse.registerContract(
            reserveName,
            clone,
            shipTypes[key],
            msg.sender
        );
        emit NewShip(reserveName, clone, shipTypes[key]);
        return clone;
    }

    function getPrice(string calldata shipType)
        public
        view
        returns (Quartermaster.Fees memory)
    {
        return quarterMaster.getFees(shipType);
    }

    function addBlueprint(
        string memory shipName,
        string memory shipType,
        address implementation
    ) public onlyOwner {
        bytes32 key = keccak256(abi.encodePacked(shipName));
        shipImplementation[key] = implementation;
        shipTypes[key] = shipType;
    }

    function removeBlueprint(string memory shipName) public onlyOwner {
        shipImplementation[keccak256(abi.encodePacked(shipName))] = address(0);
    }

    function withdraw(address tokenAddress) public onlyOwner {
        if (tokenAddress == address(0)) {
            payable(msg.sender).transfer(address(this).balance);
        } else {
            IERC20 token = IERC20(tokenAddress);
            token.transfer(msg.sender, token.balanceOf(address(this)));
        }
    }

    function setQM(address qm) public onlyOwner {
        quarterMaster = Quartermaster(qm);
    }

    function setLH(address lh) public onlyOwner {
        lighthouse = Lighthouse(lh);
    }

    receive() external payable {}

    fallback() external payable {}
}