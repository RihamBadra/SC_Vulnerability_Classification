


pragma solidity ^0.8.0;

interface IERC20 {
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
    function transfer(address recipient, uint256 amount) external returns (bool);
    function approve(address spender, uint256 amount) external returns (bool);
}

interface ISmartSwap {
    function isSystem(address caller) external returns(bool);   
    function decimals(address token) external returns(uint256);   
    function processingFee() external returns(uint256); 
    function companySPFee() external returns(uint256); 
    function reimburse(address user, uint256 amount) external; 
    function swap(
        address tokenA,
        address tokenB, 
        address receiver,
        uint256 amountA,
        address licensee,
        bool isInvestment,
        uint128 minimumAmountToClaim,   
        uint128 limitPice   
    )
        external
        payable
        returns (bool);

    function cancel(
        address tokenA,
        address tokenB, 
        address receiver,
        uint256 amountA    
    )
        external
        payable
        returns (bool);

    function claimTokenBehalf(
        address tokenA, 
        address tokenB, 
        address sender,
        address receiver,
        bool isInvestment,
        uint128 amountA,    
        uint128 currentRate,     
        uint256 foreignBalance  
    )   
        external
        returns (bool);
}

contract SPImplementation{
    struct Tokens {
        address nativeToken;
        address foreignToken;
        uint8 nativeDecimals;
        uint8 foreignDecimals;        
    }
    Tokens public tokensData;
    address public nativeTokenReceiver;
    address public foreignTokenReceiver;
    address public owner;

    ISmartSwap public smartSwap; 
    uint256 private feeAmountLimit; 
    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
    event FeeTransfer(address indexed systemWallet, uint256 fee);
    event Deposit(uint256 value);

    
    function initialize(
        address _owner,     
        address _nativeToken, 
        address _foreignToken, 
        address _nativeTokenReceiver, 
        address _foreignTokenReceiver, 
        uint256 _feeAmountLimit 
    )
        external
    {
        require(owner == address(0)); 
        require(
            _nativeToken != address(0)
            && _foreignToken != address(0)
            && _nativeTokenReceiver != address(0)
            && _foreignTokenReceiver != address(0)
        );
        tokensData.nativeToken = _nativeToken;
        tokensData.foreignToken = _foreignToken;
        nativeTokenReceiver = _nativeTokenReceiver;
        foreignTokenReceiver = _foreignTokenReceiver;
        feeAmountLimit = _feeAmountLimit;
        smartSwap = ISmartSwap(msg.sender);
        tokensData.nativeDecimals = uint8(smartSwap.decimals(tokensData.nativeToken));
        tokensData.foreignDecimals = uint8(smartSwap.decimals(tokensData.foreignToken));
        owner = _owner;
        emit OwnershipTransferred(address(0), _owner);
    }

    receive() external payable {
        emit Deposit(msg.value);
    }

    
    modifier onlySystem() {
        require(smartSwap.isSystem(msg.sender), "Caller is not the system");
        _;
    }

    
    modifier onlyOwner() {
        require(owner == msg.sender, "Ownable: caller is not the owner");
        _;
    }

    
    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), "Ownable: new owner is the zero address");
        emit OwnershipTransferred(owner, newOwner);
        owner = newOwner;
    }

    
    function setFeeAmountLimit(uint256 amount) external onlyOwner {
        feeAmountLimit = amount;
    }

    
    function getFeeAmountLimit() external view returns(uint256) {
        return feeAmountLimit;
    }

    function cancel(uint256 amount) external onlySystem {
        smartSwap.cancel(tokensData.nativeToken, tokensData.foreignToken, foreignTokenReceiver, amount);
    }

    
    function withdraw(address token, uint256 amount) external onlyOwner {
        if (token < address(9))
            safeTransferETH(msg.sender, amount);
        else
            safeTransfer(token, msg.sender, amount);
    }



    
    function addLiquidityAndClaimBehalf(
        uint128 amount,    
        uint128 currentRate,     
        uint128[] memory claimAmount, 
        uint256[] memory foreignBalance,  
        address[] memory senderCounterparty, 
        address[] memory receiverCounterparty,    
        uint256 feeAmount,   
        uint256 reimbursement   
    ) 
        external 
        onlySystem 
    {
        require(feeAmountLimit >= feeAmount, "Fee limit exceeded");

        feeAmountLimit -= feeAmount;
        Tokens memory t = tokensData;
        require(claimAmount.length == foreignBalance.length &&
            senderCounterparty.length == receiverCounterparty.length &&
            foreignBalance.length == senderCounterparty.length,
            "Wrong length"
        );
        
        swap(t, amount, feeAmount);
        
        claimBehalf(t, amount, currentRate, claimAmount, foreignBalance, senderCounterparty, receiverCounterparty, reimbursement);

    }

    function claimBehalf(
        Tokens memory t, 
        uint128 amount,    
        uint128 currentRate,     
        uint128[] memory claimAmount, 
        uint256[] memory foreignBalance,  
        address[] memory senderCounterparty, 
        address[] memory receiverCounterparty,    
        uint256 reimbursement   
    ) 
        internal 
    {
        uint256 totalAmount;
        for (uint256 i = 0; i < claimAmount.length; i++) {
            totalAmount += claimAmount[i];
            smartSwap.claimTokenBehalf(
                t.foreignToken,
                t.nativeToken,
                senderCounterparty[i],
                receiverCounterparty[i],
                false,
                claimAmount[i],
                currentRate, 
                foreignBalance[i]
            );
        }
        require(totalAmount * currentRate / (10**(18+t.foreignDecimals-t.nativeDecimals)) <= uint256(amount), "Insuficiant amount");

        if (reimbursement != 0) {
            for (uint256 i = 0; i < claimAmount.length; i++) {
                smartSwap.reimburse(receiverCounterparty[i], reimbursement * claimAmount[i] / totalAmount);
            }
        }
    }

    function swap(Tokens memory t, uint128 amount, uint256 feeAmount) internal {
        uint256 processingFee = smartSwap.processingFee();
        if (t.nativeToken > address(9)) {
            
            IERC20(t.nativeToken).approve(address(smartSwap), uint256(amount));
            smartSwap.swap{value: processingFee}(
                t.nativeToken, 
                t.foreignToken,
                foreignTokenReceiver, 
                amount, 
                address(0),
                false, 
                0,
                0
            );            
        } else {    
            processingFee = uint256(amount)*smartSwap.companySPFee()/10000 + processingFee;
            smartSwap.swap{value: uint256(amount) + processingFee}(
                t.nativeToken, 
                t.foreignToken,
                foreignTokenReceiver, 
                amount, 
                address(0),
                false, 
                0,
                0
            );
        }
        require(processingFee <= feeAmount, "Insuficiant fee");
        feeAmount -= processingFee; 
        if (feeAmount != 0) {
            payable(msg.sender).transfer(feeAmount);
            emit FeeTransfer(msg.sender, feeAmount);
        }        
    }

    function safeTransfer(address token, address to, uint value) internal {
        
        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));
        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TRANSFER_FAILED');
    }

    function safeTransferETH(address to, uint value) internal {
        (bool success,) = to.call{value:value}(new bytes(0));
        require(success, 'ETH_TRANSFER_FAILED');
    }
}