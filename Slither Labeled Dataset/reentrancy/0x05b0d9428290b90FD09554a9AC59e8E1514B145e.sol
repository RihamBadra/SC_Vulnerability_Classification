







pragma solidity ^0.8.0;


abstract contract Context {
    function _msgSender() internal view virtual returns (address) {
        return msg.sender;
    }

    function _msgData() internal view virtual returns (bytes calldata) {
        this; 
        return msg.data;
    }
}





pragma solidity ^0.8.0;


abstract contract Ownable is Context {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    
    constructor () {
        address msgSender = _msgSender();
        _owner = msgSender;
        emit OwnershipTransferred(address(0), msgSender);
    }

    
    function owner() public view virtual returns (address) {
        return _owner;
    }

    
    modifier onlyOwner() {
        require(owner() == _msgSender(), "Ownable: caller is not the owner");
        _;
    }

    
    function renounceOwnership() public virtual onlyOwner {
        revert("Cannot renounceOwnership with this contract");
        
    }

    
    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), "Ownable: new owner is the zero address");
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }
}





pragma solidity ^0.8.0;


interface IERC20 {
    
    function totalSupply() external view returns (uint256);

    
    function balanceOf(address account) external view returns (uint256);

    
    function transfer(address recipient, uint256 amount) external returns (bool);

    
    function allowance(address owner, address spender) external view returns (uint256);

    
    function approve(address spender, uint256 amount) external returns (bool);

    
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);

    
    event Transfer(address indexed from, address indexed to, uint256 value);

    
    event Approval(address indexed owner, address indexed spender, uint256 value);
}





pragma solidity ^0.8.0;



contract ERC20 is Context, IERC20 {
    mapping (address => uint256) private _balances;

    mapping (address => mapping (address => uint256)) private _allowances;

    uint256 private _totalSupply;

    string private _name;
    string private _symbol;

    
    constructor (string memory name_, string memory symbol_) {
        _name = name_;
        _symbol = symbol_;
    }

    
    function name() public view virtual returns (string memory) {
        return _name;
    }

    
    function symbol() public view virtual returns (string memory) {
        return _symbol;
    }

    
    function decimals() public view virtual returns (uint8) {
        return 18;
    }

    
    function totalSupply() public view virtual override returns (uint256) {
        return _totalSupply;
    }

    
    function balanceOf(address account) public view virtual override returns (uint256) {
        return _balances[account];
    }

    
    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {
        _transfer(_msgSender(), recipient, amount);
        return true;
    }

    
    function allowance(address owner, address spender) public view virtual override returns (uint256) {
        return _allowances[owner][spender];
    }

    
    function approve(address spender, uint256 amount) public virtual override returns (bool) {
        _approve(_msgSender(), spender, amount);
        return true;
    }

    
    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {
        _transfer(sender, recipient, amount);

        uint256 currentAllowance = _allowances[sender][_msgSender()];
        require(currentAllowance >= amount, "ERC20: transfer amount exceeds allowance");
        _approve(sender, _msgSender(), currentAllowance - amount);

        return true;
    }

    
    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {
        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);
        return true;
    }

    
    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {
        uint256 currentAllowance = _allowances[_msgSender()][spender];
        require(currentAllowance >= subtractedValue, "ERC20: decreased allowance below zero");
        _approve(_msgSender(), spender, currentAllowance - subtractedValue);

        return true;
    }

    
    function _transfer(address sender, address recipient, uint256 amount) internal virtual {
        require(sender != address(0), "ERC20: transfer from the zero address");
        require(recipient != address(0), "ERC20: transfer to the zero address");

        _beforeTokenTransfer(sender, recipient, amount);

        uint256 senderBalance = _balances[sender];
        require(senderBalance >= amount, "ERC20: transfer amount exceeds balance");
        _balances[sender] = senderBalance - amount;
        _balances[recipient] += amount;

        emit Transfer(sender, recipient, amount);
    }

    
    function _mint(address account, uint256 amount) internal virtual {
        require(account != address(0), "ERC20: mint to the zero address");

        _beforeTokenTransfer(address(0), account, amount);

        _totalSupply += amount;
        _balances[account] += amount;
        emit Transfer(address(0), account, amount);
    }

    
    function _burn(address account, uint256 amount) internal virtual {
        require(account != address(0), "ERC20: burn from the zero address");

        _beforeTokenTransfer(account, address(0), amount);

        uint256 accountBalance = _balances[account];
        require(accountBalance >= amount, "ERC20: burn amount exceeds balance");
        _balances[account] = accountBalance - amount;
        _totalSupply -= amount;

        emit Transfer(account, address(0), amount);
    }

    
    function _approve(address owner, address spender, uint256 amount) internal virtual {
        require(owner != address(0), "ERC20: approve from the zero address");
        require(spender != address(0), "ERC20: approve to the zero address");

        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }

    
    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }
}




pragma solidity 0.8.4;
contract Vault is Ownable {
    address private dispatcherAddress;
    address private multiSigAddress;
    address[] private tokens;

    struct supportedToken {
        ERC20 token;
        bool active;
    }

    mapping(address => supportedToken) private tokensStore;

    constructor(address _multiSigAddress) Ownable() {
        require(_multiSigAddress != address(0), "Cannot set address to 0");
        multiSigAddress = _multiSigAddress;
    }

    

    function getDispatcherAddress() public view returns (address) {
        return dispatcherAddress;
    }

    function getMultiSigAddress() public view returns (address) {
        return multiSigAddress;
    }

    function getTokenAddresses() public view returns (address[] memory) {
        return tokens;
    }

    
    function transferFunds(address _tokenAddress, address _recipient, uint256 _amount) external onlyDispatcher {
        require(tokensStore[_tokenAddress].active == true, "Token not supported");
        require(_amount > 0, "Cannot transfer 0 tokens");
        ERC20(_tokenAddress).transfer(_recipient, _amount);
        emit ReleasedFundsEvent(_recipient, _amount);
    }

    function newMultiSig(address _multiSigAddress) external onlyMultiSig {
        require(_multiSigAddress != address(0), "Cannot set address to 0");
        multiSigAddress = _multiSigAddress;
        emit NewMultiSigEvent(_multiSigAddress);
    }

    function newDispatcher(address _dispatcherAddress) external onlyMultiSig {
        require(_dispatcherAddress != address(0), "Can't set address to 0");
        dispatcherAddress = _dispatcherAddress;
        emit NewDispatcherEvent(dispatcherAddress);
    }

    function addToken(address _tokenAddress) external onlyMultiSig {
        require(tokensStore[_tokenAddress].active != true, "Token already supported");
        tokensStore[_tokenAddress].token = ERC20(_tokenAddress);
        tokensStore[_tokenAddress].active = true;
        tokens.push(_tokenAddress);
        emit AddTokenEvent(_tokenAddress);
    }

    function removeToken(address _tokenAddress) external onlyMultiSig {
        require(tokensStore[_tokenAddress].active == true, "Token not supported already");
        tokensStore[_tokenAddress].active = false;
        popTokenArray(_tokenAddress);
        emit RemoveTokenEvent(_tokenAddress);
    }

    

    function popTokenArray(address _tokenAddress) private {
        for(uint256 i = 0; i <= tokens.length; i++)
        {
            if(_tokenAddress == tokens[i])
            {
                tokens[i] = tokens[tokens.length - 1];
                tokens.pop();
                break;
            }
        }
    }

    

    modifier onlyDispatcher() {
        require(dispatcherAddress == msg.sender, "Not the disptacher");
        _;
    }

    modifier onlyMultiSig() {
        require(multiSigAddress == msg.sender, "Not the multisig");
        _;
    }

    
    event NewMultiSigEvent(address newMultiSigAddress);
    event AddTokenEvent(address newTokenAddress);
    event RemoveTokenEvent(address removedTokenAddress);
    event NewDispatcherEvent(address newdDspatcherAddress);
    event ReleasedFundsEvent(address indexed recipient, uint256 amount);
}




pragma solidity 0.8.4;
contract Dispatcher is Ownable {

    Vault private vault;

    address private multiSigAddress;
    address private bridgeControllerAddress;
    address[] private validators;

    uint256 private valThreshold = 1;
    uint256 private uuid = 0;

    uint256[] private outstandingTransferProposalsIndex;

    struct transferProposal {
        address recipientAddress;
        uint256 amount;
        address tokenAddress;
        address[] signatures;
        string note;
        bool signed;
    }
    mapping(uint256 => transferProposal) private transferProposalStore;

    mapping(string => string) private transactions;

    constructor(address _vaultAddress, address _multiSigAddress) Ownable() {
        require(_multiSigAddress != address(0), "Cannot set address to 0");
        multiSigAddress = _multiSigAddress;
        vault = Vault(_vaultAddress);
        bridgeControllerAddress = msg.sender;
    }

    
    function getBridgeController() public view returns (address) 
    {
        return bridgeControllerAddress;
    }

    function getValidators() public view returns (address[] memory) 
    {
        return validators;
    }

    function getVaultAddress() public view returns (Vault) 
    {
        return vault;
    }

    function getMultiSig() public view returns (address) 
    {
        return multiSigAddress;
    }
    
    function getOutstandingTransferProposals() public view returns (uint256[] memory) {
        return outstandingTransferProposalsIndex;
    }

    function getValThreshold() public view returns (uint256) 
    {
        return valThreshold;
    }
    function getCreatedTransanction(string memory txID) public view returns (string memory)
    {
        return transactions[txID];
    }

    function getUUID() public view returns (uint256)
    {
        return uuid;
    }

    
    function newThreshold(uint256 _threshold) external onlyMultiSig {
        require(_threshold <= validators.length, "Validation threshold cannot exceed amount of validators");
        require(_threshold > 0, "Threshold must be greater than 0");
        valThreshold = _threshold;
        emit NewThresholdEvent(_threshold);
    }

    function newMultiSig(address _multiSigAddress) external onlyMultiSig {
        require(_multiSigAddress != address(0), "Cannot set address to 0");
        multiSigAddress = _multiSigAddress;
        emit NewMultiSigEvent(_multiSigAddress);
    }


    function newVault(address _vaultAddress) external onlyMultiSig {
        require(_vaultAddress != address(0), "Vault address cannot be 0");
        vault = Vault(_vaultAddress);
        emit NewVault(_vaultAddress);
    }

    function newBridgeController(address _bridgeControllerAddress) external onlyMultiSig {
        require(_bridgeControllerAddress != address(0), "Bridge controller address cannot be 0");
        bridgeControllerAddress = _bridgeControllerAddress;
        emit NewBridgeController(_bridgeControllerAddress);
    }

    function addNewValidator(address _validatorAddress) external onlyMultiSig {
        require(_validatorAddress != address(0), "Validator cannot be 0");
        validators.push(_validatorAddress);
        emit AddedNewValidator(_validatorAddress);
    }

    function removeValidator(address _validatorAddress) external onlyMultiSig {
        
        for(uint256 i = 0; i <= validators.length; i++)
        {
            if(validators[i] == _validatorAddress)
            {
                validators[i] = validators[validators.length - 1];
                validators.pop();
                if(valThreshold > 1)
                {
                    valThreshold = valThreshold - 1;
                }
                break;
            }
        }
        emit RemovedValidator(_validatorAddress);
    }


    

    function proposeNewTxn(address _userAddress, address _tokenAddress, uint256 _amount, string memory _note) external onlyBridgeController{
        transferProposalStore[uuid].recipientAddress = _userAddress;
        transferProposalStore[uuid].amount = _amount;
        transferProposalStore[uuid].tokenAddress = _tokenAddress;
        transferProposalStore[uuid].note = _note;
        if(valThreshold == 1)
        {
            vault.transferFunds(transferProposalStore[uuid].tokenAddress, transferProposalStore[uuid].recipientAddress, transferProposalStore[uuid].amount);
            emit ApprovedTransaction(transferProposalStore[uuid].recipientAddress, transferProposalStore[uuid].amount, uuid);
            emit proposalCreated(uuid);
            transferProposalStore[uuid].signed = true;
        }
        else
        {
            transferProposalStore[uuid].signatures.push(msg.sender);
            outstandingTransferProposalsIndex.push(uuid);
            emit proposalCreated(uuid);
        }
        uuid += 1;
    }

    function approveTxn(uint256 _proposal) external onlyValidators oneVoteTransfer(_proposal){
        require(transferProposalStore[_proposal].signed == false, "Already Signed");

        transferProposalStore[_proposal].signatures.push(msg.sender);

        if (transferProposalStore[_proposal].signatures.length >= valThreshold) {
            vault.transferFunds(transferProposalStore[_proposal].tokenAddress, transferProposalStore[_proposal].recipientAddress, transferProposalStore[_proposal].amount);
            popTransferProposal(_proposal);
            emit ApprovedTransaction(transferProposalStore[_proposal].recipientAddress, transferProposalStore[_proposal].amount, _proposal);
        }
    }

    function createTxn(
    string memory _id, 
    string memory _note,
    address _tokenAddress,
    uint256 _calculatedFee,
    uint256 _amount
    ) external payable{
        require(_amount > 0, "Must send an amount");
        require(msg.value == _calculatedFee, "Calculated fee sent wrong");
        require(bytes(transactions[_id]).length == 0, "Must be a new transaction");
        transactions[_id] = _note;
        ERC20(_tokenAddress).transferFrom(msg.sender, address(this), _amount);
        payable(bridgeControllerAddress).transfer(msg.value);
        emit NewTransactionCreated(msg.sender, _tokenAddress, _amount);
    }


    

    function popTransferProposal(uint256 _uuid) private {
        for(uint256 i = 0; i <= outstandingTransferProposalsIndex.length; i++)
        {
            if(outstandingTransferProposalsIndex[i] == _uuid)
            {
                outstandingTransferProposalsIndex[i] = outstandingTransferProposalsIndex[outstandingTransferProposalsIndex.length - 1];
                outstandingTransferProposalsIndex.pop();
                break;
            }
        }
    }

    
    modifier onlyBridgeController() {
        require(bridgeControllerAddress == msg.sender, "Only the controller can create new transactions");
        _;
    }
    
    modifier onlyMultiSig() {
        require(multiSigAddress == msg.sender, "Not the multisig");
        _;
    }

    modifier onlyValidators() {
        for (uint256 i = 0; i < validators.length; i++) {
            if (validators[i] == msg.sender) {
                _;
            }
        }
    }

    modifier oneVoteTransfer (uint256 _proposal) {
        for(uint256 i = 0; i < transferProposalStore[_proposal].signatures.length; i++){
            require(transferProposalStore[_proposal].signatures[i] != msg.sender, "You have already voted");
        }

        _;
    }

        
    event NewVault(address newAddress); 
    event NewMultiSigEvent(address newMultiSigAddress);
    event AddedNewValidator(address newValidator);
    event RemovedValidator(address oldValidator);
    event NewBridgeController(address newBridgeController);
    event NewThresholdEvent(uint256 newThreshold);
    event proposalCreated(uint256 UUID);
    event ApprovedTransaction(address indexed recipient, uint256 amount, uint256 UUID);
    event NewTransactionCreated(address indexed sender, address tokenAddress, uint256 amount);
    event ReleasedFunds(address indexed recipient, uint256 amount);
}