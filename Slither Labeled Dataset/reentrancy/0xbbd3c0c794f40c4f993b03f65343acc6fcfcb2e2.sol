pragma solidity 0.7.0;

library Address {

    

    function isContract(address account) internal view returns (bool) {

        

        

        

        bytes32 codehash;

        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;

        

        assembly { codehash := extcodehash(account) }

        return (codehash != accountHash && codehash != 0x0);

    }



    

    function sendValue(address payable recipient, uint256 amount) internal {

        require(address(this).balance >= amount, "Address: insufficient balance");



        

        (bool success, ) = recipient.call{value: amount}("");

        require(success, "Address: unable to send value, recipient may have reverted");

    }

}

interface ERCProxy {

    function proxyType() external pure returns (uint256);

    function implementation() external view returns (address);

}

abstract contract Ownable {

    address private _owner;



    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);



    

    constructor () {

        _owner = msg.sender;

        emit OwnershipTransferred(address(0), _owner);

    }



    

    function owner() public view returns (address) {

        return _owner;

    }



    

    modifier onlyOwner() {

        require(isOwner());

        _;

    }



    

    function isOwner() public view returns (bool) {

        return msg.sender == _owner;

    }



    

    function renounceOwnership() public onlyOwner {

        emit OwnershipTransferred(_owner, address(0));

        _owner = address(0);

    }



    

    function transferOwnership(address newOwner) public onlyOwner {

        _transferOwnership(newOwner);

    }



    

    function _transferOwnership(address newOwner) internal {

        require(newOwner != address(0));

        emit OwnershipTransferred(_owner, newOwner);

        _owner = newOwner;

    }

}

abstract contract Upgradeable is Ownable {



    event StateVerified(address indexed testTarget, address sender);

    event UpgradeFinished(address indexed target, address sender);



    

    address public target;



    

    address public previousTarget;



    

    uint8 public isUpgrade;



    

    uint256 stubSlot;



    

    uint8 constant UPGRADE_FALSE = 1;

    uint8 constant UPGRADE_TRUE = 2;



    

    modifier onlyWhileUpgrading()

    {

        require(isUpgrade == UPGRADE_TRUE);

        _;

    }



    

    function verifyState(address _testTarget) public virtual onlyWhileUpgrading {

        emit StateVerified(_testTarget, msg.sender);

    }



    

    function finishUpgrade(address _target) public virtual onlyWhileUpgrading {

        emit UpgradeFinished(_target, msg.sender);

    }



    

    function delegateGetData(

        address _target,

        bytes4 _selector,

        uint8 _numberOfArguments,

        bytes32 _argument1,

        bytes32 _argument2

    )

        internal returns (bytes32 memoryAddress)

    {

        assembly {

            memoryAddress := mload(0x40)

            mstore(memoryAddress, _selector)

            if gt(_numberOfArguments, 0) {

                mstore(add(memoryAddress, 0x04), _argument1)

            }

            if gt(_numberOfArguments, 1) {

                mstore(add(memoryAddress, 0x24), _argument2)

            }

            switch delegatecall(gas(), _target, memoryAddress, add(0x04, mul(0x20, _numberOfArguments)), 0, 0)

                case 0 {

                    revert(memoryAddress, 0)

                }

                default {

                    returndatacopy(memoryAddress, 0x0, returndatasize())

                }

        }

    }



    

    function delegateGet(address _target, bytes4 _selector)

        internal returns (uint256 result)

    {

        bytes32 memoryAddress = delegateGetData(_target, _selector, 0, 0, 0);

        assembly {

            result := mload(memoryAddress)

        }

    }



    

    function delegateGet(address _target, bytes4 _selector, bytes32 _argument)

        internal returns (uint256 result)

    {

        bytes32 memoryAddress = delegateGetData(_target, _selector, 1, _argument, 0);

        assembly {

            result := mload(memoryAddress)

        }

    }



    

    function delegateGet(

        address _target,

        bytes4 _selector,

        bytes32 _argument1,

        bytes32 _argument2

    )

        internal returns (uint256 result)

    {

        bytes32 memoryAddress = delegateGetData(_target, _selector, 2, _argument1, _argument2);

        assembly {

            result := mload(memoryAddress)

        }

    }

}

contract Dispatcher is Upgradeable, ERCProxy {

    using Address for address;



    event Upgraded(address indexed from, address indexed to, address owner);

    event RolledBack(address indexed from, address indexed to, address owner);



    

    modifier upgrading()

    {

        isUpgrade = UPGRADE_TRUE;

        _;

        isUpgrade = UPGRADE_FALSE;

    }



    

    constructor(address _target) upgrading {

        require(_target.isContract());

        

        verifyState(_target);

        

        verifyUpgradeableState(_target, _target);

        target = _target;

        finishUpgrade();

        emit Upgraded(address(0), _target, msg.sender);

    }



    

    

    function proxyType() external pure override returns (uint256) {

        return 2;

    }



    

    function implementation() external view override returns (address) {

        return target;

    }

    



    

    function upgrade(address _target) public onlyOwner upgrading {

        require(_target.isContract());

        

        verifyState(_target);

        

        verifyUpgradeableState(_target, _target);

        if (target.isContract()) {

            verifyUpgradeableState(target, _target);

        }

        previousTarget = target;

        target = _target;

        finishUpgrade();

        emit Upgraded(previousTarget, _target, msg.sender);

    }



    

    function rollback() public onlyOwner upgrading {

        require(previousTarget.isContract());

        emit RolledBack(target, previousTarget, msg.sender);

        

        

        verifyState(previousTarget);

        if (target.isContract()) {

            verifyUpgradeableState(previousTarget, target);

        }

        target = previousTarget;

        previousTarget = address(0);

        finishUpgrade();

    }



    

    function verifyUpgradeableState(address _from, address _to) private {

        (bool callSuccess,) = _from.delegatecall(abi.encodeWithSelector(this.verifyState.selector, _to));

        require(callSuccess);

    }



    

    function finishUpgrade() private {

        (bool callSuccess,) = target.delegatecall(abi.encodeWithSelector(this.finishUpgrade.selector, target));

        require(callSuccess);

    }



    function verifyState(address _testTarget) public override onlyWhileUpgrading {

        

        require(address(uint160(delegateGet(_testTarget, this.owner.selector))) == owner());

        require(address(uint160(delegateGet(_testTarget, this.target.selector))) == target);

        require(address(uint160(delegateGet(_testTarget, this.previousTarget.selector))) == previousTarget);

        require(uint8(delegateGet(_testTarget, this.isUpgrade.selector)) == isUpgrade);

    }



    

    function finishUpgrade(address) public override {}



    

    receive() external payable {

        assert(target.isContract());

        

        (bool callSuccess,) = target.delegatecall("");

        if (!callSuccess) {

            revert();

        }

    }



    

    fallback() external payable {

        assert(target.isContract());

        

        (bool callSuccess,) = target.delegatecall(msg.data);

        if (callSuccess) {

            

            

            

            assembly {

                returndatacopy(0x0, 0x0, returndatasize())

                return(0x0, returndatasize())

            }

        } else {

            revert();

        }

    }



}
