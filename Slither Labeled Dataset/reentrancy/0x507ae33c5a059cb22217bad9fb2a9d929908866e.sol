pragma solidity 0.6.6;

abstract contract Context {

    function _msgSender() internal view virtual returns (address payable) {

        return msg.sender;

    }



    function _msgData() internal view virtual returns (bytes memory) {

        this; 

        return msg.data;

    }

}

library SafeMath {

    

    function add(uint256 a, uint256 b) internal pure returns (uint256) {

        uint256 c = a + b;

        require(c >= a, "SafeMath: addition overflow");



        return c;

    }



    

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {

        return sub(a, b, "SafeMath: subtraction overflow");

    }



    

    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {

        require(b <= a, errorMessage);

        uint256 c = a - b;



        return c;

    }



    

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {

        

        

        

        if (a == 0) {

            return 0;

        }



        uint256 c = a * b;

        require(c / a == b, "SafeMath: multiplication overflow");



        return c;

    }



    

    function div(uint256 a, uint256 b) internal pure returns (uint256) {

        return div(a, b, "SafeMath: division by zero");

    }



    

    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {

        require(b > 0, errorMessage);

        uint256 c = a / b;

        



        return c;

    }



    

    function mod(uint256 a, uint256 b) internal pure returns (uint256) {

        return mod(a, b, "SafeMath: modulo by zero");

    }



    

    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {

        require(b != 0, errorMessage);

        return a % b;

    }



    function ceil(uint256 a, uint256 m) internal pure returns (uint256) {

        uint256 c = add(a, m);

        uint256 d = sub(c, 1);

        return mul(div(d,m),m);

    }

}

interface IKEK {

    function transfer(address recipient, uint256 amount) external returns (bool);

    function balanceOf(address account) external view returns (uint256);

    function burn(address account, uint256 amount) external;

}

interface IFARMINGPOOL {

    function getTotalStakedAmount() external view returns (uint256);

    function getStakedAmount(address account) external view returns (uint256);

    function getStakers() external view returns (address[] memory);

}

contract StakingReward is Context {

    using SafeMath for uint256;

    

    

    event ClaimedReward(address account, uint256 amount);

    

    

    struct Gains {

        uint256 RPEPEBLUPendingGains;

        uint256 RPEPELPURPLEPendingGains;

        uint256 RPEPEBLUTotalGained;

        uint256 RPEPELPURPLETotalGained;

    }



    address private _RPEPEBLU;

    address private _RPEPELPURPLE;

    address private _KEK;

    

    uint private _lastTimestamp;

    uint private _timeInterval;

    uint256 private _rewardBlockAmount;

    uint256 private _totalRewardsPerDay;



    mapping(address => Gains) private _gains;

    

    constructor(address kek, address rpepeblu, address rpepelpurple, uint timeInterval) public {

        _KEK = kek;

        _RPEPEBLU = rpepeblu;

        _RPEPELPURPLE = rpepelpurple;



        

        _lastTimestamp = block.timestamp;

        

        _rewardBlockAmount = 260000E18;

        

        

        _timeInterval = timeInterval;

    }



    

    function getRewardBlockAmount() external view returns (uint256) {

        return _rewardBlockAmount;

    }

    

    

    function getPendingGainsInRPEPEBLU(address account) public view returns (uint256) {

        return _gains[account].RPEPEBLUPendingGains;

    }



    

    function getPendingGainsInRPEPELPURPLE(address account) public view returns (uint256) {

        return _gains[account].RPEPELPURPLEPendingGains;

    }



    

    function getTotalGainedInRPEPEBLU(address account) public view returns (uint256) {

        return _gains[account].RPEPEBLUTotalGained;

    }



    

    function getTotalGainedInRPEPELPURPLE(address account) public view returns (uint256) {

        return _gains[account].RPEPELPURPLETotalGained;

    }



    

    function getTotalStakedAmountInPools() public view returns (uint256) {

        uint256 stakedAmountInPKPool = IFARMINGPOOL(_RPEPEBLU).getTotalStakedAmount();

        uint256 stakedAmountInLPPool = IFARMINGPOOL(_RPEPELPURPLE).getTotalStakedAmount();

        return stakedAmountInPKPool.add(stakedAmountInLPPool);

    }



    

    function getStakingRateInRPEPEBLU() public view returns (uint256) {

        uint256 maxRate = _getMaximunRate();

        uint256 minRate = _getMinimunRate();

        uint256 totalStakedAmount = getTotalStakedAmountInPools();

        uint256 rate = 0;



        if (totalStakedAmount > 0) {

            rate = _rewardBlockAmount.mul(1E18).div(totalStakedAmount);

            if (rate < minRate) {

                rate = minRate;

            } else if (rate > maxRate) {

                rate = maxRate;

            }

        }

        return rate;

    }



    

    function getStakingRateInRPEPELPURPLE() public view returns (uint256) {

        uint256 maxRate = _getMaximunRate().mul(2);

        uint256 minRate = _getMinimunRate().mul(2);

        uint256 totalStakedAmount = getTotalStakedAmountInPools();

        uint256 rate = 0;



        if (totalStakedAmount > 0) {

            rate = _rewardBlockAmount.mul(1E18).div(totalStakedAmount);

            if (rate < minRate) {

                rate = minRate;

            } else if (rate > maxRate) {

                rate = maxRate;

            }

        }

        return rate;

    }



    

    function harvestFromRPEPEBLU() external {

        uint256 pendingGains = getPendingGainsInRPEPEBLU(_msgSender());

        

        require(IKEK(_KEK).transfer(_msgSender(), pendingGains));

        _gains[_msgSender()].RPEPEBLUPendingGains = 0;

        _gains[_msgSender()].RPEPEBLUTotalGained = _gains[_msgSender()].RPEPEBLUTotalGained.add(pendingGains);

        emit ClaimedReward(_msgSender(), pendingGains);

    }



    

    function harvestFromRPEPELPURPLE() external {

        uint256 pendingGains = getPendingGainsInRPEPELPURPLE(_msgSender());

        

        require(IKEK(_KEK).transfer(_msgSender(), pendingGains));

        _gains[_msgSender()].RPEPELPURPLEPendingGains = 0;

        _gains[_msgSender()].RPEPELPURPLETotalGained = _gains[_msgSender()].RPEPELPURPLETotalGained.add(pendingGains);

        emit ClaimedReward(_msgSender(), pendingGains);

    }



    

    function createRewardBlockAndClaimRewards() external {

        uint count = (block.timestamp - _lastTimestamp) / _timeInterval;

        _createRewardBlockAndClaimRewards(count);

        

        _lastTimestamp = count * _timeInterval + _lastTimestamp;

    }

    

    

    function _getMaximunRate() internal view returns (uint256) {

        uint256 maxRate = 0;

        if (_rewardBlockAmount == 260000E18) { 

            maxRate = 5E16;

        } else if (_rewardBlockAmount == 130000E18) { 

            maxRate = 25E15;

        } else if (_rewardBlockAmount == 65000E18) { 

            maxRate = 125E14;

        } else if (_rewardBlockAmount == 32500E18) { 

            maxRate = 625E13;

        }

        require(maxRate > 0, "Block size has been undefined");

        return maxRate;

    }



    

    function _getMinimunRate() internal view returns (uint256) {

        uint256 minRate = 0;

        if (_rewardBlockAmount == 260000E18) { 

            minRate = 5E15;

        } else if (_rewardBlockAmount == 130000E18) { 

            minRate = 25E14;

        } else if (_rewardBlockAmount == 65000E18) { 

            minRate = 125E13;

        } else if (_rewardBlockAmount == 32500E18) { 

            minRate = 625E12;

        }

        require(minRate > 0, "Block size has been undefined");

        return minRate;

    }



    

    function _createRewardBlockAndClaimRewards(uint count) internal {

        for (uint i = 0; i < count; i++) {

            _createRewardBlockAndBurn(IKEK(_KEK).balanceOf(address(this)));

            _claimRewardsInRPEPEBLU();

            _claimRewardsInRPEPELPURPLE();

        }

    }



    

    function _createRewardBlockAndBurn(uint256 available) internal {

        require(available > 0, "Available KEK amount must be more than zero.");

        uint256 percent = available.div(49000000E10).mul(100);

        

        _totalRewardsPerDay = 0;



        if (percent > 0 && percent < 25) {

            _rewardBlockAmount = 32500E18;

            IKEK(_KEK).burn(address(this), 32500E18);

        } else if (percent >= 25 && percent < 50) {

            _rewardBlockAmount = 65000E18;

            IKEK(_KEK).burn(address(this), 65000E18);

        } else if (percent >= 50 && percent < 75) {

            _rewardBlockAmount = 130000E18;

            IKEK(_KEK).burn(address(this), 130000E18);

        } else if (percent >= 75 && percent <= 100) {

            _rewardBlockAmount = 260000E18;

            IKEK(_KEK).burn(address(this), 260000E18);

        }

    }

    

    

    function _claimRewardsInRPEPEBLU() internal {

        address[] memory stakers = IFARMINGPOOL(_RPEPEBLU).getStakers();

        for (uint256 i = 0; i < stakers.length; i++) {

            _calcPendingGainsInRPEPEBLU(stakers[i]);

        }

    }



    

    function _claimRewardsInRPEPELPURPLE() internal {

        address[] memory stakers = IFARMINGPOOL(_RPEPELPURPLE).getStakers();

        for (uint256 i = 0; i < stakers.length; i++) {

            _calcPendingGainsInRPEPELPURPLE(stakers[i]);

        }

    }



    

    function _calcPendingGainsInRPEPEBLU(address account) internal {

        require(account != address(0), "Invalid address");

        uint256 rewards = (IFARMINGPOOL(_RPEPEBLU).getStakedAmount(account)).mul(getStakingRateInRPEPEBLU()).div(1E18);



        if (_totalRewardsPerDay.add(rewards) > _rewardBlockAmount) {

            rewards = _rewardBlockAmount.sub(_totalRewardsPerDay);

        }

        _gains[account].RPEPEBLUPendingGains = _gains[account].RPEPEBLUPendingGains.add(rewards);

        _totalRewardsPerDay = _totalRewardsPerDay.add(rewards);

    }



    

    function _calcPendingGainsInRPEPELPURPLE(address account) internal {

        require(account != address(0), "Invalid address");

        uint256 rewards = (IFARMINGPOOL(_RPEPELPURPLE).getStakedAmount(account)).mul(getStakingRateInRPEPELPURPLE()).div(1E18);



        if (_totalRewardsPerDay.add(rewards) > _rewardBlockAmount) {

            rewards = _rewardBlockAmount.sub(_totalRewardsPerDay);

        }

        _gains[account].RPEPELPURPLEPendingGains = _gains[account].RPEPELPURPLEPendingGains.add(rewards);

        _totalRewardsPerDay = _totalRewardsPerDay.add(rewards);

    }

}
