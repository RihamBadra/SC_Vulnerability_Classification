pragma solidity 0.7.3;

abstract contract Context {


    function _msgSender() internal virtual view returns (address payable) {


        return msg.sender;


    }





    function _msgData() internal virtual view returns (bytes memory) {


        this; 


        return msg.data;


    }


}

interface IERC20 {


    


    function totalSupply() external view returns (uint256);





    


    function balanceOf(address account) external view returns (uint256);





    


    function transfer(address recipient, uint256 amount)


        external


        returns (bool);





    


    function allowance(address owner, address spender)


        external


        view


        returns (uint256);





    


    function approve(address spender, uint256 amount) external returns (bool);





    


    function transferFrom(


        address sender,


        address recipient,


        uint256 amount


    ) external returns (bool);





    


    event Transfer(address indexed from, address indexed to, uint256 value);





    


    event Approval(


        address indexed owner,


        address indexed spender,


        uint256 value


    );


}

library SafeMath {


    


    function add(uint256 a, uint256 b) internal pure returns (uint256) {


        uint256 c = a + b;


        require(c >= a, "SafeMath: addition overflow");





        return c;


    }





    


    function sub(uint256 a, uint256 b) internal pure returns (uint256) {


        return sub(a, b, "SafeMath: subtraction overflow");


    }





    


    function sub(


        uint256 a,


        uint256 b,


        string memory errorMessage


    ) internal pure returns (uint256) {


        require(b <= a, errorMessage);


        uint256 c = a - b;





        return c;


    }





    


    function mul(uint256 a, uint256 b) internal pure returns (uint256) {


        


        


        


        if (a == 0) {


            return 0;


        }





        uint256 c = a * b;


        require(c / a == b, "SafeMath: multiplication overflow");





        return c;


    }





    


    function div(uint256 a, uint256 b) internal pure returns (uint256) {


        return div(a, b, "SafeMath: division by zero");


    }





    


    function div(


        uint256 a,


        uint256 b,


        string memory errorMessage


    ) internal pure returns (uint256) {


        require(b > 0, errorMessage);


        uint256 c = a / b;


        





        return c;


    }





    


    function mod(uint256 a, uint256 b) internal pure returns (uint256) {


        return mod(a, b, "SafeMath: modulo by zero");


    }





    


    function mod(


        uint256 a,


        uint256 b,


        string memory errorMessage


    ) internal pure returns (uint256) {


        require(b != 0, errorMessage);


        return a % b;


    }


}

contract ERC20 is Context, IERC20 {


    using SafeMath for uint256;





    address private _owner;


    uint256 private _totalSupply;


    address private _underlying;





    bytes32[] private _transactions;


    mapping (address => uint256) private _balances;


    mapping (address => mapping (address => uint256)) private _allowances;





    string private _name;


    string private _symbol;


    uint8 private _decimals;





    


    modifier onlyOwner() {


        require(msg.sender == _owner);


        _;


    }    





    


    constructor (string memory name, string memory symbol, address underlying) {


        _owner = _msgSender();


        _name = name;


        _symbol = symbol;


        _decimals = 18;


        _underlying = underlying;


    }





    


    function name() public view returns (string memory) {


        return _name;


    }





    


    function symbol() public view returns (string memory) {


        return _symbol;


    }





    


    function decimals() public view returns (uint8) {


        return _decimals;


    }





    


    function underlying() public view returns (address) {


        return _underlying;


    }





    


    function minted(bytes32 transaction) public view returns (bool) {


        return _minted(transaction);


    }    





    


    function totalSupply() public view override returns (uint256) {


        return _totalSupply;


    }





    


    function balanceOf(address account) public view override returns (uint256) {


        return _balances[account];


    }





    


    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {


        _transfer(_msgSender(), recipient, amount);


        return true;


    }





        


    function mint(bytes32 transaction, address recipient, uint256 amount) public virtual onlyOwner returns (bool) {


        require(transaction != bytes32(0), "ERC20: transaction is zero");


        require(recipient != address(0), "ERC20: mint to the zero address");


        require(_minted(transaction) == false, "ERC20: transaction has been minted");





        _mint(recipient, amount);





        _transactions.push(transaction);


        


        return true;


    }





    


    function unwrap(uint256 amount) public virtual returns (bool) {      


        require(_balances[_msgSender()] >= amount, "ERC20: unwrap amount exceeds balance");





        require(ERC20(_underlying).transfer(_msgSender(), amount), "ERC20: underlying.transfer() returned false");





        _burn(_msgSender(), amount);


        


        return true;


    }    





    


    function allowance(address owner, address spender) public view virtual override returns (uint256) {


        return _allowances[owner][spender];


    }





    


    function approve(address spender, uint256 amount) public virtual override returns (bool) {


        _approve(_msgSender(), spender, amount);


        return true;


    }





    


    function transferFrom(address source, address recipient, uint256 amount) public virtual override returns (bool) {


        require(source != address(0), "ERC20: transfer from the zero address");


        require(recipient != address(0), "ERC20: transfer to the zero address");





        require(_balances[source] >= amount, "ERC20: transfer amount exceeds balance");





        if (source != _msgSender() && _allowances[source][_msgSender()] != uint(-1)) {           


            require(_allowances[source][_msgSender()] >= amount, "ERC20: transfer amount exceeds allowance");


            _approve(source, _msgSender(), _allowances[source][_msgSender()].sub(amount));


        }





        _transfer(source, recipient, amount);


        


        return true;


    }    





    


    function _transfer(address sender, address recipient, uint256 amount) internal virtual {


        require(sender != address(0), "ERC20: transfer from the zero address");


        require(recipient != address(0), "ERC20: transfer to the zero address");





        _balances[sender] = _balances[sender].sub(amount, "ERC20: transfer amount exceeds balance");


        _balances[recipient] = _balances[recipient].add(amount);





        emit Transfer(sender, recipient, amount);


    }





    


    function _mint(address account, uint256 amount) internal virtual {


        require(account != address(0), "ERC20: mint to the zero address");





        _totalSupply = _totalSupply.add(amount);


        _balances[account] = _balances[account].add(amount);





        emit Transfer(address(0), account, amount);


    }





    


    function _minted(bytes32 transaction) internal view returns (bool) {


        for (uint i; i < _transactions.length; i++) {


            if (_transactions[i] == transaction) {


                return true;


            }


        }


        return false;


    }       





    


    function _burn(address account, uint256 amount) internal virtual {


        require(account != address(0), "ERC20: burn from the zero address");





        _balances[account] = _balances[account].sub(amount, "ERC20: burn amount exceeds balance");


        _totalSupply = _totalSupply.sub(amount);





        emit Transfer(account, address(0), amount);


    }    





    


    function _approve(address owner, address spender, uint256 amount) internal virtual {


        require(owner != address(0), "ERC20: approve from the zero address");


        require(spender != address(0), "ERC20: approve to the zero address");





        _allowances[owner][spender] = amount;





        emit Approval(owner, spender, amount);


    }                                    


}
