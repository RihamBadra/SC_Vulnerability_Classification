





pragma solidity ^0.8.0;

abstract contract Context {
    function _msgSender() internal view virtual returns (address) {
        return msg.sender;
    }

    function _msgData() internal view virtual returns (bytes memory) {
        this; 
        return msg.data;
    }
}


abstract contract Ownable is Context {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    
    constructor () {
        address msgSender = _msgSender();
        _owner = msgSender;
        emit OwnershipTransferred(address(0), msgSender);
    }

    
    function owner() public view virtual returns (address) {
        return _owner;
    }

    
    modifier onlyOwner() {
        require(owner() == _msgSender(), "Ownable: caller is not the owner");
        _;
    }

    
    function renounceOwnership() public virtual onlyOwner {
        emit OwnershipTransferred(_owner, address(0));
        _owner = address(0);
    }

    
    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), "Ownable: new owner is the zero address");
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }
}



library SafeMath {
    
    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        uint256 c = a + b;
        if (c < a) return (false, 0);
        return (true, c);
    }

    
    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        if (b > a) return (false, 0);
        return (true, a - b);
    }

    
    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        
        
        
        if (a == 0) return (true, 0);
        uint256 c = a * b;
        if (c / a != b) return (false, 0);
        return (true, c);
    }

    
    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        if (b == 0) return (false, 0);
        return (true, a / b);
    }

    
    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        if (b == 0) return (false, 0);
        return (true, a % b);
    }

    
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, "SafeMath: addition overflow");
        return c;
    }

    
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a, "SafeMath: subtraction overflow");
        return a - b;
    }

    
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a == 0) return 0;
        uint256 c = a * b;
        require(c / a == b, "SafeMath: multiplication overflow");
        return c;
    }

    
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b > 0, "SafeMath: division by zero");
        return a / b;
    }

    
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b > 0, "SafeMath: modulo by zero");
        return a % b;
    }

    
    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b <= a, errorMessage);
        return a - b;
    }

    
    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b > 0, errorMessage);
        return a / b;
    }

    
    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b > 0, errorMessage);
        return a % b;
    }
}


interface IERC20 {
    function decimals() external view returns (uint8);
    function totalSupply() external view returns (uint256);
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
    function allowance(address owner, address spender) external view returns (uint256);
    function approve(address spender, uint256 amount) external returns (bool);
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
}

contract GiveawayContract is Ownable {
    using SafeMath for uint256;

    IERC20 public tokenAccel;

    struct TokenInputInfo {
        address addr;
        uint256 rateInput;
        uint256 rateOutput;
    }
    mapping (uint256 => TokenInputInfo) public tokenInput;
    mapping (uint256 => mapping (address => uint256)) private balances;
    mapping (address => bool) public claimed;

    uint256 private totalDevidend;

    constructor(address _tokenAccel) {
        tokenAccel = IERC20(_tokenAccel);
    }    
    
    function ownerAddInputTokenForSwap(uint256 id, address _inputToken, uint256 _inputRate, uint256 _outputRate)public onlyOwner{
        require(id < 3, "There 3 token, id should be 0,1,2");
        tokenInput[id].addr = _inputToken;
        tokenInput[id].rateInput = _inputRate;
        tokenInput[id].rateOutput = _outputRate;
    }

    receive() external payable {
    }

    function ownerWithdrawEthAndToken() public onlyOwner{    
        tokenAccel.transfer(msg.sender, tokenAccel.balanceOf(address(this)));
        payable(msg.sender).transfer(address(this).balance);
    }

    function ownerSetupTokenBalance(uint256 id, address[] calldata accounts, uint256[] calldata amount) public onlyOwner {
        require(id < 3, "There 3 token, id should be 0,1,2");
        for( uint256 i = 0; i < accounts.length; i++){
            balances[id][accounts[i]] = amount[i];
            totalDevidend = totalDevidend.add(amount[i].mul(tokenInput[id].rateOutput).div(tokenInput[id].rateInput));
        }
    }

    function getClaimableAmount(address account) public view returns(uint256 tokens, uint256 eth, uint256 dividend){
        if(totalDevidend == 0){
            tokens = 0;
            eth = 0;
            dividend = 0;
        }else{
            uint256 yourDividend = 0;
            for (uint256 i= 0; i<3; i++){
                if(tokenInput[i].rateInput > 0)
                    yourDividend = yourDividend.add(balances[i][account].mul(tokenInput[i].rateOutput).div(tokenInput[i].rateInput));
            }
            tokens = tokenAccel.balanceOf(address(this)).mul(yourDividend).div(totalDevidend);
            eth = address(this).balance.mul(yourDividend).div(totalDevidend);
            dividend = yourDividend;
        }
    }

    function claim() public{
        require(claimed[msg.sender] == false, "Already claimed");
        claimed[msg.sender] = true;
        (uint256 tokens, uint256 eth, uint256 dividend) = getClaimableAmount(msg.sender);
        tokenAccel.transfer(msg.sender, tokens);
        payable(msg.sender).transfer(eth);
        totalDevidend = totalDevidend - dividend;
    }

}