pragma solidity 0.6.12;

abstract contract ERC20Interface {


    function totalSupply() public virtual view returns (uint);


    function balanceOf(address tokenOwner) public virtual view returns (uint256 balance);


    function allowance(address tokenOwner, address spender) public virtual view returns (uint256 remaining);


    function transfer(address to, uint256 tokens) public virtual returns (bool success);


    function approve(address spender, uint256 tokens) public virtual returns (bool success);


    function transferFrom(address from, address to, uint256 tokens) public virtual returns (bool success);





    event Transfer(address indexed from, address indexed to, uint256 tokens);


    event Approval(address indexed tokenOwner, address indexed spender, uint256 tokens);


}

contract Owned {


    address payable public owner;





    event OwnershipTransferred(address indexed _from, address indexed _to);





    constructor() public {


        owner = msg.sender;


    }





    modifier onlyOwner {


        require(msg.sender == owner);


        _;


    }





    function transferOwnership(address payable _newOwner) public onlyOwner {


        owner = _newOwner;


        emit OwnershipTransferred(msg.sender, _newOwner);


    }


}

library SafeMath {


  function mul(uint256 a, uint256 b) internal pure returns (uint256) {


    if (a == 0) {


      return 0;


    }


    uint256 c = a * b;


    assert(c / a == b);


    return c;


  }





  function div(uint256 a, uint256 b) internal pure returns (uint256) {


    


    uint256 c = a / b;


    


    return c;


  }





  function sub(uint256 a, uint256 b) internal pure returns (uint256) {


    assert(b <= a);


    return a - b;


  }





  function add(uint256 a, uint256 b) internal pure returns (uint256) {


    uint256 c = a + b;


    assert(c >= a);


    return c;


  }


  


  function ceil(uint a, uint m) internal pure returns (uint r) {


    return (a + m - 1) / m * m;


  }


}

contract Token is ERC20Interface, Owned {


    using SafeMath for uint256;


    string public symbol = "BREE";


    string public  name = "CBDAO";


    uint256 public decimals = 18;


    uint256 private maxCapSupply = 1e7 * 10**(decimals); 


    uint256 _totalSupply = 1530409 * 10 ** (decimals); 


    address stakeFarmingContract;


    


    mapping(address => uint256) balances;


    mapping(address => mapping(address => uint256)) allowed;


    


    


    


    


    constructor() public {


        


        balances[owner] = balances[owner].add(_totalSupply);


        emit Transfer(address(0),owner, _totalSupply);


    }


    


    


    


    


    


    function SetStakeFarmingContract(address _address) external onlyOwner{


        require(_address != address(0), "Invalid address");


        stakeFarmingContract = _address;


    }


    


    


    


    


    


    


    


    


    function MintTokens(uint256 _amount, address _beneficiary) public returns(bool){


        require(msg.sender == stakeFarmingContract);


        require(_beneficiary != address(0), "Invalid address");


        require(_totalSupply.add(_amount) <= maxCapSupply, "exceeds max cap supply 10 million");


        _totalSupply = _totalSupply.add(_amount);


        


        


        balances[_beneficiary] = balances[_beneficiary].add(_amount);


        


        emit Transfer(address(0),_beneficiary, _amount);


        return true;


    }


    


    


    


    


    


    function BurnTokens(uint256 _amount) external {


        _burn(_amount, msg.sender);


    }





    


    


    


    


    


    function _burn(uint256 _amount, address _account) internal {


        require(balances[_account] >= _amount, "insufficient account balance");


        _totalSupply = _totalSupply.sub(_amount);


        balances[_account] = balances[_account].sub(_amount);


        emit Transfer(_account, address(0), _amount);


    }


    


    


    


    


    


    


    function totalSupply() public override view returns (uint256){


       return _totalSupply; 


    }


    


    


    


    


    function balanceOf(address tokenOwner) public override view returns (uint256 balance) {


        return balances[tokenOwner];


    }





    


    


    


    


    


    function transfer(address to, uint256 tokens) public override returns  (bool success) {


        


        require(address(to) != address(0));


        require(balances[msg.sender] >= tokens );


        require(balances[to].add(tokens) >= balances[to]);


            


        balances[msg.sender] = balances[msg.sender].sub(tokens);


        balances[to] = balances[to].add(tokens);


        emit Transfer(msg.sender,to,tokens);


        return true;


    }





    


    function approve(address spender, uint256 value) public override returns (bool) {


        _approve(msg.sender, spender, value);


        return true;


    }





    


    


    


    


    


    


    


    


    


    function transferFrom(address from, address to, uint256 tokens) public override returns (bool success){


        require(tokens <= allowed[from][msg.sender]); 


        require(balances[from] >= tokens);


        require(from != address(0), "Invalid address");


        require(to != address(0), "Invalid address");


        


        balances[from] = balances[from].sub(tokens);


        balances[to] = balances[to].add(tokens);


        allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens);


        emit Transfer(from,to,tokens);


        return true;


    }


    


    


    


    


    


    function allowance(address tokenOwner, address spender) public override view returns (uint256 remaining) {


        return allowed[tokenOwner][spender];


    }


    


    


    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {


        _approve(msg.sender, spender, allowed[msg.sender][spender].add(addedValue));


        return true;


    }





    


    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {


        _approve(msg.sender, spender, allowed[msg.sender][spender].sub(subtractedValue));


        return true;


    }


    


    


    function _approve(address owner, address spender, uint256 value) internal {


        require(owner != address(0), "ERC20: approve from the zero address");


        require(spender != address(0), "ERC20: approve to the zero address");





        allowed[owner][spender] = value;


        emit Approval(owner, spender, value);


    }


}

contract BREE_STAKE_FARM is Owned{


    


    using SafeMath for uint256;


    


    uint256 public yieldCollectionFee = 0.01 ether;


    uint256 public stakingPeriod = 30 days;


    uint256 public stakeClaimFee = 0.001 ether;


    uint256 public minStakeLimit = 500 * 10 **(18); 


    uint256 public totalYield;


    uint256 public totalRewards;


    


    Token public bree;


    


    struct Tokens{


        bool exists;


        uint256 rate;


    }


    


    mapping(address => Tokens) public tokens;


    address[] TokensAddresses;


    address governance;


    


    struct DepositedToken{


        bool    whitelisted;


        uint256 activeDeposit;


        uint256 totalDeposits;


        uint256 startTime;


        uint256 pendingGains;


        uint256 lastClaimedDate;


        uint256 totalGained;


        uint    rate;


        uint    period;


    }


    


    mapping(address => mapping(address => DepositedToken)) users;


    


    event TokenAdded(address indexed tokenAddress, uint256 indexed APY);


    event TokenRemoved(address indexed tokenAddress, uint256 indexed APY);


    event FarmingRateChanged(address indexed tokenAddress, uint256 indexed newAPY);


    event YieldCollectionFeeChanged(uint256 indexed yieldCollectionFee);


    event FarmingStarted(address indexed _tokenAddress, uint256 indexed _amount);


    event YieldCollected(address indexed _tokenAddress, uint256 indexed _yield);


    event AddedToExistingFarm(address indexed _tokenAddress, uint256 indexed tokens);


    


    event Staked(address indexed staker, uint256 indexed tokens);


    event AddedToExistingStake(address indexed staker, uint256 indexed tokens);


    event StakingRateChanged(uint256 indexed newAPY);


    event TokensClaimed(address indexed claimer, uint256 indexed stakedTokens);


    event RewardClaimed(address indexed claimer, uint256 indexed reward);


    


    event GovernanceSet(address indexed governanceAddress);


    


    modifier validStake(uint256 stakeAmount){


        require(stakeAmount >= minStakeLimit, "stake amount should be equal/greater than min stake limit");


        _;


    }


    


    modifier OwnerOrGovernance(address _caller){


        require(_caller == owner || _caller == governance);


        _;


    }


    


    constructor(address _tokenAddress) public {


        bree = Token(_tokenAddress);


        


        


        _addToken(_tokenAddress, 40); 


    }


    


    


    


    


    


    


    


    


    


    


    function Farm(address _tokenAddress, uint256 _amount) external{


        require(_tokenAddress != address(bree), "Use staking instead"); 


        


        


        _newDeposit(_tokenAddress, _amount);


        


        


        require(ERC20Interface(_tokenAddress).transferFrom(msg.sender, address(this), _amount));


        


        emit FarmingStarted(_tokenAddress, _amount);


    }


    


    


    


    


    


    


    function AddToFarm(address _tokenAddress, uint256 _amount) external{


        require(_tokenAddress != address(bree), "use staking instead");


        _addToExisting(_tokenAddress, _amount);


        


        


        require(ERC20Interface(_tokenAddress).transferFrom(msg.sender,address(this), _amount));


        


        emit AddedToExistingFarm(_tokenAddress, _amount);


    }


    


    


    


    


    


    


    function Yield(address _tokenAddress) external payable {


        require(msg.value >= yieldCollectionFee, "should pay exact claim fee");


        require(PendingYield(_tokenAddress, msg.sender) > 0, "No pending yield");


        require(tokens[_tokenAddress].exists, "Token doesn't exist");


        require(_tokenAddress != address(bree), "use staking instead");


    


        uint256 _pendingYield = PendingYield(_tokenAddress, msg.sender);


        


        


        totalYield = totalYield.add(_pendingYield);


        


        


        users[msg.sender][_tokenAddress].totalGained = users[msg.sender][_tokenAddress].totalGained.add(_pendingYield);


        users[msg.sender][_tokenAddress].lastClaimedDate = now;


        users[msg.sender][_tokenAddress].pendingGains = 0;


        


        


        owner.transfer(msg.value);


        


        


        require(bree.MintTokens(_pendingYield, msg.sender));


        


        emit YieldCollected(_tokenAddress, _pendingYield);


    }


    


    


    


    


    


    


    function WithdrawFarmedTokens(address _tokenAddress, uint256 _amount) external {


        require(users[msg.sender][_tokenAddress].activeDeposit >= _amount, "insufficient amount in farming");


        require(_tokenAddress != address(bree), "use withdraw of staking instead");


        


        


            


            users[msg.sender][_tokenAddress].pendingGains = PendingYield(_tokenAddress, msg.sender);


            


            users[msg.sender][_tokenAddress].activeDeposit = users[msg.sender][_tokenAddress].activeDeposit.sub(_amount);


            


            users[msg.sender][_tokenAddress].startTime = now;


            


            users[msg.sender][_tokenAddress].lastClaimedDate = now;


        


        


        require(ERC20Interface(_tokenAddress).transfer(msg.sender, _amount));


        


        emit TokensClaimed(msg.sender, _amount);


    }


    


    


    


    


    


    


    


    


    


    


    function Stake(uint256 _amount) external validStake(_amount) {


        


        _newDeposit(address(bree), _amount);


        


        


        require(bree.transferFrom(msg.sender, address(this), _amount));


        


        emit Staked(msg.sender, _amount);


        


    }


    


    


    


    


    


    


    function AddToStake(uint256 _amount) external {


        require(now - users[msg.sender][address(bree)].startTime < users[msg.sender][address(bree)].period, "current staking expired");


        _addToExisting(address(bree), _amount);





        


        require(bree.transferFrom(msg.sender,address(this), _amount));


        


        emit AddedToExistingStake(msg.sender, _amount);


    }


    


    


    


    


    


    


    function ClaimStakedTokens() external {


        


        require(users[msg.sender][address(bree)].activeDeposit > 0, "no running stake");


        require(users[msg.sender][address(bree)].startTime.add(users[msg.sender][address(bree)].period) < now, "not claimable before staking period");


        


        uint256 _currentDeposit = users[msg.sender][address(bree)].activeDeposit;


        


        


        users[msg.sender][address(bree)].pendingGains = PendingReward(msg.sender);


        


        users[msg.sender][address(bree)].activeDeposit = 0;


        


        


        require(bree.transfer(msg.sender, _currentDeposit));


        


        emit TokensClaimed(msg.sender, _currentDeposit);


        


    }


    


    


    


    


    


    


    function ClaimReward() external payable {


        require(msg.value >= stakeClaimFee, "should pay exact claim fee");


        require(PendingReward(msg.sender) > 0, "nothing pending to claim");


    


        uint256 _pendingReward = PendingReward(msg.sender);


        


        


        totalRewards = totalRewards.add(_pendingReward);


        


        users[msg.sender][address(bree)].totalGained = users[msg.sender][address(bree)].totalGained.add(_pendingReward);


        


        users[msg.sender][address(bree)].lastClaimedDate = now;


        


        users[msg.sender][address(bree)].pendingGains = 0;


        


        


        owner.transfer(msg.value);


        


        


        require(bree.MintTokens(_pendingReward, msg.sender));


         


        emit RewardClaimed(msg.sender, _pendingReward);


    }


    


    


    


    


    


    


    


    


    


    function PendingYield(address _tokenAddress, address _caller) public view returns(uint256 _pendingRewardWeis){


        uint256 _totalFarmingTime = now.sub(users[_caller][_tokenAddress].lastClaimedDate);


        


        uint256 _reward_token_second = ((tokens[_tokenAddress].rate).mul(10 ** 21)).div(365 days); 


        


        uint256 yield = ((users[_caller][_tokenAddress].activeDeposit).mul(_totalFarmingTime.mul(_reward_token_second))).div(10 ** 27); 


        


        return yield.add(users[_caller][_tokenAddress].pendingGains);


    }


    


    


    


    


    


    function ActiveFarmDeposit(address _tokenAddress, address _user) external view returns(uint256 _activeDeposit){


        return users[_user][_tokenAddress].activeDeposit;


    }


    


    


    


    


    


    function YourTotalFarmingTillToday(address _tokenAddress, address _user) external view returns(uint256 _totalFarming){


        return users[_user][_tokenAddress].totalDeposits;


    }


    


    


    


    


    function LastFarmedOn(address _tokenAddress, address _user) external view returns(uint256 _unixLastFarmedTime){


        return users[_user][_tokenAddress].startTime;


    }


    


    


    


    


    


    function TotalFarmingRewards(address _tokenAddress, address _user) external view returns(uint256 _totalEarned){


        return users[_user][_tokenAddress].totalGained;


    }


    


    


    


    


    


    


    


    


    


    


    function setGovernanceContract(address _govAddress) external onlyOwner {


        governance = _govAddress;


        emit GovernanceSet(_govAddress);


    }


    


    


    


    


    


    


    


    function AddToken(address _tokenAddress, uint256 _rate) public OwnerOrGovernance(msg.sender) {


        _addToken(_tokenAddress, _rate);


    }


    


    


    


    


    


    


    function RemoveToken(address _tokenAddress) public OwnerOrGovernance(msg.sender) {


        


        require(tokens[_tokenAddress].exists, "token doesn't exist");


        


        tokens[_tokenAddress].exists = false;


        


        emit TokenRemoved(_tokenAddress, tokens[_tokenAddress].rate);


    }


    


    


    


    


    


    


    


    function ChangeFarmingRate(address _tokenAddress, uint256 _newFarmingRate) public OwnerOrGovernance(msg.sender) {


        


        require(tokens[_tokenAddress].exists, "token doesn't exist");


        


        tokens[_tokenAddress].rate = _newFarmingRate;


        


        emit FarmingRateChanged(_tokenAddress, _newFarmingRate);


    }





    


    


    


    


    


    function SetYieldCollectionFee(uint256 _fee) public OwnerOrGovernance(msg.sender){


        yieldCollectionFee = _fee;


        emit YieldCollectionFeeChanged(_fee);


    }


    


    


    


    


    


    


    


    


    function PendingReward(address _caller) public view returns(uint256 _pendingReward){


        uint256 _totalStakedTime = 0;


        uint256 expiryDate = (users[_caller][address(bree)].period).add(users[_caller][address(bree)].startTime);


        


        if(now < expiryDate)


            _totalStakedTime = now.sub(users[_caller][address(bree)].lastClaimedDate);


        else{


            if(users[_caller][address(bree)].lastClaimedDate >= expiryDate) 


                _totalStakedTime = 0;


            else


                _totalStakedTime = expiryDate.sub(users[_caller][address(bree)].lastClaimedDate);


        }


            


        uint256 _reward_token_second = ((users[_caller][address(bree)].rate).mul(10 ** 21)); 


        uint256 reward =  ((users[_caller][address(bree)].activeDeposit).mul(_totalStakedTime.mul(_reward_token_second))).div(10 ** 27); 


        reward = reward.div(365 days);


        return (reward.add(users[_caller][address(bree)].pendingGains));


    }


    


    


    


    


    function YourActiveStake(address _user) external view returns(uint256 _activeStake){


        return users[_user][address(bree)].activeDeposit;


    }


    


    


    


    


    function YourTotalStakesTillToday(address _user) external view returns(uint256 _totalStakes){


        return users[_user][address(bree)].totalDeposits;


    }


    


    


    


    


    function LastStakedOn(address _user) public view returns(uint256 _unixLastStakedTime){


        return users[_user][address(bree)].startTime;


    }


    


    


    


    


    function TotalStakeRewardsClaimedTillToday(address _user) external view returns(uint256 _totalEarned){


        return users[_user][address(bree)].totalGained;


    }


    


    


    


    


    function LatestStakingRate() external view returns(uint256 APY){


        return tokens[address(bree)].rate;


    }


    


    


    


    


    function YourStakingRate(address _user) external view returns(uint256 _stakingRate){


        return users[_user][address(bree)].rate;


    }


    


    


    


    


    function YourStakingPeriod(address _user) external view returns(uint256 _stakingPeriod){


        return users[_user][address(bree)].period;


    }


    


    


    


    


    function StakingTimeLeft(address _user) external view returns(uint256 _secsLeft){


        uint256 left = 0; 


        uint256 expiryDate = (users[_user][address(bree)].period).add(LastStakedOn(_user));


        


        if(now < expiryDate)


            left = expiryDate.sub(now);


            


        return left;


    }


    


    


    


    


    


    


    


    


    


    


    function ChangeStakingRate(uint256 _newStakingRate) public OwnerOrGovernance(msg.sender){


        


        tokens[address(bree)].rate = _newStakingRate;


        


        emit StakingRateChanged(_newStakingRate);


    }


    


    


    


    


    


    


    function SetMinStakeLimit(uint256 _minStakeLimit) public OwnerOrGovernance(msg.sender){


       minStakeLimit = _minStakeLimit;


    }


    


    


    


    


    


    


    function SetStakingPeriod(uint256 _seconds) public OwnerOrGovernance(msg.sender){


       stakingPeriod = _seconds;


    }


    


    


    


    


    


    


    function SetClaimFee(uint256 _fee) public OwnerOrGovernance(msg.sender){


       stakeClaimFee = _fee;


    }


    


    


    


    


    


    


    


    


    function _newDeposit(address _tokenAddress, uint256 _amount) internal{


        require(users[msg.sender][_tokenAddress].activeDeposit ==  0, "Already running");


        require(tokens[_tokenAddress].exists, "Token doesn't exist");


        


        


        


        if(_tokenAddress == address(bree)){


            users[msg.sender][_tokenAddress].pendingGains = PendingReward(msg.sender);


            users[msg.sender][_tokenAddress].period = stakingPeriod;


            users[msg.sender][_tokenAddress].rate = tokens[_tokenAddress].rate; 


        }


        else


            users[msg.sender][_tokenAddress].pendingGains = PendingYield(_tokenAddress, msg.sender);


            


        users[msg.sender][_tokenAddress].activeDeposit = _amount;


        users[msg.sender][_tokenAddress].totalDeposits = users[msg.sender][_tokenAddress].totalDeposits.add(_amount);


        users[msg.sender][_tokenAddress].startTime = now;


        users[msg.sender][_tokenAddress].lastClaimedDate = now;


        


    }





    


    


    


    function _addToExisting(address _tokenAddress, uint256 _amount) internal{


        require(tokens[_tokenAddress].exists, "Token doesn't exist");


        


        require(users[msg.sender][_tokenAddress].activeDeposit > 0, "no running farming/stake");


        


            


            if(_tokenAddress == address(bree)){


                users[msg.sender][_tokenAddress].pendingGains = PendingReward(msg.sender);


                users[msg.sender][_tokenAddress].period = stakingPeriod;


                users[msg.sender][_tokenAddress].rate = tokens[_tokenAddress].rate; 


            }


            else


                users[msg.sender][_tokenAddress].pendingGains = PendingYield(_tokenAddress, msg.sender);


            


            users[msg.sender][_tokenAddress].activeDeposit = users[msg.sender][_tokenAddress].activeDeposit.add(_amount);


            


            users[msg.sender][_tokenAddress].totalDeposits = users[msg.sender][_tokenAddress].totalDeposits.add(_amount);


            


            users[msg.sender][_tokenAddress].startTime = now;


            


            users[msg.sender][_tokenAddress].lastClaimedDate = now;


            


            


    }





    


    


    


    function _addToken(address _tokenAddress, uint256 _rate) internal{


        require(!tokens[_tokenAddress].exists, "token already exists");


        


        tokens[_tokenAddress] = Tokens({


            exists: true,


            rate: _rate


        });


        


        TokensAddresses.push(_tokenAddress);


        emit TokenAdded(_tokenAddress, _rate);


    }


    


    


}
