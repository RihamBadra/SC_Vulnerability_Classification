pragma solidity 0.5.17;

contract AffiliateStorage {

	using SafeMath for uint;



	mapping(uint=>address) public codeToAddressMap;

	mapping(address=>uint) public addressToCodeMap;

	mapping(address=>uint) public addressToFatherCode;

	uint private constant maxCode = 100000000;

	bytes public constant baseString = "0123456789abcdefghjklmnpqrstuvwxyz";





	

	function newCode(address user) public returns(uint) {

		require(addressToCodeMap[user] == 0, "user existed");



		uint code = uint(user);

		code = code.sub(code.div(maxCode).mul(maxCode));



		require(code !=0, "code must > 0");



		while(codeToAddressMap[code]!=address(0)) {

			code = code.add(7);

		}

		codeToAddressMap[code] = user;

		addressToCodeMap[user] = code;

		return code;



	}



	function getCode(address user) public view returns(uint) {

		uint code = addressToCodeMap[user];

		if(code != 0)

			return code;

	}



	function getUser(uint code) public view returns(address) {

		return codeToAddressMap[code];

	}

	

	function setFather(uint code) public {

	    require(codeToAddressMap[code] != address(0), "inviteCode not existed");

	    addressToFatherCode[msg.sender] = code;

	}

	

	function getFatherCode(address userAddress) public view returns (uint){

	    uint FatherCode = addressToFatherCode[userAddress];

	    return FatherCode;

	}

	

	function getFather(address userAddress) public view returns(address){

        uint FatherCode = addressToFatherCode[userAddress];

        if(FatherCode != 0 ){

        address FatherAddress = getUser(FatherCode);

        return  FatherAddress;

        }

        

	}

	

}

library SafeMath {

    

    function add(uint256 a, uint256 b) internal pure returns (uint256) {

        uint256 c = a + b;

        require(c >= a, "SafeMath: addition overflow");



        return c;

    }



    

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {

        return sub(a, b, "SafeMath: subtraction overflow");

    }



    

    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {

        require(b <= a, errorMessage);

        uint256 c = a - b;



        return c;

    }



    

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {

        

        

        

        if (a == 0) {

            return 0;

        }



        uint256 c = a * b;

        require(c / a == b, "SafeMath: multiplication overflow");



        return c;

    }



    

    function div(uint256 a, uint256 b) internal pure returns (uint256) {

        return div(a, b, "SafeMath: division by zero");

    }



    

    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {

        

        require(b > 0, errorMessage);

        uint256 c = a / b;

        



        return c;

    }



    

    function mod(uint256 a, uint256 b) internal pure returns (uint256) {

        return mod(a, b, "SafeMath: modulo by zero");

    }



    

    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {

        require(b != 0, errorMessage);

        return a % b;

    }

}
