







pragma solidity ^0.6.12;
pragma experimental ABIEncoderV2;

interface IPowerPoke {
  
  function authorizeReporter(uint256 userId_, address pokerKey_) external view;

  function authorizeNonReporter(uint256 userId_, address pokerKey_) external view;

  function authorizeNonReporterWithDeposit(
    uint256 userId_,
    address pokerKey_,
    uint256 overrideMinDeposit_
  ) external view;

  function authorizePoker(uint256 userId_, address pokerKey_) external view;

  function authorizePokerWithDeposit(
    uint256 userId_,
    address pokerKey_,
    uint256 overrideMinStake_
  ) external view;

  function slashReporter(uint256 slasherId_, uint256 times_) external;

  function reward(
    uint256 userId_,
    uint256 gasUsed_,
    uint256 compensationPlan_,
    bytes calldata pokeOptions_
  ) external;

  
  function transferClientOwnership(address client_, address to_) external;

  function addCredit(address client_, uint256 amount_) external;

  function withdrawCredit(
    address client_,
    address to_,
    uint256 amount_
  ) external;

  function setReportIntervals(
    address client_,
    uint256 minReportInterval_,
    uint256 maxReportInterval_
  ) external;

  function setSlasherHeartbeat(address client_, uint256 slasherHeartbeat_) external;

  function setGasPriceLimit(address client_, uint256 gasPriceLimit_) external;

  function setFixedCompensations(
    address client_,
    uint256 eth_,
    uint256 cvp_
  ) external;

  function setBonusPlan(
    address client_,
    uint256 planId_,
    bool active_,
    uint64 bonusNominator_,
    uint64 bonusDenominator_,
    uint64 perGas_
  ) external;

  function setMinimalDeposit(address client_, uint256 defaultMinDeposit_) external;

  
  function withdrawRewards(uint256 userId_, address to_) external;

  function setPokerKeyRewardWithdrawAllowance(uint256 userId_, bool allow_) external;

  
  function addClient(
    address client_,
    address owner_,
    bool canSlash_,
    uint256 gasPriceLimit_,
    uint256 minReportInterval_,
    uint256 maxReportInterval_
  ) external;

  function setClientActiveFlag(address client_, bool active_) external;

  function setCanSlashFlag(address client_, bool canSlash) external;

  function setOracle(address oracle_) external;

  function pause() external;

  function unpause() external;

  
  function creditOf(address client_) external view returns (uint256);

  function ownerOf(address client_) external view returns (address);

  function getMinMaxReportIntervals(address client_) external view returns (uint256 min, uint256 max);

  function getSlasherHeartbeat(address client_) external view returns (uint256);

  function getGasPriceLimit(address client_) external view returns (uint256);

  function getPokerBonus(
    address client_,
    uint256 bonusPlanId_,
    uint256 gasUsed_,
    uint256 userDeposit_
  ) external view returns (uint256);

  function getGasPriceFor(address client_) external view returns (uint256);
}



pragma solidity >=0.6.0 <0.8.0;


interface IERC20 {
    
    function totalSupply() external view returns (uint256);

    
    function balanceOf(address account) external view returns (uint256);

    
    function transfer(address recipient, uint256 amount) external returns (bool);

    
    function allowance(address owner, address spender) external view returns (uint256);

    
    function approve(address spender, uint256 amount) external returns (bool);

    
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);

    
    event Transfer(address indexed from, address indexed to, uint256 value);

    
    event Approval(address indexed owner, address indexed spender, uint256 value);
}



pragma solidity >=0.6.0 <0.8.0;


library SafeMath {
    
    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        uint256 c = a + b;
        if (c < a) return (false, 0);
        return (true, c);
    }

    
    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        if (b > a) return (false, 0);
        return (true, a - b);
    }

    
    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        
        
        
        if (a == 0) return (true, 0);
        uint256 c = a * b;
        if (c / a != b) return (false, 0);
        return (true, c);
    }

    
    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        if (b == 0) return (false, 0);
        return (true, a / b);
    }

    
    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        if (b == 0) return (false, 0);
        return (true, a % b);
    }

    
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, "SafeMath: addition overflow");
        return c;
    }

    
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a, "SafeMath: subtraction overflow");
        return a - b;
    }

    
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a == 0) return 0;
        uint256 c = a * b;
        require(c / a == b, "SafeMath: multiplication overflow");
        return c;
    }

    
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b > 0, "SafeMath: division by zero");
        return a / b;
    }

    
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b > 0, "SafeMath: modulo by zero");
        return a % b;
    }

    
    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b <= a, errorMessage);
        return a - b;
    }

    
    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b > 0, errorMessage);
        return a / b;
    }

    
    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b > 0, errorMessage);
        return a % b;
    }
}



pragma solidity >=0.6.2 <0.8.0;


library Address {
    
    function isContract(address account) internal view returns (bool) {
        
        
        

        uint256 size;
        
        assembly { size := extcodesize(account) }
        return size > 0;
    }

    
    function sendValue(address payable recipient, uint256 amount) internal {
        require(address(this).balance >= amount, "Address: insufficient balance");

        
        (bool success, ) = recipient.call{ value: amount }("");
        require(success, "Address: unable to send value, recipient may have reverted");
    }

    
    function functionCall(address target, bytes memory data) internal returns (bytes memory) {
      return functionCall(target, data, "Address: low-level call failed");
    }

    
    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {
        return functionCallWithValue(target, data, 0, errorMessage);
    }

    
    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {
        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");
    }

    
    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {
        require(address(this).balance >= value, "Address: insufficient balance for call");
        require(isContract(target), "Address: call to non-contract");

        
        (bool success, bytes memory returndata) = target.call{ value: value }(data);
        return _verifyCallResult(success, returndata, errorMessage);
    }

    
    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {
        return functionStaticCall(target, data, "Address: low-level static call failed");
    }

    
    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {
        require(isContract(target), "Address: static call to non-contract");

        
        (bool success, bytes memory returndata) = target.staticcall(data);
        return _verifyCallResult(success, returndata, errorMessage);
    }

    
    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {
        return functionDelegateCall(target, data, "Address: low-level delegate call failed");
    }

    
    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {
        require(isContract(target), "Address: delegate call to non-contract");

        
        (bool success, bytes memory returndata) = target.delegatecall(data);
        return _verifyCallResult(success, returndata, errorMessage);
    }

    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {
        if (success) {
            return returndata;
        } else {
            
            if (returndata.length > 0) {
                

                
                assembly {
                    let returndata_size := mload(returndata)
                    revert(add(32, returndata), returndata_size)
                }
            } else {
                revert(errorMessage);
            }
        }
    }
}




pragma solidity >=0.6.0 <0.8.0;


library SafeERC20 {
    using SafeMath for uint256;
    using Address for address;

    function safeTransfer(IERC20 token, address to, uint256 value) internal {
        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));
    }

    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {
        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));
    }

    
    function safeApprove(IERC20 token, address spender, uint256 value) internal {
        
        
        
        
        require((value == 0) || (token.allowance(address(this), spender) == 0),
            "SafeERC20: approve from non-zero to non-zero allowance"
        );
        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));
    }

    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {
        uint256 newAllowance = token.allowance(address(this), spender).add(value);
        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
    }

    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {
        uint256 newAllowance = token.allowance(address(this), spender).sub(value, "SafeERC20: decreased allowance below zero");
        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
    }

    
    function _callOptionalReturn(IERC20 token, bytes memory data) private {
        
        
        

        bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");
        if (returndata.length > 0) { 
            
            require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");
        }
    }
}



pragma solidity >=0.6.0 <0.8.0;


interface IERC20Permit is IERC20 {
  
  function permit(
    address owner,
    address spender,
    uint256 value,
    uint256 deadline,
    uint8 v,
    bytes32 r,
    bytes32 s
  ) external;

  
  function nonces(address owner) external view returns (uint256);

  
  
  function DOMAIN_SEPARATOR() external view returns (bytes32);
}



pragma solidity 0.6.12;

interface WrappedPiErc20Interface is IERC20Permit {
  function deposit(uint256 _amount) external payable returns (uint256);

  function withdraw(uint256 _amount) external payable returns (uint256);

  function withdrawShares(uint256 _burnAmount) external payable returns (uint256);

  function changeRouter(address _newRouter) external;

  function enableRouterCallback(bool _enable) external;

  function setNoFee(address _for, bool _noFee) external;

  function setEthFee(uint256 _newEthFee) external;

  function withdrawEthFee(address payable receiver) external;

  function approveUnderlying(address _to, uint256 _amount) external;

  function getPiEquivalentForUnderlying(uint256 _underlyingAmount) external view returns (uint256);

  function getUnderlyingEquivalentForPi(uint256 _piAmount) external view returns (uint256);

  function balanceOfUnderlying(address account) external view returns (uint256);

  function callExternal(
    address voting,
    bytes4 signature,
    bytes calldata args,
    uint256 value
  ) external payable returns (bytes memory);

  struct ExternalCallData {
    address destination;
    bytes4 signature;
    bytes args;
    uint256 value;
  }

  function callExternalMultiple(ExternalCallData[] calldata calls) external payable returns (bytes[] memory);

  function getUnderlyingBalance() external view returns (uint256);
}



pragma solidity 0.6.12;

interface IPoolRestrictions {
  function getMaxTotalSupply(address _pool) external view returns (uint256);

  function isVotingSignatureAllowed(address _votingAddress, bytes4 _signature) external view returns (bool);

  function isVotingSenderAllowed(address _votingAddress, address _sender) external view returns (bool);

  function isWithoutFee(address _addr) external view returns (bool);
}



pragma solidity 0.6.12;

interface PowerIndexRouterInterface {
  enum StakeStatus {
    EQUILIBRIUM,
    EXCESS,
    SHORTAGE
  }

  

  function setReserveConfig(
    uint256 _reserveRatio,
    uint256 _reserveRatioLowerBound,
    uint256 _reserveRatioUpperBound,
    uint256 _claimRewardsInterval
  ) external;

  function getPiEquivalentForUnderlying(uint256 _underlyingAmount, uint256 _piTotalSupply)
    external
    view
    returns (uint256);

  function getPiEquivalentForUnderlyingPure(
    uint256 _underlyingAmount,
    uint256 _totalUnderlyingWrapped,
    uint256 _piTotalSupply
  ) external pure returns (uint256);

  function getUnderlyingEquivalentForPi(uint256 _piAmount, uint256 _piTotalSupply) external view returns (uint256);

  function getUnderlyingEquivalentForPiPure(
    uint256 _piAmount,
    uint256 _totalUnderlyingWrapped,
    uint256 _piTotalSupply
  ) external pure returns (uint256);
}



pragma solidity 0.6.12;

interface IRouterConnector {
  struct DistributeData {
    bytes stakeData;
    bytes stakeParams;
    uint256 performanceFee;
    address performanceFeeReceiver;
  }

  function beforePoke(
    bytes calldata _pokeData,
    DistributeData memory _distributeData,
    bool _willClaimReward
  ) external;

  function afterPoke(PowerIndexRouterInterface.StakeStatus _status, bool _rewardClaimDone)
    external
    returns (bytes calldata);

  function initRouter(bytes calldata) external;

  function getUnderlyingStaked() external view returns (uint256);

  function isClaimAvailable(
    bytes calldata _claimParams,
    uint256 _lastClaimRewardsAt,
    uint256 _lastChangeStakeAt
  ) external view returns (bool);

  function redeem(uint256 _amount, DistributeData calldata _distributeData)
    external
    returns (bytes calldata, bool claimed);

  function stake(uint256 _amount, DistributeData calldata _distributeData)
    external
    returns (bytes calldata, bool claimed);

  function calculateLockedProfit(bytes calldata _stakeData) external view returns (uint256);

  function claimRewards(PowerIndexRouterInterface.StakeStatus _status, DistributeData calldata _distributeData)
    external
    returns (bytes calldata);
}



pragma solidity >=0.6.0 <0.8.0;


abstract contract Context {
    function _msgSender() internal view virtual returns (address payable) {
        return msg.sender;
    }

    function _msgData() internal view virtual returns (bytes memory) {
        this; 
        return msg.data;
    }
}



pragma solidity >=0.6.0 <0.8.0;


abstract contract Ownable is Context {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    
    constructor () internal {
        address msgSender = _msgSender();
        _owner = msgSender;
        emit OwnershipTransferred(address(0), msgSender);
    }

    
    function owner() public view virtual returns (address) {
        return _owner;
    }

    
    modifier onlyOwner() {
        require(owner() == _msgSender(), "Ownable: caller is not the owner");
        _;
    }

    
    function renounceOwnership() public virtual onlyOwner {
        emit OwnershipTransferred(_owner, address(0));
        _owner = address(0);
    }

    
    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), "Ownable: new owner is the zero address");
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }
}



pragma solidity 0.6.12;

interface PowerIndexNaiveRouterInterface {
  function migrateToNewRouter(
    address _piToken,
    address payable _newRouter,
    address[] memory _tokens
  ) external;

  function enableRouterCallback(address _piToken, bool _enable) external;

  function piTokenCallback(address sender, uint256 _withdrawAmount) external payable;
}



pragma solidity 0.6.12;

contract PowerIndexNaiveRouter is PowerIndexNaiveRouterInterface, Ownable {
  using SafeMath for uint256;

  function migrateToNewRouter(
    address _piToken,
    address payable _newRouter,
    address[] memory 
  ) public virtual override onlyOwner {
    WrappedPiErc20Interface(_piToken).changeRouter(_newRouter);
  }

  function enableRouterCallback(address _piToken, bool _enable) public override onlyOwner {
    WrappedPiErc20Interface(_piToken).enableRouterCallback(_enable);
  }

  function piTokenCallback(address sender, uint256 _withdrawAmount) external payable virtual override {
    
  }
}



pragma solidity 0.6.12;


contract PowerIndexRouter is PowerIndexRouterInterface, PowerIndexNaiveRouter {
  using SafeERC20 for IERC20;

  uint256 internal constant COMPENSATION_PLAN_1_ID = 1;
  uint256 public constant HUNDRED_PCT = 1 ether;

  event SetReserveConfig(uint256 ratio, uint256 ratioLowerBound, uint256 ratioUpperBound, uint256 claimRewardsInterval);
  event SetPerformanceFee(uint256 performanceFee);
  event SetConnector(
    IRouterConnector indexed connector,
    uint256 share,
    bool callBeforeAfterPoke,
    uint256 indexed connectorIndex,
    bool indexed isNewConnector
  );
  event SetConnectorClaimParams(address connector, bytes claimParams);
  event SetConnectorStakeParams(address connector, bytes stakeParams);

  struct BasicConfig {
    address poolRestrictions;
    address powerPoke;
    uint256 reserveRatio;
    uint256 reserveRatioLowerBound;
    uint256 reserveRatioUpperBound;
    uint256 claimRewardsInterval;
    address performanceFeeReceiver;
    uint256 performanceFee;
  }

  WrappedPiErc20Interface public immutable piToken;
  IERC20 public immutable underlying;
  address public immutable performanceFeeReceiver;

  IPoolRestrictions public poolRestrictions;
  IPowerPoke public powerPoke;
  uint256 public reserveRatio;
  uint256 public claimRewardsInterval;
  uint256 public lastRebalancedAt;
  uint256 public reserveRatioLowerBound;
  uint256 public reserveRatioUpperBound;
  
  uint256 public performanceFee;
  Connector[] public connectors;

  struct RebalanceConfig {
    bool shouldPushFunds;
    StakeStatus status;
    uint256 diff;
    bool shouldClaim;
    bool forceRebalance;
    uint256 connectorIndex;
  }

  struct Connector {
    IRouterConnector connector;
    uint256 share;
    bool callBeforeAfterPoke;
    uint256 lastClaimRewardsAt;
    uint256 lastChangeStakeAt;
    bytes stakeData;
    bytes pokeData;
    bytes stakeParams;
    bytes claimParams;
  }

  struct ConnectorInput {
    bool newConnector;
    uint256 connectorIndex;
    IRouterConnector connector;
    uint256 share;
    bool callBeforeAfterPoke;
  }

  struct PokeFromState {
    uint256 minInterval;
    uint256 maxInterval;
    uint256 piTokenUnderlyingBalance;
    bool atLeastOneForceRebalance;
  }

  modifier onlyEOA() {
    require(tx.origin == msg.sender, "ONLY_EOA");
    _;
  }

  modifier onlyReporter(uint256 _reporterId, bytes calldata _rewardOpts) {
    uint256 gasStart = gasleft();
    powerPoke.authorizeReporter(_reporterId, msg.sender);
    _;
    _reward(_reporterId, gasStart, COMPENSATION_PLAN_1_ID, _rewardOpts);
  }

  modifier onlyNonReporter(uint256 _reporterId, bytes calldata _rewardOpts) {
    uint256 gasStart = gasleft();
    powerPoke.authorizeNonReporter(_reporterId, msg.sender);
    _;
    _reward(_reporterId, gasStart, COMPENSATION_PLAN_1_ID, _rewardOpts);
  }

  constructor(address _piToken, BasicConfig memory _basicConfig) public PowerIndexNaiveRouter() Ownable() {
    require(_piToken != address(0), "INVALID_PI_TOKEN");
    require(_basicConfig.reserveRatioUpperBound <= HUNDRED_PCT, "UPPER_RR_GREATER_THAN_100_PCT");
    require(_basicConfig.reserveRatio >= _basicConfig.reserveRatioLowerBound, "RR_LTE_LOWER_RR");
    require(_basicConfig.reserveRatio <= _basicConfig.reserveRatioUpperBound, "RR_GTE_UPPER_RR");
    require(_basicConfig.performanceFee < HUNDRED_PCT, "PVP_FEE_GTE_HUNDRED_PCT");
    require(_basicConfig.performanceFeeReceiver != address(0), "INVALID_PVP_ADDR");
    require(_basicConfig.poolRestrictions != address(0), "INVALID_POOL_RESTRICTIONS_ADDR");

    piToken = WrappedPiErc20Interface(_piToken);
    (, bytes memory underlyingRes) = _piToken.call(abi.encodeWithSignature("underlying()"));
    underlying = IERC20(abi.decode(underlyingRes, (address)));
    poolRestrictions = IPoolRestrictions(_basicConfig.poolRestrictions);
    powerPoke = IPowerPoke(_basicConfig.powerPoke);
    reserveRatio = _basicConfig.reserveRatio;
    reserveRatioLowerBound = _basicConfig.reserveRatioLowerBound;
    reserveRatioUpperBound = _basicConfig.reserveRatioUpperBound;
    claimRewardsInterval = _basicConfig.claimRewardsInterval;
    performanceFeeReceiver = _basicConfig.performanceFeeReceiver;
    performanceFee = _basicConfig.performanceFee;
  }

  receive() external payable {}

  

  
  function setReserveConfig(
    uint256 _reserveRatio,
    uint256 _reserveRatioLowerBound,
    uint256 _reserveRatioUpperBound,
    uint256 _claimRewardsInterval
  ) external virtual override onlyOwner {
    require(_reserveRatioUpperBound <= HUNDRED_PCT, "UPPER_RR_GREATER_THAN_100_PCT");
    require(_reserveRatio >= _reserveRatioLowerBound, "RR_LT_LOWER_RR");
    require(_reserveRatio <= _reserveRatioUpperBound, "RR_GT_UPPER_RR");

    reserveRatio = _reserveRatio;
    reserveRatioLowerBound = _reserveRatioLowerBound;
    reserveRatioUpperBound = _reserveRatioUpperBound;
    claimRewardsInterval = _claimRewardsInterval;
    emit SetReserveConfig(_reserveRatio, _reserveRatioLowerBound, _reserveRatioUpperBound, _claimRewardsInterval);
  }

  
  function setPerformanceFee(uint256 _performanceFee) external onlyOwner {
    require(_performanceFee < HUNDRED_PCT, "PERFORMANCE_FEE_OVER_THE_LIMIT");
    performanceFee = _performanceFee;
    emit SetPerformanceFee(_performanceFee);
  }

  
  function setPiTokenEthFee(uint256 _ethFee) external onlyOwner {
    require(_ethFee <= 0.1 ether, "ETH_FEE_OVER_THE_LIMIT");
    piToken.setEthFee(_ethFee);
  }

  
  function setConnectorList(ConnectorInput[] memory _connectorList) external onlyOwner {
    require(_connectorList.length != 0, "CONNECTORS_LENGTH_CANT_BE_NULL");

    for (uint256 i = 0; i < _connectorList.length; i++) {
      ConnectorInput memory c = _connectorList[i];

      if (c.newConnector) {
        connectors.push(
          Connector(
            c.connector,
            c.share,
            c.callBeforeAfterPoke,
            0,
            0,
            new bytes(0),
            new bytes(0),
            new bytes(0),
            new bytes(0)
          )
        );
        c.connectorIndex = connectors.length - 1;
      } else {
        connectors[c.connectorIndex].connector = c.connector;
        connectors[c.connectorIndex].share = c.share;
        connectors[c.connectorIndex].callBeforeAfterPoke = c.callBeforeAfterPoke;
      }

      emit SetConnector(c.connector, c.share, c.callBeforeAfterPoke, c.connectorIndex, c.newConnector);
    }
    _checkConnectorsTotalShare();
  }

  
  function setClaimParams(uint256 _connectorIndex, bytes memory _claimParams) external onlyOwner {
    connectors[_connectorIndex].claimParams = _claimParams;
    emit SetConnectorClaimParams(address(connectors[_connectorIndex].connector), _claimParams);
  }

  
  function setStakeParams(uint256 _connectorIndex, bytes memory _stakeParams) external onlyOwner {
    connectors[_connectorIndex].stakeParams = _stakeParams;
    emit SetConnectorStakeParams(address(connectors[_connectorIndex].connector), _stakeParams);
  }

  
  function setPiTokenNoFee(address _for, bool _noFee) external onlyOwner {
    piToken.setNoFee(_for, _noFee);
  }

  
  function withdrawEthFee(address payable _receiver) external onlyOwner {
    piToken.withdrawEthFee(_receiver);
  }

  
  function migrateToNewRouter(
    address _piToken,
    address payable _newRouter,
    address[] memory _tokens
  ) public override onlyOwner {
    super.migrateToNewRouter(_piToken, _newRouter, _tokens);

    _newRouter.transfer(address(this).balance);

    uint256 len = _tokens.length;
    for (uint256 i = 0; i < len; i++) {
      IERC20 t = IERC20(_tokens[i]);
      t.safeTransfer(_newRouter, t.balanceOf(address(this)));
    }
  }

  
  function initRouterByConnector(uint256 _connectorIndex, bytes memory _data) public onlyOwner {
    (bool success, bytes memory result) = address(connectors[_connectorIndex].connector).delegatecall(
      abi.encodeWithSignature("initRouter(bytes)", _data)
    );
    require(success, string(result));
  }

  
  function pokeFromReporter(
    uint256 _reporterId,
    bool _claimAndDistributeRewards,
    bytes calldata _rewardOpts
  ) external onlyReporter(_reporterId, _rewardOpts) onlyEOA {
    _pokeFrom(_claimAndDistributeRewards, false);
  }

  
  function pokeFromSlasher(
    uint256 _reporterId,
    bool _claimAndDistributeRewards,
    bytes calldata _rewardOpts
  ) external onlyNonReporter(_reporterId, _rewardOpts) onlyEOA {
    _pokeFrom(_claimAndDistributeRewards, true);
  }

  
  function _rebalancePokeByConf(RebalanceConfig memory _conf) internal {
    Connector storage c = connectors[_conf.connectorIndex];

    if (c.callBeforeAfterPoke) {
      _beforePoke(c, _conf.shouldClaim);
    }

    if (_conf.status != StakeStatus.EQUILIBRIUM) {
      _rebalancePoke(c, _conf.status, _conf.diff);
    }

    
    if (_conf.shouldClaim && claimRewardsIntervalReached(c.lastClaimRewardsAt)) {
      _claimRewards(c, _conf.status);
      c.lastClaimRewardsAt = block.timestamp;
    } else {
      require(_conf.status != StakeStatus.EQUILIBRIUM, "NOTHING_TO_DO");
    }

    if (c.callBeforeAfterPoke) {
      _afterPoke(c, _conf.status, _conf.shouldClaim);
    }
  }

  function claimRewardsIntervalReached(uint256 _lastClaimRewardsAt) public view returns (bool) {
    return _lastClaimRewardsAt + claimRewardsInterval < block.timestamp;
  }

  
  function _pokeFrom(bool _claimAndDistributeRewards, bool _isSlasher) internal {
    PokeFromState memory state = PokeFromState(0, 0, 0, false);
    (state.minInterval, state.maxInterval) = _getMinMaxReportInterval();

    state.piTokenUnderlyingBalance = piToken.getUnderlyingBalance();
    (uint256[] memory stakedBalanceList, uint256 totalStakedBalance) = _getUnderlyingStakedList();

    state.atLeastOneForceRebalance = false;

    RebalanceConfig[] memory configs = new RebalanceConfig[](connectors.length);

    
    for (uint256 i = 0; i < connectors.length; i++) {
      if (connectors[i].share == 0) {
        continue;
      }

      (StakeStatus status, uint256 diff, bool shouldClaim, bool forceRebalance) = getStakeAndClaimStatus(
        state.piTokenUnderlyingBalance,
        totalStakedBalance,
        stakedBalanceList[i],
        _claimAndDistributeRewards,
        connectors[i]
      );
      if (forceRebalance) {
        state.atLeastOneForceRebalance = true;
      }

      if (status == StakeStatus.EXCESS) {
        
        if (_canPoke(_isSlasher, forceRebalance, state.minInterval, state.maxInterval)) {
          _rebalancePokeByConf(RebalanceConfig(false, status, diff, shouldClaim, forceRebalance, i));
        }
      } else {
        
        configs[i] = RebalanceConfig(true, status, diff, shouldClaim, forceRebalance, i);
      }
    }

    require(
      _canPoke(_isSlasher, state.atLeastOneForceRebalance, state.minInterval, state.maxInterval),
      "INTERVAL_NOT_REACHED_OR_NOT_FORCE"
    );

    
    for (uint256 i = 0; i < connectors.length; i++) {
      if (!configs[i].shouldPushFunds) {
        continue;
      }
      
      if (_canPoke(_isSlasher, configs[i].forceRebalance, state.minInterval, state.maxInterval)) {
        _rebalancePokeByConf(configs[i]);
      }
    }

    lastRebalancedAt = block.timestamp;
  }

  
  function _canPoke(
    bool _isSlasher,
    bool _forceRebalance,
    uint256 _minInterval,
    uint256 _maxInterval
  ) internal view returns (bool) {
    if (_forceRebalance) {
      return true;
    }
    return
      _isSlasher
        ? (lastRebalancedAt + _maxInterval < block.timestamp)
        : (lastRebalancedAt + _minInterval < block.timestamp);
  }

  
  function _redeem(Connector storage _c, uint256 _diff) internal {
    _callStakeRedeem("redeem(uint256,(bytes,bytes,uint256,address))", _c, _diff);
  }

  
  function _stake(Connector storage _c, uint256 _diff) internal {
    _callStakeRedeem("stake(uint256,(bytes,bytes,uint256,address))", _c, _diff);
  }

  function _callStakeRedeem(
    string memory _method,
    Connector storage _c,
    uint256 _diff
  ) internal {
    (bool success, bytes memory result) = address(_c.connector).delegatecall(
      abi.encodeWithSignature(_method, _diff, _getDistributeData(_c))
    );
    require(success, string(result));
    bool claimed;
    (result, claimed) = abi.decode(result, (bytes, bool));
    if (result.length > 0) {
      _c.stakeData = result;
    }
    if (claimed) {
      _c.lastClaimRewardsAt = block.timestamp;
    }
    _c.lastChangeStakeAt = block.timestamp;
  }

  
  function _beforePoke(Connector storage c, bool _willClaimReward) internal {
    (bool success, ) = address(c.connector).delegatecall(
      abi.encodeWithSignature(
        "beforePoke(bytes,(bytes,uint256,address),bool)",
        c.pokeData,
        _getDistributeData(c),
        _willClaimReward
      )
    );
    require(success, "_beforePoke call error");
  }

  
  function _afterPoke(
    Connector storage _c,
    StakeStatus _stakeStatus,
    bool _rewardClaimDone
  ) internal {
    (bool success, bytes memory result) = address(_c.connector).delegatecall(
      abi.encodeWithSignature("afterPoke(uint8,bool)", uint8(_stakeStatus), _rewardClaimDone)
    );
    require(success, string(result));
    result = abi.decode(result, (bytes));
    if (result.length > 0) {
      _c.pokeData = result;
    }
  }

  
  function _rebalancePoke(
    Connector storage _c,
    StakeStatus _stakeStatus,
    uint256 _diff
  ) internal {
    if (_stakeStatus == StakeStatus.EXCESS) {
      _redeem(_c, _diff);
    } else if (_stakeStatus == StakeStatus.SHORTAGE) {
      _stake(_c, _diff);
    }
  }

  function redeem(uint256 _connectorIndex, uint256 _diff) external onlyOwner {
    _redeem(connectors[_connectorIndex], _diff);
  }

  function stake(uint256 _connectorIndex, uint256 _diff) external onlyOwner {
    _stake(connectors[_connectorIndex], _diff);
  }

  
  function _claimRewards(Connector storage c, StakeStatus _stakeStatus) internal {
    (bool success, bytes memory result) = address(c.connector).delegatecall(
      abi.encodeWithSelector(IRouterConnector.claimRewards.selector, _stakeStatus, _getDistributeData(c))
    );
    require(success, string(result));
    result = abi.decode(result, (bytes));
    if (result.length > 0) {
      c.stakeData = result;
    }
  }

  function _reward(
    uint256 _reporterId,
    uint256 _gasStart,
    uint256 _compensationPlan,
    bytes calldata _rewardOpts
  ) internal {
    powerPoke.reward(_reporterId, _gasStart.sub(gasleft()), _compensationPlan, _rewardOpts);
  }

  
  function getStakeStatusForBalance(uint256 _stakedBalance, uint256 _share)
    external
    view
    returns (
      StakeStatus status,
      uint256 diff,
      bool forceRebalance
    )
  {
    return getStakeStatus(piToken.getUnderlyingBalance(), getUnderlyingStaked(), _stakedBalance, _share);
  }

  function getStakeAndClaimStatus(
    uint256 _leftOnPiTokenBalance,
    uint256 _totalStakedBalance,
    uint256 _stakedBalance,
    bool _claimAndDistributeRewards,
    Connector memory _c
  )
    public
    view
    returns (
      StakeStatus status,
      uint256 diff,
      bool shouldClaim,
      bool forceRebalance
    )
  {
    (status, diff, forceRebalance) = getStakeStatus(
      _leftOnPiTokenBalance,
      _totalStakedBalance,
      _stakedBalance,
      _c.share
    );
    shouldClaim = _claimAndDistributeRewards && claimRewardsIntervalReached(_c.lastClaimRewardsAt);

    if (shouldClaim && _c.claimParams.length != 0) {
      shouldClaim = _c.connector.isClaimAvailable(_c.claimParams, _c.lastClaimRewardsAt, _c.lastChangeStakeAt);
      if (shouldClaim && !forceRebalance) {
        forceRebalance = true;
      }
    }
  }

  
  function getStakeStatus(
    uint256 _leftOnPiTokenBalance,
    uint256 _totalStakedBalance,
    uint256 _stakedBalance,
    uint256 _share
  )
    public
    view
    returns (
      StakeStatus status,
      uint256 diff,
      bool forceRebalance
    )
  {
    uint256 expectedStakeAmount;
    (status, diff, expectedStakeAmount) = getStakeStatusPure(
      reserveRatio,
      _leftOnPiTokenBalance,
      _totalStakedBalance,
      _stakedBalance,
      _share
    );

    if (status == StakeStatus.EQUILIBRIUM) {
      return (status, diff, forceRebalance);
    }

    uint256 denominator = _leftOnPiTokenBalance.add(_totalStakedBalance);

    if (status == StakeStatus.EXCESS) {
      uint256 numerator = _leftOnPiTokenBalance.add(diff).mul(HUNDRED_PCT);
      uint256 currentRatio = numerator.div(denominator);
      forceRebalance = reserveRatioLowerBound >= currentRatio;
    } else if (status == StakeStatus.SHORTAGE) {
      if (diff > _leftOnPiTokenBalance) {
        return (status, diff, true);
      }
      uint256 numerator = _leftOnPiTokenBalance.sub(diff).mul(HUNDRED_PCT);
      uint256 currentRatio = numerator.div(denominator);
      forceRebalance = reserveRatioUpperBound <= currentRatio;
    }
  }

  function getUnderlyingStaked() public view virtual returns (uint256) {
    uint256 underlyingStaked = 0;
    for (uint256 i = 0; i < connectors.length; i++) {
      require(address(connectors[i].connector) != address(0), "CONNECTOR_IS_NULL");
      underlyingStaked += connectors[i].connector.getUnderlyingStaked();
    }
    return underlyingStaked;
  }

  function _getUnderlyingStakedList() internal view virtual returns (uint256[] memory list, uint256 total) {
    uint256[] memory underlyingStakedList = new uint256[](connectors.length);
    total = 0;
    for (uint256 i = 0; i < connectors.length; i++) {
      require(address(connectors[i].connector) != address(0), "CONNECTOR_IS_NULL");
      underlyingStakedList[i] = connectors[i].connector.getUnderlyingStaked();
      total += underlyingStakedList[i];
    }
    return (underlyingStakedList, total);
  }

  function getUnderlyingReserve() public view returns (uint256) {
    return underlying.balanceOf(address(piToken));
  }

  function calculateLockedProfit() public view returns (uint256) {
    uint256 lockedProfit = 0;
    for (uint256 i = 0; i < connectors.length; i++) {
      require(address(connectors[i].connector) != address(0), "CONNECTOR_IS_NULL");
      lockedProfit += connectors[i].connector.calculateLockedProfit(connectors[i].stakeData);
    }
    return lockedProfit;
  }

  function getUnderlyingAvailable() public view returns (uint256) {
    
    return getUnderlyingReserve().add(getUnderlyingStaked()).sub(calculateLockedProfit());
  }

  function getUnderlyingTotal() external view returns (uint256) {
    
    return getUnderlyingReserve().add(getUnderlyingStaked());
  }

  function getPiEquivalentForUnderlying(uint256 _underlyingAmount, uint256 _piTotalSupply)
    external
    view
    virtual
    override
    returns (uint256)
  {
    return getPiEquivalentForUnderlyingPure(_underlyingAmount, getUnderlyingAvailable(), _piTotalSupply);
  }

  function getPiEquivalentForUnderlyingPure(
    uint256 _underlyingAmount,
    uint256 _totalUnderlyingWrapped,
    uint256 _piTotalSupply
  ) public pure virtual override returns (uint256) {
    if (_piTotalSupply == 0) {
      return _underlyingAmount;
    }
    
    return _piTotalSupply.mul(_underlyingAmount).div(_totalUnderlyingWrapped);
  }

  function getUnderlyingEquivalentForPi(uint256 _piAmount, uint256 _piTotalSupply)
    external
    view
    virtual
    override
    returns (uint256)
  {
    return getUnderlyingEquivalentForPiPure(_piAmount, getUnderlyingAvailable(), _piTotalSupply);
  }

  function getUnderlyingEquivalentForPiPure(
    uint256 _piAmount,
    uint256 _totalUnderlyingWrapped,
    uint256 _piTotalSupply
  ) public pure virtual override returns (uint256) {
    if (_piTotalSupply == 0) {
      return _piAmount;
    }
    
    return _totalUnderlyingWrapped.mul(_piAmount).div(_piTotalSupply);
  }

  
  function getStakeStatusPure(
    uint256 _reserveRatioPct,
    uint256 _leftOnPiToken,
    uint256 _totalStakedBalance,
    uint256 _stakedBalance,
    uint256 _share
  )
    public
    view
    returns (
      StakeStatus status,
      uint256 diff,
      uint256 expectedStakeAmount
    )
  {
    require(_reserveRatioPct <= HUNDRED_PCT, "RR_GREATER_THAN_100_PCT");
    expectedStakeAmount = getExpectedStakeAmount(_reserveRatioPct, _leftOnPiToken, _totalStakedBalance, _share);

    if (expectedStakeAmount > _stakedBalance) {
      status = StakeStatus.SHORTAGE;
      diff = expectedStakeAmount.sub(_stakedBalance);
    } else if (expectedStakeAmount < _stakedBalance) {
      status = StakeStatus.EXCESS;
      diff = _stakedBalance.sub(expectedStakeAmount);
    } else {
      status = StakeStatus.EQUILIBRIUM;
      diff = 0;
    }
  }

  
  function getExpectedStakeAmount(
    uint256 _reserveRatioPct,
    uint256 _leftOnPiToken,
    uint256 _stakedBalance,
    uint256 _share
  ) public pure returns (uint256) {
    return
      uint256(1 ether).sub(_reserveRatioPct).mul(_stakedBalance.add(_leftOnPiToken).mul(_share).div(HUNDRED_PCT)).div(
        HUNDRED_PCT
      );
  }

  function _getMinMaxReportInterval() internal view returns (uint256 min, uint256 max) {
    return powerPoke.getMinMaxReportIntervals(address(this));
  }

  function _getDistributeData(Connector storage c) internal view returns (IRouterConnector.DistributeData memory) {
    return IRouterConnector.DistributeData(c.stakeData, c.stakeParams, performanceFee, performanceFeeReceiver);
  }

  function _checkConnectorsTotalShare() internal view {
    uint256 totalShare = 0;
    for (uint256 i = 0; i < connectors.length; i++) {
      require(address(connectors[i].connector) != address(0), "CONNECTOR_IS_NULL");
      totalShare = totalShare.add(connectors[i].share);
    }
    require(totalShare == HUNDRED_PCT, "TOTAL_SHARE_IS_NOT_HUNDRED_PCT");
  }
}