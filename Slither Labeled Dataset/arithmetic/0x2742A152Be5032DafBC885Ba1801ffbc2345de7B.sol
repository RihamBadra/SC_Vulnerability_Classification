pragma solidity 0.5.15;

contract IFactRegistry {

    

    function isValid(bytes32 fact)

        external view

        returns(bool);

}

contract IMerkleVerifier {

    uint256 constant internal MAX_N_MERKLE_VERIFIER_QUERIES =  128;



    function verify(

        uint256 channelPtr,

        uint256 queuePtr,

        bytes32 root,

        uint256 n)

        internal view

        returns (bytes32 hash);

}

contract IQueryableFactRegistry is IFactRegistry {



    

    function hasRegisteredFact()

        external view

        returns(bool);



}

contract MerkleVerifier is IMerkleVerifier {



    function getHashMask() internal pure returns(uint256) {

        

        return 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF000000000000000000000000;

    }



    

    function verify(

        uint256 channelPtr,

        uint256 queuePtr,

        bytes32 root,

        uint256 n)

        internal view

        returns (bytes32 hash)

    {

        uint256 lhashMask = getHashMask();

        require(n <= MAX_N_MERKLE_VERIFIER_QUERIES, "TOO_MANY_MERKLE_QUERIES");



        assembly {

            

            

            let hashesPtr := add(queuePtr, 0x20)

            let queueSize := mul(n, 0x40)

            let slotSize := 0x40



            

            let rdIdx := 0

            let wrIdx := 0 



            

            let index := mload(add(rdIdx, queuePtr))

            let proofPtr := mload(channelPtr)



            

            for { } gt(index, 1) { } {

                let siblingIndex := xor(index, 1)

                

                let sibblingOffset := mulmod(siblingIndex, 0x20, 0x40)



                

                

                

                mstore(xor(0x20, sibblingOffset), mload(add(rdIdx, hashesPtr)))

                rdIdx := addmod(rdIdx, slotSize, queueSize)



                

                

                

                let newHashPtr := proofPtr

                proofPtr := add(proofPtr, 0x20)



                

                

                

                

                mstore(add(wrIdx, queuePtr), div(index, 2))



                

                index := mload(add(rdIdx, queuePtr))

                if eq(index, siblingIndex) {

                    

                    newHashPtr := add(rdIdx, hashesPtr)

                    

                    proofPtr := sub(proofPtr, 0x20)

                    rdIdx := addmod(rdIdx, slotSize, queueSize)



                    

                    

                    

                    

                    index := mload(add(rdIdx, queuePtr))

                }



                mstore(sibblingOffset, mload(newHashPtr))



                

                mstore(add(wrIdx, hashesPtr), and(lhashMask, keccak256(0x00, 0x40)))

                wrIdx := addmod(wrIdx, slotSize, queueSize)

            }

            hash := mload(add(rdIdx, hashesPtr))



            

            mstore(channelPtr, proofPtr)

        }

        

        require(hash == root, "INVALID_MERKLE_PROOF");

    }

}

contract PrimeFieldElement0 {

    uint256 constant internal K_MODULUS =

    0x800000000000011000000000000000000000000000000000000000000000001;

    uint256 constant internal K_MODULUS_MASK =

    0x0fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;

    uint256 constant internal K_MONTGOMERY_R =

    0x7fffffffffffdf0ffffffffffffffffffffffffffffffffffffffffffffffe1;

    uint256 constant internal K_MONTGOMERY_R_INV =

    0x40000000000001100000000000012100000000000000000000000000000000;

    uint256 constant internal GENERATOR_VAL = 3;

    uint256 constant internal ONE_VAL = 1;

    uint256 constant internal GEN1024_VAL =

    0x659d83946a03edd72406af6711825f5653d9e35dc125289a206c054ec89c4f1;



    function fromMontgomery(uint256 val) internal pure returns (uint256 res) {

        

        assembly {

            res := mulmod(val,

                          0x40000000000001100000000000012100000000000000000000000000000000,

                          0x800000000000011000000000000000000000000000000000000000000000001)

        }

        return res;

    }



    function fromMontgomeryBytes(bytes32 bs) internal pure returns (uint256) {

        

        

        uint256 res = uint256(bs);

        return fromMontgomery(res);

    }



    function toMontgomeryInt(uint256 val) internal pure returns (uint256 res) {

        

        assembly {

            res := mulmod(val,

                          0x7fffffffffffdf0ffffffffffffffffffffffffffffffffffffffffffffffe1,

                          0x800000000000011000000000000000000000000000000000000000000000001)

        }

        return res;

    }



    function fmul(uint256 a, uint256 b) internal pure returns (uint256 res) {

        

        assembly {

            res := mulmod(a, b,

                0x800000000000011000000000000000000000000000000000000000000000001)

        }

        return res;

    }



    function fadd(uint256 a, uint256 b) internal pure returns (uint256 res) {

        

        assembly {

            res := addmod(a, b,

                0x800000000000011000000000000000000000000000000000000000000000001)

        }

        return res;

    }



    function fsub(uint256 a, uint256 b) internal pure returns (uint256 res) {

        

        assembly {

            res := addmod(

                a,

                sub(0x800000000000011000000000000000000000000000000000000000000000001, b),

                0x800000000000011000000000000000000000000000000000000000000000001)

        }

        return res;

    }



    function fpow(uint256 val, uint256 exp) internal view returns (uint256) {

        return expmod(val, exp, K_MODULUS);

    }



    function expmod(uint256 base, uint256 exponent, uint256 modulus)

        internal view returns (uint256 res)

    {

        assembly {

            let p := mload(0x40)

            mstore(p, 0x20)                  

            mstore(add(p, 0x20), 0x20)       

            mstore(add(p, 0x40), 0x20)       

            mstore(add(p, 0x60), base)       

            mstore(add(p, 0x80), exponent)   

            mstore(add(p, 0xa0), modulus)    

            

            if iszero(staticcall(gas, 0x05, p, 0xc0, p, 0x20)) {

                revert(0, 0)

            }

            res := mload(p)

        }

    }



    function inverse(uint256 val) internal view returns (uint256) {

        return expmod(val, K_MODULUS - 2, K_MODULUS);

    }

}

contract FactRegistry is IQueryableFactRegistry {

    

    mapping (bytes32 => bool) private verifiedFact;



    

    bool anyFactRegistered;



    

    function isValid(bytes32 fact)

        external view

        returns(bool)

    {

        return _factCheck(fact);

    }





    

    function _factCheck(bytes32 fact)

        internal view

        returns(bool)

    {

        return verifiedFact[fact];

    }



    function registerFact(

        bytes32 factHash

        )

        internal

    {

        

        verifiedFact[factHash] = true;



        

        if (!anyFactRegistered) {

            anyFactRegistered = true;

        }

    }



    

    function hasRegisteredFact()

        external view

        returns(bool)

    {

        return anyFactRegistered;

    }



}

contract FriLayer is MerkleVerifier, PrimeFieldElement0 {

    event LogGas(string name, uint256 val);



    uint256 constant internal FRI_MAX_FRI_STEP = 4;

    uint256 constant internal MAX_COSET_SIZE = 2**FRI_MAX_FRI_STEP;

    

    uint256 constant internal FRI_GROUP_GEN =

    0x5ec467b88826aba4537602d514425f3b0bdf467bbf302458337c45f6021e539;



    uint256 constant internal FRI_GROUP_SIZE = 0x20 * MAX_COSET_SIZE;

    uint256 constant internal FRI_CTX_TO_COSET_EVALUATIONS_OFFSET = 0;

    uint256 constant internal FRI_CTX_TO_FRI_GROUP_OFFSET = FRI_GROUP_SIZE;

    uint256 constant internal FRI_CTX_TO_FRI_HALF_INV_GROUP_OFFSET =

    FRI_CTX_TO_FRI_GROUP_OFFSET + FRI_GROUP_SIZE;



    uint256 constant internal FRI_CTX_SIZE =

    FRI_CTX_TO_FRI_HALF_INV_GROUP_OFFSET + (FRI_GROUP_SIZE / 2);



    function nextLayerElementFromTwoPreviousLayerElements(

        uint256 fX, uint256 fMinusX, uint256 evalPoint, uint256 xInv)

        internal pure

        returns (uint256 res)

    {

        

        

        

        

        

        

        

        

        

        

        

        assembly {

            

            let PRIME := 0x800000000000011000000000000000000000000000000000000000000000001

            

            

            res := addmod(add(fX, fMinusX),

                   mulmod(mulmod(evalPoint, xInv, PRIME),

                   add(fX, sub(PRIME, fMinusX)), PRIME), PRIME)

        }

    }



    

    function do2FriSteps(

        uint256 friHalfInvGroupPtr, uint256 evaluationsOnCosetPtr, uint256 cosetOffset_,

        uint256 friEvalPoint)

    internal pure returns (uint256 nextLayerValue, uint256 nextXInv) {

        assembly {

            let PRIME := 0x800000000000011000000000000000000000000000000000000000000000001

            let friEvalPointDivByX := mulmod(friEvalPoint, cosetOffset_, PRIME)



            let f0 := mload(evaluationsOnCosetPtr)

            {

                let f1 := mload(add(evaluationsOnCosetPtr, 0x20))



                

                f0 := add(add(f0, f1),

                             mulmod(friEvalPointDivByX,

                                    add(f0, sub(PRIME, f1)),

                                    PRIME))

            }



            let f2 := mload(add(evaluationsOnCosetPtr, 0x40))

            {

                let f3 := mload(add(evaluationsOnCosetPtr, 0x60))

                f2 := addmod(add(f2, f3),

                             mulmod(add(f2, sub(PRIME, f3)),

                                    mulmod(mload(add(friHalfInvGroupPtr, 0x20)),

                                           friEvalPointDivByX,

                                           PRIME),

                                    PRIME),

                             PRIME)

            }



            {

                let newXInv := mulmod(cosetOffset_, cosetOffset_, PRIME)

                nextXInv := mulmod(newXInv, newXInv, PRIME)

            }



            

            nextLayerValue := addmod(add(f0, f2),

                          mulmod(mulmod(friEvalPointDivByX, friEvalPointDivByX, PRIME),

                                 add(f0, sub(PRIME, f2)),

                                 PRIME),

                          PRIME)

        }

    }



    

    function do3FriSteps(

        uint256 friHalfInvGroupPtr, uint256 evaluationsOnCosetPtr, uint256 cosetOffset_,

        uint256 friEvalPoint)

    internal pure returns (uint256 nextLayerValue, uint256 nextXInv) {

        assembly {

            let PRIME := 0x800000000000011000000000000000000000000000000000000000000000001

            let MPRIME := 0x8000000000000110000000000000000000000000000000000000000000000010

            let f0 := mload(evaluationsOnCosetPtr)



            let friEvalPointDivByX := mulmod(friEvalPoint, cosetOffset_, PRIME)

            let friEvalPointDivByXSquared := mulmod(friEvalPointDivByX, friEvalPointDivByX, PRIME)

            let imaginaryUnit := mload(add(friHalfInvGroupPtr, 0x20))



            {

                let f1 := mload(add(evaluationsOnCosetPtr, 0x20))



                

                f0 := add(add(f0, f1),

                          mulmod(friEvalPointDivByX,

                                 add(f0, sub(PRIME, f1)),

                                 PRIME))

            }

            {

                let f2 := mload(add(evaluationsOnCosetPtr, 0x40))

                {

                    let f3 := mload(add(evaluationsOnCosetPtr, 0x60))



                    

                    f2 := add(add(f2, f3),

                              mulmod(add(f2, sub(PRIME, f3)),

                                     mulmod(friEvalPointDivByX, imaginaryUnit, PRIME),

                                     PRIME))

                }



                

                f0 := add(add(f0, f2),

                          mulmod(friEvalPointDivByXSquared,

                                 add(f0, sub(MPRIME, f2)),

                                 PRIME))

            }

            {

                let f4 := mload(add(evaluationsOnCosetPtr, 0x80))

                {

                    let friEvalPointDivByX2 := mulmod(friEvalPointDivByX,

                                                    mload(add(friHalfInvGroupPtr, 0x40)), PRIME)

                    {

                        let f5 := mload(add(evaluationsOnCosetPtr, 0xa0))



                        

                        f4 := add(add(f4, f5),

                                  mulmod(friEvalPointDivByX2,

                                         add(f4, sub(PRIME, f5)),

                                         PRIME))

                    }



                    let f6 := mload(add(evaluationsOnCosetPtr, 0xc0))

                    {

                        let f7 := mload(add(evaluationsOnCosetPtr, 0xe0))



                        

                        f6 := add(add(f6, f7),

                                  mulmod(add(f6, sub(PRIME, f7)),

                                         

                                         

                                         mulmod(friEvalPointDivByX2, imaginaryUnit, PRIME),

                                         PRIME))

                    }



                    

                    f4 := add(add(f4, f6),

                              mulmod(mulmod(friEvalPointDivByX2, friEvalPointDivByX2, PRIME),

                                     add(f4, sub(MPRIME, f6)),

                                     PRIME))

                }



                

                nextLayerValue :=

                   addmod(add(f0, f4),

                          mulmod(mulmod(friEvalPointDivByXSquared, friEvalPointDivByXSquared, PRIME),

                                 add(f0, sub(MPRIME, f4)),

                                 PRIME),

                          PRIME)

            }



            {

                let xInv2 := mulmod(cosetOffset_, cosetOffset_, PRIME)

                let xInv4 := mulmod(xInv2, xInv2, PRIME)

                nextXInv := mulmod(xInv4, xInv4, PRIME)

            }





        }

    }



    

    function do4FriSteps(

        uint256 friHalfInvGroupPtr, uint256 evaluationsOnCosetPtr, uint256 cosetOffset_,

        uint256 friEvalPoint)

    internal pure returns (uint256 nextLayerValue, uint256 nextXInv) {

        assembly {

            let friEvalPointDivByXTessed

            let PRIME := 0x800000000000011000000000000000000000000000000000000000000000001

            let MPRIME := 0x8000000000000110000000000000000000000000000000000000000000000010

            let f0 := mload(evaluationsOnCosetPtr)



            let friEvalPointDivByX := mulmod(friEvalPoint, cosetOffset_, PRIME)

            let imaginaryUnit := mload(add(friHalfInvGroupPtr, 0x20))



            {

                let f1 := mload(add(evaluationsOnCosetPtr, 0x20))



                

                f0 := add(add(f0, f1),

                          mulmod(friEvalPointDivByX,

                                 add(f0, sub(PRIME, f1)),

                                 PRIME))

            }

            {

                let f2 := mload(add(evaluationsOnCosetPtr, 0x40))

                {

                    let f3 := mload(add(evaluationsOnCosetPtr, 0x60))



                    

                    f2 := add(add(f2, f3),

                                mulmod(add(f2, sub(PRIME, f3)),

                                       mulmod(friEvalPointDivByX, imaginaryUnit, PRIME),

                                       PRIME))

                }

                {

                    let friEvalPointDivByXSquared := mulmod(friEvalPointDivByX, friEvalPointDivByX, PRIME)

                    friEvalPointDivByXTessed := mulmod(friEvalPointDivByXSquared, friEvalPointDivByXSquared, PRIME)



                    

                    f0 := add(add(f0, f2),

                              mulmod(friEvalPointDivByXSquared,

                                     add(f0, sub(MPRIME, f2)),

                                     PRIME))

                }

            }

            {

                let f4 := mload(add(evaluationsOnCosetPtr, 0x80))

                {

                    let friEvalPointDivByX2 := mulmod(friEvalPointDivByX,

                                                      mload(add(friHalfInvGroupPtr, 0x40)), PRIME)

                    {

                        let f5 := mload(add(evaluationsOnCosetPtr, 0xa0))



                        

                        f4 := add(add(f4, f5),

                                  mulmod(friEvalPointDivByX2,

                                         add(f4, sub(PRIME, f5)),

                                         PRIME))

                    }



                    let f6 := mload(add(evaluationsOnCosetPtr, 0xc0))

                    {

                        let f7 := mload(add(evaluationsOnCosetPtr, 0xe0))



                        

                        f6 := add(add(f6, f7),

                                  mulmod(add(f6, sub(PRIME, f7)),

                                         

                                         

                                         mulmod(friEvalPointDivByX2, imaginaryUnit, PRIME),

                                         PRIME))

                    }



                    

                    f4 := add(add(f4, f6),

                              mulmod(mulmod(friEvalPointDivByX2, friEvalPointDivByX2, PRIME),

                                     add(f4, sub(MPRIME, f6)),

                                     PRIME))

                }



                

                f0 := add(add(f0, f4),

                          mulmod(friEvalPointDivByXTessed,

                                 add(f0, sub(MPRIME, f4)),

                                 PRIME))

            }

            {

                let f8 := mload(add(evaluationsOnCosetPtr, 0x100))

                {

                    let friEvalPointDivByX4 := mulmod(friEvalPointDivByX,

                                                      mload(add(friHalfInvGroupPtr, 0x80)), PRIME)

                    {

                        let f9 := mload(add(evaluationsOnCosetPtr, 0x120))



                        

                        f8 := add(add(f8, f9),

                                  mulmod(friEvalPointDivByX4,

                                         add(f8, sub(PRIME, f9)),

                                         PRIME))

                    }



                    let f10 := mload(add(evaluationsOnCosetPtr, 0x140))

                    {

                        let f11 := mload(add(evaluationsOnCosetPtr, 0x160))

                        

                        f10 := add(add(f10, f11),

                                   mulmod(add(f10, sub(PRIME, f11)),

                                          

                                          

                                          mulmod(friEvalPointDivByX4, imaginaryUnit, PRIME),

                                          PRIME))

                    }



                    

                    f8 := add(add(f8, f10),

                              mulmod(mulmod(friEvalPointDivByX4, friEvalPointDivByX4, PRIME),

                                     add(f8, sub(MPRIME, f10)),

                                     PRIME))

                }

                {

                    let f12 := mload(add(evaluationsOnCosetPtr, 0x180))

                    {

                        let friEvalPointDivByX6 := mulmod(friEvalPointDivByX,

                                                          mload(add(friHalfInvGroupPtr, 0xc0)), PRIME)

                        {

                            let f13 := mload(add(evaluationsOnCosetPtr, 0x1a0))



                            

                            f12 := add(add(f12, f13),

                                       mulmod(friEvalPointDivByX6,

                                              add(f12, sub(PRIME, f13)),

                                              PRIME))

                        }



                        let f14 := mload(add(evaluationsOnCosetPtr, 0x1c0))

                        {

                            let f15 := mload(add(evaluationsOnCosetPtr, 0x1e0))



                            

                            f14 := add(add(f14, f15),

                                       mulmod(add(f14, sub(PRIME, f15)),

                                              

                                              

                                              mulmod(friEvalPointDivByX6, imaginaryUnit, PRIME),

                                              PRIME))

                        }



                        

                        f12 := add(add(f12, f14),

                                   mulmod(mulmod(friEvalPointDivByX6, friEvalPointDivByX6, PRIME),

                                          add(f12, sub(MPRIME, f14)),

                                          PRIME))

                    }



                    

                    f8 := add(add(f8, f12),

                              mulmod(mulmod(friEvalPointDivByXTessed, imaginaryUnit, PRIME),

                                     add(f8, sub(MPRIME, f12)),

                                     PRIME))

                }



                

                nextLayerValue :=

                    addmod(add(f0, f8),

                           mulmod(mulmod(friEvalPointDivByXTessed, friEvalPointDivByXTessed, PRIME),

                                  add(f0, sub(MPRIME, f8)),

                                  PRIME),

                           PRIME)

            }



            {

                let xInv2 := mulmod(cosetOffset_, cosetOffset_, PRIME)

                let xInv4 := mulmod(xInv2, xInv2, PRIME)

                let xInv8 := mulmod(xInv4, xInv4, PRIME)

                nextXInv := mulmod(xInv8, xInv8, PRIME)

            }

        }

    }



    

    function gatherCosetInputs(

        uint256 channelPtr, uint256 friCtx, uint256 friQueueHead_, uint256 cosetSize)

        internal pure returns (uint256 friQueueHead, uint256 cosetIdx, uint256 cosetOffset_) {



        uint256 evaluationsOnCosetPtr = friCtx + FRI_CTX_TO_COSET_EVALUATIONS_OFFSET;

        uint256 friGroupPtr = friCtx + FRI_CTX_TO_FRI_GROUP_OFFSET;



        friQueueHead = friQueueHead_;

        assembly {

            let queueItemIdx := mload(friQueueHead)

            

            cosetIdx := and(queueItemIdx, not(sub(cosetSize, 1)))

            let nextCosetIdx := add(cosetIdx, cosetSize)

            let PRIME := 0x800000000000011000000000000000000000000000000000000000000000001



            

            

            

            

            

            

            

            cosetOffset_ := mulmod(

                 mload(add(friQueueHead, 0x40)),

                     mload(add(friGroupPtr,

                                        mul(sub(queueItemIdx, cosetIdx),

                                            0x20))),

                PRIME)



            let proofPtr := mload(channelPtr)



            for { let index := cosetIdx } lt(index, nextCosetIdx) { index := add(index, 1) } {

                

                

                

                let fieldElementPtr := proofPtr

                proofPtr := add(proofPtr, 0x20)



                

                if eq(index, queueItemIdx) {

                    

                    

                    fieldElementPtr := add(friQueueHead, 0x20)



                    

                    proofPtr := sub(proofPtr, 0x20)



                    

                    

                    friQueueHead := add(friQueueHead, 0x60)

                    queueItemIdx := mload(friQueueHead)

                }



                

                

                mstore(evaluationsOnCosetPtr, mod(mload(fieldElementPtr), PRIME))

                evaluationsOnCosetPtr := add(evaluationsOnCosetPtr, 0x20)

            }



            mstore(channelPtr, proofPtr)

        }

    }



    

    function bitReverse(uint256 num, uint256 numberOfBits)

    internal pure

        returns(uint256 numReversed)

    {

        assert((numberOfBits == 256) || (num < 2 ** numberOfBits));

        uint256 n = num;

        uint256 r = 0;

        for (uint256 k = 0; k < numberOfBits; k++) {

            r = (r * 2) | (n % 2);

            n = n / 2;

        }

        return r;

    }



    

    function initFriGroups(uint256 friCtx) internal view {

        uint256 friGroupPtr = friCtx + FRI_CTX_TO_FRI_GROUP_OFFSET;

        uint256 friHalfInvGroupPtr = friCtx + FRI_CTX_TO_FRI_HALF_INV_GROUP_OFFSET;



        

        

        uint256 genFriGroup = FRI_GROUP_GEN;



        uint256 genFriGroupInv = fpow(genFriGroup, (MAX_COSET_SIZE - 1));



        uint256 lastVal = ONE_VAL;

        uint256 lastValInv = ONE_VAL;

        uint256 prime = PrimeFieldElement0.K_MODULUS;

        assembly {

            

            mstore(friHalfInvGroupPtr, lastValInv)

            

            mstore(friGroupPtr, lastVal)

            

            mstore(add(friGroupPtr, 0x20), sub(prime, lastVal))

        }



        

        

        uint256 halfCosetSize = MAX_COSET_SIZE / 2;

        for (uint256 i = 1; i < halfCosetSize; i++) {

            lastVal = fmul(lastVal, genFriGroup);

            lastValInv = fmul(lastValInv, genFriGroupInv);

            uint256 idx = bitReverse(i, FRI_MAX_FRI_STEP-1);



            assembly {

                

                mstore(add(friHalfInvGroupPtr, mul(idx, 0x20)), lastValInv)

                

                mstore(add(friGroupPtr, mul(idx, 0x40)), lastVal)

                

                mstore(add(friGroupPtr, add(mul(idx, 0x40), 0x20)), sub(prime, lastVal))

            }

        }

    }



    

    function doFriSteps(

        uint256 friCtx, uint256 friQueueTail, uint256 cosetOffset_, uint256 friEvalPoint,

        uint256 friCosetSize, uint256 index, uint256 merkleQueuePtr)

        internal pure {

        uint256 friValue;



        uint256 evaluationsOnCosetPtr = friCtx + FRI_CTX_TO_COSET_EVALUATIONS_OFFSET;

        uint256 friHalfInvGroupPtr = friCtx + FRI_CTX_TO_FRI_HALF_INV_GROUP_OFFSET;



        

        if (friCosetSize == 8) {

            (friValue, cosetOffset_) = do3FriSteps(

                friHalfInvGroupPtr, evaluationsOnCosetPtr, cosetOffset_, friEvalPoint);

        } else if (friCosetSize == 4) {

            (friValue, cosetOffset_) = do2FriSteps(

                friHalfInvGroupPtr, evaluationsOnCosetPtr, cosetOffset_, friEvalPoint);

        } else if (friCosetSize == 16) {

            (friValue, cosetOffset_) = do4FriSteps(

                friHalfInvGroupPtr, evaluationsOnCosetPtr, cosetOffset_, friEvalPoint);

        } else {

            require(false, "Only step sizes of 2, 3 or 4 are supported.");

        }



        uint256 lhashMask = getHashMask();

        assembly {

            let indexInNextStep := div(index, friCosetSize)

            mstore(merkleQueuePtr, indexInNextStep)

            mstore(add(merkleQueuePtr, 0x20), and(lhashMask, keccak256(evaluationsOnCosetPtr,

                                                                          mul(0x20,friCosetSize))))



            mstore(friQueueTail, indexInNextStep)

            mstore(add(friQueueTail, 0x20), friValue)

            mstore(add(friQueueTail, 0x40), cosetOffset_)

        }

    }



    

    function computeNextLayer(

        uint256 channelPtr, uint256 friQueuePtr, uint256 merkleQueuePtr, uint256 nQueries,

        uint256 friEvalPoint, uint256 friCosetSize, uint256 friCtx)

        internal pure returns (uint256 nLiveQueries) {

        uint256 merkleQueueTail = merkleQueuePtr;

        uint256 friQueueHead = friQueuePtr;

        uint256 friQueueTail = friQueuePtr;

        uint256 friQueueEnd = friQueueHead + (0x60 * nQueries);



        do {

            uint256 cosetOffset;

            uint256 index;

            (friQueueHead, index, cosetOffset) = gatherCosetInputs(

                channelPtr, friCtx, friQueueHead, friCosetSize);



            doFriSteps(

                friCtx, friQueueTail, cosetOffset, friEvalPoint, friCosetSize, index,

                merkleQueueTail);



            merkleQueueTail += 0x40;

            friQueueTail += 0x60;

        } while (friQueueHead < friQueueEnd);

        return (friQueueTail - friQueuePtr) / 0x60;

    }



}

contract FriStatementContract is FriLayer, FactRegistry {

    

    function verifyFRI(

        uint256[] memory proof,

        uint256[] memory friQueue,

        uint256 evaluationPoint,

        uint256 friStepSize,

        uint256 expectedRoot) public {



        require (friStepSize <= FRI_MAX_FRI_STEP, "FRI step size too large");

        

        require (

            friQueue.length % 3 == 1,

            "FRI Queue must be composed of triplets plus one delimiter cell");

        require (friQueue.length >= 4, "No query to process");



        uint256 mmFriCtxSize = FRI_CTX_SIZE;

        uint256 nQueries = friQueue.length / 3;

        friQueue[3*nQueries] = 0;  

        uint256 merkleQueuePtr;

        uint256 friQueuePtr;

        uint256 channelPtr;

        uint256 friCtx;

        uint256 dataToHash;



        

        require(evaluationPoint < K_MODULUS, "INVALID_EVAL_POINT");



        

        

        

        



        

        

        uint256 prevQuery = 0; 

        for (uint256 i = 0; i < nQueries; i++) {

            require(friQueue[3*i] > prevQuery, "INVALID_QUERY_VALUE");

            require(friQueue[3*i+1] < K_MODULUS, "INVALID_FRI_VALUE");

            require(friQueue[3*i+2] < K_MODULUS, "INVALID_FRI_INVERSE_POINT");

            prevQuery = friQueue[3*i];

        }



        

        

        require((friQueue[0] ^ friQueue[3*nQueries-3]) < friQueue[0], "INVALID_QUERIES_RANGE");



        

        assembly {

            friQueuePtr := add(friQueue, 0x20)

            channelPtr := mload(0x40) 

            mstore(channelPtr, add(proof, 0x20))

            merkleQueuePtr := add(channelPtr, 0x20)

            friCtx := add(merkleQueuePtr, mul(0x40, nQueries))

            dataToHash := add(friCtx, mmFriCtxSize)

            mstore(0x40, add(dataToHash, 0xa0)) 



            mstore(dataToHash, evaluationPoint)

            mstore(add(dataToHash, 0x20), friStepSize)

            mstore(add(dataToHash, 0x80), expectedRoot)



            

            mstore(add(dataToHash, 0x40), keccak256(friQueuePtr, mul(0x60, nQueries)))

        }



        initFriGroups(friCtx);



        nQueries = computeNextLayer(

            channelPtr, friQueuePtr, merkleQueuePtr, nQueries, evaluationPoint,

            2**friStepSize, 

            friCtx);



        verify(channelPtr, merkleQueuePtr, bytes32(expectedRoot), nQueries);



        bytes32 factHash;

        assembly {

            

            mstore(add(dataToHash, 0x60), keccak256(friQueuePtr, mul(0x60, nQueries)))

            factHash := keccak256(dataToHash, 0xa0)

        }



        registerFact(factHash);

    }

}
