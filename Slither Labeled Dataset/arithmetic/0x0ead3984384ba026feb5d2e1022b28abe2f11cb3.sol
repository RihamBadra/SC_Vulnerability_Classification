




pragma solidity ^0.8.0;


interface IERC165 {
    
    function supportsInterface(bytes4 interfaceId) external view returns (bool);
}





            



pragma solidity ^0.8.0;




abstract contract ERC165 is IERC165 {
    
    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {
        return interfaceId == type(IERC165).interfaceId;
    }
}





            



pragma solidity ^0.8.0;




interface IERC1155Receiver is IERC165 {
    
    function onERC1155Received(
        address operator,
        address from,
        uint256 id,
        uint256 value,
        bytes calldata data
    ) external returns (bytes4);

    
    function onERC1155BatchReceived(
        address operator,
        address from,
        uint256[] calldata ids,
        uint256[] calldata values,
        bytes calldata data
    ) external returns (bytes4);
}





            



pragma solidity ^0.8.0;





abstract contract ERC1155Receiver is ERC165, IERC1155Receiver {
    
    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {
        return interfaceId == type(IERC1155Receiver).interfaceId || super.supportsInterface(interfaceId);
    }
}





            



pragma solidity ^0.8.0;






library SafeMath {
    
    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        unchecked {
            uint256 c = a + b;
            if (c < a) return (false, 0);
            return (true, c);
        }
    }

    
    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        unchecked {
            if (b > a) return (false, 0);
            return (true, a - b);
        }
    }

    
    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        unchecked {
            
            
            
            if (a == 0) return (true, 0);
            uint256 c = a * b;
            if (c / a != b) return (false, 0);
            return (true, c);
        }
    }

    
    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        unchecked {
            if (b == 0) return (false, 0);
            return (true, a / b);
        }
    }

    
    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        unchecked {
            if (b == 0) return (false, 0);
            return (true, a % b);
        }
    }

    
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        return a + b;
    }

    
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        return a - b;
    }

    
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        return a * b;
    }

    
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        return a / b;
    }

    
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        return a % b;
    }

    
    function sub(
        uint256 a,
        uint256 b,
        string memory errorMessage
    ) internal pure returns (uint256) {
        unchecked {
            require(b <= a, errorMessage);
            return a - b;
        }
    }

    
    function div(
        uint256 a,
        uint256 b,
        string memory errorMessage
    ) internal pure returns (uint256) {
        unchecked {
            require(b > 0, errorMessage);
            return a / b;
        }
    }

    
    function mod(
        uint256 a,
        uint256 b,
        string memory errorMessage
    ) internal pure returns (uint256) {
        unchecked {
            require(b > 0, errorMessage);
            return a % b;
        }
    }
}





            



pragma solidity ^0.8.0;


abstract contract ReentrancyGuard {
    
    
    
    
    

    
    
    
    
    
    uint256 private constant _NOT_ENTERED = 1;
    uint256 private constant _ENTERED = 2;

    uint256 private _status;

    constructor() {
        _status = _NOT_ENTERED;
    }

    
    modifier nonReentrant() {
        
        require(_status != _ENTERED, "ReentrancyGuard: reentrant call");

        
        _status = _ENTERED;

        _;

        
        
        _status = _NOT_ENTERED;
    }
}





            



pragma solidity ^0.8.0;




contract ERC1155Holder is ERC1155Receiver {
    function onERC1155Received(
        address,
        address,
        uint256,
        uint256,
        bytes memory
    ) public virtual override returns (bytes4) {
        return this.onERC1155Received.selector;
    }

    function onERC1155BatchReceived(
        address,
        address,
        uint256[] memory,
        uint256[] memory,
        bytes memory
    ) public virtual override returns (bytes4) {
        return this.onERC1155BatchReceived.selector;
    }
}





            



pragma solidity ^0.8.0;




interface IERC1155 is IERC165 {
    
    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);

    
    event TransferBatch(
        address indexed operator,
        address indexed from,
        address indexed to,
        uint256[] ids,
        uint256[] values
    );

    
    event ApprovalForAll(address indexed account, address indexed operator, bool approved);

    
    event URI(string value, uint256 indexed id);

    
    function balanceOf(address account, uint256 id) external view returns (uint256);

    
    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)
        external
        view
        returns (uint256[] memory);

    
    function setApprovalForAll(address operator, bool approved) external;

    
    function isApprovedForAll(address account, address operator) external view returns (bool);

    
    function safeTransferFrom(
        address from,
        address to,
        uint256 id,
        uint256 amount,
        bytes calldata data
    ) external;

    
    function safeBatchTransferFrom(
        address from,
        address to,
        uint256[] calldata ids,
        uint256[] calldata amounts,
        bytes calldata data
    ) external;
}





pragma solidity ^0.8.7;






contract DutchAuction is ERC1155Holder, ReentrancyGuard {
    using SafeMath for uint256;

    event Start(uint256 time);
    event Buy(address winner, uint256 amount, uint256 tokenId);

    IERC1155 public nft;

    address payable public seller;
    uint256 public startingPrice;
    uint256 public endPrice;
    uint256 public startAt;
    uint256 public expiresAt;
    uint256 public priceDeductionRate;
    uint256 public duction;

    uint256[30] public tokenIds;

    uint256 public currentTokenIndex;

    address public admin;
    bool public isStart;

    modifier onlyAdmin() {
        require(admin == msg.sender, "ONLY_ADMIN_ALLOWED");
        _;
    }

    constructor(
        address _admin,
        address _seller,
        address _nft
    ) {
        tokenIds = [
            48140505124491600008018462510081168373768676474431063544200989249872003596289,
            48140505124491600008018462510081168373768676474431063544200989250971515224065,
            48140505124491600008018462510081168373768676474431063544200989252071026851841,
            48140505124491600008018462510081168373768676474431063544200989253170538479617,
            48140505124491600008018462510081168373768676474431063544200989254270050107393,
            48140505124491600008018462510081168373768676474431063544200989255369561735169,
            48140505124491600008018462510081168373768676474431063544200989256469073362945,
            48140505124491600008018462510081168373768676474431063544200989257568584990721,
            48140505124491600008018462510081168373768676474431063544200989258668096618497,
            48140505124491600008018462510081168373768676474431063544200989259767608246273,
            48140505124491600008018462510081168373768676474431063544200989260867119874049,
            48140505124491600008018462510081168373768676474431063544200989261966631501825,
            48140505124491600008018462510081168373768676474431063544200989263066143129601,
            48140505124491600008018462510081168373768676474431063544200989264165654757377,
            48140505124491600008018462510081168373768676474431063544200989265265166385153,
            48140505124491600008018462510081168373768676474431063544200989266364678012929,
            48140505124491600008018462510081168373768676474431063544200989267464189640705,
            48140505124491600008018462510081168373768676474431063544200989268563701268481,
            48140505124491600008018462510081168373768676474431063544200989269663212896257,
            48140505124491600008018462510081168373768676474431063544200989270762724524033,
            48140505124491600008018462510081168373768676474431063544200989272961747779585,
            48140505124491600008018462510081168373768676474431063544200989271862236151809,
            48140505124491600008018462510081168373768676474431063544200989274061259407361,
            48140505124491600008018462510081168373768676474431063544200989275160771035137,
            48140505124491600008018462510081168373768676474431063544200989276260282662913,
            48140505124491600008018462510081168373768676474431063544200989277359794290689,
            48140505124491600008018462510081168373768676474431063544200989278459305918465,
            48140505124491600008018462510081168373768676474431063544200989279558817546241,
            48140505124491600008018462510081168373768676474431063544200989280658329174017,
            48140505124491600008018462510081168373768676474431063544200989281757840801793
        ];
        require(tokenIds.length == 30, "err:tokenIds");
        admin = _admin;
        nft = IERC1155(_nft);
        seller = payable(_seller);
        startingPrice = 4 * 10**18;
        endPrice = 0.5 * 10**18;
        priceDeductionRate = 0.25 * 10**18;
        duction = 5 * 1 minutes;
        currentTokenIndex = 0;
        isStart = false;
    }

    function start() external onlyAdmin returns (uint256) {
        startAt = block.timestamp;
        expiresAt = block.timestamp + 70 minutes;
        isStart = true;
        emit Start(startAt);
        return startAt;
    }

    function setStart(bool _bo) external onlyAdmin {
        isStart = _bo;
    }

    function bid() external payable nonReentrant {
        require(isStart == true, "err:not start");

        require(currentTokenIndex < tokenIds.length, "err:auction finished");

        uint256 price = getPrice();

        require(msg.value >= price, "err:ETH < price");

        uint256 nftId = tokenIds[currentTokenIndex];
        currentTokenIndex += 1;

        (bool bo, ) = payable(seller).call{value: msg.value}("");
        require(bo, "Failed to send Eth");

        nft.safeTransferFrom(address(this), msg.sender, nftId, 1, "0x00");
        emit Buy(msg.sender, msg.value, nftId);
    }

    function getPrice() public view returns (uint256) {
        require(isStart == true, "err:not start");
        uint256 blockNow = block.timestamp;
        if (blockNow > expiresAt) {
            return endPrice;
        }
        uint256 timeElapsed = blockNow.sub(startAt);

        uint256 round = timeElapsed.div(duction);
        uint256 price = startingPrice - round * priceDeductionRate;
        if (price > endPrice) {
            return price;
        } else {
            return endPrice;
        }
    }

    function withdraw() external onlyAdmin {
        require(address(this).balance > 0, "balance zero");
        payable(seller).transfer(address(this).balance);
    }

    function withdrawNFT(uint256 _nftId) external onlyAdmin {
        nft.safeTransferFrom(address(this), seller, _nftId, 1, "0x00");
    }

    function setTokenId(uint256 _index, uint256 _tokenId) external onlyAdmin {
        tokenIds[_index] = _tokenId;
    }
}