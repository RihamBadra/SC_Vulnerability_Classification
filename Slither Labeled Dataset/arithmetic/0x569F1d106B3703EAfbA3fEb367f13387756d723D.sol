pragma solidity 0.5.15;

contract CairoVerifierContract {

    function verifyProofExternal(

        uint256[] calldata proofParams, uint256[] calldata proof, uint256[] calldata publicInput)

        external;

}

contract CpuConstraintPoly {

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    



    function() external {

        uint256 res;

        assembly {

            let PRIME := 0x800000000000011000000000000000000000000000000000000000000000001

            

            calldatacopy(0x0, 0x0,  0x3f40)

            let point :=  mload(0x3c0)

            

            mstore(0x3f40, mul(2,  mload(0x80)))

            function expmod(base, exponent, modulus) -> res {

              let p :=  0x50a0

              mstore(p, 0x20)                 

              mstore(add(p, 0x20), 0x20)      

              mstore(add(p, 0x40), 0x20)      

              mstore(add(p, 0x60), base)      

              mstore(add(p, 0x80), exponent)  

              mstore(add(p, 0xa0), modulus)   

              

              if iszero(staticcall(not(0), 0x05, p, 0xc0, p, 0x20)) {

                revert(0, 0)

              }

              res := mload(p)

            }



            function degreeAdjustment(compositionPolynomialDegreeBound, constraintDegree, numeratorDegree,

                                       denominatorDegree) -> res {

              res := sub(sub(compositionPolynomialDegreeBound, 1),

                         sub(add(constraintDegree, numeratorDegree), denominatorDegree))

            }



            {

              



              

              mstore(0x4440, expmod(point,  mload(0x80), PRIME))



              

              mstore(0x4460, expmod(point, div( mload(0x80), 16), PRIME))



              

              mstore(0x4480, expmod(point, div( mload(0x80), 2), PRIME))



              

              mstore(0x44a0, expmod(point, div( mload(0x80), 8), PRIME))



              

              mstore(0x44c0, expmod(point, div( mload(0x80), 256), PRIME))



              

              mstore(0x44e0, expmod(point, div( mload(0x80), 512), PRIME))



              

              mstore(0x4500, expmod(point, div( mload(0x80), 128), PRIME))



              

              mstore(0x4520, expmod(point, div( mload(0x80), 4096), PRIME))



              

              mstore(0x4540, expmod(point, div( mload(0x80), 32), PRIME))



              

              mstore(0x4560, expmod(point, div( mload(0x80), 8192), PRIME))



              

              mstore(0x4580, expmod( mload(0x3a0), div(mul(15,  mload(0x80)), 16), PRIME))



              

              mstore(0x45a0, expmod( mload(0x3a0), mul(16, sub(div( mload(0x80), 16), 1)), PRIME))



              

              mstore(0x45c0, expmod( mload(0x3a0), mul(2, sub(div( mload(0x80), 2), 1)), PRIME))



              

              mstore(0x45e0, expmod( mload(0x3a0), sub( mload(0x80), 1), PRIME))



              

              mstore(0x4600, expmod( mload(0x3a0), div(mul(255,  mload(0x80)), 256), PRIME))



              

              mstore(0x4620, expmod( mload(0x3a0), div(mul(63,  mload(0x80)), 64), PRIME))



              

              mstore(0x4640, expmod( mload(0x3a0), div( mload(0x80), 2), PRIME))



              

              mstore(0x4660, expmod( mload(0x3a0), mul(128, sub(div( mload(0x80), 128), 1)), PRIME))



              

              mstore(0x4680, expmod( mload(0x3a0), div(mul(251,  mload(0x80)), 256), PRIME))



              

              mstore(0x46a0, expmod( mload(0x3a0), mul(8192, sub(div( mload(0x80), 8192), 1)), PRIME))



              

              mstore(0x46c0, expmod( mload(0x3a0), mul(256, sub(div( mload(0x80), 256), 1)), PRIME))



            }



            {

              



              

              

              mstore(0x49a0,

                     addmod( mload(0x4440), sub(PRIME, 1), PRIME))



              

              

              mstore(0x49c0,

                     addmod(

                        mload(0x4460),

                       sub(PRIME,  mload(0x4580)),

                       PRIME))



              

              

              mstore(0x49e0,

                     addmod( mload(0x4460), sub(PRIME, 1), PRIME))



              

              

              mstore(0x4a00,

                     addmod(point, sub(PRIME, 1), PRIME))



              

              

              mstore(0x4a20,

                     addmod(

                       point,

                       sub(PRIME,  mload(0x45a0)),

                       PRIME))



              

              

              mstore(0x4a40,

                     addmod( mload(0x4480), sub(PRIME, 1), PRIME))



              

              

              mstore(0x4a60,

                     addmod(

                       point,

                       sub(PRIME,  mload(0x45c0)),

                       PRIME))



              

              

              mstore(0x4a80,

                     addmod( mload(0x44a0), sub(PRIME, 1), PRIME))



              

              

              mstore(0x4aa0,

                     addmod(point, sub(PRIME,  mload(0x45e0)), PRIME))



              

              

              mstore(0x4ac0,

                     addmod(

                        mload(0x44c0),

                       sub(PRIME,  mload(0x4620)),

                       PRIME))



              

              

              mstore(0x4ae0,

                     addmod(

                        mload(0x44c0),

                       sub(PRIME,  mload(0x4600)),

                       PRIME))



              

              

              mstore(0x4b00,

                     addmod( mload(0x44c0), sub(PRIME, 1), PRIME))



              

              

              mstore(0x4b20,

                     addmod( mload(0x44e0), sub(PRIME, 1), PRIME))



              

              

              mstore(0x4b40,

                     addmod( mload(0x4500), sub(PRIME, 1), PRIME))



              

              

              mstore(0x4b60,

                     addmod( mload(0x4540), sub(PRIME, 1), PRIME))



              

              

              mstore(0x4b80,

                     addmod(

                        mload(0x4560),

                       sub(PRIME,  mload(0x4680)),

                       PRIME))



              

              

              mstore(0x4ba0,

                     addmod(

                        mload(0x4560),

                       sub(PRIME,  mload(0x4600)),

                       PRIME))



              

              

              mstore(0x4bc0,

                     addmod(

                        mload(0x4520),

                       sub(PRIME,  mload(0x4680)),

                       PRIME))



              

              

              mstore(0x4be0,

                     addmod(

                        mload(0x4520),

                       sub(PRIME,  mload(0x4600)),

                       PRIME))



              

              

              mstore(0x4c00,

                     addmod( mload(0x4560), sub(PRIME, 1), PRIME))



              

              

              mstore(0x4c20,

                     addmod( mload(0x4520), sub(PRIME, 1), PRIME))



              

              

              mstore(0x4c40,

                     addmod(

                       point,

                       sub(PRIME,  mload(0x46c0)),

                       PRIME))



            }



            {

              



              

              

              

              

              

              let productsToValuesOffset := 0x2c0

              let prod := 1

              let partialProductEndPtr := 0x49a0

              for { let partialProductPtr := 0x46e0 }

                  lt(partialProductPtr, partialProductEndPtr)

                  { partialProductPtr := add(partialProductPtr, 0x20) } {

                  mstore(partialProductPtr, prod)

                  

                  prod := mulmod(prod,

                                 mload(add(partialProductPtr, productsToValuesOffset)),

                                 PRIME)

              }



              let firstPartialProductPtr := 0x46e0

              

              let prodInv := expmod(prod, sub(PRIME, 2), PRIME)



              if eq(prodInv, 0) {

                  

                  

                  

                  

                  



                  mstore(0, 0x08c379a000000000000000000000000000000000000000000000000000000000)

                  mstore(0x4, 0x20)

                  mstore(0x24, 0x1e)

                  mstore(0x44, "Batch inverse product is zero.")

                  revert(0, 0x62)

              }



              

              

              

              let currentPartialProductPtr := 0x49a0

              for { } gt(currentPartialProductPtr, firstPartialProductPtr) { } {

                  currentPartialProductPtr := sub(currentPartialProductPtr, 0x20)

                  

                  mstore(currentPartialProductPtr,

                         mulmod(mload(currentPartialProductPtr), prodInv, PRIME))

                  

                  prodInv := mulmod(prodInv,

                                     mload(add(currentPartialProductPtr, productsToValuesOffset)),

                                     PRIME)

              }

            }



            {

              



              

              

              mstore(0x4c60,

                     addmod(

                        mload(0x4460),

                       sub(PRIME,  mload(0x4580)),

                       PRIME))



              

              

              mstore(0x4c80,

                     addmod(

                       point,

                       sub(PRIME,  mload(0x45a0)),

                       PRIME))



              

              

              mstore(0x4ca0,

                     addmod(

                       point,

                       sub(PRIME,  mload(0x45c0)),

                       PRIME))



              

              

              mstore(0x4cc0,

                     addmod(point, sub(PRIME,  mload(0x45e0)), PRIME))



              

              

              mstore(0x4ce0,

                     addmod(

                        mload(0x44c0),

                       sub(PRIME,  mload(0x4600)),

                       PRIME))



              

              

              mstore(0x4d00,

                     addmod(

                        mload(0x44e0),

                       sub(PRIME,  mload(0x4640)),

                       PRIME))



              

              

              mstore(0x4d20,

                     addmod(

                       point,

                       sub(PRIME,  mload(0x4660)),

                       PRIME))



              

              

              mstore(0x4d40,

                     addmod(

                        mload(0x4520),

                       sub(PRIME,  mload(0x4600)),

                       PRIME))



              

              

              mstore(0x4d60,

                     addmod(

                        mload(0x4560),

                       sub(PRIME,  mload(0x4600)),

                       PRIME))



              

              

              mstore(0x4d80,

                     addmod(

                       point,

                       sub(PRIME,  mload(0x46a0)),

                       PRIME))



              

              

              mstore(0x4da0,

                     addmod(

                       point,

                       sub(PRIME,  mload(0x46c0)),

                       PRIME))



              

              

              mstore(0x4dc0,

                     expmod(point, degreeAdjustment( mload(0x3f40), mul(2, sub( mload(0x80), 1)), div( mload(0x80), 16),  mload(0x80)), PRIME))



              

              

              mstore(0x4de0,

                     expmod(point, degreeAdjustment( mload(0x3f40), mul(2, sub( mload(0x80), 1)), 0, div( mload(0x80), 16)), PRIME))



              

              

              mstore(0x4e00,

                     expmod(point, degreeAdjustment( mload(0x3f40), sub( mload(0x80), 1), 0, div( mload(0x80), 16)), PRIME))



              

              

              mstore(0x4e20,

                     expmod(point, degreeAdjustment( mload(0x3f40), mul(2, sub( mload(0x80), 1)), 1, div( mload(0x80), 16)), PRIME))



              

              

              mstore(0x4e40,

                     expmod(point, degreeAdjustment( mload(0x3f40), sub( mload(0x80), 1), 0, 1), PRIME))



              

              

              mstore(0x4e60,

                     expmod(point, degreeAdjustment( mload(0x3f40), mul(2, sub( mload(0x80), 1)), 0, 1), PRIME))



              

              

              mstore(0x4e80,

                     expmod(point, degreeAdjustment( mload(0x3f40), mul(2, sub( mload(0x80), 1)), 1, div( mload(0x80), 2)), PRIME))



              

              

              mstore(0x4ea0,

                     expmod(point, degreeAdjustment( mload(0x3f40), sub( mload(0x80), 1), 0, div( mload(0x80), 8)), PRIME))



              

              

              mstore(0x4ec0,

                     expmod(point, degreeAdjustment( mload(0x3f40), mul(2, sub( mload(0x80), 1)), 1,  mload(0x80)), PRIME))



              

              

              mstore(0x4ee0,

                     expmod(point, degreeAdjustment( mload(0x3f40), mul(2, sub( mload(0x80), 1)), div( mload(0x80), 256),  mload(0x80)), PRIME))



              

              

              mstore(0x4f00,

                     expmod(point, degreeAdjustment( mload(0x3f40), sub( mload(0x80), 1), 0, div( mload(0x80), 256)), PRIME))



              

              

              mstore(0x4f20,

                     expmod(point, degreeAdjustment( mload(0x3f40), sub( mload(0x80), 1), div( mload(0x80), 512), div( mload(0x80), 256)), PRIME))



              

              

              mstore(0x4f40,

                     expmod(point, degreeAdjustment( mload(0x3f40), sub( mload(0x80), 1), 0, div( mload(0x80), 512)), PRIME))



              

              

              mstore(0x4f60,

                     expmod(point, degreeAdjustment( mload(0x3f40), sub( mload(0x80), 1), 1, div( mload(0x80), 128)), PRIME))



              

              

              mstore(0x4f80,

                     expmod(point, degreeAdjustment( mload(0x3f40), sub( mload(0x80), 1), 0, div( mload(0x80), 128)), PRIME))



              

              

              mstore(0x4fa0,

                     expmod(point, degreeAdjustment( mload(0x3f40), mul(2, sub( mload(0x80), 1)), div( mload(0x80), 4096), div( mload(0x80), 16)), PRIME))



              

              

              mstore(0x4fc0,

                     expmod(point, degreeAdjustment( mload(0x3f40), mul(2, sub( mload(0x80), 1)), div( mload(0x80), 8192), div( mload(0x80), 32)), PRIME))



              

              

              mstore(0x4fe0,

                     expmod(point, degreeAdjustment( mload(0x3f40), sub( mload(0x80), 1), 0, div( mload(0x80), 8192)), PRIME))



              

              

              mstore(0x5000,

                     expmod(point, degreeAdjustment( mload(0x3f40), sub( mload(0x80), 1), 0, div( mload(0x80), 4096)), PRIME))



              

              

              mstore(0x5020,

                     expmod(point, degreeAdjustment( mload(0x3f40), mul(2, sub( mload(0x80), 1)), 0, div( mload(0x80), 8192)), PRIME))



              

              

              mstore(0x5040,

                     expmod(point, degreeAdjustment( mload(0x3f40), mul(2, sub( mload(0x80), 1)), 0, div( mload(0x80), 4096)), PRIME))



              

              

              mstore(0x5060,

                     expmod(point, degreeAdjustment( mload(0x3f40), sub( mload(0x80), 1), 1, div( mload(0x80), 8192)), PRIME))



              

              

              mstore(0x5080,

                     expmod(point, degreeAdjustment( mload(0x3f40), mul(2, sub( mload(0x80), 1)), 1, div( mload(0x80), 256)), PRIME))



            }



            {

              



              {

              

              let val := addmod(

                 mload(0x2b00),

                sub(

                  PRIME,

                  addmod( mload(0x2b20),  mload(0x2b20), PRIME)),

                PRIME)

              mstore(0x3f60, val)

              }





              {

              

              let val := addmod(

                 mload(0x2b20),

                sub(

                  PRIME,

                  addmod( mload(0x2b40),  mload(0x2b40), PRIME)),

                PRIME)

              mstore(0x3f80, val)

              }





              {

              

              let val := addmod(

                 mload(0x2b40),

                sub(

                  PRIME,

                  addmod( mload(0x2b60),  mload(0x2b60), PRIME)),

                PRIME)

              mstore(0x3fa0, val)

              }





              {

              

              let val := addmod(

                 mload(0x2b80),

                sub(

                  PRIME,

                  addmod( mload(0x2ba0),  mload(0x2ba0), PRIME)),

                PRIME)

              mstore(0x3fc0, val)

              }





              {

              

              let val := addmod(

                 mload(0x2b60),

                sub(

                  PRIME,

                  addmod( mload(0x2b80),  mload(0x2b80), PRIME)),

                PRIME)

              mstore(0x3fe0, val)

              }





              {

              

              let val := addmod(

                 mload(0x2c20),

                sub(

                  PRIME,

                  addmod( mload(0x2c40),  mload(0x2c40), PRIME)),

                PRIME)

              mstore(0x4000, val)

              }





              {

              

              let val := addmod(

                 mload(0x2ba0),

                sub(

                  PRIME,

                  addmod( mload(0x2bc0),  mload(0x2bc0), PRIME)),

                PRIME)

              mstore(0x4020, val)

              }





              {

              

              let val := addmod(

                 mload(0x2bc0),

                sub(

                  PRIME,

                  addmod( mload(0x2be0),  mload(0x2be0), PRIME)),

                PRIME)

              mstore(0x4040, val)

              }





              {

              

              let val := addmod(

                 mload(0x2be0),

                sub(

                  PRIME,

                  addmod( mload(0x2c00),  mload(0x2c00), PRIME)),

                PRIME)

              mstore(0x4060, val)

              }





              {

              

              let val := addmod(

                 mload(0x2c00),

                sub(

                  PRIME,

                  addmod( mload(0x2c20),  mload(0x2c20), PRIME)),

                PRIME)

              mstore(0x4080, val)

              }





              {

              

              let val := addmod(

                addmod(

                   mload(0x33c0),

                   mload(0x3fa0),

                  PRIME),

                1,

                PRIME)

              mstore(0x40a0, val)

              }





              {

              

              let val := addmod(

                 mload(0x2c40),

                sub(

                  PRIME,

                  addmod( mload(0x2c60),  mload(0x2c60), PRIME)),

                PRIME)

              mstore(0x40c0, val)

              }





              {

              

              let val := addmod(

                 mload(0x2c60),

                sub(

                  PRIME,

                  addmod( mload(0x2c80),  mload(0x2c80), PRIME)),

                PRIME)

              mstore(0x40e0, val)

              }





              {

              

              let val := addmod(

                 mload(0x2c80),

                sub(

                  PRIME,

                  addmod( mload(0x2ca0),  mload(0x2ca0), PRIME)),

                PRIME)

              mstore(0x4100, val)

              }





              {

              

              let val := addmod(

                 mload(0x2ca0),

                sub(

                  PRIME,

                  addmod( mload(0x2cc0),  mload(0x2cc0), PRIME)),

                PRIME)

              mstore(0x4120, val)

              }





              {

              

              let val := addmod(

                 mload(0x2cc0),

                sub(

                  PRIME,

                  addmod( mload(0x2ce0),  mload(0x2ce0), PRIME)),

                PRIME)

              mstore(0x4140, val)

              }





              {

              

              let val := addmod( mload(0x3900), sub(PRIME,  mload(0x38c0)), PRIME)

              mstore(0x4160, val)

              }





              {

              

              let val := addmod( mload(0x2d20), sub(PRIME,  mload(0x2d00)), PRIME)

              mstore(0x4180, val)

              }





              {

              

              let val := addmod(

                 mload(0x2e80),

                sub(

                  PRIME,

                  addmod( mload(0x2ea0),  mload(0x2ea0), PRIME)),

                PRIME)

              mstore(0x41a0, val)

              }





              {

              

              let val := addmod(

                1,

                sub(PRIME,  mload(0x41a0)),

                PRIME)

              mstore(0x41c0, val)

              }





              {

              

              let val := addmod(

                 mload(0x3020),

                sub(

                  PRIME,

                  addmod( mload(0x3040),  mload(0x3040), PRIME)),

                PRIME)

              mstore(0x41e0, val)

              }





              {

              

              let val := addmod(

                1,

                sub(PRIME,  mload(0x41e0)),

                PRIME)

              mstore(0x4200, val)

              }





              {

              

              let val := addmod(

                 mload(0x31c0),

                sub(

                  PRIME,

                  addmod( mload(0x31e0),  mload(0x31e0), PRIME)),

                PRIME)

              mstore(0x4220, val)

              }





              {

              

              let val := addmod(

                1,

                sub(PRIME,  mload(0x4220)),

                PRIME)

              mstore(0x4240, val)

              }





              {

              

              let val := addmod(

                 mload(0x3360),

                sub(

                  PRIME,

                  addmod( mload(0x3380),  mload(0x3380), PRIME)),

                PRIME)

              mstore(0x4260, val)

              }





              {

              

              let val := addmod(

                1,

                sub(PRIME,  mload(0x4260)),

                PRIME)

              mstore(0x4280, val)

              }





              {

              

              let val :=  mload(0x2a00)

              mstore(0x42a0, val)

              }





              {

              

              let val := addmod(

                mulmod(

                   mload(0x42a0),

                   mload(0xa0),

                  PRIME),

                 mload(0x2a20),

                PRIME)

              mstore(0x42c0, val)

              }





              {

              

              let val := addmod(

                mulmod(

                   mload(0x42c0),

                   mload(0xa0),

                  PRIME),

                 mload(0x2a40),

                PRIME)

              mstore(0x42e0, val)

              }





              {

              

              let val := addmod(

                mulmod(

                   mload(0x42e0),

                   mload(0xa0),

                  PRIME),

                 mload(0x2a60),

                PRIME)

              mstore(0x4300, val)

              }





              {

              

              let val := addmod(

                mulmod(

                   mload(0x4300),

                   mload(0xa0),

                  PRIME),

                 mload(0x2a80),

                PRIME)

              mstore(0x4320, val)

              }





              {

              

              let val := addmod(

                mulmod(

                   mload(0x4320),

                   mload(0xa0),

                  PRIME),

                 mload(0x2aa0),

                PRIME)

              mstore(0x4340, val)

              }





              {

              

              let val := addmod(

                mulmod(

                   mload(0x4340),

                   mload(0xa0),

                  PRIME),

                 mload(0x2ac0),

                PRIME)

              mstore(0x4360, val)

              }





              {

              

              let val := addmod(

                mulmod(

                   mload(0x4360),

                   mload(0xa0),

                  PRIME),

                 mload(0x2ae0),

                PRIME)

              mstore(0x4380, val)

              }





              {

              

              let val := mulmod( mload(0x3a00),  mload(0x3a00), PRIME)

              mstore(0x43a0, val)

              }





              {

              

              let val := addmod(

                 mload(0x3c40),

                sub(

                  PRIME,

                  addmod( mload(0x3ca0),  mload(0x3ca0), PRIME)),

                PRIME)

              mstore(0x43c0, val)

              }





              {

              

              let val := addmod(

                1,

                sub(

                  PRIME,

                   mload(0x43c0)),

                PRIME)

              mstore(0x43e0, val)

              }





              {

              

              let val := addmod(

                 mload(0x39a0),

                sub(

                  PRIME,

                  addmod( mload(0x3b60),  mload(0x3b60), PRIME)),

                PRIME)

              mstore(0x4400, val)

              }





              {

              

              let val := addmod(

                1,

                sub(

                  PRIME,

                   mload(0x4400)),

                PRIME)

              mstore(0x4420, val)

              }





              {

              

              let val := addmod(

                mulmod(

                   mload(0x3f60),

                   mload(0x3f60),

                  PRIME),

                sub(PRIME,  mload(0x3f60)),

                PRIME)



              

              

              val := mulmod(val, mload(0x4c60), PRIME)

              

              

              val := mulmod(val, mload(0x46e0), PRIME)



              

              res := addmod(res,

                            mulmod(val,

                                   add( mload(0x440),

                                       mulmod( mload(0x460),

                                              mload(0x4dc0),

                      PRIME)),

                      PRIME),

                      PRIME)

              }



              {

              

              let val := addmod(

                mulmod( mload(0x2b00),  mload(0x2b00), PRIME),

                sub(PRIME,  mload(0x2b00)),

                PRIME)



              

              

              

              

              

              val := mulmod(val, mload(0x4700), PRIME)



              

              res := addmod(res,

                            mulmod(val,

                                   add( mload(0x480),

                                       mulmod( mload(0x4a0),

                                              mload(0x4de0),

                      PRIME)),

                      PRIME),

                      PRIME)

              }



              {

              

              let val := addmod(

                 mload(0x33e0),

                sub(

                  PRIME,

                  addmod(

                    mulmod(

                      addmod(

                        mulmod(

                          addmod(

                            mulmod( mload(0x2b00),  mload(0xa0), PRIME),

                             mload(0x29c0),

                            PRIME),

                           mload(0xa0),

                          PRIME),

                         mload(0x29e0),

                        PRIME),

                       mload(0xa0),

                      PRIME),

                     mload(0x2980),

                    PRIME)),

                PRIME)



              

              

              

              

              

              val := mulmod(val, mload(0x4720), PRIME)



              

              res := addmod(res,

                            mulmod(val,

                                   add( mload(0x4c0),

                                       mulmod( mload(0x4e0),

                                              mload(0x4e00),

                      PRIME)),

                      PRIME),

                      PRIME)

              }



              {

              

              let val := addmod(

                addmod( mload(0x34c0),  mload(0xc0), PRIME),

                sub(

                  PRIME,

                  addmod(

                    addmod(

                      mulmod(

                         mload(0x3f60),

                         mload(0x3a40),

                        PRIME),

                      mulmod(

                        addmod(

                          1,

                          sub(PRIME,  mload(0x3f60)),

                          PRIME),

                         mload(0x3940),

                        PRIME),

                      PRIME),

                     mload(0x2980),

                    PRIME)),

                PRIME)



              

              

              

              

              

              val := mulmod(val, mload(0x4720), PRIME)



              

              res := addmod(res,

                            mulmod(val,

                                   add( mload(0x500),

                                       mulmod( mload(0x520),

                                              mload(0x4de0),

                      PRIME)),

                      PRIME),

                      PRIME)

              }



              {

              

              let val := addmod(

                addmod( mload(0x3440),  mload(0xc0), PRIME),

                sub(

                  PRIME,

                  addmod(

                    addmod(

                      mulmod(

                         mload(0x3f80),

                         mload(0x3a40),

                        PRIME),

                      mulmod(

                        addmod(

                          1,

                          sub(PRIME,  mload(0x3f80)),

                          PRIME),

                         mload(0x3940),

                        PRIME),

                      PRIME),

                     mload(0x29e0),

                    PRIME)),

                PRIME)



              

              

              

              

              

              val := mulmod(val, mload(0x4720), PRIME)



              

              res := addmod(res,

                            mulmod(val,

                                   add( mload(0x540),

                                       mulmod( mload(0x560),

                                              mload(0x4de0),

                      PRIME)),

                      PRIME),

                      PRIME)

              }



              {

              

              let val := addmod(

                addmod( mload(0x3500),  mload(0xc0), PRIME),

                sub(

                  PRIME,

                  addmod(

                    addmod(

                      addmod(

                        addmod(

                          mulmod(

                             mload(0x3fa0),

                             mload(0x33c0),

                            PRIME),

                          mulmod(

                             mload(0x3fc0),

                             mload(0x3940),

                            PRIME),

                          PRIME),

                        mulmod(

                           mload(0x3fe0),

                           mload(0x3a40),

                          PRIME),

                        PRIME),

                      mulmod(

                        addmod(

                          1,

                          sub(

                            PRIME,

                            addmod(

                              addmod(

                                 mload(0x3fa0),

                                 mload(0x3fc0),

                                PRIME),

                               mload(0x3fe0),

                              PRIME)),

                          PRIME),

                         mload(0x3460),

                        PRIME),

                      PRIME),

                     mload(0x29c0),

                    PRIME)),

                PRIME)



              

              

              

              

              

              val := mulmod(val, mload(0x4720), PRIME)



              

              res := addmod(res,

                            mulmod(val,

                                   add( mload(0x580),

                                       mulmod( mload(0x5a0),

                                              mload(0x4de0),

                      PRIME)),

                      PRIME),

                      PRIME)

              }



              {

              

              let val := addmod(

                 mload(0x39c0),

                sub(

                  PRIME,

                  mulmod( mload(0x3460),  mload(0x3520), PRIME)),

                PRIME)



              

              

              

              

              

              val := mulmod(val, mload(0x4720), PRIME)



              

              res := addmod(res,

                            mulmod(val,

                                   add( mload(0x5c0),

                                       mulmod( mload(0x5e0),

                                              mload(0x4de0),

                      PRIME)),

                      PRIME),

                      PRIME)

              }



              {

              

              let val := addmod(

                mulmod(

                  addmod(

                    1,

                    sub(PRIME,  mload(0x4000)),

                    PRIME),

                   mload(0x3ac0),

                  PRIME),

                sub(

                  PRIME,

                  addmod(

                    addmod(

                      mulmod(

                         mload(0x4020),

                        addmod( mload(0x3460),  mload(0x3520), PRIME),

                        PRIME),

                      mulmod(

                         mload(0x4040),

                         mload(0x39c0),

                        PRIME),

                      PRIME),

                    mulmod(

                      addmod(

                        1,

                        sub(

                          PRIME,

                          addmod(

                            addmod(

                               mload(0x4020),

                               mload(0x4040),

                              PRIME),

                             mload(0x4000),

                            PRIME)),

                        PRIME),

                       mload(0x3520),

                      PRIME),

                    PRIME)),

                PRIME)



              

              

              

              

              

              val := mulmod(val, mload(0x4720), PRIME)



              

              res := addmod(res,

                            mulmod(val,

                                   add( mload(0x600),

                                       mulmod( mload(0x620),

                                              mload(0x4de0),

                      PRIME)),

                      PRIME),

                      PRIME)

              }



              {

              

              let val := addmod(

                 mload(0x3980),

                sub(

                  PRIME,

                  mulmod(

                     mload(0x4000),

                     mload(0x34e0),

                    PRIME)),

                PRIME)



              

              

              val := mulmod(val, mload(0x4c80), PRIME)

              

              

              val := mulmod(val, mload(0x4720), PRIME)



              

              res := addmod(res,

                            mulmod(val,

                                   add( mload(0x640),

                                       mulmod( mload(0x660),

                                              mload(0x4e20),

                      PRIME)),

                      PRIME),

                      PRIME)

              }



              {

              

              let val := addmod(

                 mload(0x3a80),

                sub(

                  PRIME,

                  mulmod( mload(0x3980),  mload(0x3ac0), PRIME)),

                PRIME)



              

              

              val := mulmod(val, mload(0x4c80), PRIME)

              

              

              val := mulmod(val, mload(0x4720), PRIME)



              

              res := addmod(res,

                            mulmod(val,

                                   add( mload(0x680),

                                       mulmod( mload(0x6a0),

                                              mload(0x4e20),

                      PRIME)),

                      PRIME),

                      PRIME)

              }



              {

              

              let val := addmod(

                addmod(

                  mulmod(

                    addmod(

                      1,

                      sub(PRIME,  mload(0x4000)),

                      PRIME),

                     mload(0x3540),

                    PRIME),

                  mulmod(

                     mload(0x3980),

                    addmod(

                       mload(0x3540),

                      sub(

                        PRIME,

                        addmod( mload(0x33c0),  mload(0x3520), PRIME)),

                      PRIME),

                    PRIME),

                  PRIME),

                sub(

                  PRIME,

                  addmod(

                    addmod(

                      mulmod(

                        addmod(

                          1,

                          sub(

                            PRIME,

                            addmod(

                              addmod(

                                 mload(0x4060),

                                 mload(0x4080),

                                PRIME),

                               mload(0x4000),

                              PRIME)),

                          PRIME),

                         mload(0x40a0),

                        PRIME),

                      mulmod(

                         mload(0x4060),

                         mload(0x3ac0),

                        PRIME),

                      PRIME),

                    mulmod(

                       mload(0x4080),

                      addmod( mload(0x33c0),  mload(0x3ac0), PRIME),

                      PRIME),

                    PRIME)),

                PRIME)



              

              

              val := mulmod(val, mload(0x4c80), PRIME)

              

              

              val := mulmod(val, mload(0x4720), PRIME)



              

              res := addmod(res,

                            mulmod(val,

                                   add( mload(0x6c0),

                                       mulmod( mload(0x6e0),

                                              mload(0x4e20),

                      PRIME)),

                      PRIME),

                      PRIME)

              }



              {

              

              let val := mulmod(

                addmod(

                   mload(0x3a80),

                  sub(PRIME,  mload(0x4000)),

                  PRIME),

                addmod(

                   mload(0x3540),

                  sub(PRIME,  mload(0x40a0)),

                  PRIME),

                PRIME)



              

              

              val := mulmod(val, mload(0x4c80), PRIME)

              

              

              val := mulmod(val, mload(0x4720), PRIME)



              

              res := addmod(res,

                            mulmod(val,

                                   add( mload(0x700),

                                       mulmod( mload(0x720),

                                              mload(0x4e20),

                      PRIME)),

                      PRIME),

                      PRIME)

              }



              {

              

              let val := addmod(

                 mload(0x3b40),

                sub(

                  PRIME,

                  addmod(

                    addmod(

                      addmod(

                         mload(0x3940),

                        mulmod(

                           mload(0x40c0),

                           mload(0x3ac0),

                          PRIME),

                        PRIME),

                       mload(0x40e0),

                      PRIME),

                    mulmod( mload(0x4100), 2, PRIME),

                    PRIME)),

                PRIME)



              

              

              val := mulmod(val, mload(0x4c80), PRIME)

              

              

              val := mulmod(val, mload(0x4720), PRIME)



              

              res := addmod(res,

                            mulmod(val,

                                   add( mload(0x740),

                                       mulmod( mload(0x760),

                                              mload(0x4e20),

                      PRIME)),

                      PRIME),

                      PRIME)

              }



              {

              

              let val := addmod(

                 mload(0x3be0),

                sub(

                  PRIME,

                  addmod(

                    addmod(

                      mulmod(

                        addmod(

                          1,

                          sub(

                            PRIME,

                            addmod(

                               mload(0x4100),

                               mload(0x4120),

                              PRIME)),

                          PRIME),

                         mload(0x3a40),

                        PRIME),

                      mulmod(

                         mload(0x4120),

                         mload(0x34e0),

                        PRIME),

                      PRIME),

                    mulmod(

                       mload(0x4100),

                      addmod( mload(0x3940), 2, PRIME),

                      PRIME),

                    PRIME)),

                PRIME)



              

              

              val := mulmod(val, mload(0x4c80), PRIME)

              

              

              val := mulmod(val, mload(0x4720), PRIME)



              

              res := addmod(res,

                            mulmod(val,

                                   add( mload(0x780),

                                       mulmod( mload(0x7a0),

                                              mload(0x4e20),

                      PRIME)),

                      PRIME),

                      PRIME)

              }



              {

              

              let val := mulmod(

                 mload(0x4100),

                addmod( mload(0x34e0), sub(PRIME,  mload(0x3a40)), PRIME),

                PRIME)



              

              

              

              

              

              val := mulmod(val, mload(0x4720), PRIME)



              

              res := addmod(res,

                            mulmod(val,

                                   add( mload(0x7c0),

                                       mulmod( mload(0x7e0),

                                              mload(0x4de0),

                      PRIME)),

                      PRIME),

                      PRIME)

              }



              {

              

              let val := mulmod(

                 mload(0x4100),

                addmod(

                   mload(0x3460),

                  sub(

                    PRIME,

                    addmod(

                      addmod(

                         mload(0x33c0),

                         mload(0x3fa0),

                        PRIME),

                      1,

                      PRIME)),

                  PRIME),

                PRIME)



              

              

              

              

              

              val := mulmod(val, mload(0x4720), PRIME)



              

              res := addmod(res,

                            mulmod(val,

                                   add( mload(0x800),

                                       mulmod( mload(0x820),

                                              mload(0x4de0),

                      PRIME)),

                      PRIME),

                      PRIME)

              }



              {

              

              let val := mulmod(

                 mload(0x4140),

                addmod(

                   mload(0x34e0),

                  sub(PRIME,  mload(0x3ac0)),

                  PRIME),

                PRIME)



              

              

              

              

              

              val := mulmod(val, mload(0x4720), PRIME)



              

              res := addmod(res,

                            mulmod(val,

                                   add( mload(0x840),

                                       mulmod( mload(0x860),

                                              mload(0x4de0),

                      PRIME)),

                      PRIME),

                      PRIME)

              }



              {

              

              let val := addmod( mload(0x3940), sub(PRIME,  mload(0xe0)), PRIME)



              

              

              

              

              

              val := mulmod(val, mload(0x4740), PRIME)



              

              res := addmod(res,

                            mulmod(val,

                                   add( mload(0x880),

                                       mulmod( mload(0x8a0),

                                              mload(0x4e40),

                      PRIME)),

                      PRIME),

                      PRIME)

              }



              {

              

              let val := addmod( mload(0x3a40), sub(PRIME,  mload(0xe0)), PRIME)



              

              

              

              

              

              val := mulmod(val, mload(0x4740), PRIME)



              

              res := addmod(res,

                            mulmod(val,

                                   add( mload(0x8c0),

                                       mulmod( mload(0x8e0),

                                              mload(0x4e40),

                      PRIME)),

                      PRIME),

                      PRIME)

              }



              {

              

              let val := addmod( mload(0x33c0), sub(PRIME,  mload(0x100)), PRIME)



              

              

              

              

              

              val := mulmod(val, mload(0x4740), PRIME)



              

              res := addmod(res,

                            mulmod(val,

                                   add( mload(0x900),

                                       mulmod( mload(0x920),

                                              mload(0x4e40),

                      PRIME)),

                      PRIME),

                      PRIME)

              }



              {

              

              let val := addmod( mload(0x3940), sub(PRIME,  mload(0x120)), PRIME)



              

              

              

              

              

              val := mulmod(val, mload(0x4760), PRIME)



              

              res := addmod(res,

                            mulmod(val,

                                   add( mload(0x940),

                                       mulmod( mload(0x960),

                                              mload(0x4e40),

                      PRIME)),

                      PRIME),

                      PRIME)

              }



              {

              

              let val := addmod( mload(0x33c0), sub(PRIME,  mload(0x140)), PRIME)



              

              

              

              

              

              val := mulmod(val, mload(0x4760), PRIME)



              

              res := addmod(res,

                            mulmod(val,

                                   add( mload(0x980),

                                       mulmod( mload(0x9a0),

                                              mload(0x4e40),

                      PRIME)),

                      PRIME),

                      PRIME)

              }



              {

              

              let val := addmod(

                addmod(

                  addmod(

                    mulmod(

                      addmod(

                         mload(0x160),

                        sub(

                          PRIME,

                          addmod(

                             mload(0x38c0),

                            mulmod(

                               mload(0x180),

                               mload(0x38e0),

                              PRIME),

                            PRIME)),

                        PRIME),

                       mload(0x3f00),

                      PRIME),

                     mload(0x33c0),

                    PRIME),

                  mulmod(

                     mload(0x180),

                     mload(0x33e0),

                    PRIME),

                  PRIME),

                sub(PRIME,  mload(0x160)),

                PRIME)



              

              

              

              

              

              val := mulmod(val, mload(0x4740), PRIME)



              

              res := addmod(res,

                            mulmod(val,

                                   add( mload(0x9c0),

                                       mulmod( mload(0x9e0),

                                              mload(0x4e60),

                      PRIME)),

                      PRIME),

                      PRIME)

              }



              {

              

              let val := addmod(

                mulmod(

                  addmod(

                     mload(0x160),

                    sub(

                      PRIME,

                      addmod(

                         mload(0x3900),

                        mulmod(

                           mload(0x180),

                           mload(0x3920),

                          PRIME),

                        PRIME)),

                    PRIME),

                   mload(0x3f20),

                  PRIME),

                sub(

                  PRIME,

                  mulmod(

                    addmod(

                       mload(0x160),

                      sub(

                        PRIME,

                        addmod(

                           mload(0x3400),

                          mulmod(

                             mload(0x180),

                             mload(0x3420),

                            PRIME),

                          PRIME)),

                      PRIME),

                     mload(0x3f00),

                    PRIME)),

                PRIME)



              

              

              val := mulmod(val, mload(0x4ca0), PRIME)

              

              

              val := mulmod(val, mload(0x4780), PRIME)



              

              res := addmod(res,

                            mulmod(val,

                                   add( mload(0xa00),

                                       mulmod( mload(0xa20),

                                              mload(0x4e80),

                      PRIME)),

                      PRIME),

                      PRIME)

              }



              {

              

              let val := addmod(

                 mload(0x3f00),

                sub(PRIME,  mload(0x1a0)),

                PRIME)



              

              

              

              

              

              val := mulmod(val, mload(0x47a0), PRIME)



              

              res := addmod(res,

                            mulmod(val,

                                   add( mload(0xa40),

                                       mulmod( mload(0xa60),

                                              mload(0x4e40),

                      PRIME)),

                      PRIME),

                      PRIME)

              }



              {

              

              let val := addmod(

                mulmod(

                   mload(0x4160),

                   mload(0x4160),

                  PRIME),

                sub(PRIME,  mload(0x4160)),

                PRIME)



              

              

              val := mulmod(val, mload(0x4ca0), PRIME)

              

              

              val := mulmod(val, mload(0x4780), PRIME)



              

              res := addmod(res,

                            mulmod(val,

                                   add( mload(0xa80),

                                       mulmod( mload(0xaa0),

                                              mload(0x4e80),

                      PRIME)),

                      PRIME),

                      PRIME)

              }



              {

              

              let val := mulmod(

                addmod( mload(0x4160), sub(PRIME, 1), PRIME),

                addmod( mload(0x38e0), sub(PRIME,  mload(0x3920)), PRIME),

                PRIME)



              

              

              val := mulmod(val, mload(0x4ca0), PRIME)

              

              

              val := mulmod(val, mload(0x4780), PRIME)



              

              res := addmod(res,

                            mulmod(val,

                                   add( mload(0xac0),

                                       mulmod( mload(0xae0),

                                              mload(0x4e80),

                      PRIME)),

                      PRIME),

                      PRIME)

              }



              {

              

              let val :=  mload(0x3400)



              

              

              

              

              

              val := mulmod(val, mload(0x47c0), PRIME)



              

              res := addmod(res,

                            mulmod(val,

                                   add( mload(0xb00),

                                       mulmod( mload(0xb20),

                                              mload(0x4ea0),

                      PRIME)),

                      PRIME),

                      PRIME)

              }



              {

              

              let val :=  mload(0x3420)



              

              

              

              

              

              val := mulmod(val, mload(0x47c0), PRIME)



              

              res := addmod(res,

                            mulmod(val,

                                   add( mload(0xb40),

                                       mulmod( mload(0xb60),

                                              mload(0x4ea0),

                      PRIME)),

                      PRIME),

                      PRIME)

              }



              {

              

              let val := addmod(

                addmod(

                  mulmod(

                    addmod(

                       mload(0x1c0),

                      sub(PRIME,  mload(0x2d00)),

                      PRIME),

                     mload(0x3ec0),

                    PRIME),

                   mload(0x2980),

                  PRIME),

                sub(PRIME,  mload(0x1c0)),

                PRIME)



              

              

              

              

              

              val := mulmod(val, mload(0x4740), PRIME)



              

              res := addmod(res,

                            mulmod(val,

                                   add( mload(0xb80),

                                       mulmod( mload(0xba0),

                                              mload(0x4e60),

                      PRIME)),

                      PRIME),

                      PRIME)

              }



              {

              

              let val := addmod(

                mulmod(

                  addmod(

                     mload(0x1c0),

                    sub(PRIME,  mload(0x2d20)),

                    PRIME),

                   mload(0x3ee0),

                  PRIME),

                sub(

                  PRIME,

                  mulmod(

                    addmod(

                       mload(0x1c0),

                      sub(PRIME,  mload(0x29a0)),

                      PRIME),

                     mload(0x3ec0),

                    PRIME)),

                PRIME)



              

              

              val := mulmod(val, mload(0x4cc0), PRIME)

              

              

              val := mulmod(val, mload(0x46e0), PRIME)



              

              res := addmod(res,

                            mulmod(val,

                                   add( mload(0xbc0),

                                       mulmod( mload(0xbe0),

                                              mload(0x4ec0),

                      PRIME)),

                      PRIME),

                      PRIME)

              }



              {

              

              let val := addmod(

                 mload(0x3ec0),

                sub(PRIME,  mload(0x1e0)),

                PRIME)



              

              

              

              

              

              val := mulmod(val, mload(0x47e0), PRIME)



              

              res := addmod(res,

                            mulmod(val,

                                   add( mload(0xc00),

                                       mulmod( mload(0xc20),

                                              mload(0x4e40),

                      PRIME)),

                      PRIME),

                      PRIME)

              }



              {

              

              let val := addmod(

                mulmod(

                   mload(0x4180),

                   mload(0x4180),

                  PRIME),

                sub(PRIME,  mload(0x4180)),

                PRIME)



              

              

              val := mulmod(val, mload(0x4cc0), PRIME)

              

              

              val := mulmod(val, mload(0x46e0), PRIME)



              

              res := addmod(res,

                            mulmod(val,

                                   add( mload(0xc40),

                                       mulmod( mload(0xc60),

                                              mload(0x4ec0),

                      PRIME)),

                      PRIME),

                      PRIME)

              }



              {

              

              let val := addmod( mload(0x2d00), sub(PRIME,  mload(0x200)), PRIME)



              

              

              

              

              

              val := mulmod(val, mload(0x4740), PRIME)



              

              res := addmod(res,

                            mulmod(val,

                                   add( mload(0xc80),

                                       mulmod( mload(0xca0),

                                              mload(0x4e40),

                      PRIME)),

                      PRIME),

                      PRIME)

              }



              {

              

              let val := addmod( mload(0x2d00), sub(PRIME,  mload(0x220)), PRIME)



              

              

              

              

              

              val := mulmod(val, mload(0x47e0), PRIME)



              

              res := addmod(res,

                            mulmod(val,

                                   add( mload(0xcc0),

                                       mulmod( mload(0xce0),

                                              mload(0x4e40),

                      PRIME)),

                      PRIME),

                      PRIME)

              }



              {

              

              let val := mulmod(

                 mload(0x41a0),

                addmod(

                   mload(0x41a0),

                  sub(PRIME, 1),

                  PRIME),

                PRIME)



              

              

              val := mulmod(val, mload(0x4ce0), PRIME)

              

              

              val := mulmod(val, mload(0x46e0), PRIME)



              

              res := addmod(res,

                            mulmod(val,

                                   add( mload(0xd00),

                                       mulmod( mload(0xd20),

                                              mload(0x4ee0),

                      PRIME)),

                      PRIME),

                      PRIME)

              }



              {

              

              let val :=  mload(0x2e80)



              

              

              

              

              

              val := mulmod(val, mload(0x4800), PRIME)



              

              res := addmod(res,

                            mulmod(val,

                                   add( mload(0xd40),

                                       mulmod( mload(0xd60),

                                              mload(0x4f00),

                      PRIME)),

                      PRIME),

                      PRIME)

              }



              {

              

              let val :=  mload(0x2e80)



              

              

              

              

              

              val := mulmod(val, mload(0x4820), PRIME)



              

              res := addmod(res,

                            mulmod(val,

                                   add( mload(0xd80),

                                       mulmod( mload(0xda0),

                                              mload(0x4f00),

                      PRIME)),

                      PRIME),

                      PRIME)

              }



              {

              

              let val := addmod(

                mulmod(

                   mload(0x41a0),

                  addmod(

                     mload(0x2de0),

                    sub(PRIME,  mload(0x20)),

                    PRIME),

                  PRIME),

                sub(

                  PRIME,

                  mulmod(

                     mload(0x2e60),

                    addmod(

                       mload(0x2d40),

                      sub(PRIME,  mload(0x0)),

                      PRIME),

                    PRIME)),

                PRIME)



              

              

              val := mulmod(val, mload(0x4ce0), PRIME)

              

              

              val := mulmod(val, mload(0x46e0), PRIME)



              

              res := addmod(res,

                            mulmod(val,

                                   add( mload(0xdc0),

                                       mulmod( mload(0xde0),

                                              mload(0x4ee0),

                      PRIME)),

                      PRIME),

                      PRIME)

              }



              {

              

              let val := addmod(

                mulmod( mload(0x2e60),  mload(0x2e60), PRIME),

                sub(

                  PRIME,

                  mulmod(

                     mload(0x41a0),

                    addmod(

                      addmod(

                         mload(0x2d40),

                         mload(0x0),

                        PRIME),

                       mload(0x2d60),

                      PRIME),

                    PRIME)),

                PRIME)



              

              

              val := mulmod(val, mload(0x4ce0), PRIME)

              

              

              val := mulmod(val, mload(0x46e0), PRIME)



              

              res := addmod(res,

                            mulmod(val,

                                   add( mload(0xe00),

                                       mulmod( mload(0xe20),

                                              mload(0x4ee0),

                      PRIME)),

                      PRIME),

                      PRIME)

              }



              {

              

              let val := addmod(

                mulmod(

                   mload(0x41a0),

                  addmod( mload(0x2de0),  mload(0x2e00), PRIME),

                  PRIME),

                sub(

                  PRIME,

                  mulmod(

                     mload(0x2e60),

                    addmod( mload(0x2d40), sub(PRIME,  mload(0x2d60)), PRIME),

                    PRIME)),

                PRIME)



              

              

              val := mulmod(val, mload(0x4ce0), PRIME)

              

              

              val := mulmod(val, mload(0x46e0), PRIME)



              

              res := addmod(res,

                            mulmod(val,

                                   add( mload(0xe40),

                                       mulmod( mload(0xe60),

                                              mload(0x4ee0),

                      PRIME)),

                      PRIME),

                      PRIME)

              }



              {

              

              let val := mulmod(

                 mload(0x41c0),

                addmod( mload(0x2d60), sub(PRIME,  mload(0x2d40)), PRIME),

                PRIME)



              

              

              val := mulmod(val, mload(0x4ce0), PRIME)

              

              

              val := mulmod(val, mload(0x46e0), PRIME)



              

              res := addmod(res,

                            mulmod(val,

                                   add( mload(0xe80),

                                       mulmod( mload(0xea0),

                                              mload(0x4ee0),

                      PRIME)),

                      PRIME),

                      PRIME)

              }



              {

              

              let val := mulmod(

                 mload(0x41c0),

                addmod( mload(0x2e00), sub(PRIME,  mload(0x2de0)), PRIME),

                PRIME)



              

              

              val := mulmod(val, mload(0x4ce0), PRIME)

              

              

              val := mulmod(val, mload(0x46e0), PRIME)



              

              res := addmod(res,

                            mulmod(val,

                                   add( mload(0xec0),

                                       mulmod( mload(0xee0),

                                              mload(0x4ee0),

                      PRIME)),

                      PRIME),

                      PRIME)

              }



              {

              

              let val := addmod(

                 mload(0x2da0),

                sub(PRIME,  mload(0x2d80)),

                PRIME)



              

              

              val := mulmod(val, mload(0x4d00), PRIME)

              

              

              val := mulmod(val, mload(0x4840), PRIME)



              

              res := addmod(res,

                            mulmod(val,

                                   add( mload(0xf00),

                                       mulmod( mload(0xf20),

                                              mload(0x4f20),

                      PRIME)),

                      PRIME),

                      PRIME)

              }



              {

              

              let val := addmod(

                 mload(0x2e40),

                sub(PRIME,  mload(0x2e20)),

                PRIME)



              

              

              val := mulmod(val, mload(0x4d00), PRIME)

              

              

              val := mulmod(val, mload(0x4840), PRIME)



              

              res := addmod(res,

                            mulmod(val,

                                   add( mload(0xf40),

                                       mulmod( mload(0xf60),

                                              mload(0x4f20),

                      PRIME)),

                      PRIME),

                      PRIME)

              }



              {

              

              let val := addmod(

                 mload(0x2d40),

                sub(PRIME,  mload(0x240)),

                PRIME)



              

              

              

              

              

              val := mulmod(val, mload(0x4860), PRIME)



              

              res := addmod(res,

                            mulmod(val,

                                   add( mload(0xf80),

                                       mulmod( mload(0xfa0),

                                              mload(0x4f40),

                      PRIME)),

                      PRIME),

                      PRIME)

              }



              {

              

              let val := addmod(

                 mload(0x2de0),

                sub(PRIME,  mload(0x260)),

                PRIME)



              

              

              

              

              

              val := mulmod(val, mload(0x4860), PRIME)



              

              res := addmod(res,

                            mulmod(val,

                                   add( mload(0xfc0),

                                       mulmod( mload(0xfe0),

                                              mload(0x4f40),

                      PRIME)),

                      PRIME),

                      PRIME)

              }



              {

              

              let val := mulmod(

                 mload(0x41e0),

                addmod(

                   mload(0x41e0),

                  sub(PRIME, 1),

                  PRIME),

                PRIME)



              

              

              val := mulmod(val, mload(0x4ce0), PRIME)

              

              

              val := mulmod(val, mload(0x46e0), PRIME)



              

              res := addmod(res,

                            mulmod(val,

                                   add( mload(0x1000),

                                       mulmod( mload(0x1020),

                                              mload(0x4ee0),

                      PRIME)),

                      PRIME),

                      PRIME)

              }



              {

              

              let val :=  mload(0x3020)



              

              

              

              

              

              val := mulmod(val, mload(0x4800), PRIME)



              

              res := addmod(res,

                            mulmod(val,

                                   add( mload(0x1040),

                                       mulmod( mload(0x1060),

                                              mload(0x4f00),

                      PRIME)),

                      PRIME),

                      PRIME)

              }



              {

              

              let val :=  mload(0x3020)



              

              

              

              

              

              val := mulmod(val, mload(0x4820), PRIME)



              

              res := addmod(res,

                            mulmod(val,

                                   add( mload(0x1080),

                                       mulmod( mload(0x10a0),

                                              mload(0x4f00),

                      PRIME)),

                      PRIME),

                      PRIME)

              }



              {

              

              let val := addmod(

                mulmod(

                   mload(0x41e0),

                  addmod(

                     mload(0x2f80),

                    sub(PRIME,  mload(0x20)),

                    PRIME),

                  PRIME),

                sub(

                  PRIME,

                  mulmod(

                     mload(0x3000),

                    addmod(

                       mload(0x2ee0),

                      sub(PRIME,  mload(0x0)),

                      PRIME),

                    PRIME)),

                PRIME)



              

              

              val := mulmod(val, mload(0x4ce0), PRIME)

              

              

              val := mulmod(val, mload(0x46e0), PRIME)



              

              res := addmod(res,

                            mulmod(val,

                                   add( mload(0x10c0),

                                       mulmod( mload(0x10e0),

                                              mload(0x4ee0),

                      PRIME)),

                      PRIME),

                      PRIME)

              }



              {

              

              let val := addmod(

                mulmod( mload(0x3000),  mload(0x3000), PRIME),

                sub(

                  PRIME,

                  mulmod(

                     mload(0x41e0),

                    addmod(

                      addmod(

                         mload(0x2ee0),

                         mload(0x0),

                        PRIME),

                       mload(0x2f00),

                      PRIME),

                    PRIME)),

                PRIME)



              

              

              val := mulmod(val, mload(0x4ce0), PRIME)

              

              

              val := mulmod(val, mload(0x46e0), PRIME)



              

              res := addmod(res,

                            mulmod(val,

                                   add( mload(0x1100),

                                       mulmod( mload(0x1120),

                                              mload(0x4ee0),

                      PRIME)),

                      PRIME),

                      PRIME)

              }



              {

              

              let val := addmod(

                mulmod(

                   mload(0x41e0),

                  addmod( mload(0x2f80),  mload(0x2fa0), PRIME),

                  PRIME),

                sub(

                  PRIME,

                  mulmod(

                     mload(0x3000),

                    addmod( mload(0x2ee0), sub(PRIME,  mload(0x2f00)), PRIME),

                    PRIME)),

                PRIME)



              

              

              val := mulmod(val, mload(0x4ce0), PRIME)

              

              

              val := mulmod(val, mload(0x46e0), PRIME)



              

              res := addmod(res,

                            mulmod(val,

                                   add( mload(0x1140),

                                       mulmod( mload(0x1160),

                                              mload(0x4ee0),

                      PRIME)),

                      PRIME),

                      PRIME)

              }



              {

              

              let val := mulmod(

                 mload(0x4200),

                addmod( mload(0x2f00), sub(PRIME,  mload(0x2ee0)), PRIME),

                PRIME)



              

              

              val := mulmod(val, mload(0x4ce0), PRIME)

              

              

              val := mulmod(val, mload(0x46e0), PRIME)



              

              res := addmod(res,

                            mulmod(val,

                                   add( mload(0x1180),

                                       mulmod( mload(0x11a0),

                                              mload(0x4ee0),

                      PRIME)),

                      PRIME),

                      PRIME)

              }



              {

              

              let val := mulmod(

                 mload(0x4200),

                addmod( mload(0x2fa0), sub(PRIME,  mload(0x2f80)), PRIME),

                PRIME)



              

              

              val := mulmod(val, mload(0x4ce0), PRIME)

              

              

              val := mulmod(val, mload(0x46e0), PRIME)



              

              res := addmod(res,

                            mulmod(val,

                                   add( mload(0x11c0),

                                       mulmod( mload(0x11e0),

                                              mload(0x4ee0),

                      PRIME)),

                      PRIME),

                      PRIME)

              }



              {

              

              let val := addmod(

                 mload(0x2f40),

                sub(PRIME,  mload(0x2f20)),

                PRIME)



              

              

              val := mulmod(val, mload(0x4d00), PRIME)

              

              

              val := mulmod(val, mload(0x4840), PRIME)



              

              res := addmod(res,

                            mulmod(val,

                                   add( mload(0x1200),

                                       mulmod( mload(0x1220),

                                              mload(0x4f20),

                      PRIME)),

                      PRIME),

                      PRIME)

              }



              {

              

              let val := addmod(

                 mload(0x2fe0),

                sub(PRIME,  mload(0x2fc0)),

                PRIME)



              

              

              val := mulmod(val, mload(0x4d00), PRIME)

              

              

              val := mulmod(val, mload(0x4840), PRIME)



              

              res := addmod(res,

                            mulmod(val,

                                   add( mload(0x1240),

                                       mulmod( mload(0x1260),

                                              mload(0x4f20),

                      PRIME)),

                      PRIME),

                      PRIME)

              }



              {

              

              let val := addmod(

                 mload(0x2ee0),

                sub(PRIME,  mload(0x240)),

                PRIME)



              

              

              

              

              

              val := mulmod(val, mload(0x4860), PRIME)



              

              res := addmod(res,

                            mulmod(val,

                                   add( mload(0x1280),

                                       mulmod( mload(0x12a0),

                                              mload(0x4f40),

                      PRIME)),

                      PRIME),

                      PRIME)

              }



              {

              

              let val := addmod(

                 mload(0x2f80),

                sub(PRIME,  mload(0x260)),

                PRIME)



              

              

              

              

              

              val := mulmod(val, mload(0x4860), PRIME)



              

              res := addmod(res,

                            mulmod(val,

                                   add( mload(0x12c0),

                                       mulmod( mload(0x12e0),

                                              mload(0x4f40),

                      PRIME)),

                      PRIME),

                      PRIME)

              }



              {

              

              let val := mulmod(

                 mload(0x4220),

                addmod(

                   mload(0x4220),

                  sub(PRIME, 1),

                  PRIME),

                PRIME)



              

              

              val := mulmod(val, mload(0x4ce0), PRIME)

              

              

              val := mulmod(val, mload(0x46e0), PRIME)



              

              res := addmod(res,

                            mulmod(val,

                                   add( mload(0x1300),

                                       mulmod( mload(0x1320),

                                              mload(0x4ee0),

                      PRIME)),

                      PRIME),

                      PRIME)

              }



              {

              

              let val :=  mload(0x31c0)



              

              

              

              

              

              val := mulmod(val, mload(0x4800), PRIME)



              

              res := addmod(res,

                            mulmod(val,

                                   add( mload(0x1340),

                                       mulmod( mload(0x1360),

                                              mload(0x4f00),

                      PRIME)),

                      PRIME),

                      PRIME)

              }



              {

              

              let val :=  mload(0x31c0)



              

              

              

              

              

              val := mulmod(val, mload(0x4820), PRIME)



              

              res := addmod(res,

                            mulmod(val,

                                   add( mload(0x1380),

                                       mulmod( mload(0x13a0),

                                              mload(0x4f00),

                      PRIME)),

                      PRIME),

                      PRIME)

              }



              {

              

              let val := addmod(

                mulmod(

                   mload(0x4220),

                  addmod(

                     mload(0x3120),

                    sub(PRIME,  mload(0x20)),

                    PRIME),

                  PRIME),

                sub(

                  PRIME,

                  mulmod(

                     mload(0x31a0),

                    addmod(

                       mload(0x3080),

                      sub(PRIME,  mload(0x0)),

                      PRIME),

                    PRIME)),

                PRIME)



              

              

              val := mulmod(val, mload(0x4ce0), PRIME)

              

              

              val := mulmod(val, mload(0x46e0), PRIME)



              

              res := addmod(res,

                            mulmod(val,

                                   add( mload(0x13c0),

                                       mulmod( mload(0x13e0),

                                              mload(0x4ee0),

                      PRIME)),

                      PRIME),

                      PRIME)

              }



              {

              

              let val := addmod(

                mulmod( mload(0x31a0),  mload(0x31a0), PRIME),

                sub(

                  PRIME,

                  mulmod(

                     mload(0x4220),

                    addmod(

                      addmod(

                         mload(0x3080),

                         mload(0x0),

                        PRIME),

                       mload(0x30a0),

                      PRIME),

                    PRIME)),

                PRIME)



              

              

              val := mulmod(val, mload(0x4ce0), PRIME)

              

              

              val := mulmod(val, mload(0x46e0), PRIME)



              

              res := addmod(res,

                            mulmod(val,

                                   add( mload(0x1400),

                                       mulmod( mload(0x1420),

                                              mload(0x4ee0),

                      PRIME)),

                      PRIME),

                      PRIME)

              }



              {

              

              let val := addmod(

                mulmod(

                   mload(0x4220),

                  addmod( mload(0x3120),  mload(0x3140), PRIME),

                  PRIME),

                sub(

                  PRIME,

                  mulmod(

                     mload(0x31a0),

                    addmod( mload(0x3080), sub(PRIME,  mload(0x30a0)), PRIME),

                    PRIME)),

                PRIME)



              

              

              val := mulmod(val, mload(0x4ce0), PRIME)

              

              

              val := mulmod(val, mload(0x46e0), PRIME)



              

              res := addmod(res,

                            mulmod(val,

                                   add( mload(0x1440),

                                       mulmod( mload(0x1460),

                                              mload(0x4ee0),

                      PRIME)),

                      PRIME),

                      PRIME)

              }



              {

              

              let val := mulmod(

                 mload(0x4240),

                addmod( mload(0x30a0), sub(PRIME,  mload(0x3080)), PRIME),

                PRIME)



              

              

              val := mulmod(val, mload(0x4ce0), PRIME)

              

              

              val := mulmod(val, mload(0x46e0), PRIME)



              

              res := addmod(res,

                            mulmod(val,

                                   add( mload(0x1480),

                                       mulmod( mload(0x14a0),

                                              mload(0x4ee0),

                      PRIME)),

                      PRIME),

                      PRIME)

              }



              {

              

              let val := mulmod(

                 mload(0x4240),

                addmod( mload(0x3140), sub(PRIME,  mload(0x3120)), PRIME),

                PRIME)



              

              

              val := mulmod(val, mload(0x4ce0), PRIME)

              

              

              val := mulmod(val, mload(0x46e0), PRIME)



              

              res := addmod(res,

                            mulmod(val,

                                   add( mload(0x14c0),

                                       mulmod( mload(0x14e0),

                                              mload(0x4ee0),

                      PRIME)),

                      PRIME),

                      PRIME)

              }



              {

              

              let val := addmod(

                 mload(0x30e0),

                sub(PRIME,  mload(0x30c0)),

                PRIME)



              

              

              val := mulmod(val, mload(0x4d00), PRIME)

              

              

              val := mulmod(val, mload(0x4840), PRIME)



              

              res := addmod(res,

                            mulmod(val,

                                   add( mload(0x1500),

                                       mulmod( mload(0x1520),

                                              mload(0x4f20),

                      PRIME)),

                      PRIME),

                      PRIME)

              }



              {

              

              let val := addmod(

                 mload(0x3180),

                sub(PRIME,  mload(0x3160)),

                PRIME)



              

              

              val := mulmod(val, mload(0x4d00), PRIME)

              

              

              val := mulmod(val, mload(0x4840), PRIME)



              

              res := addmod(res,

                            mulmod(val,

                                   add( mload(0x1540),

                                       mulmod( mload(0x1560),

                                              mload(0x4f20),

                      PRIME)),

                      PRIME),

                      PRIME)

              }



              {

              

              let val := addmod(

                 mload(0x3080),

                sub(PRIME,  mload(0x240)),

                PRIME)



              

              

              

              

              

              val := mulmod(val, mload(0x4860), PRIME)



              

              res := addmod(res,

                            mulmod(val,

                                   add( mload(0x1580),

                                       mulmod( mload(0x15a0),

                                              mload(0x4f40),

                      PRIME)),

                      PRIME),

                      PRIME)

              }



              {

              

              let val := addmod(

                 mload(0x3120),

                sub(PRIME,  mload(0x260)),

                PRIME)



              

              

              

              

              

              val := mulmod(val, mload(0x4860), PRIME)



              

              res := addmod(res,

                            mulmod(val,

                                   add( mload(0x15c0),

                                       mulmod( mload(0x15e0),

                                              mload(0x4f40),

                      PRIME)),

                      PRIME),

                      PRIME)

              }



              {

              

              let val := mulmod(

                 mload(0x4260),

                addmod(

                   mload(0x4260),

                  sub(PRIME, 1),

                  PRIME),

                PRIME)



              

              

              val := mulmod(val, mload(0x4ce0), PRIME)

              

              

              val := mulmod(val, mload(0x46e0), PRIME)



              

              res := addmod(res,

                            mulmod(val,

                                   add( mload(0x1600),

                                       mulmod( mload(0x1620),

                                              mload(0x4ee0),

                      PRIME)),

                      PRIME),

                      PRIME)

              }



              {

              

              let val :=  mload(0x3360)



              

              

              

              

              

              val := mulmod(val, mload(0x4800), PRIME)



              

              res := addmod(res,

                            mulmod(val,

                                   add( mload(0x1640),

                                       mulmod( mload(0x1660),

                                              mload(0x4f00),

                      PRIME)),

                      PRIME),

                      PRIME)

              }



              {

              

              let val :=  mload(0x3360)



              

              

              

              

              

              val := mulmod(val, mload(0x4820), PRIME)



              

              res := addmod(res,

                            mulmod(val,

                                   add( mload(0x1680),

                                       mulmod( mload(0x16a0),

                                              mload(0x4f00),

                      PRIME)),

                      PRIME),

                      PRIME)

              }



              {

              

              let val := addmod(

                mulmod(

                   mload(0x4260),

                  addmod(

                     mload(0x32c0),

                    sub(PRIME,  mload(0x20)),

                    PRIME),

                  PRIME),

                sub(

                  PRIME,

                  mulmod(

                     mload(0x3340),

                    addmod(

                       mload(0x3220),

                      sub(PRIME,  mload(0x0)),

                      PRIME),

                    PRIME)),

                PRIME)



              

              

              val := mulmod(val, mload(0x4ce0), PRIME)

              

              

              val := mulmod(val, mload(0x46e0), PRIME)



              

              res := addmod(res,

                            mulmod(val,

                                   add( mload(0x16c0),

                                       mulmod( mload(0x16e0),

                                              mload(0x4ee0),

                      PRIME)),

                      PRIME),

                      PRIME)

              }



              {

              

              let val := addmod(

                mulmod( mload(0x3340),  mload(0x3340), PRIME),

                sub(

                  PRIME,

                  mulmod(

                     mload(0x4260),

                    addmod(

                      addmod(

                         mload(0x3220),

                         mload(0x0),

                        PRIME),

                       mload(0x3240),

                      PRIME),

                    PRIME)),

                PRIME)



              

              

              val := mulmod(val, mload(0x4ce0), PRIME)

              

              

              val := mulmod(val, mload(0x46e0), PRIME)



              

              res := addmod(res,

                            mulmod(val,

                                   add( mload(0x1700),

                                       mulmod( mload(0x1720),

                                              mload(0x4ee0),

                      PRIME)),

                      PRIME),

                      PRIME)

              }



              {

              

              let val := addmod(

                mulmod(

                   mload(0x4260),

                  addmod( mload(0x32c0),  mload(0x32e0), PRIME),

                  PRIME),

                sub(

                  PRIME,

                  mulmod(

                     mload(0x3340),

                    addmod( mload(0x3220), sub(PRIME,  mload(0x3240)), PRIME),

                    PRIME)),

                PRIME)



              

              

              val := mulmod(val, mload(0x4ce0), PRIME)

              

              

              val := mulmod(val, mload(0x46e0), PRIME)



              

              res := addmod(res,

                            mulmod(val,

                                   add( mload(0x1740),

                                       mulmod( mload(0x1760),

                                              mload(0x4ee0),

                      PRIME)),

                      PRIME),

                      PRIME)

              }



              {

              

              let val := mulmod(

                 mload(0x4280),

                addmod( mload(0x3240), sub(PRIME,  mload(0x3220)), PRIME),

                PRIME)



              

              

              val := mulmod(val, mload(0x4ce0), PRIME)

              

              

              val := mulmod(val, mload(0x46e0), PRIME)



              

              res := addmod(res,

                            mulmod(val,

                                   add( mload(0x1780),

                                       mulmod( mload(0x17a0),

                                              mload(0x4ee0),

                      PRIME)),

                      PRIME),

                      PRIME)

              }



              {

              

              let val := mulmod(

                 mload(0x4280),

                addmod( mload(0x32e0), sub(PRIME,  mload(0x32c0)), PRIME),

                PRIME)



              

              

              val := mulmod(val, mload(0x4ce0), PRIME)

              

              

              val := mulmod(val, mload(0x46e0), PRIME)



              

              res := addmod(res,

                            mulmod(val,

                                   add( mload(0x17c0),

                                       mulmod( mload(0x17e0),

                                              mload(0x4ee0),

                      PRIME)),

                      PRIME),

                      PRIME)

              }



              {

              

              let val := addmod(

                 mload(0x3280),

                sub(PRIME,  mload(0x3260)),

                PRIME)



              

              

              val := mulmod(val, mload(0x4d00), PRIME)

              

              

              val := mulmod(val, mload(0x4840), PRIME)



              

              res := addmod(res,

                            mulmod(val,

                                   add( mload(0x1800),

                                       mulmod( mload(0x1820),

                                              mload(0x4f20),

                      PRIME)),

                      PRIME),

                      PRIME)

              }



              {

              

              let val := addmod(

                 mload(0x3320),

                sub(PRIME,  mload(0x3300)),

                PRIME)



              

              

              val := mulmod(val, mload(0x4d00), PRIME)

              

              

              val := mulmod(val, mload(0x4840), PRIME)



              

              res := addmod(res,

                            mulmod(val,

                                   add( mload(0x1840),

                                       mulmod( mload(0x1860),

                                              mload(0x4f20),

                      PRIME)),

                      PRIME),

                      PRIME)

              }



              {

              

              let val := addmod(

                 mload(0x3220),

                sub(PRIME,  mload(0x240)),

                PRIME)



              

              

              

              

              

              val := mulmod(val, mload(0x4860), PRIME)



              

              res := addmod(res,

                            mulmod(val,

                                   add( mload(0x1880),

                                       mulmod( mload(0x18a0),

                                              mload(0x4f40),

                      PRIME)),

                      PRIME),

                      PRIME)

              }



              {

              

              let val := addmod(

                 mload(0x32c0),

                sub(PRIME,  mload(0x260)),

                PRIME)



              

              

              

              

              

              val := mulmod(val, mload(0x4860), PRIME)



              

              res := addmod(res,

                            mulmod(val,

                                   add( mload(0x18c0),

                                       mulmod( mload(0x18e0),

                                              mload(0x4f40),

                      PRIME)),

                      PRIME),

                      PRIME)

              }



              {

              

              let val := addmod( mload(0x34a0), sub(PRIME,  mload(0x2e80)), PRIME)



              

              

              

              

              

              val := mulmod(val, mload(0x4860), PRIME)



              

              res := addmod(res,

                            mulmod(val,

                                   add( mload(0x1900),

                                       mulmod( mload(0x1920),

                                              mload(0x4f40),

                      PRIME)),

                      PRIME),

                      PRIME)

              }



              {

              

              let val := addmod(

                 mload(0x36c0),

                sub(PRIME,  mload(0x3020)),

                PRIME)



              

              

              

              

              

              val := mulmod(val, mload(0x4860), PRIME)



              

              res := addmod(res,

                            mulmod(val,

                                   add( mload(0x1940),

                                       mulmod( mload(0x1960),

                                              mload(0x4f40),

                      PRIME)),

                      PRIME),

                      PRIME)

              }



              {

              

              let val := addmod(

                 mload(0x3780),

                sub(PRIME,  mload(0x31c0)),

                PRIME)



              

              

              

              

              

              val := mulmod(val, mload(0x4860), PRIME)



              

              res := addmod(res,

                            mulmod(val,

                                   add( mload(0x1980),

                                       mulmod( mload(0x19a0),

                                              mload(0x4f40),

                      PRIME)),

                      PRIME),

                      PRIME)

              }



              {

              

              let val := addmod(

                 mload(0x37e0),

                sub(PRIME,  mload(0x3360)),

                PRIME)



              

              

              

              

              

              val := mulmod(val, mload(0x4860), PRIME)



              

              res := addmod(res,

                            mulmod(val,

                                   add( mload(0x19c0),

                                       mulmod( mload(0x19e0),

                                              mload(0x4f40),

                      PRIME)),

                      PRIME),

                      PRIME)

              }



              {

              

              let val := addmod(

                 mload(0x36a0),

                sub(PRIME, addmod( mload(0x35a0), 1, PRIME)),

                PRIME)



              

              

              val := mulmod(val, mload(0x4d20), PRIME)

              

              

              val := mulmod(val, mload(0x4880), PRIME)



              

              res := addmod(res,

                            mulmod(val,

                                   add( mload(0x1a00),

                                       mulmod( mload(0x1a20),

                                              mload(0x4f60),

                      PRIME)),

                      PRIME),

                      PRIME)

              }



              {

              

              let val := addmod(

                 mload(0x3480),

                sub(PRIME,  mload(0x280)),

                PRIME)



              

              

              

              

              

              val := mulmod(val, mload(0x4740), PRIME)



              

              res := addmod(res,

                            mulmod(val,

                                   add( mload(0x1a40),

                                       mulmod( mload(0x1a60),

                                              mload(0x4e40),

                      PRIME)),

                      PRIME),

                      PRIME)

              }



              {

              

              let val := addmod(

                 mload(0x3600),

                sub(PRIME,  mload(0x2ec0)),

                PRIME)



              

              

              

              

              

              val := mulmod(val, mload(0x4860), PRIME)



              

              res := addmod(res,

                            mulmod(val,

                                   add( mload(0x1a80),

                                       mulmod( mload(0x1aa0),

                                              mload(0x4f40),

                      PRIME)),

                      PRIME),

                      PRIME)

              }



              {

              

              let val := addmod(

                 mload(0x3740),

                sub(PRIME,  mload(0x3060)),

                PRIME)



              

              

              

              

              

              val := mulmod(val, mload(0x4860), PRIME)



              

              res := addmod(res,

                            mulmod(val,

                                   add( mload(0x1ac0),

                                       mulmod( mload(0x1ae0),

                                              mload(0x4f40),

                      PRIME)),

                      PRIME),

                      PRIME)

              }



              {

              

              let val := addmod(

                 mload(0x37c0),

                sub(PRIME,  mload(0x3200)),

                PRIME)



              

              

              

              

              

              val := mulmod(val, mload(0x4860), PRIME)



              

              res := addmod(res,

                            mulmod(val,

                                   add( mload(0x1b00),

                                       mulmod( mload(0x1b20),

                                              mload(0x4f40),

                      PRIME)),

                      PRIME),

                      PRIME)

              }



              {

              

              let val := addmod(

                 mload(0x3840),

                sub(PRIME,  mload(0x33a0)),

                PRIME)



              

              

              

              

              

              val := mulmod(val, mload(0x4860), PRIME)



              

              res := addmod(res,

                            mulmod(val,

                                   add( mload(0x1b40),

                                       mulmod( mload(0x1b60),

                                              mload(0x4f40),

                      PRIME)),

                      PRIME),

                      PRIME)

              }



              {

              

              let val := addmod(

                 mload(0x35e0),

                sub(PRIME, addmod( mload(0x3480), 1, PRIME)),

                PRIME)



              

              

              

              

              

              val := mulmod(val, mload(0x4880), PRIME)



              

              res := addmod(res,

                            mulmod(val,

                                   add( mload(0x1b80),

                                       mulmod( mload(0x1ba0),

                                              mload(0x4f80),

                      PRIME)),

                      PRIME),

                      PRIME)

              }



              {

              

              let val := addmod(

                 mload(0x35c0),

                sub(PRIME,  mload(0x2dc0)),

                PRIME)



              

              

              

              

              

              val := mulmod(val, mload(0x4860), PRIME)



              

              res := addmod(res,

                            mulmod(val,

                                   add( mload(0x1bc0),

                                       mulmod( mload(0x1be0),

                                              mload(0x4f40),

                      PRIME)),

                      PRIME),

                      PRIME)

              }



              {

              

              let val := addmod(

                 mload(0x3720),

                sub(PRIME,  mload(0x2f60)),

                PRIME)



              

              

              

              

              

              val := mulmod(val, mload(0x4860), PRIME)



              

              res := addmod(res,

                            mulmod(val,

                                   add( mload(0x1c00),

                                       mulmod( mload(0x1c20),

                                              mload(0x4f40),

                      PRIME)),

                      PRIME),

                      PRIME)

              }



              {

              

              let val := addmod(

                 mload(0x37a0),

                sub(PRIME,  mload(0x3100)),

                PRIME)



              

              

              

              

              

              val := mulmod(val, mload(0x4860), PRIME)



              

              res := addmod(res,

                            mulmod(val,

                                   add( mload(0x1c40),

                                       mulmod( mload(0x1c60),

                                              mload(0x4f40),

                      PRIME)),

                      PRIME),

                      PRIME)

              }



              {

              

              let val := addmod(

                 mload(0x3820),

                sub(PRIME,  mload(0x32a0)),

                PRIME)



              

              

              

              

              

              val := mulmod(val, mload(0x4860), PRIME)



              

              res := addmod(res,

                            mulmod(val,

                                   add( mload(0x1c80),

                                       mulmod( mload(0x1ca0),

                                              mload(0x4f40),

                      PRIME)),

                      PRIME),

                      PRIME)

              }



              {

              

              let val := addmod(

                 mload(0x35a0),

                sub(PRIME, addmod( mload(0x35e0), 1, PRIME)),

                PRIME)



              

              

              

              

              

              val := mulmod(val, mload(0x4880), PRIME)



              

              res := addmod(res,

                            mulmod(val,

                                   add( mload(0x1cc0),

                                       mulmod( mload(0x1ce0),

                                              mload(0x4f80),

                      PRIME)),

                      PRIME),

                      PRIME)

              }



              {

              

              let val := addmod(

                 mload(0x4380),

                sub(PRIME,  mload(0x3680)),

                PRIME)



              

              

              

              

              

              val := mulmod(val, mload(0x4880), PRIME)



              

              res := addmod(res,

                            mulmod(val,

                                   add( mload(0x1d00),

                                       mulmod( mload(0x1d20),

                                              mload(0x4f80),

                      PRIME)),

                      PRIME),

                      PRIME)

              }



              {

              

              let val := addmod(

                 mload(0x3760),

                sub(PRIME, addmod( mload(0x3660), 1, PRIME)),

                PRIME)



              

              

              val := mulmod(val, mload(0x4d20), PRIME)

              

              

              val := mulmod(val, mload(0x4880), PRIME)



              

              res := addmod(res,

                            mulmod(val,

                                   add( mload(0x1d40),

                                       mulmod( mload(0x1d60),

                                              mload(0x4f60),

                      PRIME)),

                      PRIME),

                      PRIME)

              }



              {

              

              let val := addmod(

                 mload(0x3660),

                sub(PRIME,  mload(0x2a0)),

                PRIME)



              

              

              

              

              

              val := mulmod(val, mload(0x4740), PRIME)



              

              res := addmod(res,

                            mulmod(val,

                                   add( mload(0x1d80),

                                       mulmod( mload(0x1da0),

                                              mload(0x4e40),

                      PRIME)),

                      PRIME),

                      PRIME)

              }



              {

              

              let val := addmod(

                addmod(

                  addmod(

                    addmod(

                       mload(0x43a0),

                       mload(0x43a0),

                      PRIME),

                     mload(0x43a0),

                    PRIME),

                   mload(0x2c0),

                  PRIME),

                sub(

                  PRIME,

                  mulmod(

                    addmod( mload(0x3b00),  mload(0x3b00), PRIME),

                     mload(0x3960),

                    PRIME)),

                PRIME)



              

              

              val := mulmod(val, mload(0x4d40), PRIME)

              

              

              val := mulmod(val, mload(0x4720), PRIME)



              

              res := addmod(res,

                            mulmod(val,

                                   add( mload(0x1dc0),

                                       mulmod( mload(0x1de0),

                                              mload(0x4fa0),

                      PRIME)),

                      PRIME),

                      PRIME)

              }



              {

              

              let val := addmod(

                mulmod( mload(0x3960),  mload(0x3960), PRIME),

                sub(

                  PRIME,

                  addmod(

                    addmod( mload(0x3a00),  mload(0x3a00), PRIME),

                     mload(0x3ba0),

                    PRIME)),

                PRIME)



              

              

              val := mulmod(val, mload(0x4d40), PRIME)

              

              

              val := mulmod(val, mload(0x4720), PRIME)



              

              res := addmod(res,

                            mulmod(val,

                                   add( mload(0x1e00),

                                       mulmod( mload(0x1e20),

                                              mload(0x4fa0),

                      PRIME)),

                      PRIME),

                      PRIME)

              }



              {

              

              let val := addmod(

                addmod( mload(0x3b00),  mload(0x3c20), PRIME),

                sub(

                  PRIME,

                  mulmod(

                     mload(0x3960),

                    addmod(

                       mload(0x3a00),

                      sub(PRIME,  mload(0x3ba0)),

                      PRIME),

                    PRIME)),

                PRIME)



              

              

              val := mulmod(val, mload(0x4d40), PRIME)

              

              

              val := mulmod(val, mload(0x4720), PRIME)



              

              res := addmod(res,

                            mulmod(val,

                                   add( mload(0x1e40),

                                       mulmod( mload(0x1e60),

                                              mload(0x4fa0),

                      PRIME)),

                      PRIME),

                      PRIME)

              }



              {

              

              let val := mulmod(

                 mload(0x43c0),

                addmod(

                   mload(0x43c0),

                  sub(PRIME, 1),

                  PRIME),

                PRIME)



              

              

              val := mulmod(val, mload(0x4d60), PRIME)

              

              

              val := mulmod(val, mload(0x48a0), PRIME)



              

              res := addmod(res,

                            mulmod(val,

                                   add( mload(0x1e80),

                                       mulmod( mload(0x1ea0),

                                              mload(0x4fc0),

                      PRIME)),

                      PRIME),

                      PRIME)

              }



              {

              

              let val :=  mload(0x3c40)



              

              

              

              

              

              val := mulmod(val, mload(0x48c0), PRIME)



              

              res := addmod(res,

                            mulmod(val,

                                   add( mload(0x1ec0),

                                       mulmod( mload(0x1ee0),

                                              mload(0x4fe0),

                      PRIME)),

                      PRIME),

                      PRIME)

              }



              {

              

              let val :=  mload(0x3c40)



              

              

              

              

              

              val := mulmod(val, mload(0x48e0), PRIME)



              

              res := addmod(res,

                            mulmod(val,

                                   add( mload(0x1f00),

                                       mulmod( mload(0x1f20),

                                              mload(0x4fe0),

                      PRIME)),

                      PRIME),

                      PRIME)

              }



              {

              

              let val := addmod(

                mulmod(

                   mload(0x43c0),

                  addmod(

                     mload(0x3bc0),

                    sub(PRIME,  mload(0x60)),

                    PRIME),

                  PRIME),

                sub(

                  PRIME,

                  mulmod(

                     mload(0x3b20),

                    addmod(

                       mload(0x3a20),

                      sub(PRIME,  mload(0x40)),

                      PRIME),

                    PRIME)),

                PRIME)



              

              

              val := mulmod(val, mload(0x4d60), PRIME)

              

              

              val := mulmod(val, mload(0x48a0), PRIME)



              

              res := addmod(res,

                            mulmod(val,

                                   add( mload(0x1f40),

                                       mulmod( mload(0x1f60),

                                              mload(0x4fc0),

                      PRIME)),

                      PRIME),

                      PRIME)

              }



              {

              

              let val := addmod(

                mulmod( mload(0x3b20),  mload(0x3b20), PRIME),

                sub(

                  PRIME,

                  mulmod(

                     mload(0x43c0),

                    addmod(

                      addmod(

                         mload(0x3a20),

                         mload(0x40),

                        PRIME),

                       mload(0x3c60),

                      PRIME),

                    PRIME)),

                PRIME)



              

              

              val := mulmod(val, mload(0x4d60), PRIME)

              

              

              val := mulmod(val, mload(0x48a0), PRIME)



              

              res := addmod(res,

                            mulmod(val,

                                   add( mload(0x1f80),

                                       mulmod( mload(0x1fa0),

                                              mload(0x4fc0),

                      PRIME)),

                      PRIME),

                      PRIME)

              }



              {

              

              let val := addmod(

                mulmod(

                   mload(0x43c0),

                  addmod( mload(0x3bc0),  mload(0x3c80), PRIME),

                  PRIME),

                sub(

                  PRIME,

                  mulmod(

                     mload(0x3b20),

                    addmod(

                       mload(0x3a20),

                      sub(PRIME,  mload(0x3c60)),

                      PRIME),

                    PRIME)),

                PRIME)



              

              

              val := mulmod(val, mload(0x4d60), PRIME)

              

              

              val := mulmod(val, mload(0x48a0), PRIME)



              

              res := addmod(res,

                            mulmod(val,

                                   add( mload(0x1fc0),

                                       mulmod( mload(0x1fe0),

                                              mload(0x4fc0),

                      PRIME)),

                      PRIME),

                      PRIME)

              }



              {

              

              let val := addmod(

                mulmod(

                   mload(0x3e80),

                  addmod(

                     mload(0x3a20),

                    sub(PRIME,  mload(0x40)),

                    PRIME),

                  PRIME),

                sub(PRIME, 1),

                PRIME)



              

              

              val := mulmod(val, mload(0x4d60), PRIME)

              

              

              val := mulmod(val, mload(0x48a0), PRIME)



              

              res := addmod(res,

                            mulmod(val,

                                   add( mload(0x2000),

                                       mulmod( mload(0x2020),

                                              mload(0x4fc0),

                      PRIME)),

                      PRIME),

                      PRIME)

              }



              {

              

              let val := mulmod(

                 mload(0x43e0),

                addmod(

                   mload(0x3c60),

                  sub(PRIME,  mload(0x3a20)),

                  PRIME),

                PRIME)



              

              

              val := mulmod(val, mload(0x4d60), PRIME)

              

              

              val := mulmod(val, mload(0x48a0), PRIME)



              

              res := addmod(res,

                            mulmod(val,

                                   add( mload(0x2040),

                                       mulmod( mload(0x2060),

                                              mload(0x4fc0),

                      PRIME)),

                      PRIME),

                      PRIME)

              }



              {

              

              let val := mulmod(

                 mload(0x43e0),

                addmod(

                   mload(0x3c80),

                  sub(PRIME,  mload(0x3bc0)),

                  PRIME),

                PRIME)



              

              

              val := mulmod(val, mload(0x4d60), PRIME)

              

              

              val := mulmod(val, mload(0x48a0), PRIME)



              

              res := addmod(res,

                            mulmod(val,

                                   add( mload(0x2080),

                                       mulmod( mload(0x20a0),

                                              mload(0x4fc0),

                      PRIME)),

                      PRIME),

                      PRIME)

              }



              {

              

              let val := mulmod(

                 mload(0x4400),

                addmod(

                   mload(0x4400),

                  sub(PRIME, 1),

                  PRIME),

                PRIME)



              

              

              val := mulmod(val, mload(0x4d40), PRIME)

              

              

              val := mulmod(val, mload(0x4720), PRIME)



              

              res := addmod(res,

                            mulmod(val,

                                   add( mload(0x20c0),

                                       mulmod( mload(0x20e0),

                                              mload(0x4fa0),

                      PRIME)),

                      PRIME),

                      PRIME)

              }



              {

              

              let val :=  mload(0x39a0)



              

              

              

              

              

              val := mulmod(val, mload(0x4900), PRIME)



              

              res := addmod(res,

                            mulmod(val,

                                   add( mload(0x2100),

                                       mulmod( mload(0x2120),

                                              mload(0x5000),

                      PRIME)),

                      PRIME),

                      PRIME)

              }



              {

              

              let val :=  mload(0x39a0)



              

              

              

              

              

              val := mulmod(val, mload(0x4920), PRIME)



              

              res := addmod(res,

                            mulmod(val,

                                   add( mload(0x2140),

                                       mulmod( mload(0x2160),

                                              mload(0x5000),

                      PRIME)),

                      PRIME),

                      PRIME)

              }



              {

              

              let val := addmod(

                mulmod(

                   mload(0x4400),

                  addmod(

                     mload(0x39e0),

                    sub(PRIME,  mload(0x3b00)),

                    PRIME),

                  PRIME),

                sub(

                  PRIME,

                  mulmod(

                     mload(0x3ae0),

                    addmod( mload(0x3a60), sub(PRIME,  mload(0x3a00)), PRIME),

                    PRIME)),

                PRIME)



              

              

              val := mulmod(val, mload(0x4d40), PRIME)

              

              

              val := mulmod(val, mload(0x4720), PRIME)



              

              res := addmod(res,

                            mulmod(val,

                                   add( mload(0x2180),

                                       mulmod( mload(0x21a0),

                                              mload(0x4fa0),

                      PRIME)),

                      PRIME),

                      PRIME)

              }



              {

              

              let val := addmod(

                mulmod( mload(0x3ae0),  mload(0x3ae0), PRIME),

                sub(

                  PRIME,

                  mulmod(

                     mload(0x4400),

                    addmod(

                      addmod( mload(0x3a60),  mload(0x3a00), PRIME),

                       mload(0x3c00),

                      PRIME),

                    PRIME)),

                PRIME)



              

              

              val := mulmod(val, mload(0x4d40), PRIME)

              

              

              val := mulmod(val, mload(0x4720), PRIME)



              

              res := addmod(res,

                            mulmod(val,

                                   add( mload(0x21c0),

                                       mulmod( mload(0x21e0),

                                              mload(0x4fa0),

                      PRIME)),

                      PRIME),

                      PRIME)

              }



              {

              

              let val := addmod(

                mulmod(

                   mload(0x4400),

                  addmod( mload(0x39e0),  mload(0x3b80), PRIME),

                  PRIME),

                sub(

                  PRIME,

                  mulmod(

                     mload(0x3ae0),

                    addmod(

                       mload(0x3a60),

                      sub(PRIME,  mload(0x3c00)),

                      PRIME),

                    PRIME)),

                PRIME)



              

              

              val := mulmod(val, mload(0x4d40), PRIME)

              

              

              val := mulmod(val, mload(0x4720), PRIME)



              

              res := addmod(res,

                            mulmod(val,

                                   add( mload(0x2200),

                                       mulmod( mload(0x2220),

                                              mload(0x4fa0),

                      PRIME)),

                      PRIME),

                      PRIME)

              }



              {

              

              let val := addmod(

                mulmod(

                   mload(0x3aa0),

                  addmod( mload(0x3a60), sub(PRIME,  mload(0x3a00)), PRIME),

                  PRIME),

                sub(PRIME, 1),

                PRIME)



              

              

              val := mulmod(val, mload(0x4d40), PRIME)

              

              

              val := mulmod(val, mload(0x4720), PRIME)



              

              res := addmod(res,

                            mulmod(val,

                                   add( mload(0x2240),

                                       mulmod( mload(0x2260),

                                              mload(0x4fa0),

                      PRIME)),

                      PRIME),

                      PRIME)

              }



              {

              

              let val := mulmod(

                 mload(0x4420),

                addmod(

                   mload(0x3c00),

                  sub(PRIME,  mload(0x3a60)),

                  PRIME),

                PRIME)



              

              

              val := mulmod(val, mload(0x4d40), PRIME)

              

              

              val := mulmod(val, mload(0x4720), PRIME)



              

              res := addmod(res,

                            mulmod(val,

                                   add( mload(0x2280),

                                       mulmod( mload(0x22a0),

                                              mload(0x4fa0),

                      PRIME)),

                      PRIME),

                      PRIME)

              }



              {

              

              let val := mulmod(

                 mload(0x4420),

                addmod(

                   mload(0x3b80),

                  sub(PRIME,  mload(0x39e0)),

                  PRIME),

                PRIME)



              

              

              val := mulmod(val, mload(0x4d40), PRIME)

              

              

              val := mulmod(val, mload(0x4720), PRIME)



              

              res := addmod(res,

                            mulmod(val,

                                   add( mload(0x22c0),

                                       mulmod( mload(0x22e0),

                                              mload(0x4fa0),

                      PRIME)),

                      PRIME),

                      PRIME)

              }



              {

              

              let val := addmod(

                 mload(0x3a20),

                sub(PRIME,  mload(0x2e0)),

                PRIME)



              

              

              

              

              

              val := mulmod(val, mload(0x4940), PRIME)



              

              res := addmod(res,

                            mulmod(val,

                                   add( mload(0x2300),

                                       mulmod( mload(0x2320),

                                              mload(0x4fe0),

                      PRIME)),

                      PRIME),

                      PRIME)

              }



              {

              

              let val := addmod(

                 mload(0x3bc0),

                 mload(0x300),

                PRIME)



              

              

              

              

              

              val := mulmod(val, mload(0x4940), PRIME)



              

              res := addmod(res,

                            mulmod(val,

                                   add( mload(0x2340),

                                       mulmod( mload(0x2360),

                                              mload(0x4fe0),

                      PRIME)),

                      PRIME),

                      PRIME)

              }



              {

              

              let val := addmod(

                 mload(0x3a60),

                sub(PRIME,  mload(0x2e0)),

                PRIME)



              

              

              

              

              

              val := mulmod(val, mload(0x4960), PRIME)



              

              res := addmod(res,

                            mulmod(val,

                                   add( mload(0x2380),

                                       mulmod( mload(0x23a0),

                                              mload(0x5000),

                      PRIME)),

                      PRIME),

                      PRIME)

              }



              {

              

              let val := addmod(

                 mload(0x39e0),

                sub(PRIME,  mload(0x300)),

                PRIME)



              

              

              

              

              

              val := mulmod(val, mload(0x4960), PRIME)



              

              res := addmod(res,

                            mulmod(val,

                                   add( mload(0x23c0),

                                       mulmod( mload(0x23e0),

                                              mload(0x5000),

                      PRIME)),

                      PRIME),

                      PRIME)

              }



              {

              

              let val := addmod(

                 mload(0x3e20),

                sub(

                  PRIME,

                  addmod(

                     mload(0x3ce0),

                    mulmod(

                       mload(0x3ea0),

                      addmod(

                         mload(0x3da0),

                        sub(PRIME,  mload(0x3d00)),

                        PRIME),

                      PRIME),

                    PRIME)),

                PRIME)



              

              

              

              

              

              val := mulmod(val, mload(0x4940), PRIME)



              

              res := addmod(res,

                            mulmod(val,

                                   add( mload(0x2400),

                                       mulmod( mload(0x2420),

                                              mload(0x5020),

                      PRIME)),

                      PRIME),

                      PRIME)

              }



              {

              

              let val := addmod(

                mulmod( mload(0x3ea0),  mload(0x3ea0), PRIME),

                sub(

                  PRIME,

                  addmod(

                    addmod( mload(0x3da0),  mload(0x3d00), PRIME),

                     mload(0x3d60),

                    PRIME)),

                PRIME)



              

              

              

              

              

              val := mulmod(val, mload(0x4940), PRIME)



              

              res := addmod(res,

                            mulmod(val,

                                   add( mload(0x2440),

                                       mulmod( mload(0x2460),

                                              mload(0x5020),

                      PRIME)),

                      PRIME),

                      PRIME)

              }



              {

              

              let val := addmod(

                addmod( mload(0x3e20),  mload(0x3d80), PRIME),

                sub(

                  PRIME,

                  mulmod(

                     mload(0x3ea0),

                    addmod(

                       mload(0x3da0),

                      sub(PRIME,  mload(0x3d60)),

                      PRIME),

                    PRIME)),

                PRIME)



              

              

              

              

              

              val := mulmod(val, mload(0x4940), PRIME)



              

              res := addmod(res,

                            mulmod(val,

                                   add( mload(0x2480),

                                       mulmod( mload(0x24a0),

                                              mload(0x5020),

                      PRIME)),

                      PRIME),

                      PRIME)

              }



              {

              

              let val := addmod(

                mulmod(

                   mload(0x3dc0),

                  addmod(

                     mload(0x3da0),

                    sub(PRIME,  mload(0x3d00)),

                    PRIME),

                  PRIME),

                sub(PRIME, 1),

                PRIME)



              

              

              

              

              

              val := mulmod(val, mload(0x4940), PRIME)



              

              res := addmod(res,

                            mulmod(val,

                                   add( mload(0x24c0),

                                       mulmod( mload(0x24e0),

                                              mload(0x5020),

                      PRIME)),

                      PRIME),

                      PRIME)

              }



              {

              

              let val := addmod(

                addmod(

                   mload(0x3e00),

                   mload(0x300),

                  PRIME),

                sub(

                  PRIME,

                  mulmod(

                     mload(0x3d40),

                    addmod(

                       mload(0x3e40),

                      sub(PRIME,  mload(0x2e0)),

                      PRIME),

                    PRIME)),

                PRIME)



              

              

              

              

              

              val := mulmod(val, mload(0x4940), PRIME)



              

              res := addmod(res,

                            mulmod(val,

                                   add( mload(0x2500),

                                       mulmod( mload(0x2520),

                                              mload(0x5020),

                      PRIME)),

                      PRIME),

                      PRIME)

              }



              {

              

              let val := addmod(

                mulmod( mload(0x3d40),  mload(0x3d40), PRIME),

                sub(

                  PRIME,

                  addmod(

                    addmod(

                       mload(0x3e40),

                       mload(0x2e0),

                      PRIME),

                     mload(0x39a0),

                    PRIME)),

                PRIME)



              

              

              

              

              

              val := mulmod(val, mload(0x4940), PRIME)



              

              res := addmod(res,

                            mulmod(val,

                                   add( mload(0x2540),

                                       mulmod( mload(0x2560),

                                              mload(0x5020),

                      PRIME)),

                      PRIME),

                      PRIME)

              }



              {

              

              let val := addmod(

                mulmod(

                   mload(0x3e60),

                  addmod(

                     mload(0x3e40),

                    sub(PRIME,  mload(0x2e0)),

                    PRIME),

                  PRIME),

                sub(PRIME, 1),

                PRIME)



              

              

              

              

              

              val := mulmod(val, mload(0x4940), PRIME)



              

              res := addmod(res,

                            mulmod(val,

                                   add( mload(0x2580),

                                       mulmod( mload(0x25a0),

                                              mload(0x5020),

                      PRIME)),

                      PRIME),

                      PRIME)

              }



              {

              

              let val := addmod(

                mulmod( mload(0x3c40),  mload(0x3cc0), PRIME),

                sub(PRIME, 1),

                PRIME)



              

              

              

              

              

              val := mulmod(val, mload(0x4940), PRIME)



              

              res := addmod(res,

                            mulmod(val,

                                   add( mload(0x25c0),

                                       mulmod( mload(0x25e0),

                                              mload(0x5020),

                      PRIME)),

                      PRIME),

                      PRIME)

              }



              {

              

              let val := addmod(

                mulmod( mload(0x39a0),  mload(0x3d20), PRIME),

                sub(PRIME, 1),

                PRIME)



              

              

              

              

              

              val := mulmod(val, mload(0x4960), PRIME)



              

              res := addmod(res,

                            mulmod(val,

                                   add( mload(0x2600),

                                       mulmod( mload(0x2620),

                                              mload(0x5040),

                      PRIME)),

                      PRIME),

                      PRIME)

              }



              {

              

              let val := addmod(

                 mload(0x3de0),

                sub(

                  PRIME,

                  mulmod( mload(0x3a00),  mload(0x3a00), PRIME)),

                PRIME)



              

              

              

              

              

              val := mulmod(val, mload(0x4940), PRIME)



              

              res := addmod(res,

                            mulmod(val,

                                   add( mload(0x2640),

                                       mulmod( mload(0x2660),

                                              mload(0x5020),

                      PRIME)),

                      PRIME),

                      PRIME)

              }



              {

              

              let val := addmod(

                mulmod( mload(0x3b00),  mload(0x3b00), PRIME),

                sub(

                  PRIME,

                  addmod(

                    addmod(

                      mulmod( mload(0x3a00),  mload(0x3de0), PRIME),

                      mulmod( mload(0x2c0),  mload(0x3a00), PRIME),

                      PRIME),

                     mload(0x320),

                    PRIME)),

                PRIME)



              

              

              

              

              

              val := mulmod(val, mload(0x4940), PRIME)



              

              res := addmod(res,

                            mulmod(val,

                                   add( mload(0x2680),

                                       mulmod( mload(0x26a0),

                                              mload(0x5020),

                      PRIME)),

                      PRIME),

                      PRIME)

              }



              {

              

              let val := addmod(

                 mload(0x3560),

                sub(PRIME,  mload(0x340)),

                PRIME)



              

              

              

              

              

              val := mulmod(val, mload(0x4740), PRIME)



              

              res := addmod(res,

                            mulmod(val,

                                   add( mload(0x26c0),

                                       mulmod( mload(0x26e0),

                                              mload(0x4e40),

                      PRIME)),

                      PRIME),

                      PRIME)

              }



              {

              

              let val := addmod(

                 mload(0x3860),

                sub(PRIME, addmod( mload(0x3560), 1, PRIME)),

                PRIME)



              

              

              

              

              

              val := mulmod(val, mload(0x4940), PRIME)



              

              res := addmod(res,

                            mulmod(val,

                                   add( mload(0x2700),

                                       mulmod( mload(0x2720),

                                              mload(0x4fe0),

                      PRIME)),

                      PRIME),

                      PRIME)

              }



              {

              

              let val := addmod(

                 mload(0x38a0),

                sub(PRIME, addmod( mload(0x3860), 1, PRIME)),

                PRIME)



              

              

              val := mulmod(val, mload(0x4d80), PRIME)

              

              

              val := mulmod(val, mload(0x4940), PRIME)



              

              res := addmod(res,

                            mulmod(val,

                                   add( mload(0x2740),

                                       mulmod( mload(0x2760),

                                              mload(0x5060),

                      PRIME)),

                      PRIME),

                      PRIME)

              }



              {

              

              let val := addmod(

                 mload(0x3880),

                sub(PRIME,  mload(0x3c40)),

                PRIME)



              

              

              

              

              

              val := mulmod(val, mload(0x4940), PRIME)



              

              res := addmod(res,

                            mulmod(val,

                                   add( mload(0x2780),

                                       mulmod( mload(0x27a0),

                                              mload(0x4fe0),

                      PRIME)),

                      PRIME),

                      PRIME)

              }



              {

              

              let val := addmod(

                 mload(0x3580),

                sub(PRIME,  mload(0x3a00)),

                PRIME)



              

              

              

              

              

              val := mulmod(val, mload(0x4940), PRIME)



              

              res := addmod(res,

                            mulmod(val,

                                   add( mload(0x27c0),

                                       mulmod( mload(0x27e0),

                                              mload(0x4fe0),

                      PRIME)),

                      PRIME),

                      PRIME)

              }



              {

              

              let val := addmod(

                 mload(0x36e0),

                sub(PRIME,  mload(0x360)),

                PRIME)



              

              

              

              

              

              val := mulmod(val, mload(0x4740), PRIME)



              

              res := addmod(res,

                            mulmod(val,

                                   add( mload(0x2800),

                                       mulmod( mload(0x2820),

                                              mload(0x4e40),

                      PRIME)),

                      PRIME),

                      PRIME)

              }



              {

              

              let val := addmod(

                 mload(0x36e0),

                sub(PRIME,  mload(0x380)),

                PRIME)



              

              

              

              

              

              val := mulmod(val, mload(0x4980), PRIME)



              

              res := addmod(res,

                            mulmod(val,

                                   add( mload(0x2840),

                                       mulmod( mload(0x2860),

                                              mload(0x4e40),

                      PRIME)),

                      PRIME),

                      PRIME)

              }



              {

              

              let val := addmod(

                 mload(0x3620),

                sub(PRIME, addmod( mload(0x36e0), 1, PRIME)),

                PRIME)



              

              

              

              

              

              val := mulmod(val, mload(0x4840), PRIME)



              

              res := addmod(res,

                            mulmod(val,

                                   add( mload(0x2880),

                                       mulmod( mload(0x28a0),

                                              mload(0x4f00),

                      PRIME)),

                      PRIME),

                      PRIME)

              }



              {

              

              let val := mulmod(

                addmod(

                   mload(0x3800),

                  sub(PRIME,  mload(0x36e0)),

                  PRIME),

                addmod(

                   mload(0x3800),

                  sub(PRIME, addmod( mload(0x36e0), 2, PRIME)),

                  PRIME),

                PRIME)



              

              

              val := mulmod(val, mload(0x4da0), PRIME)

              

              

              val := mulmod(val, mload(0x4840), PRIME)



              

              res := addmod(res,

                            mulmod(val,

                                   add( mload(0x28c0),

                                       mulmod( mload(0x28e0),

                                              mload(0x5080),

                      PRIME)),

                      PRIME),

                      PRIME)

              }



              {

              

              let val := mulmod(

                addmod(

                   mload(0x3800),

                  sub(PRIME,  mload(0x36e0)),

                  PRIME),

                addmod(

                   mload(0x3700),

                  sub(PRIME,  mload(0x33c0)),

                  PRIME),

                PRIME)



              

              

              val := mulmod(val, mload(0x4da0), PRIME)

              

              

              val := mulmod(val, mload(0x4840), PRIME)



              

              res := addmod(res,

                            mulmod(val,

                                   add( mload(0x2900),

                                       mulmod( mload(0x2920),

                                              mload(0x5080),

                      PRIME)),

                      PRIME),

                      PRIME)

              }



              {

              

              let val := mulmod(

                addmod(

                   mload(0x3800),

                  sub(PRIME,  mload(0x36e0)),

                  PRIME),

                addmod(

                   mload(0x3640),

                  sub(PRIME,  mload(0x3a40)),

                  PRIME),

                PRIME)



              

              

              val := mulmod(val, mload(0x4da0), PRIME)

              

              

              val := mulmod(val, mload(0x4840), PRIME)



              

              res := addmod(res,

                            mulmod(val,

                                   add( mload(0x2940),

                                       mulmod( mload(0x2960),

                                              mload(0x5080),

                      PRIME)),

                      PRIME),

                      PRIME)

              }



            mstore(0, res)

            return(0, 0x20)

            }

        }

    }

}

contract CpuPublicInputOffsets {

    

    uint256 internal constant OFFSET_LOG_N_STEPS = 0;

    uint256 internal constant OFFSET_RC_MIN = 1;

    uint256 internal constant OFFSET_RC_MAX = 2;

    uint256 internal constant OFFSET_LAYOUT_CODE = 3;

    uint256 internal constant OFFSET_PROGRAM_BEGIN_ADDR = 4;

    uint256 internal constant OFFSET_PROGRAM_STOP_PTR = 5;

    uint256 internal constant OFFSET_EXECUTION_BEGIN_ADDR = 6;

    uint256 internal constant OFFSET_EXECUTION_STOP_PTR = 7;

    uint256 internal constant OFFSET_OUTPUT_BEGIN_ADDR = 8;

    uint256 internal constant OFFSET_OUTPUT_STOP_PTR = 9;

    uint256 internal constant OFFSET_PEDERSEN_BEGIN_ADDR = 10;

    uint256 internal constant OFFSET_PEDERSEN_STOP_PTR = 11;

    uint256 internal constant OFFSET_RANGE_CHECK_BEGIN_ADDR = 12;

    uint256 internal constant OFFSET_RANGE_CHECK_STOP_PTR = 13;

    uint256 internal constant OFFSET_ECDSA_BEGIN_ADDR = 14;

    uint256 internal constant OFFSET_ECDSA_STOP_PTR = 15;

    uint256 internal constant OFFSET_CHECKPOINTS_BEGIN_PTR = 16;

    uint256 internal constant OFFSET_CHECKPOINTS_STOP_PTR = 17;

    uint256 internal constant OFFSET_N_PUBLIC_MEMORY_PAGES = 18;

    uint256 internal constant OFFSET_PUBLIC_MEMORY = 19;



    uint256 internal constant N_WORDS_PER_PUBLIC_MEMORY_ENTRY = 2;



    

    

    

    

    

    

    

    

    

    



    function getOffsetPageSize(uint256 pageId) internal pure returns (uint256) {

        return OFFSET_PUBLIC_MEMORY + 3 * pageId;

    }



    function getOffsetPageHash(uint256 pageId) internal pure returns (uint256) {

        return OFFSET_PUBLIC_MEMORY + 3 * pageId + 1;

    }



    function getOffsetPageAddr(uint256 pageId) internal pure returns (uint256) {

        require(pageId >= 1, "Address of page 0 is not part of the public input.");

        return OFFSET_PUBLIC_MEMORY + 3 * pageId - 1;

    }



    

    function getOffsetPaddingCell(uint256 nPages) internal pure returns (uint256) {

        return OFFSET_PUBLIC_MEMORY + 3 * nPages - 1;

    }



    function getOffsetPageProd(uint256 pageId, uint256 nPages) internal pure returns (uint256) {

        return OFFSET_PUBLIC_MEMORY + 3 * nPages + 1 + pageId;

    }



    function getPublicInputLength(uint256 nPages) internal pure returns (uint256) {

        return OFFSET_PUBLIC_MEMORY + 4 * nPages + 1;

    }



}

contract PeriodicColumnContract {

    function compute(uint256 x) external pure returns(uint256 result);

}

contract IFactRegistry {

    

    function isValid(bytes32 fact)

        external view

        returns(bool);

}

contract IMerkleVerifier {

    uint256 constant internal MAX_N_MERKLE_VERIFIER_QUERIES =  128;



    function verify(

        uint256 channelPtr,

        uint256 queuePtr,

        bytes32 root,

        uint256 n)

        internal view

        returns (bytes32 hash);

}

contract IQueryableFactRegistry is IFactRegistry {



    

    function hasRegisteredFact()

        external view

        returns(bool);



}

contract IStarkVerifier {



    function verifyProof(

        uint256[] memory proofParams,

        uint256[] memory proof,

        uint256[] memory publicInput

    )

        internal view;

}

contract MemoryMap {

    

    uint256 constant internal CHANNEL_STATE_SIZE = 3;

    uint256 constant internal MAX_N_QUERIES =  48;

    uint256 constant internal FRI_QUEUE_SIZE = MAX_N_QUERIES;



    uint256 constant internal MAX_SUPPORTED_MAX_FRI_STEP = 4;



    uint256 constant internal MM_EVAL_DOMAIN_SIZE =                          0x0;

    uint256 constant internal MM_BLOW_UP_FACTOR =                            0x1;

    uint256 constant internal MM_LOG_EVAL_DOMAIN_SIZE =                      0x2;

    uint256 constant internal MM_PROOF_OF_WORK_BITS =                        0x3;

    uint256 constant internal MM_EVAL_DOMAIN_GENERATOR =                     0x4;

    uint256 constant internal MM_PUBLIC_INPUT_PTR =                          0x5;

    uint256 constant internal MM_TRACE_COMMITMENT =                          0x6; 

    uint256 constant internal MM_OODS_COMMITMENT =                           0x8;

    uint256 constant internal MM_N_UNIQUE_QUERIES =                          0x9;

    uint256 constant internal MM_CHANNEL =                                   0xa; 

    uint256 constant internal MM_MERKLE_QUEUE =                              0xd; 

    uint256 constant internal MM_FRI_QUEUE =                                0x6d; 

    uint256 constant internal MM_FRI_QUERIES_DELIMITER =                    0xfd;

    uint256 constant internal MM_FRI_CTX =                                  0xfe; 

    uint256 constant internal MM_FRI_STEPS_PTR =                           0x126;

    uint256 constant internal MM_FRI_EVAL_POINTS =                         0x127; 

    uint256 constant internal MM_FRI_COMMITMENTS =                         0x131; 

    uint256 constant internal MM_FRI_LAST_LAYER_DEG_BOUND =                0x13b;

    uint256 constant internal MM_FRI_LAST_LAYER_PTR =                      0x13c;

    uint256 constant internal MM_CONSTRAINT_POLY_ARGS_START =              0x13d;

    uint256 constant internal MM_PERIODIC_COLUMN__PEDERSEN__POINTS__X =    0x13d;

    uint256 constant internal MM_PERIODIC_COLUMN__PEDERSEN__POINTS__Y =    0x13e;

    uint256 constant internal MM_PERIODIC_COLUMN__ECDSA__GENERATOR_POINTS__X = 0x13f;

    uint256 constant internal MM_PERIODIC_COLUMN__ECDSA__GENERATOR_POINTS__Y = 0x140;

    uint256 constant internal MM_TRACE_LENGTH =                            0x141;

    uint256 constant internal MM_OFFSET_SIZE =                             0x142;

    uint256 constant internal MM_HALF_OFFSET_SIZE =                        0x143;

    uint256 constant internal MM_INITIAL_AP =                              0x144;

    uint256 constant internal MM_INITIAL_PC =                              0x145;

    uint256 constant internal MM_FINAL_AP =                                0x146;

    uint256 constant internal MM_FINAL_PC =                                0x147;

    uint256 constant internal MM_MEMORY__MULTI_COLUMN_PERM__PERM__INTERACTION_ELM = 0x148;

    uint256 constant internal MM_MEMORY__MULTI_COLUMN_PERM__HASH_INTERACTION_ELM0 = 0x149;

    uint256 constant internal MM_MEMORY__MULTI_COLUMN_PERM__PERM__PUBLIC_MEMORY_PROD = 0x14a;

    uint256 constant internal MM_RC16__PERM__INTERACTION_ELM =             0x14b;

    uint256 constant internal MM_RC16__PERM__PUBLIC_MEMORY_PROD =          0x14c;

    uint256 constant internal MM_RC_MIN =                                  0x14d;

    uint256 constant internal MM_RC_MAX =                                  0x14e;

    uint256 constant internal MM_PEDERSEN__SHIFT_POINT_X =                 0x14f;

    uint256 constant internal MM_PEDERSEN__SHIFT_POINT_Y =                 0x150;

    uint256 constant internal MM_INITIAL_PEDERSEN_ADDR =                   0x151;

    uint256 constant internal MM_INITIAL_RC_ADDR =                         0x152;

    uint256 constant internal MM_ECDSA__SIG_CONFIG_ALPHA =                 0x153;

    uint256 constant internal MM_ECDSA__SIG_CONFIG_SHIFT_POINT_X =         0x154;

    uint256 constant internal MM_ECDSA__SIG_CONFIG_SHIFT_POINT_Y =         0x155;

    uint256 constant internal MM_ECDSA__SIG_CONFIG_BETA =                  0x156;

    uint256 constant internal MM_INITIAL_ECDSA_ADDR =                      0x157;

    uint256 constant internal MM_INITIAL_CHECKPOINTS_ADDR =                0x158;

    uint256 constant internal MM_FINAL_CHECKPOINTS_ADDR =                  0x159;

    uint256 constant internal MM_TRACE_GENERATOR =                         0x15a;

    uint256 constant internal MM_OODS_POINT =                              0x15b;

    uint256 constant internal MM_INTERACTION_ELEMENTS =                    0x15c; 

    uint256 constant internal MM_COEFFICIENTS =                            0x15f; 

    uint256 constant internal MM_OODS_VALUES =                             0x289; 

    uint256 constant internal MM_CONSTRAINT_POLY_ARGS_END =                0x337;

    uint256 constant internal MM_COMPOSITION_OODS_VALUES =                 0x337; 

    uint256 constant internal MM_OODS_EVAL_POINTS =                        0x339; 

    uint256 constant internal MM_OODS_COEFFICIENTS =                       0x369; 

    uint256 constant internal MM_TRACE_QUERY_RESPONSES =                   0x419; 

    uint256 constant internal MM_COMPOSITION_QUERY_RESPONSES =             0x8c9; 

    uint256 constant internal MM_LOG_N_STEPS =                             0x929;

    uint256 constant internal MM_N_PUBLIC_MEM_ENTRIES =                    0x92a;

    uint256 constant internal MM_N_PUBLIC_MEM_PAGES =                      0x92b;

    uint256 constant internal MM_CONTEXT_SIZE =                            0x92c;

}

contract MemoryPageFactRegistryConstants {

    

    

    uint256 internal constant REGULAR_PAGE = 0;

    

    

    uint256 internal constant CONTINUOUS_PAGE = 1;

}

contract MerkleStatementVerifier is IMerkleVerifier {

    MerkleStatementContract merkleStatementContract;



    constructor(address merkleStatementContractAddress) internal {

        merkleStatementContract = MerkleStatementContract(merkleStatementContractAddress);

    }



    

    

    

    function verify(uint256 , uint256 queuePtr, bytes32 root, uint256 n) internal view

        returns(bytes32) {

        bytes32 statement;

        require(n <= MAX_N_MERKLE_VERIFIER_QUERIES, "TOO_MANY_MERKLE_QUERIES");



        assembly {

            let dataToHashPtrStart := mload(0x40) 

            let dataToHashPtrCur := dataToHashPtrStart



            let queEndPtr := add(queuePtr, mul(n, 0x40))



            for { } lt(queuePtr, queEndPtr) { } {

                mstore(dataToHashPtrCur, mload(queuePtr))

                dataToHashPtrCur := add(dataToHashPtrCur, 0x20)

                queuePtr := add(queuePtr, 0x20)

            }



            mstore(dataToHashPtrCur, root)

            dataToHashPtrCur := add(dataToHashPtrCur, 0x20)

            mstore(0x40, dataToHashPtrCur)



            statement := keccak256(dataToHashPtrStart, sub(dataToHashPtrCur, dataToHashPtrStart))

        }

        require(merkleStatementContract.isValid(statement), "INVALIDATED_MERKLE_STATEMENT");

        return root;

    }



}

contract MerkleVerifier is IMerkleVerifier {



    function getHashMask() internal pure returns(uint256) {

        

        return 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF000000000000000000000000;

    }



    

    function verify(

        uint256 channelPtr,

        uint256 queuePtr,

        bytes32 root,

        uint256 n)

        internal view

        returns (bytes32 hash)

    {

        uint256 lhashMask = getHashMask();

        require(n <= MAX_N_MERKLE_VERIFIER_QUERIES, "TOO_MANY_MERKLE_QUERIES");



        assembly {

            

            

            let hashesPtr := add(queuePtr, 0x20)

            let queueSize := mul(n, 0x40)

            let slotSize := 0x40



            

            let rdIdx := 0

            let wrIdx := 0 



            

            let index := mload(add(rdIdx, queuePtr))

            let proofPtr := mload(channelPtr)



            

            for { } gt(index, 1) { } {

                let siblingIndex := xor(index, 1)

                

                let sibblingOffset := mulmod(siblingIndex, 0x20, 0x40)



                

                

                

                mstore(xor(0x20, sibblingOffset), mload(add(rdIdx, hashesPtr)))

                rdIdx := addmod(rdIdx, slotSize, queueSize)



                

                

                

                let newHashPtr := proofPtr

                proofPtr := add(proofPtr, 0x20)



                

                

                

                

                mstore(add(wrIdx, queuePtr), div(index, 2))



                

                index := mload(add(rdIdx, queuePtr))

                if eq(index, siblingIndex) {

                    

                    newHashPtr := add(rdIdx, hashesPtr)

                    

                    proofPtr := sub(proofPtr, 0x20)

                    rdIdx := addmod(rdIdx, slotSize, queueSize)



                    

                    

                    

                    

                    index := mload(add(rdIdx, queuePtr))

                }



                mstore(sibblingOffset, mload(newHashPtr))



                

                mstore(add(wrIdx, hashesPtr), and(lhashMask, keccak256(0x00, 0x40)))

                wrIdx := addmod(wrIdx, slotSize, queueSize)

            }

            hash := mload(add(rdIdx, hashesPtr))



            

            mstore(channelPtr, proofPtr)

        }

        

        require(hash == root, "INVALID_MERKLE_PROOF");

    }

}

contract PrimeFieldElement0 {

    uint256 constant internal K_MODULUS =

    0x800000000000011000000000000000000000000000000000000000000000001;

    uint256 constant internal K_MODULUS_MASK =

    0x0fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;

    uint256 constant internal K_MONTGOMERY_R =

    0x7fffffffffffdf0ffffffffffffffffffffffffffffffffffffffffffffffe1;

    uint256 constant internal K_MONTGOMERY_R_INV =

    0x40000000000001100000000000012100000000000000000000000000000000;

    uint256 constant internal GENERATOR_VAL = 3;

    uint256 constant internal ONE_VAL = 1;

    uint256 constant internal GEN1024_VAL =

    0x659d83946a03edd72406af6711825f5653d9e35dc125289a206c054ec89c4f1;



    function fromMontgomery(uint256 val) internal pure returns (uint256 res) {

        

        assembly {

            res := mulmod(val,

                          0x40000000000001100000000000012100000000000000000000000000000000,

                          0x800000000000011000000000000000000000000000000000000000000000001)

        }

        return res;

    }



    function fromMontgomeryBytes(bytes32 bs) internal pure returns (uint256) {

        

        

        uint256 res = uint256(bs);

        return fromMontgomery(res);

    }



    function toMontgomeryInt(uint256 val) internal pure returns (uint256 res) {

        

        assembly {

            res := mulmod(val,

                          0x7fffffffffffdf0ffffffffffffffffffffffffffffffffffffffffffffffe1,

                          0x800000000000011000000000000000000000000000000000000000000000001)

        }

        return res;

    }



    function fmul(uint256 a, uint256 b) internal pure returns (uint256 res) {

        

        assembly {

            res := mulmod(a, b,

                0x800000000000011000000000000000000000000000000000000000000000001)

        }

        return res;

    }



    function fadd(uint256 a, uint256 b) internal pure returns (uint256 res) {

        

        assembly {

            res := addmod(a, b,

                0x800000000000011000000000000000000000000000000000000000000000001)

        }

        return res;

    }



    function fsub(uint256 a, uint256 b) internal pure returns (uint256 res) {

        

        assembly {

            res := addmod(

                a,

                sub(0x800000000000011000000000000000000000000000000000000000000000001, b),

                0x800000000000011000000000000000000000000000000000000000000000001)

        }

        return res;

    }



    function fpow(uint256 val, uint256 exp) internal view returns (uint256) {

        return expmod(val, exp, K_MODULUS);

    }



    function expmod(uint256 base, uint256 exponent, uint256 modulus)

        internal view returns (uint256 res)

    {

        assembly {

            let p := mload(0x40)

            mstore(p, 0x20)                  

            mstore(add(p, 0x20), 0x20)       

            mstore(add(p, 0x40), 0x20)       

            mstore(add(p, 0x60), base)       

            mstore(add(p, 0x80), exponent)   

            mstore(add(p, 0xa0), modulus)    

            

            if iszero(staticcall(gas, 0x05, p, 0xc0, p, 0x20)) {

                revert(0, 0)

            }

            res := mload(p)

        }

    }



    function inverse(uint256 val) internal view returns (uint256) {

        return expmod(val, K_MODULUS - 2, K_MODULUS);

    }

}

contract Prng is PrimeFieldElement0 {

    function storePrng(uint256 statePtr, bytes32 digest, uint256 counter)

        internal pure {

        assembly {

            mstore(statePtr, digest)

            mstore(add(statePtr, 0x20), counter)

        }

    }



    function loadPrng(uint256 statePtr)

        internal pure

        returns (bytes32, uint256) {

        bytes32 digest;

        uint256 counter;



        assembly {

            digest := mload(statePtr)

            counter := mload(add(statePtr, 0x20))

        }



        return (digest, counter);

    }



    function initPrng(uint256 prngPtr, bytes32 publicInputHash)

        internal pure

    {

        storePrng(prngPtr,  publicInputHash, 0);

    }



    

    function getRandomBytesInner(bytes32 digest, uint256 counter)

        internal pure

        returns (bytes32, uint256, bytes32)

    {

        

        bytes32 randomBytes = keccak256(abi.encodePacked(digest, counter));



        return (digest, counter + 1, randomBytes);

    }



    

    function getRandomBytes(uint256 prngPtr)

        internal pure

        returns (bytes32 randomBytes)

    {

        bytes32 digest;

        uint256 counter;

        (digest, counter) = loadPrng(prngPtr);



        

        (digest, counter, randomBytes) = getRandomBytesInner(digest, counter);



        storePrng(prngPtr, digest, counter);

        return randomBytes;

    }



    function mixSeedWithBytes(uint256 prngPtr, bytes memory dataBytes)

        internal pure

    {

        bytes32 digest;



        assembly {

            digest := mload(prngPtr)

        }

        initPrng(prngPtr, keccak256(abi.encodePacked(digest, dataBytes)));

    }



    function getPrngDigest(uint256 prngPtr)

        internal pure

        returns (bytes32 digest)

    {

        assembly {

           digest := mload(prngPtr)

        }

    }

}

contract StarkParameters is PrimeFieldElement0 {

    uint256 constant internal N_COEFFICIENTS = 298;

    uint256 constant internal N_INTERACTION_ELEMENTS = 3;

    uint256 constant internal MASK_SIZE = 174;

    uint256 constant internal N_ROWS_IN_MASK = 77;

    uint256 constant internal N_COLUMNS_IN_MASK = 25;

    uint256 constant internal N_COLUMNS_IN_TRACE0 = 23;

    uint256 constant internal N_COLUMNS_IN_TRACE1 = 2;

    uint256 constant internal CONSTRAINTS_DEGREE_BOUND = 2;

    uint256 constant internal N_OODS_VALUES = MASK_SIZE + CONSTRAINTS_DEGREE_BOUND;

    uint256 constant internal N_OODS_COEFFICIENTS = N_OODS_VALUES;

    uint256 constant internal MAX_FRI_STEP = 3;



    

    uint256 constant internal PUBLIC_MEMORY_STEP = 8;

    uint256 constant internal PEDERSEN_BUILTIN_RATIO = 8;

    uint256 constant internal PEDERSEN_BUILTIN_REPETITIONS = 4;

    uint256 constant internal RC_BUILTIN_RATIO = 8;

    uint256 constant internal RC_N_PARTS = 8;

    uint256 constant internal ECDSA_BUILTIN_RATIO = 512;

    uint256 constant internal ECDSA_BUILTIN_REPETITIONS = 1;

    uint256 constant internal LAYOUT_CODE = 8098989891770344814;

    uint256 constant internal LOG_CPU_COMPONENT_HEIGHT = 4;

}

contract VerifierChannel is Prng {



    

    uint256 constant internal CHANNEL_STATE_SIZE = 3;



    event LogValue(bytes32 val);



    event SendRandomnessEvent(uint256 val);



    event ReadFieldElementEvent(uint256 val);



    event ReadHashEvent(bytes32 val);



    function getPrngPtr(uint256 channelPtr)

        internal pure

        returns (uint256)

    {

        return channelPtr + 0x20;

    }



    function initChannel(uint256 channelPtr, uint256 proofPtr, bytes32 publicInputHash)

        internal pure

    {

        assembly {

            

            mstore(channelPtr, add(proofPtr, 0x20))

        }



        initPrng(getPrngPtr(channelPtr), publicInputHash);

    }



    function sendFieldElements(uint256 channelPtr, uint256 nElements, uint256 targetPtr)

        internal pure

    {

        require(nElements < 0x1000000, "Overflow protection failed.");

        assembly {

            let PRIME := 0x800000000000011000000000000000000000000000000000000000000000001

            let PRIME_MON_R_INV := 0x40000000000001100000000000012100000000000000000000000000000000

            let PRIME_MASK := 0x0fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff

            let digestPtr := add(channelPtr, 0x20)

            let counterPtr := add(channelPtr, 0x40)



            let endPtr := add(targetPtr, mul(nElements, 0x20))

            for { } lt(targetPtr, endPtr) { targetPtr := add(targetPtr, 0x20) } {

                



                let fieldElement := PRIME

                

                for { } iszero(lt(fieldElement, PRIME)) { } {

                    

                    fieldElement := and(keccak256(digestPtr, 0x40), PRIME_MASK)

                    

                    mstore(counterPtr, add(mload(counterPtr), 1))

                }

                

                mstore(targetPtr, mulmod(fieldElement, PRIME_MON_R_INV, PRIME))

                

                

            }

        }

    }



    

    function sendRandomQueries(

        uint256 channelPtr, uint256 count, uint256 mask, uint256 queriesOutPtr, uint256 stride)

        internal pure returns (uint256)

    {

        uint256 val;

        uint256 shift = 0;

        uint256 endPtr = queriesOutPtr;

        for (uint256 i = 0; i < count; i++) {

            if (shift == 0) {

                val = uint256(getRandomBytes(getPrngPtr(channelPtr)));

                shift = 0x100;

            }

            shift -= 0x40;

            uint256 queryIdx = (val >> shift) & mask;

            



            uint256 ptr = endPtr;

            uint256 curr;

            



            while (ptr > queriesOutPtr) {

                assembly {

                    curr := mload(sub(ptr, stride))

                }



                if (queryIdx >= curr) {

                    break;

                }



                assembly {

                    mstore(ptr, curr)

                }

                ptr -= stride;

            }



            if (queryIdx != curr) {

                assembly {

                    mstore(ptr, queryIdx)

                }

                endPtr += stride;

            } else {

                

                while (ptr < endPtr) {

                    assembly {

                        mstore(ptr, mload(add(ptr, stride)))

                        ptr := add(ptr, stride)

                    }

                }

            }

        }



        return (endPtr - queriesOutPtr) / stride;

    }



    function readBytes(uint256 channelPtr, bool mix)

        internal pure

        returns (bytes32)

    {

        uint256 proofPtr;

        bytes32 val;



        assembly {

            proofPtr := mload(channelPtr)

            val := mload(proofPtr)

            mstore(channelPtr, add(proofPtr, 0x20))

        }

        if (mix) {

            

            assembly {

                let digestPtr := add(channelPtr, 0x20)

                let counterPtr := add(digestPtr, 0x20)

                mstore(counterPtr, val)

                

                mstore(digestPtr, keccak256(digestPtr, 0x40))

                

                mstore(counterPtr, 0)

            }

        }



        return val;

    }



    function readHash(uint256 channelPtr, bool mix)

        internal pure

        returns (bytes32)

    {

        bytes32 val = readBytes(channelPtr, mix);

        



        return val;

    }



    function readFieldElement(uint256 channelPtr, bool mix)

        internal pure returns (uint256) {

        uint256 val = fromMontgomery(uint256(readBytes(channelPtr, mix)));

        



        return val;

    }



    function verifyProofOfWork(uint256 channelPtr, uint256 proofOfWorkBits) internal pure {

        if (proofOfWorkBits == 0) {

            return;

        }



        uint256 proofOfWorkDigest;

        assembly {

            

            mstore(0, 0x0123456789abcded000000000000000000000000000000000000000000000000)

            let digest := mload(add(channelPtr, 0x20))

            mstore(0x8, digest)

            mstore8(0x28, proofOfWorkBits)

            mstore(0, keccak256(0, 0x29))



            let proofPtr := mload(channelPtr)

            mstore(0x20, mload(proofPtr))

            

            proofOfWorkDigest := keccak256(0, 0x28)



            mstore(0, digest)

            

            mstore(add(channelPtr, 0x20), keccak256(0, 0x28))

            

            mstore(add(channelPtr, 0x40), 0)



            mstore(channelPtr, add(proofPtr, 0x8))

        }



        uint256 proofOfWorkThreshold = uint256(1) << (256 - proofOfWorkBits);

        require(proofOfWorkDigest < proofOfWorkThreshold, "Proof of work check failed.");

    }

}

contract FactRegistry is IQueryableFactRegistry {

    

    mapping (bytes32 => bool) private verifiedFact;



    

    bool anyFactRegistered;



    

    function isValid(bytes32 fact)

        external view

        returns(bool)

    {

        return _factCheck(fact);

    }





    

    function _factCheck(bytes32 fact)

        internal view

        returns(bool)

    {

        return verifiedFact[fact];

    }



    function registerFact(

        bytes32 factHash

        )

        internal

    {

        

        verifiedFact[factHash] = true;



        

        if (!anyFactRegistered) {

            anyFactRegistered = true;

        }

    }



    

    function hasRegisteredFact()

        external view

        returns(bool)

    {

        return anyFactRegistered;

    }



}

contract FriLayer is MerkleVerifier, PrimeFieldElement0 {

    event LogGas(string name, uint256 val);



    uint256 constant internal FRI_MAX_FRI_STEP = 4;

    uint256 constant internal MAX_COSET_SIZE = 2**FRI_MAX_FRI_STEP;

    

    uint256 constant internal FRI_GROUP_GEN =

    0x5ec467b88826aba4537602d514425f3b0bdf467bbf302458337c45f6021e539;



    uint256 constant internal FRI_GROUP_SIZE = 0x20 * MAX_COSET_SIZE;

    uint256 constant internal FRI_CTX_TO_COSET_EVALUATIONS_OFFSET = 0;

    uint256 constant internal FRI_CTX_TO_FRI_GROUP_OFFSET = FRI_GROUP_SIZE;

    uint256 constant internal FRI_CTX_TO_FRI_HALF_INV_GROUP_OFFSET =

    FRI_CTX_TO_FRI_GROUP_OFFSET + FRI_GROUP_SIZE;



    uint256 constant internal FRI_CTX_SIZE =

    FRI_CTX_TO_FRI_HALF_INV_GROUP_OFFSET + (FRI_GROUP_SIZE / 2);



    function nextLayerElementFromTwoPreviousLayerElements(

        uint256 fX, uint256 fMinusX, uint256 evalPoint, uint256 xInv)

        internal pure

        returns (uint256 res)

    {

        

        

        

        

        

        

        

        

        

        

        

        assembly {

            

            let PRIME := 0x800000000000011000000000000000000000000000000000000000000000001

            

            

            res := addmod(add(fX, fMinusX),

                   mulmod(mulmod(evalPoint, xInv, PRIME),

                   add(fX, sub(PRIME, fMinusX)), PRIME), PRIME)

        }

    }



    

    function do2FriSteps(

        uint256 friHalfInvGroupPtr, uint256 evaluationsOnCosetPtr, uint256 cosetOffset_,

        uint256 friEvalPoint)

    internal pure returns (uint256 nextLayerValue, uint256 nextXInv) {

        assembly {

            let PRIME := 0x800000000000011000000000000000000000000000000000000000000000001

            let friEvalPointDivByX := mulmod(friEvalPoint, cosetOffset_, PRIME)



            let f0 := mload(evaluationsOnCosetPtr)

            {

                let f1 := mload(add(evaluationsOnCosetPtr, 0x20))



                

                f0 := add(add(f0, f1),

                             mulmod(friEvalPointDivByX,

                                    add(f0, sub(PRIME, f1)),

                                    PRIME))

            }



            let f2 := mload(add(evaluationsOnCosetPtr, 0x40))

            {

                let f3 := mload(add(evaluationsOnCosetPtr, 0x60))

                f2 := addmod(add(f2, f3),

                             mulmod(add(f2, sub(PRIME, f3)),

                                    mulmod(mload(add(friHalfInvGroupPtr, 0x20)),

                                           friEvalPointDivByX,

                                           PRIME),

                                    PRIME),

                             PRIME)

            }



            {

                let newXInv := mulmod(cosetOffset_, cosetOffset_, PRIME)

                nextXInv := mulmod(newXInv, newXInv, PRIME)

            }



            

            nextLayerValue := addmod(add(f0, f2),

                          mulmod(mulmod(friEvalPointDivByX, friEvalPointDivByX, PRIME),

                                 add(f0, sub(PRIME, f2)),

                                 PRIME),

                          PRIME)

        }

    }



    

    function do3FriSteps(

        uint256 friHalfInvGroupPtr, uint256 evaluationsOnCosetPtr, uint256 cosetOffset_,

        uint256 friEvalPoint)

    internal pure returns (uint256 nextLayerValue, uint256 nextXInv) {

        assembly {

            let PRIME := 0x800000000000011000000000000000000000000000000000000000000000001

            let MPRIME := 0x8000000000000110000000000000000000000000000000000000000000000010

            let f0 := mload(evaluationsOnCosetPtr)



            let friEvalPointDivByX := mulmod(friEvalPoint, cosetOffset_, PRIME)

            let friEvalPointDivByXSquared := mulmod(friEvalPointDivByX, friEvalPointDivByX, PRIME)

            let imaginaryUnit := mload(add(friHalfInvGroupPtr, 0x20))



            {

                let f1 := mload(add(evaluationsOnCosetPtr, 0x20))



                

                f0 := add(add(f0, f1),

                          mulmod(friEvalPointDivByX,

                                 add(f0, sub(PRIME, f1)),

                                 PRIME))

            }

            {

                let f2 := mload(add(evaluationsOnCosetPtr, 0x40))

                {

                    let f3 := mload(add(evaluationsOnCosetPtr, 0x60))



                    

                    f2 := add(add(f2, f3),

                              mulmod(add(f2, sub(PRIME, f3)),

                                     mulmod(friEvalPointDivByX, imaginaryUnit, PRIME),

                                     PRIME))

                }



                

                f0 := add(add(f0, f2),

                          mulmod(friEvalPointDivByXSquared,

                                 add(f0, sub(MPRIME, f2)),

                                 PRIME))

            }

            {

                let f4 := mload(add(evaluationsOnCosetPtr, 0x80))

                {

                    let friEvalPointDivByX2 := mulmod(friEvalPointDivByX,

                                                    mload(add(friHalfInvGroupPtr, 0x40)), PRIME)

                    {

                        let f5 := mload(add(evaluationsOnCosetPtr, 0xa0))



                        

                        f4 := add(add(f4, f5),

                                  mulmod(friEvalPointDivByX2,

                                         add(f4, sub(PRIME, f5)),

                                         PRIME))

                    }



                    let f6 := mload(add(evaluationsOnCosetPtr, 0xc0))

                    {

                        let f7 := mload(add(evaluationsOnCosetPtr, 0xe0))



                        

                        f6 := add(add(f6, f7),

                                  mulmod(add(f6, sub(PRIME, f7)),

                                         

                                         

                                         mulmod(friEvalPointDivByX2, imaginaryUnit, PRIME),

                                         PRIME))

                    }



                    

                    f4 := add(add(f4, f6),

                              mulmod(mulmod(friEvalPointDivByX2, friEvalPointDivByX2, PRIME),

                                     add(f4, sub(MPRIME, f6)),

                                     PRIME))

                }



                

                nextLayerValue :=

                   addmod(add(f0, f4),

                          mulmod(mulmod(friEvalPointDivByXSquared, friEvalPointDivByXSquared, PRIME),

                                 add(f0, sub(MPRIME, f4)),

                                 PRIME),

                          PRIME)

            }



            {

                let xInv2 := mulmod(cosetOffset_, cosetOffset_, PRIME)

                let xInv4 := mulmod(xInv2, xInv2, PRIME)

                nextXInv := mulmod(xInv4, xInv4, PRIME)

            }





        }

    }



    

    function do4FriSteps(

        uint256 friHalfInvGroupPtr, uint256 evaluationsOnCosetPtr, uint256 cosetOffset_,

        uint256 friEvalPoint)

    internal pure returns (uint256 nextLayerValue, uint256 nextXInv) {

        assembly {

            let friEvalPointDivByXTessed

            let PRIME := 0x800000000000011000000000000000000000000000000000000000000000001

            let MPRIME := 0x8000000000000110000000000000000000000000000000000000000000000010

            let f0 := mload(evaluationsOnCosetPtr)



            let friEvalPointDivByX := mulmod(friEvalPoint, cosetOffset_, PRIME)

            let imaginaryUnit := mload(add(friHalfInvGroupPtr, 0x20))



            {

                let f1 := mload(add(evaluationsOnCosetPtr, 0x20))



                

                f0 := add(add(f0, f1),

                          mulmod(friEvalPointDivByX,

                                 add(f0, sub(PRIME, f1)),

                                 PRIME))

            }

            {

                let f2 := mload(add(evaluationsOnCosetPtr, 0x40))

                {

                    let f3 := mload(add(evaluationsOnCosetPtr, 0x60))



                    

                    f2 := add(add(f2, f3),

                                mulmod(add(f2, sub(PRIME, f3)),

                                       mulmod(friEvalPointDivByX, imaginaryUnit, PRIME),

                                       PRIME))

                }

                {

                    let friEvalPointDivByXSquared := mulmod(friEvalPointDivByX, friEvalPointDivByX, PRIME)

                    friEvalPointDivByXTessed := mulmod(friEvalPointDivByXSquared, friEvalPointDivByXSquared, PRIME)



                    

                    f0 := add(add(f0, f2),

                              mulmod(friEvalPointDivByXSquared,

                                     add(f0, sub(MPRIME, f2)),

                                     PRIME))

                }

            }

            {

                let f4 := mload(add(evaluationsOnCosetPtr, 0x80))

                {

                    let friEvalPointDivByX2 := mulmod(friEvalPointDivByX,

                                                      mload(add(friHalfInvGroupPtr, 0x40)), PRIME)

                    {

                        let f5 := mload(add(evaluationsOnCosetPtr, 0xa0))



                        

                        f4 := add(add(f4, f5),

                                  mulmod(friEvalPointDivByX2,

                                         add(f4, sub(PRIME, f5)),

                                         PRIME))

                    }



                    let f6 := mload(add(evaluationsOnCosetPtr, 0xc0))

                    {

                        let f7 := mload(add(evaluationsOnCosetPtr, 0xe0))



                        

                        f6 := add(add(f6, f7),

                                  mulmod(add(f6, sub(PRIME, f7)),

                                         

                                         

                                         mulmod(friEvalPointDivByX2, imaginaryUnit, PRIME),

                                         PRIME))

                    }



                    

                    f4 := add(add(f4, f6),

                              mulmod(mulmod(friEvalPointDivByX2, friEvalPointDivByX2, PRIME),

                                     add(f4, sub(MPRIME, f6)),

                                     PRIME))

                }



                

                f0 := add(add(f0, f4),

                          mulmod(friEvalPointDivByXTessed,

                                 add(f0, sub(MPRIME, f4)),

                                 PRIME))

            }

            {

                let f8 := mload(add(evaluationsOnCosetPtr, 0x100))

                {

                    let friEvalPointDivByX4 := mulmod(friEvalPointDivByX,

                                                      mload(add(friHalfInvGroupPtr, 0x80)), PRIME)

                    {

                        let f9 := mload(add(evaluationsOnCosetPtr, 0x120))



                        

                        f8 := add(add(f8, f9),

                                  mulmod(friEvalPointDivByX4,

                                         add(f8, sub(PRIME, f9)),

                                         PRIME))

                    }



                    let f10 := mload(add(evaluationsOnCosetPtr, 0x140))

                    {

                        let f11 := mload(add(evaluationsOnCosetPtr, 0x160))

                        

                        f10 := add(add(f10, f11),

                                   mulmod(add(f10, sub(PRIME, f11)),

                                          

                                          

                                          mulmod(friEvalPointDivByX4, imaginaryUnit, PRIME),

                                          PRIME))

                    }



                    

                    f8 := add(add(f8, f10),

                              mulmod(mulmod(friEvalPointDivByX4, friEvalPointDivByX4, PRIME),

                                     add(f8, sub(MPRIME, f10)),

                                     PRIME))

                }

                {

                    let f12 := mload(add(evaluationsOnCosetPtr, 0x180))

                    {

                        let friEvalPointDivByX6 := mulmod(friEvalPointDivByX,

                                                          mload(add(friHalfInvGroupPtr, 0xc0)), PRIME)

                        {

                            let f13 := mload(add(evaluationsOnCosetPtr, 0x1a0))



                            

                            f12 := add(add(f12, f13),

                                       mulmod(friEvalPointDivByX6,

                                              add(f12, sub(PRIME, f13)),

                                              PRIME))

                        }



                        let f14 := mload(add(evaluationsOnCosetPtr, 0x1c0))

                        {

                            let f15 := mload(add(evaluationsOnCosetPtr, 0x1e0))



                            

                            f14 := add(add(f14, f15),

                                       mulmod(add(f14, sub(PRIME, f15)),

                                              

                                              

                                              mulmod(friEvalPointDivByX6, imaginaryUnit, PRIME),

                                              PRIME))

                        }



                        

                        f12 := add(add(f12, f14),

                                   mulmod(mulmod(friEvalPointDivByX6, friEvalPointDivByX6, PRIME),

                                          add(f12, sub(MPRIME, f14)),

                                          PRIME))

                    }



                    

                    f8 := add(add(f8, f12),

                              mulmod(mulmod(friEvalPointDivByXTessed, imaginaryUnit, PRIME),

                                     add(f8, sub(MPRIME, f12)),

                                     PRIME))

                }



                

                nextLayerValue :=

                    addmod(add(f0, f8),

                           mulmod(mulmod(friEvalPointDivByXTessed, friEvalPointDivByXTessed, PRIME),

                                  add(f0, sub(MPRIME, f8)),

                                  PRIME),

                           PRIME)

            }



            {

                let xInv2 := mulmod(cosetOffset_, cosetOffset_, PRIME)

                let xInv4 := mulmod(xInv2, xInv2, PRIME)

                let xInv8 := mulmod(xInv4, xInv4, PRIME)

                nextXInv := mulmod(xInv8, xInv8, PRIME)

            }

        }

    }



    

    function gatherCosetInputs(

        uint256 channelPtr, uint256 friCtx, uint256 friQueueHead_, uint256 cosetSize)

        internal pure returns (uint256 friQueueHead, uint256 cosetIdx, uint256 cosetOffset_) {



        uint256 evaluationsOnCosetPtr = friCtx + FRI_CTX_TO_COSET_EVALUATIONS_OFFSET;

        uint256 friGroupPtr = friCtx + FRI_CTX_TO_FRI_GROUP_OFFSET;



        friQueueHead = friQueueHead_;

        assembly {

            let queueItemIdx := mload(friQueueHead)

            

            cosetIdx := and(queueItemIdx, not(sub(cosetSize, 1)))

            let nextCosetIdx := add(cosetIdx, cosetSize)

            let PRIME := 0x800000000000011000000000000000000000000000000000000000000000001



            

            

            

            

            

            

            

            cosetOffset_ := mulmod(

                 mload(add(friQueueHead, 0x40)),

                     mload(add(friGroupPtr,

                                        mul(sub(queueItemIdx, cosetIdx),

                                            0x20))),

                PRIME)



            let proofPtr := mload(channelPtr)



            for { let index := cosetIdx } lt(index, nextCosetIdx) { index := add(index, 1) } {

                

                

                

                let fieldElementPtr := proofPtr

                proofPtr := add(proofPtr, 0x20)



                

                if eq(index, queueItemIdx) {

                    

                    

                    fieldElementPtr := add(friQueueHead, 0x20)



                    

                    proofPtr := sub(proofPtr, 0x20)



                    

                    

                    friQueueHead := add(friQueueHead, 0x60)

                    queueItemIdx := mload(friQueueHead)

                }



                

                

                mstore(evaluationsOnCosetPtr, mod(mload(fieldElementPtr), PRIME))

                evaluationsOnCosetPtr := add(evaluationsOnCosetPtr, 0x20)

            }



            mstore(channelPtr, proofPtr)

        }

    }



    

    function bitReverse(uint256 num, uint256 numberOfBits)

    internal pure

        returns(uint256 numReversed)

    {

        assert((numberOfBits == 256) || (num < 2 ** numberOfBits));

        uint256 n = num;

        uint256 r = 0;

        for (uint256 k = 0; k < numberOfBits; k++) {

            r = (r * 2) | (n % 2);

            n = n / 2;

        }

        return r;

    }



    

    function initFriGroups(uint256 friCtx) internal view {

        uint256 friGroupPtr = friCtx + FRI_CTX_TO_FRI_GROUP_OFFSET;

        uint256 friHalfInvGroupPtr = friCtx + FRI_CTX_TO_FRI_HALF_INV_GROUP_OFFSET;



        

        

        uint256 genFriGroup = FRI_GROUP_GEN;



        uint256 genFriGroupInv = fpow(genFriGroup, (MAX_COSET_SIZE - 1));



        uint256 lastVal = ONE_VAL;

        uint256 lastValInv = ONE_VAL;

        uint256 prime = PrimeFieldElement0.K_MODULUS;

        assembly {

            

            mstore(friHalfInvGroupPtr, lastValInv)

            

            mstore(friGroupPtr, lastVal)

            

            mstore(add(friGroupPtr, 0x20), sub(prime, lastVal))

        }



        

        

        uint256 halfCosetSize = MAX_COSET_SIZE / 2;

        for (uint256 i = 1; i < halfCosetSize; i++) {

            lastVal = fmul(lastVal, genFriGroup);

            lastValInv = fmul(lastValInv, genFriGroupInv);

            uint256 idx = bitReverse(i, FRI_MAX_FRI_STEP-1);



            assembly {

                

                mstore(add(friHalfInvGroupPtr, mul(idx, 0x20)), lastValInv)

                

                mstore(add(friGroupPtr, mul(idx, 0x40)), lastVal)

                

                mstore(add(friGroupPtr, add(mul(idx, 0x40), 0x20)), sub(prime, lastVal))

            }

        }

    }



    

    function doFriSteps(

        uint256 friCtx, uint256 friQueueTail, uint256 cosetOffset_, uint256 friEvalPoint,

        uint256 friCosetSize, uint256 index, uint256 merkleQueuePtr)

        internal pure {

        uint256 friValue;



        uint256 evaluationsOnCosetPtr = friCtx + FRI_CTX_TO_COSET_EVALUATIONS_OFFSET;

        uint256 friHalfInvGroupPtr = friCtx + FRI_CTX_TO_FRI_HALF_INV_GROUP_OFFSET;



        

        if (friCosetSize == 8) {

            (friValue, cosetOffset_) = do3FriSteps(

                friHalfInvGroupPtr, evaluationsOnCosetPtr, cosetOffset_, friEvalPoint);

        } else if (friCosetSize == 4) {

            (friValue, cosetOffset_) = do2FriSteps(

                friHalfInvGroupPtr, evaluationsOnCosetPtr, cosetOffset_, friEvalPoint);

        } else if (friCosetSize == 16) {

            (friValue, cosetOffset_) = do4FriSteps(

                friHalfInvGroupPtr, evaluationsOnCosetPtr, cosetOffset_, friEvalPoint);

        } else {

            require(false, "Only step sizes of 2, 3 or 4 are supported.");

        }



        uint256 lhashMask = getHashMask();

        assembly {

            let indexInNextStep := div(index, friCosetSize)

            mstore(merkleQueuePtr, indexInNextStep)

            mstore(add(merkleQueuePtr, 0x20), and(lhashMask, keccak256(evaluationsOnCosetPtr,

                                                                          mul(0x20,friCosetSize))))



            mstore(friQueueTail, indexInNextStep)

            mstore(add(friQueueTail, 0x20), friValue)

            mstore(add(friQueueTail, 0x40), cosetOffset_)

        }

    }



    

    function computeNextLayer(

        uint256 channelPtr, uint256 friQueuePtr, uint256 merkleQueuePtr, uint256 nQueries,

        uint256 friEvalPoint, uint256 friCosetSize, uint256 friCtx)

        internal pure returns (uint256 nLiveQueries) {

        uint256 merkleQueueTail = merkleQueuePtr;

        uint256 friQueueHead = friQueuePtr;

        uint256 friQueueTail = friQueuePtr;

        uint256 friQueueEnd = friQueueHead + (0x60 * nQueries);



        do {

            uint256 cosetOffset;

            uint256 index;

            (friQueueHead, index, cosetOffset) = gatherCosetInputs(

                channelPtr, friCtx, friQueueHead, friCosetSize);



            doFriSteps(

                friCtx, friQueueTail, cosetOffset, friEvalPoint, friCosetSize, index,

                merkleQueueTail);



            merkleQueueTail += 0x40;

            friQueueTail += 0x60;

        } while (friQueueHead < friQueueEnd);

        return (friQueueTail - friQueuePtr) / 0x60;

    }



}

contract FriStatementContract is FriLayer, FactRegistry {

    

    function verifyFRI(

        uint256[] memory proof,

        uint256[] memory friQueue,

        uint256 evaluationPoint,

        uint256 friStepSize,

        uint256 expectedRoot) public {



        require (friStepSize <= FRI_MAX_FRI_STEP, "FRI step size too large");

        

        require (

            friQueue.length % 3 == 1,

            "FRI Queue must be composed of triplets plus one delimiter cell");

        require (friQueue.length >= 4, "No query to process");



        uint256 mmFriCtxSize = FRI_CTX_SIZE;

        uint256 nQueries = friQueue.length / 3;

        friQueue[3*nQueries] = 0;  

        uint256 merkleQueuePtr;

        uint256 friQueuePtr;

        uint256 channelPtr;

        uint256 friCtx;

        uint256 dataToHash;



        

        require(evaluationPoint < K_MODULUS, "INVALID_EVAL_POINT");



        

        

        

        



        

        

        uint256 prevQuery = 0; 

        for (uint256 i = 0; i < nQueries; i++) {

            require(friQueue[3*i] > prevQuery, "INVALID_QUERY_VALUE");

            require(friQueue[3*i+1] < K_MODULUS, "INVALID_FRI_VALUE");

            require(friQueue[3*i+2] < K_MODULUS, "INVALID_FRI_INVERSE_POINT");

            prevQuery = friQueue[3*i];

        }



        

        

        require((friQueue[0] ^ friQueue[3*nQueries-3]) < friQueue[0], "INVALID_QUERIES_RANGE");



        

        assembly {

            friQueuePtr := add(friQueue, 0x20)

            channelPtr := mload(0x40) 

            mstore(channelPtr, add(proof, 0x20))

            merkleQueuePtr := add(channelPtr, 0x20)

            friCtx := add(merkleQueuePtr, mul(0x40, nQueries))

            dataToHash := add(friCtx, mmFriCtxSize)

            mstore(0x40, add(dataToHash, 0xa0)) 



            mstore(dataToHash, evaluationPoint)

            mstore(add(dataToHash, 0x20), friStepSize)

            mstore(add(dataToHash, 0x80), expectedRoot)



            

            mstore(add(dataToHash, 0x40), keccak256(friQueuePtr, mul(0x60, nQueries)))

        }



        initFriGroups(friCtx);



        nQueries = computeNextLayer(

            channelPtr, friQueuePtr, merkleQueuePtr, nQueries, evaluationPoint,

            2**friStepSize, 

            friCtx);



        verify(channelPtr, merkleQueuePtr, bytes32(expectedRoot), nQueries);



        bytes32 factHash;

        assembly {

            

            mstore(add(dataToHash, 0x60), keccak256(friQueuePtr, mul(0x60, nQueries)))

            factHash := keccak256(dataToHash, 0xa0)

        }



        registerFact(factHash);

    }

}

contract HornerEvaluator is PrimeFieldElement0 {

    

    function hornerEval(uint256 coefsStart, uint256 point, uint256 nCoefs)

        internal pure

        returns (uint256) {

        uint256 result = 0;

        uint256 prime = PrimeFieldElement0.K_MODULUS;



        require(nCoefs % 8 == 0, "Number of polynomial coefficients must be divisible by 8");

        require(nCoefs < 4096, "No more than 4096 coefficients are supported");



        assembly {

            let coefsPtr := add(coefsStart, mul(nCoefs, 0x20))

            for { } gt(coefsPtr, coefsStart) { } {

                

                coefsPtr := sub(coefsPtr, 0x100)



                

                result :=

                    add(mload(add(coefsPtr, 0x80)), mulmod(

                    add(mload(add(coefsPtr, 0xa0)), mulmod(

                    add(mload(add(coefsPtr, 0xc0)), mulmod(

                    add(mload(add(coefsPtr, 0xe0)), mulmod(

                        result,

                    point, prime)),

                    point, prime)),

                    point, prime)),

                    point, prime))



                

                result :=

                    add(mload(coefsPtr), mulmod(

                    add(mload(add(coefsPtr, 0x20)), mulmod(

                    add(mload(add(coefsPtr, 0x40)), mulmod(

                    add(mload(add(coefsPtr, 0x60)), mulmod(

                        result,

                    point, prime)),

                    point, prime)),

                    point, prime)),

                    point, prime))

            }

        }



        

        return result % prime;

    }

}

contract MemoryAccessUtils is MemoryMap {

    function getPtr(uint256[] memory ctx, uint256 offset)

        internal pure

        returns (uint256) {

        uint256 ctxPtr;

        require(offset < MM_CONTEXT_SIZE, "Overflow protection failed");

        assembly {

            ctxPtr := add(ctx, 0x20)

        }

        return ctxPtr + offset * 0x20;

    }



    function getProofPtr(uint256[] memory proof)

        internal pure

        returns (uint256)

    {

        uint256 proofPtr;

        assembly {

            proofPtr := proof

        }

        return proofPtr;

    }



    function getChannelPtr(uint256[] memory ctx)

        internal pure

        returns (uint256) {

        uint256 ctxPtr;

        assembly {

            ctxPtr := add(ctx, 0x20)

        }

        return ctxPtr + MM_CHANNEL * 0x20;

    }



    function getQueries(uint256[] memory ctx)

        internal pure

        returns (uint256[] memory)

    {

        uint256[] memory queries;

        

        uint256 offset = 0x20 + 0x20*MM_N_UNIQUE_QUERIES;

        assembly {

            queries := add(ctx, offset)

        }

        return queries;

    }



    function getMerkleQueuePtr(uint256[] memory ctx)

        internal pure

        returns (uint256)

    {

        return getPtr(ctx, MM_MERKLE_QUEUE);

    }



    function getFriSteps(uint256[] memory ctx)

        internal pure

        returns (uint256[] memory friSteps)

    {

        uint256 friStepsPtr = getPtr(ctx, MM_FRI_STEPS_PTR);

        assembly {

            friSteps := mload(friStepsPtr)

        }

    }

}

contract MemoryPageFactRegistry is FactRegistry, MemoryPageFactRegistryConstants {

    event LogMemoryPageFact(bytes32 factHash, uint256 memoryHash, uint256 prod);



    

    function registerRegularMemoryPage(

        uint256[] calldata memoryPairs, uint256 z, uint256 alpha, uint256 prime)

        external returns (bytes32 factHash, uint256 memoryHash, uint256 prod)

    {

        require(memoryPairs.length < 2**20, "Too many memory values.");

        require(memoryPairs.length % 2 == 0, "Size of memoryPairs must be even.");

        require(z < prime, "Invalid value of z.");

        require(alpha < prime, "Invalid value of alpha.");

        (factHash, memoryHash, prod) = computeFactHash(memoryPairs, z, alpha, prime);

        emit LogMemoryPageFact(factHash, memoryHash, prod);



        registerFact(factHash);

    }



    function computeFactHash(

        uint256[] memory memoryPairs, uint256 z, uint256 alpha, uint256 prime)

        internal pure returns (bytes32 factHash, uint256 memoryHash, uint256 prod) {

        uint256 memorySize = memoryPairs.length / 2;



        prod = 1;



        assembly {

            let memoryPtr := add(memoryPairs, 0x20)



            

            let lastPtr := add(memoryPtr, mul(memorySize, 0x40))

            for { let ptr := memoryPtr } lt(ptr, lastPtr) { ptr := add(ptr, 0x40) } {

                

                let address_value_lin_comb := addmod(

                     mload(ptr),

                    mulmod( mload(add(ptr, 0x20)), alpha, prime),

                    prime)

                prod := mulmod(prod, add(z, sub(prime, address_value_lin_comb)), prime)

            }



            memoryHash := keccak256(memoryPtr, mul( 0x40, memorySize))

        }



        factHash = keccak256(

            abi.encodePacked(

                REGULAR_PAGE, prime, memorySize, z, alpha, prod, memoryHash, uint256(0))

        );

    }



    

    function registerContinuousMemoryPage(  

        uint256 startAddr, uint256[] memory values, uint256 z, uint256 alpha, uint256 prime)

        public returns (bytes32 factHash, uint256 memoryHash, uint256 prod)

    {

        require(values.length < 2**20, "Too many memory values.");

        require(prime < 2**254, "prime is too big for the optimizations in this function.");

        require(z < prime, "Invalid value of z.");

        require(alpha < prime, "Invalid value of alpha.");

        require(startAddr < 2**64 && startAddr < prime, "Invalid value of startAddr.");



        uint256 nValues = values.length;



        assembly {

            

            prod := 1

            

            let valuesPtr := add(values, 0x20)



            let minus_z := mod(sub(prime, z), prime)



            

            

            let addr := add(startAddr, 7)

            let lastAddr := add(startAddr, nValues)

            for {} lt(addr, lastAddr) { addr := add(addr, 8) } {

                

                

                prod :=

                    mulmod(prod,

                    mulmod(add(add(sub(addr, 7), mulmod(

                        mload(valuesPtr), alpha, prime)), minus_z),

                    add(add(sub(addr, 6), mulmod(

                        mload(add(valuesPtr, 0x20)), alpha, prime)), minus_z),

                    prime), prime)



                prod :=

                    mulmod(prod,

                    mulmod(add(add(sub(addr, 5), mulmod(

                        mload(add(valuesPtr, 0x40)), alpha, prime)), minus_z),

                    add(add(sub(addr, 4), mulmod(

                        mload(add(valuesPtr, 0x60)), alpha, prime)), minus_z),

                    prime), prime)



                prod :=

                    mulmod(prod,

                    mulmod(add(add(sub(addr, 3), mulmod(

                        mload(add(valuesPtr, 0x80)), alpha, prime)), minus_z),

                    add(add(sub(addr, 2), mulmod(

                        mload(add(valuesPtr, 0xa0)), alpha, prime)), minus_z),

                    prime), prime)



                prod :=

                    mulmod(prod,

                    mulmod(add(add(sub(addr, 1), mulmod(

                        mload(add(valuesPtr, 0xc0)), alpha, prime)), minus_z),

                    add(add(addr, mulmod(

                        mload(add(valuesPtr, 0xe0)), alpha, prime)), minus_z),

                    prime), prime)



                valuesPtr := add(valuesPtr, 0x100)

            }



            

            

            addr := sub(addr, 7)

            for {} lt(addr, lastAddr) { addr := add(addr, 1) } {

                let address_value_lin_comb := addmod(

                    addr, mulmod(mload(valuesPtr), alpha, prime), prime)

                prod := mulmod(prod, add(z, sub(prime, address_value_lin_comb)), prime)

                valuesPtr := add(valuesPtr, 0x20)

            }



            memoryHash := keccak256(add(values, 0x20), mul(0x20, nValues))

        }



        factHash = keccak256(

            abi.encodePacked(

                CONTINUOUS_PAGE, prime, nValues, z, alpha, prod, memoryHash, startAddr)

        );



        emit LogMemoryPageFact(factHash, memoryHash, prod);



        registerFact(factHash);

    }

}

contract MerkleStatementContract is MerkleVerifier, FactRegistry {

    

    

    function verifyMerkle(

        uint256[] memory merkleView,

        uint256[] memory initialMerkleQueue,

        uint256 height,

        uint256 expectedRoot

        )

        public

    {

        require(height < 200, "Height must be < 200.");

        require(

            initialMerkleQueue.length <= MAX_N_MERKLE_VERIFIER_QUERIES * 2,

            "TOO_MANY_MERKLE_QUERIES");



        uint256 merkleQueuePtr;

        uint256 channelPtr;

        uint256 nQueries;

        uint256 dataToHashPtr;

        uint256 badInput = 0;



        assembly {

            

            let merkleViewPtr := add(merkleView, 0x20)

            

            channelPtr := mload(0x40) 

            

            

            mstore(channelPtr, merkleViewPtr)

            

            merkleQueuePtr := add(initialMerkleQueue, 0x20)

            

            nQueries := div(mload(initialMerkleQueue), 0x2)

            

            let initialMerkleQueueEndPtr := add(merkleQueuePtr, mul(nQueries, 0x40))

            

            dataToHashPtr := add(channelPtr, 0x20) 



            

            

            



            

            let idxLowerLimit := shl(height, 1)

            for { } lt(merkleQueuePtr, initialMerkleQueueEndPtr) { } {

                let curIdx := mload(merkleQueuePtr)

                

                badInput := or(badInput, lt(curIdx, idxLowerLimit))



                

                idxLowerLimit := add(curIdx, 1)



                

                mstore(dataToHashPtr, curIdx)

                mstore(add(dataToHashPtr, 0x20), mload(add(merkleQueuePtr, 0x20)))



                dataToHashPtr := add(dataToHashPtr, 0x40)

                merkleQueuePtr := add(merkleQueuePtr, 0x40)

            }



            

            

            

            

            badInput := or(badInput, gt(idxLowerLimit, shl(height, 2)))



            

            merkleQueuePtr := add(initialMerkleQueue, 0x20)

            

            

            mstore(0x40, add(dataToHashPtr, 0x20))

        }

        require(badInput == 0, "INVALID_MERKLE_INDICES");

        bytes32 resRoot = verify(channelPtr, merkleQueuePtr, bytes32(expectedRoot), nQueries);

        bytes32 factHash;

        assembly {

            

            mstore(dataToHashPtr, resRoot)

            

            dataToHashPtr := add(channelPtr, 0x20)

            factHash := keccak256(dataToHashPtr, add(mul(nQueries, 0x40), 0x20))

        }



        registerFact(factHash);

    }

}

contract Fri is MemoryMap, MemoryAccessUtils, HornerEvaluator, FriLayer {

    event LogGas(string name, uint256 val);



    function verifyLastLayer(uint256[] memory ctx, uint256 nPoints)

        internal view {

        uint256 friLastLayerDegBound = ctx[MM_FRI_LAST_LAYER_DEG_BOUND];

        uint256 groupOrderMinusOne = friLastLayerDegBound * ctx[MM_BLOW_UP_FACTOR] - 1;

        uint256 coefsStart = ctx[MM_FRI_LAST_LAYER_PTR];



        for (uint256 i = 0; i < nPoints; i++) {

            uint256 point = ctx[MM_FRI_QUEUE + 3*i + 2];

            



            point = fpow(point, groupOrderMinusOne);

            require(

                hornerEval(coefsStart, point, friLastLayerDegBound) == ctx[MM_FRI_QUEUE + 3*i + 1],

                "Bad Last layer value.");

        }

    }



    

    function friVerifyLayers(

        uint256[] memory ctx)

        internal view

    {



        uint256 friCtx = getPtr(ctx, MM_FRI_CTX);

        require(

            MAX_SUPPORTED_MAX_FRI_STEP == FRI_MAX_FRI_STEP,

            "Incosistent MAX_FRI_STEP between MemoryMap.sol and FriLayer.sol");

        initFriGroups(friCtx);

        

        uint256 channelPtr = getChannelPtr(ctx);

        uint256 merkleQueuePtr = getMerkleQueuePtr(ctx);



        uint256 friStep = 1;

        uint256 nLiveQueries = ctx[MM_N_UNIQUE_QUERIES];



        

        ctx[MM_FRI_QUERIES_DELIMITER] = 0;



        

        

        

        

        

        

        for (uint256 i = 0; i < nLiveQueries; i++ ) {

            ctx[MM_FRI_QUEUE + 3*i + 1] = fmul(ctx[MM_FRI_QUEUE + 3*i + 1], K_MONTGOMERY_R);

        }



        uint256 friQueue = getPtr(ctx, MM_FRI_QUEUE);



        uint256[] memory friSteps = getFriSteps(ctx);

        uint256 nFriSteps = friSteps.length;

        while (friStep < nFriSteps) {

            uint256 friCosetSize = 2**friSteps[friStep];



            nLiveQueries = computeNextLayer(

                channelPtr, friQueue, merkleQueuePtr, nLiveQueries,

                ctx[MM_FRI_EVAL_POINTS + friStep], friCosetSize, friCtx);



            

            



            

            

            

            verify(

                channelPtr, merkleQueuePtr, bytes32(ctx[MM_FRI_COMMITMENTS + friStep - 1]),

                nLiveQueries);



            

            

            

            friStep++;

        }



        verifyLastLayer(ctx, nLiveQueries);

        

    }

}

contract FriStatementVerifier is MemoryMap, MemoryAccessUtils, VerifierChannel, HornerEvaluator {

    event LogGas(string name, uint256 val);



    FriStatementContract friStatementContract;



    constructor(address friStatementContractAddress) internal {

        friStatementContract = FriStatementContract(friStatementContractAddress);

    }



    

    function computerLastLayerHash(uint256[] memory ctx, uint256 nPoints, uint256 numLayers)

        internal view returns (bytes32 lastLayerHash) {

        uint256 friLastLayerDegBound = ctx[MM_FRI_LAST_LAYER_DEG_BOUND];

        uint256 groupOrderMinusOne = friLastLayerDegBound * ctx[MM_BLOW_UP_FACTOR] - 1;

        uint256 exponent = 1 << numLayers;

        uint256 curPointIndex = 0;

        uint256 prevQuery = 0;

        uint256 coefsStart = ctx[MM_FRI_LAST_LAYER_PTR];



        for (uint256 i = 0; i < nPoints; i++) {

            uint256 query = ctx[MM_FRI_QUEUE + 3*i] >> numLayers;

            if (query == prevQuery) {

                continue;

            }

            ctx[MM_FRI_QUEUE + 3*curPointIndex] = query;

            prevQuery = query;



            uint256 point = fpow(ctx[MM_FRI_QUEUE + 3*i + 2], exponent);

            ctx[MM_FRI_QUEUE + 3*curPointIndex + 2] = point;

            



            point = fpow(point, groupOrderMinusOne);

            ctx[MM_FRI_QUEUE + 3*curPointIndex + 1] = hornerEval(

                coefsStart, point, friLastLayerDegBound);



            curPointIndex++;

        }



        uint256 friQueue = getPtr(ctx, MM_FRI_QUEUE);

        assembly {

            lastLayerHash := keccak256(friQueue, mul(curPointIndex, 0x60))

        }

    }



    

    function friVerifyLayers(

        uint256[] memory ctx)

        internal view

    {

        uint256 channelPtr = getChannelPtr(ctx);

        uint256 nQueries = ctx[MM_N_UNIQUE_QUERIES];



        

        

        

        

        

        

        for (uint256 i = 0; i < nQueries; i++ ) {

            ctx[MM_FRI_QUEUE + 3*i + 1] = fmul(ctx[MM_FRI_QUEUE + 3*i + 1], K_MONTGOMERY_R);

        }



        uint256 friQueue = getPtr(ctx, MM_FRI_QUEUE);

        uint256 inputLayerHash;

        assembly {

            inputLayerHash := keccak256(friQueue, mul(nQueries, 0x60))

        }





        uint256[] memory friSteps = getFriSteps(ctx);

        uint256 nFriStepsLessOne = friSteps.length - 1;

        uint256 friStep = 1;

        uint256 sumSteps = friSteps[1];

        uint256[5] memory dataToHash;

        while (friStep < nFriStepsLessOne) {

            uint256 outputLayerHash = uint256(readBytes(channelPtr, true));

            dataToHash[0] = ctx[MM_FRI_EVAL_POINTS + friStep];

            dataToHash[1] = friSteps[friStep];

            dataToHash[2] = inputLayerHash;

            dataToHash[3] = outputLayerHash;

            dataToHash[4] = ctx[MM_FRI_COMMITMENTS + friStep - 1];



            

            require( 

                friStatementContract.isValid(keccak256(abi.encodePacked(dataToHash))),

                "INVALIDATED_FRI_STATEMENT");



            inputLayerHash = outputLayerHash;



            friStep++;

            sumSteps += friSteps[friStep];

        }



        dataToHash[0] = ctx[MM_FRI_EVAL_POINTS + friStep];

        dataToHash[1] = friSteps[friStep];

        dataToHash[2] = inputLayerHash;

        dataToHash[3] = uint256(computerLastLayerHash(ctx, nQueries, sumSteps));

        dataToHash[4] = ctx[MM_FRI_COMMITMENTS + friStep - 1];



        require(

            friStatementContract.isValid(keccak256(abi.encodePacked(dataToHash))),

            "INVALIDATED_FRI_STATEMENT");

    }

}

contract StarkVerifier is MemoryMap, MemoryAccessUtils, VerifierChannel, IStarkVerifier, Fri {

    

    uint256 numSecurityBits;



    

    uint256 minProofOfWorkBits;



    constructor(uint256 numSecurityBits_, uint256 minProofOfWorkBits_) public {

        numSecurityBits = numSecurityBits_;

        minProofOfWorkBits = minProofOfWorkBits_;

    }



    

    event LogBool(bool val);

    event LogDebug(uint256 val);

    address oodsContractAddress;



    function airSpecificInit(uint256[] memory publicInput)

        internal view returns (uint256[] memory ctx, uint256 logTraceLength);



    uint256 constant internal PROOF_PARAMS_N_QUERIES_OFFSET = 0;

    uint256 constant internal PROOF_PARAMS_LOG_BLOWUP_FACTOR_OFFSET = 1;

    uint256 constant internal PROOF_PARAMS_PROOF_OF_WORK_BITS_OFFSET = 2;

    uint256 constant internal PROOF_PARAMS_FRI_LAST_LAYER_DEG_BOUND_OFFSET = 3;

    uint256 constant internal PROOF_PARAMS_N_FRI_STEPS_OFFSET = 4;

    uint256 constant internal PROOF_PARAMS_FRI_STEPS_OFFSET = 5;



    function validateFriParams(

        uint256[] memory friSteps, uint256 logTraceLength, uint256 logFriLastLayerDegBound)

        internal pure {

        require (friSteps[0] == 0, "Only eta0 == 0 is currently supported");



        uint256 expectedLogDegBound = logFriLastLayerDegBound;

        uint256 nFriSteps = friSteps.length;

        for (uint256 i = 1; i < nFriSteps; i++) {

            uint256 friStep = friSteps[i];

            require(friStep > 0, "Only the first fri step can be 0");

            require(friStep <= 4, "Max supported fri step is 4.");

            expectedLogDegBound += friStep;

        }



        

        

        

        require (

            expectedLogDegBound == logTraceLength, "Fri params do not match trace length");

    }



    function initVerifierParams(uint256[] memory publicInput, uint256[] memory proofParams)

        internal view returns (uint256[] memory ctx) {

        require (proofParams.length > PROOF_PARAMS_FRI_STEPS_OFFSET, "Invalid proofParams.");

        require (

            proofParams.length == (

                PROOF_PARAMS_FRI_STEPS_OFFSET + proofParams[PROOF_PARAMS_N_FRI_STEPS_OFFSET]),

            "Invalid proofParams.");

        uint256 logBlowupFactor = proofParams[PROOF_PARAMS_LOG_BLOWUP_FACTOR_OFFSET];

        require (logBlowupFactor <= 16, "logBlowupFactor must be at most 16");

        require (logBlowupFactor >= 1, "logBlowupFactor must be at least 1");



        uint256 proofOfWorkBits = proofParams[PROOF_PARAMS_PROOF_OF_WORK_BITS_OFFSET];

        require (proofOfWorkBits <= 50, "proofOfWorkBits must be at most 50");

        require (proofOfWorkBits >= minProofOfWorkBits, "minimum proofOfWorkBits not satisfied");

        require (proofOfWorkBits < numSecurityBits, "Proofs may not be purely based on PoW.");



        uint256 logFriLastLayerDegBound = (

            proofParams[PROOF_PARAMS_FRI_LAST_LAYER_DEG_BOUND_OFFSET]

        );

        require (

            logFriLastLayerDegBound <= 10, "logFriLastLayerDegBound must be at most 10.");



        uint256 nFriSteps = proofParams[PROOF_PARAMS_N_FRI_STEPS_OFFSET];

        require (nFriSteps <= 10, "Too many fri steps.");

        require (nFriSteps > 1, "Not enough fri steps.");



        uint256[] memory friSteps = new uint256[](nFriSteps);

        for (uint256 i = 0; i < nFriSteps; i++) {

            friSteps[i] = proofParams[PROOF_PARAMS_FRI_STEPS_OFFSET + i];

        }



        uint256 logTraceLength;

        (ctx, logTraceLength) = airSpecificInit(publicInput);



        validateFriParams(friSteps, logTraceLength, logFriLastLayerDegBound);



        uint256 friStepsPtr = getPtr(ctx, MM_FRI_STEPS_PTR);

        assembly {

            mstore(friStepsPtr, friSteps)

        }

        ctx[MM_FRI_LAST_LAYER_DEG_BOUND] = 2**logFriLastLayerDegBound;

        ctx[MM_TRACE_LENGTH] = 2 ** logTraceLength;



        ctx[MM_BLOW_UP_FACTOR] = 2**logBlowupFactor;

        ctx[MM_PROOF_OF_WORK_BITS] = proofOfWorkBits;



        uint256 nQueries = proofParams[PROOF_PARAMS_N_QUERIES_OFFSET];

        require (nQueries > 0, "Number of queries must be at least one");

        require (nQueries <= MAX_N_QUERIES, "Too many queries.");

        require (

            nQueries * logBlowupFactor + proofOfWorkBits >= numSecurityBits,

            "Proof params do not satisfy security requirements.");



        ctx[MM_N_UNIQUE_QUERIES] = nQueries;



        

        ctx[MM_LOG_EVAL_DOMAIN_SIZE] = logTraceLength + logBlowupFactor;

        ctx[MM_EVAL_DOMAIN_SIZE] = 2**ctx[MM_LOG_EVAL_DOMAIN_SIZE];



        uint256 gen_evalDomain = fpow(GENERATOR_VAL, (K_MODULUS - 1) / ctx[MM_EVAL_DOMAIN_SIZE]);

        ctx[MM_EVAL_DOMAIN_GENERATOR] = gen_evalDomain;

        uint256 genTraceDomain = fpow(gen_evalDomain, ctx[MM_BLOW_UP_FACTOR]);

        ctx[MM_TRACE_GENERATOR] = genTraceDomain;

    }



    function getPublicInputHash(uint256[] memory publicInput) internal pure returns (bytes32);



    function oodsConsistencyCheck(uint256[] memory ctx) internal view;



    function getNColumnsInTrace() internal pure returns(uint256);



    function getNColumnsInComposition() internal pure returns(uint256);



    function getMmCoefficients() internal pure returns(uint256);



    function getMmOodsValues() internal pure returns(uint256);



    function getMmOodsCoefficients() internal pure returns(uint256);



    function getNCoefficients() internal pure returns(uint256);



    function getNOodsValues() internal pure returns(uint256);



    function getNOodsCoefficients() internal pure returns(uint256);



    

    

    function getNColumnsInTrace0() internal pure returns(uint256) {

        return getNColumnsInTrace();

    }



    function getNColumnsInTrace1() internal pure returns(uint256) {

        return 0;

    }



    function getMmInteractionElements() internal pure returns(uint256) {

        require(false, "AIR does not support interaction.");

    }



    function getNInteractionElements() internal pure returns(uint256) {

        require(false, "AIR does not support interaction.");

    }



    function hasInteraction() internal pure returns (bool) {

        return getNColumnsInTrace1() > 0;

    }



    function hashRow(uint256[] memory ctx, uint256 offset, uint256 length)

    internal pure returns (uint256 res) {

        assembly {

            res := keccak256(add(add(ctx, 0x20), offset), length)

        }

        res &= getHashMask();

    }



    

    function adjustQueryIndicesAndPrepareEvalPoints(uint256[] memory ctx) internal view {

        uint256 nUniqueQueries = ctx[MM_N_UNIQUE_QUERIES];

        uint256 friQueue = getPtr(ctx, MM_FRI_QUEUE);

        uint256 friQueueEnd = friQueue + nUniqueQueries * 0x60;

        uint256 evalPointsPtr = getPtr(ctx, MM_OODS_EVAL_POINTS);

        uint256 log_evalDomainSize = ctx[MM_LOG_EVAL_DOMAIN_SIZE];

        uint256 evalDomainSize = ctx[MM_EVAL_DOMAIN_SIZE];

        uint256 evalDomainGenerator = ctx[MM_EVAL_DOMAIN_GENERATOR];



        assembly {

            

            function bitReverse(value, numberOfBits) -> res {

                

                

                

                res := value

                

                res := or(mul(and(res, 0x5555555555555555), 0x4),

                        and(res, 0xaaaaaaaaaaaaaaaa))

                

                res := or(mul(and(res, 0x6666666666666666), 0x10),

                        and(res, 0x19999999999999998))

                

                res := or(mul(and(res, 0x7878787878787878), 0x100),

                        and(res, 0x78787878787878780))

                

                res := or(mul(and(res, 0x7f807f807f807f80), 0x10000),

                        and(res, 0x7f807f807f807f8000))

                

                res := or(mul(and(res, 0x7fff80007fff8000), 0x100000000),

                        and(res, 0x7fff80007fff80000000))

                

                res := or(mul(and(res, 0x7fffffff80000000), 0x10000000000000000),

                        and(res, 0x7fffffff8000000000000000))

                

                res := div(res, exp(2, sub(127, numberOfBits)))

            }



            function expmod(base, exponent, modulus) -> res {

                let p := mload(0x40)

                mstore(p, 0x20)                 

                mstore(add(p, 0x20), 0x20)      

                mstore(add(p, 0x40), 0x20)      

                mstore(add(p, 0x60), base)      

                mstore(add(p, 0x80), exponent)  

                mstore(add(p, 0xa0), modulus)   

                

                if iszero(staticcall(gas, 0x05, p, 0xc0, p, 0x20)) {

                    revert(0, 0)

                }

                res := mload(p)

            }



            let PRIME := 0x800000000000011000000000000000000000000000000000000000000000001



            for {} lt(friQueue, friQueueEnd) {friQueue := add(friQueue, 0x60)} {

                let queryIdx := mload(friQueue)

                

                let adjustedQueryIdx := add(queryIdx, evalDomainSize)

                mstore(friQueue, adjustedQueryIdx)



                

                mstore(evalPointsPtr, expmod(evalDomainGenerator,

                                             bitReverse(queryIdx, log_evalDomainSize),

                                             PRIME))

                evalPointsPtr := add(evalPointsPtr, 0x20)

            }

        }

    }



    

    function readQueryResponsesAndDecommit(

        uint256[] memory ctx, uint256 nTotalColumns, uint256 nColumns, uint256 proofDataPtr,

        bytes32 merkleRoot)

         internal view {

        require(nColumns <= getNColumnsInTrace() + getNColumnsInComposition(), "Too many columns.");



        uint256 nUniqueQueries = ctx[MM_N_UNIQUE_QUERIES];

        uint256 channelPtr = getPtr(ctx, MM_CHANNEL);

        uint256 friQueue = getPtr(ctx, MM_FRI_QUEUE);

        uint256 friQueueEnd = friQueue + nUniqueQueries * 0x60;

        uint256 merkleQueuePtr = getPtr(ctx, MM_MERKLE_QUEUE);

        uint256 rowSize = 0x20 * nColumns;

        uint256 lhashMask = getHashMask();

        uint256 proofDataSkipBytes = 0x20 * (nTotalColumns - nColumns);



        assembly {

            let proofPtr := mload(channelPtr)

            let merklePtr := merkleQueuePtr



            for {} lt(friQueue, friQueueEnd) {friQueue := add(friQueue, 0x60)} {

                let merkleLeaf := and(keccak256(proofPtr, rowSize), lhashMask)

                if eq(rowSize, 0x20) {

                    

                    merkleLeaf := mload(proofPtr)

                }



                

                mstore(merklePtr, mload(friQueue))

                mstore(add(merklePtr, 0x20), merkleLeaf)

                merklePtr := add(merklePtr, 0x40)



                

                

                for {let proofDataChunk_end := add(proofPtr, rowSize)}

                        lt(proofPtr, proofDataChunk_end)

                        {proofPtr := add(proofPtr, 0x20)} {

                    mstore(proofDataPtr, mload(proofPtr))

                    proofDataPtr := add(proofDataPtr, 0x20)

                }

                proofDataPtr := add(proofDataPtr, proofDataSkipBytes)

            }



            mstore(channelPtr, proofPtr)

        }



        verify(channelPtr, merkleQueuePtr, merkleRoot, nUniqueQueries);

    }



    

    function computeFirstFriLayer(uint256[] memory ctx) internal view {

        adjustQueryIndicesAndPrepareEvalPoints(ctx);

        

        readQueryResponsesAndDecommit(

            ctx, getNColumnsInTrace(), getNColumnsInTrace0(), getPtr(ctx, MM_TRACE_QUERY_RESPONSES),

            bytes32(ctx[MM_TRACE_COMMITMENT]));

        



        if (hasInteraction()) {

            readQueryResponsesAndDecommit(

                ctx, getNColumnsInTrace(), getNColumnsInTrace1(),

                getPtr(ctx, MM_TRACE_QUERY_RESPONSES + getNColumnsInTrace0()),

                bytes32(ctx[MM_TRACE_COMMITMENT + 1]));

            

        }



        readQueryResponsesAndDecommit(

            ctx, getNColumnsInComposition(), getNColumnsInComposition(),

            getPtr(ctx, MM_COMPOSITION_QUERY_RESPONSES),

            bytes32(ctx[MM_OODS_COMMITMENT]));



        



        address oodsAddress = oodsContractAddress;

        uint256 friQueue = getPtr(ctx, MM_FRI_QUEUE);

        uint256 returnDataSize = MAX_N_QUERIES * 0x60;

        assembly {

            

            if iszero(staticcall(not(0), oodsAddress, ctx,

                                  mul(add(mload(ctx), 1), 0x20),

                                 friQueue, returnDataSize)) {

              returndatacopy(0, 0, returndatasize)

              revert(0, returndatasize)

            }

        }

        

    }



    

    function readLastFriLayer(uint256[] memory ctx)

        internal pure

    {

        uint256 lmmChannel = MM_CHANNEL;

        uint256 friLastLayerDegBound = ctx[MM_FRI_LAST_LAYER_DEG_BOUND];

        uint256 lastLayerPtr;

        uint256 badInput = 0;



        assembly {

            let primeMinusOne := 0x800000000000011000000000000000000000000000000000000000000000000

            let channelPtr := add(add(ctx, 0x20), mul(lmmChannel, 0x20))

            lastLayerPtr := mload(channelPtr)



            

            let length := mul(friLastLayerDegBound, 0x20)

            let lastLayerEnd := add(lastLayerPtr, length)

            for { let coefsPtr := lastLayerPtr } lt(coefsPtr, lastLayerEnd)

                { coefsPtr := add(coefsPtr, 0x20) } {

                badInput := or(badInput, gt(mload(coefsPtr), primeMinusOne))

            }



            

            

            

            

            let newDigestPtr := sub(lastLayerPtr, 0x20)

            let digestPtr := add(channelPtr, 0x20)

            

            mstore(newDigestPtr, mload(digestPtr))



            

            mstore(digestPtr, keccak256(newDigestPtr, add(length, 0x20)))

            

            mstore(add(channelPtr, 0x40), 0)



            

            mstore(channelPtr, lastLayerEnd)

        }



        require(badInput == 0, "Invalid field element.");

        ctx[MM_FRI_LAST_LAYER_PTR] = lastLayerPtr;

    }



    function verifyProof(

        uint256[] memory proofParams, uint256[] memory proof, uint256[] memory publicInput)

        internal view {

        

        uint256[] memory ctx = initVerifierParams(publicInput, proofParams);

        uint256 channelPtr = getChannelPtr(ctx);



        initChannel(channelPtr,  getProofPtr(proof), getPublicInputHash(publicInput));

        



        

        ctx[MM_TRACE_COMMITMENT] = uint256(readHash(channelPtr, true));



        if (hasInteraction()) {

            

            VerifierChannel.sendFieldElements(

                channelPtr, getNInteractionElements(), getPtr(ctx, getMmInteractionElements()));



            

            ctx[MM_TRACE_COMMITMENT + 1] = uint256(readHash(channelPtr, true));

        }



        VerifierChannel.sendFieldElements(

            channelPtr, getNCoefficients(), getPtr(ctx, getMmCoefficients()));

        



        ctx[MM_OODS_COMMITMENT] = uint256(readHash(channelPtr, true));



        

        VerifierChannel.sendFieldElements(channelPtr, 1, getPtr(ctx, MM_OODS_POINT));



        

        uint256 lmmOodsValues = getMmOodsValues();

        for (uint256 i = lmmOodsValues; i < lmmOodsValues+getNOodsValues(); i++) {

            ctx[i] = VerifierChannel.readFieldElement(channelPtr, true);

        }

        

        oodsConsistencyCheck(ctx);

        

        VerifierChannel.sendFieldElements(

            channelPtr, getNOodsCoefficients(), getPtr(ctx, getMmOodsCoefficients()));

        

        ctx[MM_FRI_COMMITMENTS] = uint256(VerifierChannel.readHash(channelPtr, true));



        uint256 nFriSteps = getFriSteps(ctx).length;

        uint256 fri_evalPointPtr = getPtr(ctx, MM_FRI_EVAL_POINTS);

        for (uint256 i = 1; i < nFriSteps - 1; i++) {

            VerifierChannel.sendFieldElements(channelPtr, 1, fri_evalPointPtr + i * 0x20);

            ctx[MM_FRI_COMMITMENTS + i] = uint256(VerifierChannel.readHash(channelPtr, true));

        }



        

        VerifierChannel.sendFieldElements(

            channelPtr, 1, getPtr(ctx, MM_FRI_EVAL_POINTS + nFriSteps - 1));



        

        readLastFriLayer(ctx);



        

        

        VerifierChannel.verifyProofOfWork(channelPtr, ctx[MM_PROOF_OF_WORK_BITS]);

        ctx[MM_N_UNIQUE_QUERIES] = VerifierChannel.sendRandomQueries(

            channelPtr, ctx[MM_N_UNIQUE_QUERIES], ctx[MM_EVAL_DOMAIN_SIZE] - 1,

            getPtr(ctx, MM_FRI_QUEUE), 0x60);

        



        computeFirstFriLayer(ctx);



        friVerifyLayers(ctx);

    }

}

contract CpuVerifier is StarkParameters, StarkVerifier, CpuPublicInputOffsets,

        CairoVerifierContract, MemoryPageFactRegistryConstants {

    CpuConstraintPoly constraintPoly;

    PeriodicColumnContract pedersenPointsX;

    PeriodicColumnContract pedersenPointsY;

    PeriodicColumnContract ecdsaPointsX;

    PeriodicColumnContract ecdsaPointsY;

    IFactRegistry memoryPageFactRegistry;



    constructor(

        address[] memory auxPolynomials,

        address oodsContract,

        address memoryPageFactRegistry_,

        uint256 numSecurityBits_,

        uint256 minProofOfWorkBits_)

        StarkVerifier(

            numSecurityBits_,

            minProofOfWorkBits_

        )

        public {

        constraintPoly = CpuConstraintPoly(auxPolynomials[0]);

        pedersenPointsX = PeriodicColumnContract(auxPolynomials[1]);

        pedersenPointsY = PeriodicColumnContract(auxPolynomials[2]);

        ecdsaPointsX = PeriodicColumnContract(auxPolynomials[3]);

        ecdsaPointsY = PeriodicColumnContract(auxPolynomials[4]);

        oodsContractAddress = oodsContract;

        memoryPageFactRegistry = IFactRegistry(memoryPageFactRegistry_);

    }



    function verifyProofExternal(

        uint256[] calldata proofParams, uint256[] calldata proof, uint256[] calldata publicInput)

        external {

        verifyProof(proofParams, proof, publicInput);

    }



    function getNColumnsInTrace() internal pure returns (uint256) {

        return N_COLUMNS_IN_MASK;

    }



    function getNColumnsInTrace0() internal pure returns (uint256) {

        return N_COLUMNS_IN_TRACE0;

    }



    function getNColumnsInTrace1() internal pure returns (uint256) {

        return N_COLUMNS_IN_TRACE1;

    }



    function getNColumnsInComposition() internal pure returns (uint256) {

        return CONSTRAINTS_DEGREE_BOUND;

    }



    function getMmInteractionElements() internal pure returns (uint256) {

        return MM_INTERACTION_ELEMENTS;

    }



    function getMmCoefficients() internal pure returns (uint256) {

        return MM_COEFFICIENTS;

    }



    function getMmOodsValues() internal pure returns (uint256) {

        return MM_OODS_VALUES;

    }



    function getMmOodsCoefficients() internal pure returns (uint256) {

        return MM_OODS_COEFFICIENTS;

    }



    function getNInteractionElements() internal pure returns (uint256) {

        return N_INTERACTION_ELEMENTS;

    }



    function getNCoefficients() internal pure returns (uint256) {

        return N_COEFFICIENTS;

    }



    function getNOodsValues() internal pure returns (uint256) {

        return N_OODS_VALUES;

    }



    function getNOodsCoefficients() internal pure returns (uint256) {

        return N_OODS_COEFFICIENTS;

    }



    function airSpecificInit(

        uint256[] memory publicInput

    ) internal view returns (uint256[] memory ctx, uint256 logTraceLength) {

        require(

            publicInput.length >= OFFSET_PUBLIC_MEMORY,

            "publicInput is too short.");

        ctx = new uint256[](MM_CONTEXT_SIZE);



        

        ctx[MM_OFFSET_SIZE] = 2**16;

        ctx[MM_HALF_OFFSET_SIZE] = 2**15;



        

        uint256 logNSteps = publicInput[OFFSET_LOG_N_STEPS];

        require(logNSteps < 50, "Number of steps is too large.");

        ctx[MM_LOG_N_STEPS] = logNSteps;

        logTraceLength = logNSteps + LOG_CPU_COMPONENT_HEIGHT;



        

        ctx[MM_RC_MIN] = publicInput[OFFSET_RC_MIN];

        ctx[MM_RC_MAX] = publicInput[OFFSET_RC_MAX];

        require(ctx[MM_RC_MIN] <= ctx[MM_RC_MAX], "rc_min must be <= rc_max");

        require(ctx[MM_RC_MAX] < ctx[MM_OFFSET_SIZE], "rc_max out of range");



        

        require(publicInput[OFFSET_LAYOUT_CODE] == LAYOUT_CODE, "Layout code mismatch.");



        

        ctx[MM_INITIAL_PC] = publicInput[OFFSET_PROGRAM_BEGIN_ADDR];

        ctx[MM_FINAL_PC] = publicInput[OFFSET_PROGRAM_STOP_PTR];

        

        

        require(ctx[MM_INITIAL_PC] == 0, "Invalid initial pc");

        require(ctx[MM_FINAL_PC] == 2, "Invalid final pc");



        

        ctx[MM_INITIAL_AP] = publicInput[OFFSET_EXECUTION_BEGIN_ADDR];

        ctx[MM_FINAL_AP] = publicInput[OFFSET_EXECUTION_STOP_PTR];



        {

        

        uint256 outputBeginAddr = publicInput[OFFSET_OUTPUT_BEGIN_ADDR];

        uint256 outputStopPtr = publicInput[OFFSET_OUTPUT_STOP_PTR];

        require(outputBeginAddr <= outputStopPtr, "output begin_addr must be <= stop_ptr");

        require(outputStopPtr < 2**64, "Out of range output stop_ptr.");

        }



        

        ctx[MM_INITIAL_CHECKPOINTS_ADDR] = publicInput[OFFSET_CHECKPOINTS_BEGIN_PTR];

        ctx[MM_FINAL_CHECKPOINTS_ADDR] = publicInput[OFFSET_CHECKPOINTS_STOP_PTR];

        require(

            ctx[MM_INITIAL_CHECKPOINTS_ADDR] <= ctx[MM_FINAL_CHECKPOINTS_ADDR],

            "checkpoints begin_addr must be <= stop_ptr");

        require(ctx[MM_FINAL_CHECKPOINTS_ADDR] < 2**64, "Out of range checkpoints stop_ptr.");

        require(

            (ctx[MM_FINAL_CHECKPOINTS_ADDR] - ctx[MM_INITIAL_CHECKPOINTS_ADDR]) % 2 == 0,

            "Checkpoints should occupy an even number of cells.");



        

        ctx[MM_INITIAL_PEDERSEN_ADDR] = publicInput[OFFSET_PEDERSEN_BEGIN_ADDR];

        require(ctx[MM_INITIAL_PEDERSEN_ADDR] < 2**64, "Out of range pedersen begin_addr.");

        uint256 pedersenStopPtr = publicInput[OFFSET_PEDERSEN_STOP_PTR];

        uint256 pedersenMaxStopPtr = ctx[MM_INITIAL_PEDERSEN_ADDR] + 3 * safeDiv(

            2 ** ctx[MM_LOG_N_STEPS], PEDERSEN_BUILTIN_RATIO);

        require(

            ctx[MM_INITIAL_PEDERSEN_ADDR] <= pedersenStopPtr &&

            pedersenStopPtr <= pedersenMaxStopPtr,

            "Invalid pedersen stop_ptr");



        

        ctx[MM_INITIAL_RC_ADDR] = publicInput[OFFSET_RANGE_CHECK_BEGIN_ADDR];

        require(ctx[MM_INITIAL_RC_ADDR] < 2**64, "Out of range range_check begin_addr.");

        uint256 rcStopPtr = publicInput[OFFSET_RANGE_CHECK_STOP_PTR];

        uint256 rcMaxStopPtr =

            ctx[MM_INITIAL_RC_ADDR] + safeDiv(2 ** ctx[MM_LOG_N_STEPS], RC_BUILTIN_RATIO);

        require(

            ctx[MM_INITIAL_RC_ADDR] <= rcStopPtr &&

            rcStopPtr <= rcMaxStopPtr,

            "Invalid range_check stop_ptr");



        

        ctx[MM_INITIAL_ECDSA_ADDR] = publicInput[OFFSET_ECDSA_BEGIN_ADDR];

        require(ctx[MM_INITIAL_ECDSA_ADDR] < 2**64, "Out of range ecdsa begin_addr.");

        uint256 ecdsaStopPtr = publicInput[OFFSET_ECDSA_STOP_PTR];

        uint256 ecdsaMaxStopPtr =

            ctx[MM_INITIAL_ECDSA_ADDR] + 2 * safeDiv(2 ** ctx[MM_LOG_N_STEPS], ECDSA_BUILTIN_RATIO);

        require(

            ctx[MM_INITIAL_ECDSA_ADDR] <= ecdsaStopPtr &&

            ecdsaStopPtr <= ecdsaMaxStopPtr,

            "Invalid ecdsa stop_ptr");



        

        require(

            publicInput[OFFSET_N_PUBLIC_MEMORY_PAGES] >= 1 &&

            publicInput[OFFSET_N_PUBLIC_MEMORY_PAGES] < 100000,

            "Invalid number of memory pages.");

        ctx[MM_N_PUBLIC_MEM_PAGES] = publicInput[OFFSET_N_PUBLIC_MEMORY_PAGES];



        {

        

        uint256 n_public_memory_entries = 0;

        for (uint256 page = 0; page < ctx[MM_N_PUBLIC_MEM_PAGES]; page++) {

            uint256 n_page_entries = publicInput[getOffsetPageSize(page)];

            require(n_page_entries < 2**30, "Too many public memory entries in one page.");

            n_public_memory_entries += n_page_entries;

        }

        ctx[MM_N_PUBLIC_MEM_ENTRIES] = n_public_memory_entries;

        }



        uint256 expectedPublicInputLength = getPublicInputLength(ctx[MM_N_PUBLIC_MEM_PAGES]);

        require(

            expectedPublicInputLength == publicInput.length,

            "Public input length mismatch.");



        uint256 lmmPublicInputPtr = MM_PUBLIC_INPUT_PTR;

        assembly {

            

            

            mstore(add(ctx, mul(add(lmmPublicInputPtr, 1), 0x20)), add(publicInput, 0x20))

        }



        

        ctx[MM_PEDERSEN__SHIFT_POINT_X] =

            0x49ee3eba8c1600700ee1b87eb599f16716b0b1022947733551fde4050ca6804;

        ctx[MM_PEDERSEN__SHIFT_POINT_Y] =

            0x3ca0cfe4b3bc6ddf346d49d06ea0ed34e621062c0e056c1d0405d266e10268a;



        ctx[MM_RC16__PERM__PUBLIC_MEMORY_PROD] = 1;

        ctx[MM_ECDSA__SIG_CONFIG_ALPHA] = 1;

        ctx[MM_ECDSA__SIG_CONFIG_BETA] =

            0x6f21413efbe40de150e596d72f7a8c5609ad26c15c915c1f4cdfcb99cee9e89;

        ctx[MM_ECDSA__SIG_CONFIG_SHIFT_POINT_X] =

            0x49ee3eba8c1600700ee1b87eb599f16716b0b1022947733551fde4050ca6804;

        ctx[MM_ECDSA__SIG_CONFIG_SHIFT_POINT_Y] =

            0x3ca0cfe4b3bc6ddf346d49d06ea0ed34e621062c0e056c1d0405d266e10268a;



    }



    function getPublicInputHash(uint256[] memory publicInput)

        internal pure

        returns (bytes32 publicInputHash) {



        

        

        

        uint256 nPages = publicInput[OFFSET_N_PUBLIC_MEMORY_PAGES];

        uint256 publicInputSizeForHash = 0x20 * (getOffsetPaddingCell(nPages) + 2);



        assembly {

            publicInputHash := keccak256(add(publicInput, 0x20), publicInputSizeForHash)

        }

    }



    function getCoefficients(uint256[] memory ctx)

        internal

        pure

        returns (uint256[N_COEFFICIENTS] memory coefficients)

    {

        uint256 offset = 0x20 + MM_COEFFICIENTS * 0x20;

        assembly {

            coefficients := add(ctx, offset)

        }

        return coefficients;

    }



    

    function computePublicMemoryQuotient(uint256[] memory ctx) internal view returns (uint256) {

        uint256 nValues = ctx[MM_N_PUBLIC_MEM_ENTRIES];

        uint256 z = ctx[MM_MEMORY__MULTI_COLUMN_PERM__PERM__INTERACTION_ELM];

        uint256 alpha = ctx[MM_MEMORY__MULTI_COLUMN_PERM__HASH_INTERACTION_ELM0];

        

        uint256 publicMemorySize = safeDiv(ctx[MM_TRACE_LENGTH], PUBLIC_MEMORY_STEP);



        require(nValues < 0x1000000, "Overflow protection failed.");

        require(nValues <= publicMemorySize, "Number of values of public memory is too large.");



        uint256 nPublicMemoryPages = ctx[MM_N_PUBLIC_MEM_PAGES];

        uint256 cumulativeProdsPtr =

            ctx[MM_PUBLIC_INPUT_PTR] + getOffsetPageProd(0, nPublicMemoryPages) * 0x20;

        uint256 denominator = computePublicMemoryProd(

            cumulativeProdsPtr, nPublicMemoryPages, K_MODULUS);



        

        uint256 publicInputPtr = ctx[MM_PUBLIC_INPUT_PTR];

        uint256 paddingOffset = getOffsetPaddingCell(nPublicMemoryPages);

        uint256 paddingAddr;

        uint256 paddingValue;

        assembly {

            paddingAddr := mload(

                add(publicInputPtr, mul(0x20, paddingOffset)))

            paddingValue := mload(

                add(publicInputPtr, mul(0x20, add(paddingOffset, 1))))

        }

        uint256 hash_first_address_value = fadd(paddingAddr, fmul(paddingValue, alpha));



        

        uint256 denom_pad = fpow(

            fsub(z, hash_first_address_value),

            publicMemorySize - nValues);

        denominator = fmul(denominator, denom_pad);



        

        uint256 numerator = fpow(z, publicMemorySize);



        

        return fmul(numerator, inverse(denominator));

    }



    

    function computePublicMemoryProd(

        uint256 cumulativeProdsPtr, uint256 nPublicMemoryPages, uint256 prime)

        internal pure returns (uint256 res)

    {

        assembly {

            let lastPtr := add(cumulativeProdsPtr, mul(nPublicMemoryPages, 0x20))

            res := 1

            for { let ptr := cumulativeProdsPtr } lt(ptr, lastPtr) { ptr := add(ptr, 0x20) } {

                res := mulmod(res, mload(ptr), prime)

            }

        }

    }



    

    function verifyMemoryPageFacts(uint256[] memory ctx) internal view {

        uint256 nPublicMemoryPages = ctx[MM_N_PUBLIC_MEM_PAGES];



        for (uint256 page = 0; page < nPublicMemoryPages; page++) {

            

            uint256 memoryHashPtr = ctx[MM_PUBLIC_INPUT_PTR] + getOffsetPageHash(page) * 0x20;

            uint256 memoryHash;



            uint256 prodPtr = ctx[MM_PUBLIC_INPUT_PTR] +

                getOffsetPageProd(page, nPublicMemoryPages) * 0x20;

            uint256 prod;



            uint256 pageSizePtr = ctx[MM_PUBLIC_INPUT_PTR] + getOffsetPageSize(page) * 0x20;

            uint256 pageSize;



            assembly {

                pageSize := mload(pageSizePtr)

                prod := mload(prodPtr)

                memoryHash := mload(memoryHashPtr)

            }



            uint256 pageAddr = 0;

            if (page > 0) {

                uint256 pageAddrPtr = ctx[MM_PUBLIC_INPUT_PTR] + getOffsetPageAddr(page) * 0x20;

                assembly {

                    pageAddr := mload(pageAddrPtr)

                }

            }



            

            

            bytes32 factHash = keccak256(

                abi.encodePacked(

                    page == 0 ? REGULAR_PAGE : CONTINUOUS_PAGE,

                    K_MODULUS,

                    pageSize,

                    ctx[MM_INTERACTION_ELEMENTS],

                    ctx[MM_INTERACTION_ELEMENTS + 1],

                    prod,

                    memoryHash,

                    pageAddr)

            );



            require(  

                memoryPageFactRegistry.isValid(factHash), "Memory page fact was not registered.");

        }

    }



    

    function oodsConsistencyCheck(uint256[] memory ctx) internal view {

        verifyMemoryPageFacts(ctx);



        uint256 oodsPoint = ctx[MM_OODS_POINT];



        

        

        uint256 nPedersenHashCopies = safeDiv(

            2 ** ctx[MM_LOG_N_STEPS],

            PEDERSEN_BUILTIN_RATIO * PEDERSEN_BUILTIN_REPETITIONS);

        uint256 zPointPowPedersen = fpow(oodsPoint, nPedersenHashCopies);



        ctx[MM_PERIODIC_COLUMN__PEDERSEN__POINTS__X] = pedersenPointsX.compute(zPointPowPedersen);

        ctx[MM_PERIODIC_COLUMN__PEDERSEN__POINTS__Y] = pedersenPointsY.compute(zPointPowPedersen);



        

        

        uint256 nEcdsaSignatureCopies = safeDiv(

            2 ** ctx[MM_LOG_N_STEPS],

            ECDSA_BUILTIN_RATIO * ECDSA_BUILTIN_REPETITIONS);

        uint256 zPointPowEcdsa = fpow(oodsPoint, nEcdsaSignatureCopies);



        ctx[MM_PERIODIC_COLUMN__ECDSA__GENERATOR_POINTS__X] = ecdsaPointsX.compute(zPointPowEcdsa);

        ctx[MM_PERIODIC_COLUMN__ECDSA__GENERATOR_POINTS__Y] = ecdsaPointsY.compute(zPointPowEcdsa);



        ctx[MM_MEMORY__MULTI_COLUMN_PERM__PERM__INTERACTION_ELM] = ctx[MM_INTERACTION_ELEMENTS];

        ctx[MM_MEMORY__MULTI_COLUMN_PERM__HASH_INTERACTION_ELM0] = ctx[MM_INTERACTION_ELEMENTS + 1];

        ctx[MM_RC16__PERM__INTERACTION_ELM] = ctx[MM_INTERACTION_ELEMENTS + 2];



        uint256 public_memory_prod = computePublicMemoryQuotient(ctx);



        ctx[MM_MEMORY__MULTI_COLUMN_PERM__PERM__PUBLIC_MEMORY_PROD] = public_memory_prod;



        uint256 compositionFromTraceValue;

        address lconstraintPoly = address(constraintPoly);

        uint256 offset = 0x20 * (1 + MM_CONSTRAINT_POLY_ARGS_START);

        uint256 size = 0x20 *

            (MM_CONSTRAINT_POLY_ARGS_END - MM_CONSTRAINT_POLY_ARGS_START);

        assembly {

            

            let p := mload(0x40)

            if iszero(

                staticcall(

                    not(0),

                    lconstraintPoly,

                    add(ctx, offset),

                    size,

                    p,

                    0x20

                )

            ) {

                returndatacopy(0, 0, returndatasize)

                revert(0, returndatasize)

            }

            compositionFromTraceValue := mload(p)

        }



        uint256 claimedComposition = fadd(

            ctx[MM_OODS_VALUES + MASK_SIZE],

            fmul(oodsPoint, ctx[MM_OODS_VALUES + MASK_SIZE + 1])

        );



        require(

            compositionFromTraceValue == claimedComposition,

            "claimedComposition does not match trace"

        );

    }



    function safeDiv(uint256 numerator, uint256 denominator) internal pure returns (uint256) {

        require(denominator > 0, "The denominator must not be zero");

        require(numerator % denominator == 0, "The numerator is not divisible by the denominator.");

        return numerator / denominator;

    }

}

contract CpuFrilessVerifier is

    CpuVerifier,

    MerkleStatementVerifier,

    FriStatementVerifier

{

    constructor(

        address[] memory auxPolynomials,

        address oodsContract,

        address memoryPageFactRegistry_,

        address merkleStatementContractAddress,

        address friStatementContractAddress,

        uint256 numSecurityBits_,

        uint256 minProofOfWorkBits_

    )

        public

        MerkleStatementVerifier(merkleStatementContractAddress)

        FriStatementVerifier(friStatementContractAddress)

        CpuVerifier(

            auxPolynomials,

            oodsContract,

            memoryPageFactRegistry_,

            numSecurityBits_,

            minProofOfWorkBits_

        )

    {

        

    }

}
