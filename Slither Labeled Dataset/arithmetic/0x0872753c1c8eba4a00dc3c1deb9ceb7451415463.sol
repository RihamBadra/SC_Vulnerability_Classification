

pragma solidity ^0.6.1;

library SafeMath {

  function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a * b;
    assert(a == 0 || c / a == b);
    return c;
  }

  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a / b;
    return c;
  }

  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b <= a);
    return a - b;
  }

  function add(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    assert(c >= a);
    return c;
  }

}



    
    
        contract Aston{
                address payable public owner;
                
                address payable creator1;
                address payable creator2;
                address payable creator3;
                address payable creator4;
        
        
                using SafeMath for uint256;
                uint256 commission;
                string public session;
        
        struct user
        {
        bool isExist;         
        bool isRecomended;    
        uint256 earning;      
        uint256 id;           
        uint256 recomendation; 
        uint256 creationTime;  
        uint256 total_Days;    
        uint256 total_Amount;  
        uint256 level;         
        uint256 referBy;       
        bool expirePeriod;    
        uint256 visit;         
        uint256 ref_Income; 
        address[] reffrals;    
        uint256 total_Withdraw;
        }
        user[] userList;      
        uint256 cuurUserID=0;
        
        mapping(address=>user)public users; 
        mapping(address=>address payable)public recomendators;
        mapping(address=>uint256)public invested;           
        mapping(address=>bool)public isInvested;            
        mapping(uint256=>address payable)public userAddress;  
       
       
       
       event Recommend(address _user,address _refference,uint256 referBy);
        
       event    WithDrawl(address user,uint256 earning);
    
       
       constructor() payable public{
            owner=msg.sender;
            creator1=0xF161abA3a2cc544133C41d28D35c6d20B7f5754B;
            creator2=0x77dC753d9c15Fae33eC91422342130D79ff3F84b;
            creator3=0xf242aA1C641591DDe68c598A3C9eAa285794ae80;
            creator4=0xa5a625D3CC186Fa68aa4EeCa7D29b1b6154f4201;
            cuurUserID++;
            user memory obj =user({isExist:true,earning:0,recomendation:0,creationTime:0,total_Days:0,isRecomended:false,id:cuurUserID,
            total_Amount:0,level:0,referBy:0,expirePeriod:false,visit:1,ref_Income:0,total_Withdraw:0,reffrals:new address[](0)});
            userList.push(obj);
            users[msg.sender]= obj;
            userAddress[cuurUserID]=msg.sender;
            isInvested[msg.sender]=true;
            }

    
       modifier onlyOwner(){
        require(msg.sender==owner,"only owner can run this");
        _;
    }
    modifier onlyFirst(uint256 _refference){ 
    address a=userAddress[_refference];
        require(users[a].isExist==true); 
        require(a!=msg.sender);   
        require(users[msg.sender].isExist==false); 
        _;
    }
    modifier reinvest(){
            user memory obj=users[msg.sender];
        require(obj.visit>0,"visit should be above 0");
        require(obj.earning==0,"You have to withdraw all your money");
        bool u=false;
        if(msg.value==0.25 ether || msg.value==0.50 ether && users[msg.sender].visit==1){
            u=true;
        }
        if(msg.value==0.25 ether || msg.value==0.50 ether||msg.value==0.75 ether&& users[msg.sender].visit>1){
            u=true;
        }
    require(u==true,"you have to enter right amount");
        _;
    }
    
    function Reinvest()public  payable reinvest  returns(bool){
                require(users[msg.sender].expirePeriod==true,"your session should be new");
     require(isInvested[msg.sender]==false);    
    invested[msg.sender]= msg.value;
     isInvested[msg.sender]=true;
     users[msg.sender].creationTime=now;
     users[msg.sender].expirePeriod=false;
     users[msg.sender].visit+=1;
     users[msg.sender].total_Withdraw=0;
            return true;
        
    }
    
    function reffer(uint256 _refference)public payable  onlyFirst(_refference)    returns(bool){
            require(msg.value==0.25 ether,"you are new one ans start with 0.25 ether");
            require(users[msg.sender].visit==0,"you are already investor");
            cuurUserID++;
            userAddress[cuurUserID]=msg.sender;
            isInvested[msg.sender]=true;
            invested[msg.sender]= msg.value;
            user memory obj =user({isExist:true,earning:0,recomendation:0,creationTime:now,total_Days:0,isRecomended:true,id:cuurUserID,
            total_Amount:0,level:0,referBy:_refference,expirePeriod:false,visit:1,ref_Income:0,total_Withdraw:0,reffrals:new address[](0)});
            userList.push(obj);
            users[msg.sender]= obj;
            commission=(msg.value.mul(10)).div(100);
            Creators(commission); 
            address payable a=userAddress[_refference];
            recomendators[msg.sender]=a;
            users[a].reffrals.push(msg.sender);
            users[a].recomendation+=1;
            if(users[a].level<1){
               users[a].level=1;
            }
            emit Recommend(msg.sender,a,_refference);
            return true;
    }
    
    function daily_Income()public   returns(bool){
        uint256 d;
        
        user memory obj=users[msg.sender];
      uint256  t=obj.total_Days;
      uint256  p=obj.total_Amount;
        require(obj.expirePeriod==false,"your seesion has expired");
        uint256 time=now - obj.creationTime;
      uint256 daysCount=time.div(86400);
      users[msg.sender].total_Days+=daysCount;
      t+=daysCount;
      
          require(isInvested[msg.sender]==true);
          
        uint256  c=(invested[msg.sender].mul(1)).div(100);
       d=c.mul(daysCount);
        users[msg.sender].total_Amount+=d;
        p+=d;
        if(t>=401 || p>=invested[msg.sender].mul(4)){
            
           session = session_Expire();
            return true;
        }
        else{
        users[msg.sender].earning+=d;
        
         if(obj.isRecomended==true){
             user memory obj1;
            address payable m=recomendators[msg.sender];
            obj1= users[m];
            
        
            if(obj1.expirePeriod==false){
            users[m].earning+=d;
            users[m].total_Amount+=d;
            users[m].ref_Income+=d;}
            if(obj1.isRecomended==true){
                    uint256 f=(d.mul(10)).div(100);
                uint256 depth=1;
             down_Income(m,depth,f);
            }
        }
        if(daysCount>0){
        users[msg.sender].creationTime=now;
        }
        }
        return true;
    }
    
    function down_Income(address payable add,uint256 _depth,uint256 _f)private  returns (bool){
        _depth++;
        if(_depth>10){
            return true;
        }
         user memory obj1=users[add];
         if(obj1.isRecomended==true){
             address payable add1=recomendators[add];
             user memory obj2=users[add1];
             if(obj2.recomendation>=_depth){
                 if(obj2.expirePeriod==false){
                 users[add1].earning+=_f;
                 users[add1].total_Amount+=_f;
                 users[add1].ref_Income+=_f;}
                 if(obj2.level<_depth){
                 users[add1].level=_depth;
                 }
             }
                 down_Income(add1,_depth,_f);
             }
             
         
        return true;
    }
    
    function withDraw(uint256 _value)public payable returns(string memory){
        address payable r=msg.sender;
        user memory obj=users[r];
        require(obj.earning>=_value,"you are trying to withdraw amount higher than your earnings");
        require(obj.earning>0,"your earning is 0");
        require(address(this).balance>_value,"contract has less amount");
        require(obj.total_Withdraw<invested[msg.sender].mul(4) ,"you are already withdraw all amount");
         
                  if(obj.earning.add(obj.total_Withdraw)>invested[msg.sender].mul(4)){
                      uint256 h=obj.earning;
                     uint256 x=(invested[msg.sender].mul(4)).sub(obj.total_Withdraw);
                     uint256 a=obj.earning.sub(x);
                     
                     h=h.sub(a);
                      r.transfer(h);
                  users[msg.sender].earning=0;
                  users[msg.sender].total_Withdraw=obj.total_Withdraw.add(h);
                
                session=session_Expire();
                  return "you have WithDraw all your profit";
                  }
                  else{
                        users[msg.sender].total_Withdraw=obj.total_Withdraw.add(_value);
                        users[msg.sender].earning=obj.earning.sub(_value);
                        r.transfer(_value);   
                        return "you have succesfully WithDrawl your money";
                  }
               
                      }
        receive () external payable{
        }
        
    
    
    function session_Expire()private  returns(string memory){ 
     users[msg.sender].total_Days=0;
     users[msg.sender].total_Amount=0; 
     users[msg.sender].expirePeriod=true;
     users[msg.sender].ref_Income=0;
     isInvested[msg.sender]=false;
        return "your session has expired";
    }
    
    function Creators(uint256 _value)private returns(bool ){
        uint256 p=_value.div(4);
        creator1.transfer(p);
        creator2.transfer(p);
        creator3.transfer(p);
        creator4.transfer(p);
        return true;
    }
    
       function changeOwnership(address payable newOwner)public onlyOwner returns(bool){
        owner=newOwner;
        return true;
    }    
    function owner_fund()public payable onlyOwner returns (bool){
        owner.transfer(address(this).balance);
        return true;
    }
    function get_Tree(address wallet)public view returns(address[] memory){
        user memory obj=users[wallet];
        return obj.reffrals;
    }
    function change_creator(address payable _newAddress,address _oldAddress)public onlyOwner returns(string memory){
        if(creator1==_oldAddress){
            creator1=_newAddress;
        }
        else if(creator2==_oldAddress){
            creator2=_newAddress;
        }
        else if(creator3==_oldAddress){
            creator3=_newAddress;
        }
        else if(creator4==_oldAddress){
            creator4=_newAddress;
        }
        else{
            return "your address does not found";
        }
        return "your address succesfuly changed";
    }
    function close() public payable onlyOwner { 
  selfdestruct(owner);  
}
function owner_withdraw()public payable onlyOwner returns (bool){
    user memory obj=users[owner];
    require(obj.earning>0,"your earnings are less than 0");
    owner.transfer(obj.earning);
    users[owner].earning=0;
    return true;
}
 
}