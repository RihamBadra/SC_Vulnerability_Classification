pragma solidity 0.6.12;

abstract contract Context {

    function _msgSender() internal view virtual returns (address payable) {

        return msg.sender;

    }



    function _msgData() internal view virtual returns (bytes memory) {

        this; 

        return msg.data;

    }

}

interface IContractRegistry {



	event ContractAddressUpdated(string contractName, address addr, bool managedContract);

	event ManagerChanged(string role, address newManager);

	event ContractRegistryUpdated(address newContractRegistry);



	



	

	

	function setContract(string calldata contractName, address addr, bool managedContract) external ;



	

	function getContract(string calldata contractName) external view returns (address);



	

	function getManagedContracts() external view returns (address[] memory);



	function setManager(string calldata role, address manager) external ;



	function getManager(string calldata role) external view returns (address);



	function lockContracts() external ;



	function unlockContracts() external ;



	function setNewContractRegistry(IContractRegistry newRegistry) external ;



	function getPreviousContractRegistry() external view returns (address);



}

interface IERC20 {

    

    function totalSupply() external view returns (uint256);



    

    function balanceOf(address account) external view returns (uint256);



    

    function transfer(address recipient, uint256 amount) external returns (bool);



    

    function allowance(address owner, address spender) external view returns (uint256);



    

    function approve(address spender, uint256 amount) external returns (bool);



    

    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);



    

    event Transfer(address indexed from, address indexed to, uint256 value);



    

    event Approval(address indexed owner, address indexed spender, uint256 value);

}

interface ILockable {



    event Locked();

    event Unlocked();



    function lock() external ;

    function unlock() external ;

    function isLocked() view external returns (bool);



}

interface IMigratableStakingContract {

    

    

    function getToken() external view returns (IERC20);



    

    

    

    

    function acceptMigration(address _stakeOwner, uint256 _amount) external;



    event AcceptedMigration(address indexed stakeOwner, uint256 amount, uint256 totalStakedAmount);

}

interface IStakeChangeNotifier {

    

    

    

    

    

    function stakeChange(address _stakeOwner, uint256 _amount, bool _sign, uint256 _updatedStake) external;



    

    

    

    

    

    function stakeChangeBatch(address[] calldata _stakeOwners, uint256[] calldata _amounts, bool[] calldata _signs,

        uint256[] calldata _updatedStakes) external;



    

    

    

    function stakeMigration(address _stakeOwner, uint256 _amount) external;

}

interface IStakingContract {

    

    

    

    function stake(uint256 _amount) external;



    

    

    

    function unstake(uint256 _amount) external;



    

    

    

    function withdraw() external;



    

    function restake() external;



    

    

    

    

    

    

    

    function distributeRewards(uint256 _totalAmount, address[] calldata _stakeOwners, uint256[] calldata _amounts) external;



    

    

    

    function getStakeBalanceOf(address _stakeOwner) external view returns (uint256);



    

    

    function getTotalStakedTokens() external view returns (uint256);



    

    

    

    

    function getUnstakeStatus(address _stakeOwner) external view returns (uint256 cooldownAmount,

        uint256 cooldownEndTime);



    

    

    

    function migrateStakedTokens(IMigratableStakingContract _newStakingContract, uint256 _amount) external;



    event Staked(address indexed stakeOwner, uint256 amount, uint256 totalStakedAmount);

    event Unstaked(address indexed stakeOwner, uint256 amount, uint256 totalStakedAmount);

    event Withdrew(address indexed stakeOwner, uint256 amount, uint256 totalStakedAmount);

    event Restaked(address indexed stakeOwner, uint256 amount, uint256 totalStakedAmount);

    event MigratedStake(address indexed stakeOwner, uint256 amount, uint256 totalStakedAmount);

}

interface IStakingContractHandler {

    event StakeChangeNotificationSkipped(address indexed stakeOwner);

    event StakeChangeBatchNotificationSkipped(address[] stakeOwners);

    event StakeMigrationNotificationSkipped(address indexed stakeOwner);



    



    

    

    

    function getStakeBalanceOf(address _stakeOwner) external view returns (uint256);



    

    

    function getTotalStakedTokens() external view returns (uint256);



    



    event NotifyDelegationsChanged(bool notifyDelegations);



    function setNotifyDelegations(bool notifyDelegations) external; 



    function getNotifyDelegations() external returns (bool);

}

contract Initializable {



    address private _initializationAdmin;



    event InitializationComplete();



    constructor() public{

        _initializationAdmin = msg.sender;

    }



    modifier onlyInitializationAdmin() {

        require(msg.sender == initializationAdmin(), "sender is not the initialization admin");



        _;

    }



    



    function initializationAdmin() public view returns (address) {

        return _initializationAdmin;

    }



    function initializationComplete() external onlyInitializationAdmin {

        _initializationAdmin = address(0);

        emit InitializationComplete();

    }



    function isInitializationComplete() public view returns (bool) {

        return _initializationAdmin == address(0);

    }



}

contract WithClaimableRegistryManagement is Context {

    address private _registryAdmin;

    address private _pendingRegistryAdmin;



    event RegistryManagementTransferred(address indexed previousRegistryAdmin, address indexed newRegistryAdmin);



    

    constructor () internal {

        address msgSender = _msgSender();

        _registryAdmin = msgSender;

        emit RegistryManagementTransferred(address(0), msgSender);

    }



    

    function registryAdmin() public view returns (address) {

        return _registryAdmin;

    }



    

    modifier onlyRegistryAdmin() {

        require(isRegistryAdmin(), "WithClaimableRegistryManagement: caller is not the registryAdmin");

        _;

    }



    

    function isRegistryAdmin() public view returns (bool) {

        return _msgSender() == _registryAdmin;

    }



    

    function renounceRegistryManagement() public onlyRegistryAdmin {

        emit RegistryManagementTransferred(_registryAdmin, address(0));

        _registryAdmin = address(0);

    }



    

    function _transferRegistryManagement(address newRegistryAdmin) internal {

        require(newRegistryAdmin != address(0), "RegistryAdmin: new registryAdmin is the zero address");

        emit RegistryManagementTransferred(_registryAdmin, newRegistryAdmin);

        _registryAdmin = newRegistryAdmin;

    }



    

    modifier onlyPendingRegistryAdmin() {

        require(msg.sender == _pendingRegistryAdmin, "Caller is not the pending registryAdmin");

        _;

    }

    

    function transferRegistryManagement(address newRegistryAdmin) public onlyRegistryAdmin {

        _pendingRegistryAdmin = newRegistryAdmin;

    }



    

    function claimRegistryManagement() external onlyPendingRegistryAdmin {

        _transferRegistryManagement(_pendingRegistryAdmin);

        _pendingRegistryAdmin = address(0);

    }



    

    function pendingRegistryAdmin() public view returns (address) {

       return _pendingRegistryAdmin;  

    }

}

contract ContractRegistryAccessor is WithClaimableRegistryManagement, Initializable {



    IContractRegistry private contractRegistry;



    constructor(IContractRegistry _contractRegistry, address _registryAdmin) public {

        require(address(_contractRegistry) != address(0), "_contractRegistry cannot be 0");

        setContractRegistry(_contractRegistry);

        _transferRegistryManagement(_registryAdmin);

    }



    modifier onlyAdmin {

        require(isAdmin(), "sender is not an admin (registryManger or initializationAdmin)");



        _;

    }



    function isManager(string memory role) internal view returns (bool) {

        IContractRegistry _contractRegistry = contractRegistry;

        return isAdmin() || _contractRegistry != IContractRegistry(0) && contractRegistry.getManager(role) == msg.sender;

    }



    function isAdmin() internal view returns (bool) {

        return msg.sender == registryAdmin() || msg.sender == initializationAdmin() || msg.sender == address(contractRegistry);

    }



    function getProtocolContract() internal view returns (address) {

        return contractRegistry.getContract("protocol");

    }



    function getStakingRewardsContract() internal view returns (address) {

        return contractRegistry.getContract("stakingRewards");

    }



    function getFeesAndBootstrapRewardsContract() internal view returns (address) {

        return contractRegistry.getContract("feesAndBootstrapRewards");

    }



    function getCommitteeContract() internal view returns (address) {

        return contractRegistry.getContract("committee");

    }



    function getElectionsContract() internal view returns (address) {

        return contractRegistry.getContract("elections");

    }



    function getDelegationsContract() internal view returns (address) {

        return contractRegistry.getContract("delegations");

    }



    function getGuardiansRegistrationContract() internal view returns (address) {

        return contractRegistry.getContract("guardiansRegistration");

    }



    function getCertificationContract() internal view returns (address) {

        return contractRegistry.getContract("certification");

    }



    function getStakingContract() internal view returns (address) {

        return contractRegistry.getContract("staking");

    }



    function getSubscriptionsContract() internal view returns (address) {

        return contractRegistry.getContract("subscriptions");

    }



    function getStakingRewardsWallet() internal view returns (address) {

        return contractRegistry.getContract("stakingRewardsWallet");

    }



    function getBootstrapRewardsWallet() internal view returns (address) {

        return contractRegistry.getContract("bootstrapRewardsWallet");

    }



    function getGeneralFeesWallet() internal view returns (address) {

        return contractRegistry.getContract("generalFeesWallet");

    }



    function getCertifiedFeesWallet() internal view returns (address) {

        return contractRegistry.getContract("certifiedFeesWallet");

    }



    function getStakingContractHandler() internal view returns (address) {

        return contractRegistry.getContract("stakingContractHandler");

    }



    



    event ContractRegistryAddressUpdated(address addr);



    function setContractRegistry(IContractRegistry newContractRegistry) public onlyAdmin {

        require(newContractRegistry.getPreviousContractRegistry() == address(contractRegistry), "new contract registry must provide the previous contract registry");

        contractRegistry = newContractRegistry;

        emit ContractRegistryAddressUpdated(address(newContractRegistry));

    }



    function getContractRegistry() public view returns (IContractRegistry) {

        return contractRegistry;

    }



}

contract Lockable is ILockable, ContractRegistryAccessor {



    bool public locked;



    constructor(IContractRegistry _contractRegistry, address _registryAdmin) ContractRegistryAccessor(_contractRegistry, _registryAdmin) public {}



    modifier onlyLockOwner() {

        require(msg.sender == registryAdmin() || msg.sender == address(getContractRegistry()), "caller is not a lock owner");



        _;

    }



    function lock() external override onlyLockOwner {

        locked = true;

        emit Locked();

    }



    function unlock() external override onlyLockOwner {

        locked = false;

        emit Unlocked();

    }



    function isLocked() external override view returns (bool) {

        return locked;

    }



    modifier onlyWhenActive() {

        require(!locked, "contract is locked for this operation");



        _;

    }

}

contract ManagedContract is Lockable {



    constructor(IContractRegistry _contractRegistry, address _registryAdmin) Lockable(_contractRegistry, _registryAdmin) public {}



    modifier onlyMigrationManager {

        require(isManager("migrationManager"), "sender is not the migration manager");



        _;

    }



    modifier onlyFunctionalManager {

        require(isManager("functionalManager"), "sender is not the functional manager");



        _;

    }



    function refreshContracts() virtual external {}



}

contract StakingContractHandler is IStakingContractHandler, IStakeChangeNotifier, ManagedContract {



    bool notifyDelegations = true;



    constructor(IContractRegistry _contractRegistry, address _registryAdmin) public ManagedContract(_contractRegistry, _registryAdmin) {}



    modifier onlyStakingContract() {

        require(msg.sender == address(getStakingContract()), "caller is not the staking contract");



        _;

    }



    



    function stakeChange(address stakeOwner, uint256 amount, bool sign, uint256 updatedStake) external override onlyStakingContract {

        if (!notifyDelegations) {

            emit StakeChangeNotificationSkipped(stakeOwner);

            return;

        }



        delegationsContract.stakeChange(stakeOwner, amount, sign, updatedStake);

    }



    

    

    

    

    

    function stakeChangeBatch(address[] calldata stakeOwners, uint256[] calldata amounts, bool[] calldata signs, uint256[] calldata updatedStakes) external override onlyStakingContract {

        if (!notifyDelegations) {

            emit StakeChangeBatchNotificationSkipped(stakeOwners);

            return;

        }



        delegationsContract.stakeChangeBatch(stakeOwners, amounts, signs, updatedStakes);

    }



    

    

    

    function stakeMigration(address stakeOwner, uint256 amount) external override onlyStakingContract {

        if (!notifyDelegations) {

            emit StakeMigrationNotificationSkipped(stakeOwner);

            return;

        }



        delegationsContract.stakeMigration(stakeOwner, amount);

    }



    

    

    

    function getStakeBalanceOf(address stakeOwner) external override view returns (uint256) {

        return stakingContract.getStakeBalanceOf(stakeOwner);

    }



    

    

    function getTotalStakedTokens() external override view returns (uint256) {

        return stakingContract.getTotalStakedTokens();

    }



    



    function setNotifyDelegations(bool _notifyDelegations) external override onlyMigrationManager {

        notifyDelegations = _notifyDelegations;

        emit NotifyDelegationsChanged(_notifyDelegations);

    }



    function getNotifyDelegations() external override returns (bool) {

        return notifyDelegations;

    }



    



    IStakeChangeNotifier delegationsContract;

    IStakingContract stakingContract;

    function refreshContracts() external override {

        delegationsContract = IStakeChangeNotifier(getDelegationsContract());

        stakingContract = IStakingContract(getStakingContract());

    }

}
