pragma solidity 0.6.5;
pragma experimental ABIEncoderV2;

struct ProtocolBalance {

    ProtocolMetadata metadata;

    AdapterBalance[] adapterBalances;

}

struct ProtocolMetadata {

    string name;

    string description;

    string websiteURL;

    string iconURL;

    uint256 version;

}

struct AdapterBalance {

    AdapterMetadata metadata;

    FullTokenBalance[] balances;

}

struct AdapterMetadata {

    address adapterAddress;

    string adapterType; 

}

struct FullTokenBalance {

    TokenBalance base;

    TokenBalance[] underlying;

}

struct TokenBalance {

    TokenMetadata metadata;

    uint256 amount;

}

struct TokenMetadata {

    address token;

    string name;

    string symbol;

    uint8 decimals;

}

struct Component {

    address token;

    string tokenType;  

    uint256 rate;  

}

interface ERC20 {

    function approve(address, uint256) external returns (bool);

    function transfer(address, uint256) external returns (bool);

    function transferFrom(address, address, uint256) external returns (bool);

    function name() external view returns (string memory);

    function symbol() external view returns (string memory);

    function decimals() external view returns (uint8);

    function totalSupply() external view returns (uint256);

    function balanceOf(address) external view returns (uint256);

}

interface TokenAdapter {



    

    function getMetadata(address token) external view returns (TokenMetadata memory);



    

    function getComponents(address token) external view returns (Component[] memory);

}

interface CToken {

    function isCToken() external view returns (bool);

}

interface Mooniswap {

    function getTokens() external view returns(address[] memory);

}

contract MooniswapTokenAdapter is TokenAdapter {



    

    function getMetadata(address token) external view override returns (TokenMetadata memory) {

        return TokenMetadata({

            token: token,

            name: ERC20(token).name(),

            symbol: ERC20(token).symbol(),

            decimals: ERC20(token).decimals()

        });

    }



    

    function getComponents(address token) external view override returns (Component[] memory) {

        address[] memory tokens = Mooniswap(token).getTokens();

        uint256 totalSupply = ERC20(token).totalSupply();

        Component[] memory underlyingTokens = new Component[](2);



        for (uint256 i = 0; i < 2; i++) {

            underlyingTokens[i] = Component({

                token: isETH(ERC20(tokens[i])) ? 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE : tokens[i],

                tokenType: getTokenType(tokens[i]),

                rate: uniBalanceOf(ERC20(tokens[i]), token) * 1e18 / totalSupply

            });

        }



        return underlyingTokens;

    }



    function getTokenType(address token) internal view returns (string memory) {

        (bool success, bytes memory returnData) = token.staticcall{gas: 2000}(

            abi.encodeWithSelector(CToken(token).isCToken.selector)

        );



        if (success) {

            if (returnData.length == 32) {

                return abi.decode(returnData, (bool)) ? "CToken" : "ERC20";

            } else {

                return "ERC20";

            }

        } else {

            return "ERC20";

        }

    }



    function uniBalanceOf(ERC20 token, address account) internal view returns (uint256) {

        if (isETH(token)) {

            return account.balance;

        } else {

            return token.balanceOf(account);

        }

    }



    function isETH(ERC20 token) internal pure returns(bool) {

        return (address(token) == address(0));

    }

}
