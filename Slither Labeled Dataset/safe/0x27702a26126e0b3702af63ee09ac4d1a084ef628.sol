pragma solidity 0.5.17;

contract EIP20Interface {

    

    

    uint256 public totalSupply;



    

    

    function balanceOf(address _owner) public view returns (uint256 balance);



    

    

    

    

    function transfer(address _to, uint256 _value) public returns (bool success);



    

    

    

    

    

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);



    

    

    

    

    function approve(address _spender, uint256 _value) public returns (bool success);



    

    

    

    function allowance(address _owner, address _spender) public view returns (uint256 remaining);



    

    event Transfer(address indexed _from, address indexed _to, uint256 _value);

    event Approval(address indexed _owner, address indexed _spender, uint256 _value);





    function DOMAIN_SEPARATOR() external view returns (bytes32);

    function PERMIT_TYPEHASH() external pure returns (bytes32);

    function nonces(address owner) external view returns (uint);

}

contract EIP20 is EIP20Interface {



    uint256 constant private MAX_UINT256 = 2**256 - 1;

    mapping (address => uint256) public balances;

    mapping (address => mapping (address => uint256)) public allowed;

    

    string public name;                   

    uint8 public decimals;                

    string public symbol;                 



    bytes32 public DOMAIN_SEPARATOR;

    

    bytes32 public constant PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;



    mapping(address => uint) public nonces;



    constructor(

        uint256 _initialAmount,

        string memory _tokenName,

        uint8 _decimalUnits,

        string memory _tokenSymbol

    ) public {

        uint chainId;

        assembly {

            chainId := chainid

        }

        

        balances[msg.sender] = _initialAmount;               

        totalSupply = _initialAmount;                        

        name = _tokenName;                                   

        decimals = _decimalUnits;                            

        symbol = _tokenSymbol;                               



        DOMAIN_SEPARATOR = keccak256(

            abi.encode(

                keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)'),

                keccak256(bytes(name)),

                keccak256(bytes('1')),

                chainId,

                address(this)

            )

        );

    }



    function transfer(address _to, uint256 _value) public returns (bool success) {

        require(balances[msg.sender] >= _value);

        balances[msg.sender] -= _value;

        balances[_to] += _value;

        emit Transfer(msg.sender, _to, _value); 

        return true;

    }



    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {

        uint256 allowance = allowed[_from][msg.sender];

        require(balances[_from] >= _value && allowance >= _value);

        balances[_to] += _value;

        balances[_from] -= _value;

        if (allowance < MAX_UINT256) {

            allowed[_from][msg.sender] -= _value;

        }

        emit Transfer(_from, _to, _value); 

        return true;

    }



    function balanceOf(address _owner) public view returns (uint256 balance) {

        return balances[_owner];

    }



    function _approve(address owner, address spender, uint value) private {

        allowed[owner][spender] = value;

        emit Approval(owner, spender, value);

    }



    function approve(address _spender, uint256 _value) public returns (bool success) {

        _approve(msg.sender, _spender, _value);

        return true;

    }



    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {

        return allowed[_owner][_spender];

    }



    function batchTransfer(address[] memory _targets, uint256[] memory _values) public returns (bool success) {

        uint8 i = 0;

        for (i; i < _targets.length; i++) {

            transfer(_targets[i], _values[i]);

        }

        return true;

    }



    function batchTransferFrom(address _from, address[] memory _targets, uint256[] memory _values) public returns (bool success) {

        uint8 i = 0;

        for (i; i < _targets.length; i++) {

            transferFrom(_from, _targets[i], _values[i]);

        }

        return true;

    }



    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external {

        require(deadline >= block.timestamp, 'PERMIT: EXPIRED');

        bytes32 digest = keccak256(

            abi.encodePacked(

                '\x19\x01',

                DOMAIN_SEPARATOR,

                keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline))

            )

        );

        address recoveredAddress = ecrecover(digest, v, r, s);

        require(recoveredAddress != address(0) && recoveredAddress == owner, 'PERMIT: INVALID_SIGNATURE');

        _approve(owner, spender, value);

    }

}
