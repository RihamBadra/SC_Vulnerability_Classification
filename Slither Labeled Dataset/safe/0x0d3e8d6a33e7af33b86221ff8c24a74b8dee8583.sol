
pragma solidity ^0.6.0;


library SafeMath {
    
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, "SafeMath: addition overflow");

        return c;
    }

    
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        return sub(a, b, "SafeMath: subtraction overflow");
    }

    
    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b <= a, errorMessage);
        uint256 c = a - b;

        return c;
    }

    
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        
        
        
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b, "SafeMath: multiplication overflow");

        return c;
    }

    
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        return div(a, b, "SafeMath: division by zero");
    }

    
    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b > 0, errorMessage);
        uint256 c = a / b;
        

        return c;
    }

    
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        return mod(a, b, "SafeMath: modulo by zero");
    }

    
    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b != 0, errorMessage);
        return a % b;
    }
}

pragma solidity ^0.6.0;

interface IAdmin {
    function admin() external view returns (address);
}

pragma solidity >=0.6.0;

interface AggregatorV3Interface {

    function decimals() external view returns (uint8);
    function description() external view returns (string memory);
    function version() external view returns (uint256);

    
    
    
    function getRoundData(uint80 _roundId)
    external
    view
    returns (
        uint80 roundId,
        int256 answer,
        uint256 startedAt,
        uint256 updatedAt,
        uint80 answeredInRound
    );
    function latestRoundData()
    external
    view
    returns (
        uint80 roundId,
        int256 answer,
        uint256 startedAt,
        uint256 updatedAt,
        uint80 answeredInRound
    );

}

contract ChainlinkPriceFeed {
    using SafeMath for uint;

    AggregatorV3Interface[] internal priceFeed;
    AggregatorV3Interface internal priceFeedETHToUSD;
    IAdmin public admin;

    constructor(address adminAddress) public {
        priceFeed.push(AggregatorV3Interface(0x773616E4d11A78F511299002da57A0a94577F1f4)); 
        priceFeed.push(AggregatorV3Interface(0x986b5E1e1755e3C2440e960477f25201B0a8bbD4)); 
        priceFeed.push(AggregatorV3Interface(0xEe9F2375b4bdF6387aa8265dD4FB8F16512A1d46)); 
        priceFeed.push(AggregatorV3Interface(0x3886BA987236181D98F2401c507Fb8BeA7871dF2)); 
        priceFeedETHToUSD = AggregatorV3Interface(0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419); 
        admin = IAdmin(adminAddress);
    }

    function addPriceFeed(address addr) public {
        require(msg.sender == admin.admin(), "Not admin");
        priceFeed.push(AggregatorV3Interface(addr));
    }

    function getLatestPrice(uint idx) public view returns (uint) {
        require(idx < priceFeed.length, "No price feed");
        (,int priceETH,,uint timeStampETH,) = priceFeed[idx].latestRoundData();
        (,int priceUSD,,uint timeStampUSD,) = priceFeedETHToUSD.latestRoundData();
        require(timeStampETH > 0 && timeStampUSD > 0, "Price feed round not complete");
        return uint(priceETH).mul(uint(priceUSD)).div(1e18);
    }
}