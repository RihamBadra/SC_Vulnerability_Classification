pragma solidity 0.5.16;

interface IDparam {

    event FeeRateEvent(uint256 feeRate);

    event LiquidationLineEvent(uint256 liquidationRate);

    event MinMintEvent(uint256 minMint);



    function stakeRate() external view returns (uint256);



    function liquidationLine() external view returns (uint256);



    function feeRate() external view returns (uint256);



    function minMint() external view returns (uint256);



    function setFeeRate(uint256 _feeRate) external;



    function setLiquidationLine(uint256 _liquidationLine) external;



    function setMinMint(uint256 _minMint) external;



    function isLiquidation(uint256 price) external view returns (bool);



    function isNormal(uint256 price) external view returns (bool);

}

contract Owned {

    address public owner;

    address public nominatedOwner;



    constructor(address _owner) public {

        require(_owner != address(0), "Owner address cannot be 0");

        owner = _owner;

        emit OwnerChanged(address(0), _owner);

    }



    function nominateNewOwner(address _owner) external onlyOwner {

        nominatedOwner = _owner;

        emit OwnerNominated(_owner);

    }



    function acceptOwnership() external {

        require(

            msg.sender == nominatedOwner,

            "You must be nominated before you can accept ownership"

        );

        emit OwnerChanged(owner, nominatedOwner);

        owner = nominatedOwner;

        nominatedOwner = address(0);

    }



    modifier onlyOwner {

        require(

            msg.sender == owner,

            "Only the contract owner may perform this action"

        );

        _;

    }



    event OwnerNominated(address newOwner);

    event OwnerChanged(address oldOwner, address newOwner);

}

library SafeMath {

    

    function add(uint256 a, uint256 b) internal pure returns (uint256) {

        uint256 c = a + b;

        require(c >= a, "SafeMath: addition overflow");



        return c;

    }



    

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {

        return sub(a, b, "SafeMath: subtraction overflow");

    }



    

    function sub(

        uint256 a,

        uint256 b,

        string memory errorMessage

    ) internal pure returns (uint256) {

        require(b <= a, errorMessage);

        uint256 c = a - b;



        return c;

    }



    

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {

        

        

        

        if (a == 0) {

            return 0;

        }



        uint256 c = a * b;

        require(c / a == b, "SafeMath: multiplication overflow");



        return c;

    }



    

    function div(uint256 a, uint256 b) internal pure returns (uint256) {

        return div(a, b, "SafeMath: division by zero");

    }



    

    function div(

        uint256 a,

        uint256 b,

        string memory errorMessage

    ) internal pure returns (uint256) {

        

        require(b > 0, errorMessage);

        uint256 c = a / b;

        



        return c;

    }



    

    function mod(uint256 a, uint256 b) internal pure returns (uint256) {

        return mod(a, b, "SafeMath: modulo by zero");

    }



    

    function mod(

        uint256 a,

        uint256 b,

        string memory errorMessage

    ) internal pure returns (uint256) {

        require(b != 0, errorMessage);

        return a % b;

    }

}

contract WhiteList is Owned {

    

    mapping(address => uint256) public whiter;



    

    event AppendWhiter(address adder);



    

    event RemoveWhiter(address remover);



    

    constructor() internal {

        appendWhiter(owner);

    }



    modifier onlyWhiter() {

        require(isWhiter(), "WhiteList: msg.sender not in whilteList.");

        _;

    }



    

    function appendWhiter(address account) public onlyOwner {

        require(account != address(0), "WhiteList: address not zero");

        require(

            !isWhiter(account),

            "WhiteListe: the account exsit whilteList yet"

        );

        whiter[account] = 1;

        emit AppendWhiter(account);

    }



    

    function removeWhiter(address account) public onlyOwner {

        require(

            isWhiter(account),

            "WhiteListe: the account not exist whilteList"

        );

        delete whiter[account];

        emit RemoveWhiter(account);

    }



    

    function isWhiter(address account) public view returns (bool) {

        return whiter[account] == 1;

    }



    

    function isWhiter() public view returns (bool) {

        return isWhiter(msg.sender);

    }

}

contract Dparam is Owned, WhiteList, IDparam {

    using SafeMath for uint256;



    

    uint256 public stakeRate = 35;

    

    uint256 public liquidationLine = 110;

    

    uint256 public feeRate = 3;



    

    uint256 public minMint = 100 * ONE;

    uint256 constant ONE = 1e8;



    

    event FeeRateEvent(uint256 feeRate);

    

    event LiquidationLineEvent(uint256 liquidationRate);

    

    event MinMintEvent(uint256 minMint);



    

    constructor() public Owned(msg.sender) {}



    

    function setFeeRate(uint256 _feeRate) external onlyWhiter {

        feeRate = _feeRate;

        emit FeeRateEvent(feeRate);

    }



    

    function setLiquidationLine(uint256 _liquidationLine) external onlyWhiter {

        liquidationLine = _liquidationLine;

        emit LiquidationLineEvent(liquidationLine);

    }



    

    function setMinMint(uint256 _minMint) external onlyWhiter {

        minMint = _minMint;

        emit MinMintEvent(minMint);

    }



    

    function isLiquidation(uint256 price) external view returns (bool) {

        return price.mul(stakeRate).mul(100) <= liquidationLine.mul(ONE);

    }



    

    function isNormal(uint256 price) external view returns (bool) {

        return price.mul(stakeRate) >= ONE.mul(7);

    }

}
