pragma solidity 0.7.0;

library Address {


    


    function isContract(address account) internal view returns (bool) {


        


        


        


        bytes32 codehash;


        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;


        


        assembly { codehash := extcodehash(account) }


        return (codehash != accountHash && codehash != 0x0);


    }





    


    function sendValue(address payable recipient, uint256 amount) internal {


        require(address(this).balance >= amount, "Address: insufficient balance");





        


        (bool success, ) = recipient.call{ value: amount }("");


        require(success, "Address: unable to send value, recipient may have reverted");


    }


}

abstract contract Context {


    


    


    constructor () { }





    function _msgSender() internal view virtual returns (address payable) {


        return msg.sender;


    }





    function _msgData() internal view virtual returns (bytes memory) {


        this; 


        return msg.data;


    }


}

interface IERC20 {


  function totalSupply() external view returns (uint256);





  function balanceOf(address who) external view returns (uint256);





  function allowance(address owner, address spender)


    external view returns (uint256);





  function transfer(address to, uint256 value) external returns (bool);





  function approve(address spender, uint256 value)


    external returns (bool);





  function transferFrom(address from, address to, uint256 value)


    external returns (bool);





  event Transfer(


    address indexed from,


    address indexed to,


    uint256 value


  );





  event Approval(


    address indexed owner,


    address indexed spender,


    uint256 value


  );


}

contract Ownable is Context {


    address private _owner;





    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);





    


    constructor () {


        address msgSender = _msgSender();


        _owner = msgSender;


        emit OwnershipTransferred(address(0), msgSender);


    }





    


    function owner() public view returns (address) {


        return _owner;


    }





    


    modifier onlyOwner() {


        require(_owner == _msgSender(), "Ownable: caller is not the owner");


        _;


    }





    


    function renounceOwnership() public virtual onlyOwner {


        emit OwnershipTransferred(_owner, address(0));


        _owner = address(0);


    }





    


    function transferOwnership(address newOwner) public virtual onlyOwner {


        require(newOwner != address(0), "Ownable: new owner is the zero address");


        emit OwnershipTransferred(_owner, newOwner);


        _owner = newOwner;


    }


}

library SafeMath {





  


  function mul(uint256 a, uint256 b) internal pure returns (uint256) {


    


    


    


    if (a == 0) {


      return 0;


    }





    uint256 c = a * b;


    require(c / a == b);





    return c;


  }





  


  function div(uint256 a, uint256 b) internal pure returns (uint256) {


    require(b > 0); 


    uint256 c = a / b;


    





    return c;


  }





  


  function sub(uint256 a, uint256 b) internal pure returns (uint256) {


    require(b <= a);


    uint256 c = a - b;





    return c;


  }





  


  function add(uint256 a, uint256 b) internal pure returns (uint256) {


    uint256 c = a + b;


    require(c >= a);





    return c;


  }





  


  function mod(uint256 a, uint256 b) internal pure returns (uint256) {


    require(b != 0);


    return a % b;


  }


}

contract NRT_Presale is Ownable {


    using SafeMath for uint256;


    using Address for address;





    mapping (address => uint256) public _balances;





    uint256 public _minimum = 0.5 ether ; 


    uint256 public _maximum = 50 ether ; 


    uint256 public hardcap = 767 ether ; 


    


    uint256 public duration = 3 * 86400 ; 


    uint256 public starting_time ; 


    


    bool public hasStarted = false ; 





        


    function mul(uint256 a, uint256 b) internal pure returns (uint256) {


        if (a == 0) {


            return 0;


        }





        uint256 c = a * b;


        require(c / a == b);





        return c;


    }


    


    


    receive() external payable {


        require(hasStarted == true, "Presale not online") ; 


        require(block.timestamp <= starting_time + duration, "Presale has ended") ;


        require(address(this).balance <= hardcap, "Harcap reached") ; 


        require(msg.value >= _minimum && msg.value <= _maximum, "Value does not exceed minimum amount or exceeds maximum amount") ; 


        


        _balances[msg.sender] += msg.value ; 


    }


    


    


    function start_presale() public onlyOwner {


        hasStarted = true ; 


        starting_time = block.timestamp ; 


    }


    


    


    function stop_presale() public onlyOwner {


        hasStarted = false ; 


    }


    


    


    function withdraw() public onlyOwner {


        require(hasStarted == false, "Presale not online") ; 


        require(block.timestamp >= starting_time + duration, "Presale has not ended yet") ; 


        msg.sender.transfer(address(this).balance) ; 


    }


    


    


    function set_hardcap(uint256 ether_amount) public onlyOwner {


        hardcap = ether_amount * 1 ether ; 


    } 


    


    


    function set_duration(uint256 new_duration) public onlyOwner {


        duration = new_duration ; 


    }


}
