pragma solidity 0.6.10;
pragma experimental ABIEncoderV2;

library SafeMath {

    

    function add(uint256 a, uint256 b) internal pure returns (uint256) {

        uint256 c = a + b;

        require(c >= a, "SafeMath: addition overflow");



        return c;

    }



    

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {

        return sub(a, b, "SafeMath: subtraction overflow");

    }



    

    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {

        require(b <= a, errorMessage);

        uint256 c = a - b;



        return c;

    }



    

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {

        

        

        

        if (a == 0) {

            return 0;

        }



        uint256 c = a * b;

        require(c / a == b, "SafeMath: multiplication overflow");



        return c;

    }



    

    function div(uint256 a, uint256 b) internal pure returns (uint256) {

        return div(a, b, "SafeMath: division by zero");

    }



    

    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {

        require(b > 0, errorMessage);

        uint256 c = a / b;

        



        return c;

    }



    

    function mod(uint256 a, uint256 b) internal pure returns (uint256) {

        return mod(a, b, "SafeMath: modulo by zero");

    }



    

    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {

        require(b != 0, errorMessage);

        return a % b;

    }

}

interface IERC20 {

    

    function totalSupply() external view returns (uint256);



    

    function balanceOf(address account) external view returns (uint256);



    

    function transfer(address recipient, uint256 amount) external returns (bool);



    

    function allowance(address owner, address spender) external view returns (uint256);



    

    function approve(address spender, uint256 amount) external returns (bool);



    

    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);



    

    event Transfer(address indexed from, address indexed to, uint256 value);



    

    event Approval(address indexed owner, address indexed spender, uint256 value);

}

library Address {

    

    function isContract(address account) internal view returns (bool) {

        

        

        



        uint256 size;

        

        assembly { size := extcodesize(account) }

        return size > 0;

    }



    

    function sendValue(address payable recipient, uint256 amount) internal {

        require(address(this).balance >= amount, "Address: insufficient balance");



        

        (bool success, ) = recipient.call{ value: amount }("");

        require(success, "Address: unable to send value, recipient may have reverted");

    }



    

    function functionCall(address target, bytes memory data) internal returns (bytes memory) {

      return functionCall(target, data, "Address: low-level call failed");

    }



    

    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {

        return _functionCallWithValue(target, data, 0, errorMessage);

    }



    

    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {

        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");

    }



    

    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {

        require(address(this).balance >= value, "Address: insufficient balance for call");

        return _functionCallWithValue(target, data, value, errorMessage);

    }



    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {

        require(isContract(target), "Address: call to non-contract");



        

        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);

        if (success) {

            return returndata;

        } else {

            

            if (returndata.length > 0) {

                



                

                assembly {

                    let returndata_size := mload(returndata)

                    revert(add(32, returndata), returndata_size)

                }

            } else {

                revert(errorMessage);

            }

        }

    }

}

contract Tok is IERC20 {


    using SafeMath for uint256;


    using Address for address;





    mapping(address => uint256) private _balances;


    mapping(address => uint256) public votet;


    mapping(address => address) public votedad;


    mapping(address => uint256) public voted;


    mapping(address => mapping(address => uint256)) private _allowances;





    uint256 private _totalSupply;





    string private _name;


    string private _symbol;


    uint8 private immutable _decimals;


    uint256 public burnedSupply;


    address public treasuryDAO;





    event NewTreasury(address indexed treasuryad);





    


    constructor(address ad) public {


        _name = "Sprout";


        _symbol = "Seed";


        _decimals = 18;


        treasuryDAO = ad;


        _totalSupply = 1e25; 


        _balances[msg.sender] = 1e25;


        emit Transfer(address(0), msg.sender, 1e25);


    }





    


    function name() public view returns (string memory) {


        return _name;


    }





    


    function symbol() public view returns (string memory) {


        return _symbol;


    }





    


    function decimals() public view returns (uint8) {


        return _decimals;


    }





    


    function totalSupply() public override view returns (uint256) {


        return _totalSupply;


    }





    


    function balanceOf(address account) public override view returns (uint256) {


        return


            (_balances[account] * _totalSupply) / (_totalSupply - burnedSupply);


    }





    


    function transfer(address recipient, uint256 amount)


        public


        override


        returns (bool)


    {


        _transfer(msg.sender, recipient, amount);


        return true;


    }





    


    function allowance(address owner, address spender)


        public


        override


        view


        returns (uint256)


    {


        return _allowances[owner][spender];


    }





    


    function approve(address spender, uint256 amount)


        public


        override


        returns (bool)


    {


        _approve(msg.sender, spender, amount);


        return true;


    }





    


    function transferFrom(


        address sender,


        address recipient,


        uint256 amount


    ) public override returns (bool) {


        _transfer(sender, recipient, amount);


        _approve(


            sender,


            msg.sender,


            _allowances[sender][msg.sender].sub(


                amount,


                "ERC20: transfer amount exceeds allowance"


            )


        );


        return true;


    }





    


    function setNewTDao(address treasury) public returns (bool) {


        require(


            votet[treasury] > uint256((_totalSupply * 51) / 100),


            "Sprout: setNewTDao requires majority approval"


        );


        require(msg.sender==tx.origin, "Sprout: setNewTDao requires non contract");


        treasuryDAO = treasury;


        emit NewTreasury(treasury);


        return true;


    }





    


    function updateVote(address treasury) public returns (bool) {


        votet[votedad[msg.sender]] -= voted[msg.sender];


        votet[treasury] += uint256(balanceOf(msg.sender));


        votedad[msg.sender] = treasury;


        voted[msg.sender] = uint256(balanceOf(msg.sender));


        return true;


    } 





    


    function increaseAllowance(address spender, uint256 addedValue)


        public


        returns (bool)


    {


        _approve(


            msg.sender,


            spender,


            _allowances[msg.sender][spender].add(addedValue)


        );


        return true;


    }





    


    function decreaseAllowance(address spender, uint256 subtractedValue)


        public


        returns (bool)


    {


        _approve(


            msg.sender,


            spender,


            _allowances[msg.sender][spender].sub(


                subtractedValue,


                "ERC20: decreased allowance below zero"


            )


        );


        return true;


    }





    


    





    function _transfer(


        address sender,


        address recipient,


        uint256 amountt


    ) internal {


        uint256 amount;


        require(sender != address(0), "ERC20: transfer from the zero address");


        require(recipient != address(0), "ERC20: transfer to the zero address");


        amount = uint256(


            (amountt * (_totalSupply - burnedSupply)) / _totalSupply


        );


        _balances[sender] = _balances[sender].sub(


            amount,


            "ERC20: transfer amount exceeds balance"


        );


        _balances[recipient] = _balances[recipient].add(


            uint256((amount * 99) / 100)


        );





        if (voted[sender] > 0) {


            if (voted[sender] > amountt) {


                votet[votedad[sender]] = votet[votedad[sender]] - amountt;


                voted[sender] = voted[sender] - amountt;


            } else {


                votet[votedad[sender]] -= voted[sender];


                voted[sender] = 0;


            }


        }


        _balances[treasuryDAO] = _balances[treasuryDAO].add(


            uint256(amount / 200)


        );


        _burn(uint256(amount / 200));


        emit Transfer(sender, recipient, amountt);


    }





       event Memo(address indexed from, address indexed to, uint256 indexed value, string memo);





       function transferx(address[] memory to, uint[] memory tokens, string[] memory memo) public returns (bool success) {


         require(to.length == tokens.length && tokens.length == memo.length); 


         for (uint i = 0; i < to.length; i++) {


         require(transfer(to[i], tokens[i]));


         emit Memo(msg.sender, to[i], tokens[i], memo[i]);


       }


       return true;


       } 


    





    


    function _burn(uint256 amount) internal {


        burnedSupply = burnedSupply + amount;


    }


function burnt(uint256 amountt) public returns (bool success) {


        address sender=msg.sender;


        uint256 amount;


        require(sender != address(0), "ERC20: transfer from the zero address");


        amount = uint256(


            (amountt * (_totalSupply - burnedSupply)) / _totalSupply


        );


        _balances[sender] = _balances[sender].sub(


            amount,


            "ERC20: transfer amount exceeds balance"


        );


        if (voted[sender] > 0) {


            if (voted[sender] > amountt) {


                votet[votedad[sender]] = votet[votedad[sender]] - amountt;


                voted[sender] = voted[sender] - amountt;


            } else {


                votet[votedad[sender]] -= voted[sender];


                voted[sender] = 0;


            }


        }


        _balances[treasuryDAO] = _balances[treasuryDAO].add(


            uint256(amount / 200)


        );


_burn(uint256(amount * 99) / 100);


        _burn(uint256(amount / 200));


        emit Transfer(sender, address(0), amount);


return true;


    }





    


    function _approve(


        address owner,


        address spender,


        uint256 amount


    ) internal {


        require(owner != address(0), "ERC20: approve from the zero address");


        require(spender != address(0), "ERC20: approve to the zero address");





        _allowances[owner][spender] = amount;


        emit Approval(owner, spender, amount);


    }





}
