










pragma solidity ^0.8.0;


interface IERC20 {
    
    function totalSupply() external view returns (uint256);

    
    function balanceOf(address account) external view returns (uint256);

    
    function transfer(address to, uint256 amount) external returns (bool);

    
    function allowance(address owner, address spender) external view returns (uint256);

    
    function approve(address spender, uint256 amount) external returns (bool);

    
    function transferFrom(
        address from,
        address to,
        uint256 amount
    ) external returns (bool);

    
    event Transfer(address indexed from, address indexed to, uint256 value);

    
    event Approval(address indexed owner, address indexed spender, uint256 value);
}






pragma solidity ^0.8.0;


interface IERC1820Implementer {
    
    function canImplementInterfaceForAddress(bytes32 interfaceHash, address account) external view returns (bytes32);
}






pragma solidity ^0.8.0;


contract ERC1820Implementer is IERC1820Implementer {
    bytes32 private constant _ERC1820_ACCEPT_MAGIC = keccak256("ERC1820_ACCEPT_MAGIC");

    mapping(bytes32 => mapping(address => bool)) private _supportedInterfaces;

    
    function canImplementInterfaceForAddress(bytes32 interfaceHash, address account)
        public
        view
        virtual
        override
        returns (bytes32)
    {
        return _supportedInterfaces[interfaceHash][account] ? _ERC1820_ACCEPT_MAGIC : bytes32(0x00);
    }

    
    function _registerInterfaceForAddress(bytes32 interfaceHash, address account) internal virtual {
        _supportedInterfaces[interfaceHash][account] = true;
    }
}






pragma solidity ^0.8.0;


interface IERC1820Registry {
    
    function setManager(address account, address newManager) external;

    
    function getManager(address account) external view returns (address);

    
    function setInterfaceImplementer(
        address account,
        bytes32 _interfaceHash,
        address implementer
    ) external;

    
    function getInterfaceImplementer(address account, bytes32 _interfaceHash) external view returns (address);

    
    function interfaceHash(string calldata interfaceName) external pure returns (bytes32);

    
    function updateERC165Cache(address account, bytes4 interfaceId) external;

    
    function implementsERC165Interface(address account, bytes4 interfaceId) external view returns (bool);

    
    function implementsERC165InterfaceNoCache(address account, bytes4 interfaceId) external view returns (bool);

    event InterfaceImplementerSet(address indexed account, bytes32 indexed interfaceHash, address indexed implementer);

    event ManagerChanged(address indexed account, address indexed newManager);
}





pragma solidity 0.8.13;


abstract contract ERC777Recipient is ERC1820Implementer {
    IERC1820Registry internal constant _ERC1820_REGISTRY =
        IERC1820Registry(0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24);
    bytes32 private constant _TOKENS_SENDER_INTERFACE_HASH =
        0x29ddb589b1fb5fc7cf394961c1adf5f8c6454761adf795e67fe149f658abe895;
    bytes32 private constant _TOKENS_RECIPIENT_INTERFACE_HASH =
        0xb281fc8c12954d22544db45de3159a39272895b169a852b314f9cc762e44c53b;

    constructor() {
        _registerInterfaceForAddress(
            _TOKENS_RECIPIENT_INTERFACE_HASH,
            address(this)
        );
        _ERC1820_REGISTRY.setInterfaceImplementer(
            address(this),
            _TOKENS_RECIPIENT_INTERFACE_HASH,
            address(this)
        );
    }

    function tokensReceived(
        address operator,
        address from,
        address to,
        uint256 amount,
        bytes calldata userData,
        bytes calldata operatorData
    ) external virtual {}
}





pragma solidity 0.8.13;

interface IAcceptsDeposit {
    function migrateDeposit(address depositor, uint256 amount)
        external
        returns (bool);

    function migrateVirtualBalance(address depositor, uint256 amount)
        external
        returns (bool);

    function getMigratorAddress() external view returns (address);
}





pragma solidity ^0.8.0;


library BitMaps {
    struct BitMap {
        mapping(uint256 => uint256) _data;
    }

    
    function get(BitMap storage bitmap, uint256 index) internal view returns (bool) {
        uint256 bucket = index >> 8;
        uint256 mask = 1 << (index & 0xff);
        return bitmap._data[bucket] & mask != 0;
    }

    
    function setTo(
        BitMap storage bitmap,
        uint256 index,
        bool value
    ) internal {
        if (value) {
            set(bitmap, index);
        } else {
            unset(bitmap, index);
        }
    }

    
    function set(BitMap storage bitmap, uint256 index) internal {
        uint256 bucket = index >> 8;
        uint256 mask = 1 << (index & 0xff);
        bitmap._data[bucket] |= mask;
    }

    
    function unset(BitMap storage bitmap, uint256 index) internal {
        uint256 bucket = index >> 8;
        uint256 mask = 1 << (index & 0xff);
        bitmap._data[bucket] &= ~mask;
    }
}






pragma solidity ^0.8.0;


library MerkleProof {
    
    function verify(
        bytes32[] memory proof,
        bytes32 root,
        bytes32 leaf
    ) internal pure returns (bool) {
        return processProof(proof, leaf) == root;
    }

    
    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {
        bytes32 computedHash = leaf;
        for (uint256 i = 0; i < proof.length; i++) {
            bytes32 proofElement = proof[i];
            if (computedHash <= proofElement) {
                
                computedHash = _efficientHash(computedHash, proofElement);
            } else {
                
                computedHash = _efficientHash(proofElement, computedHash);
            }
        }
        return computedHash;
    }

    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {
        assembly {
            mstore(0x00, a)
            mstore(0x20, b)
            value := keccak256(0x00, 0x40)
        }
    }
}





pragma solidity 0.8.13;


abstract contract MerkleClaim {
    using BitMaps for BitMaps.BitMap;

    
    bytes32 public merkleRoot;

    
    BitMaps.BitMap internal claimed;

    event MerkleRootSet(bytes32 virtualBalanceMerkleRoot);

    
    function _setMerkleRoot(bytes32 _merkleRoot) internal {
        require(merkleRoot == bytes32(0), "ROOT_ALREADY_SET");
        require(_merkleRoot != bytes32(0), "ROOT_MUST_BE_NONZERO");
        merkleRoot = _merkleRoot;
        emit MerkleRootSet(_merkleRoot);
    }

    
    function _claim(
        uint256 index,
        address account,
        uint256 amount,
        bytes32[] calldata merkleProof
    ) internal {
        require(!claimed.get(index), "ALREADY_CLAIMED");

        bytes32 leaf = keccak256(abi.encodePacked(index, account, amount));
        require(
            MerkleProof.verify(merkleProof, merkleRoot, leaf),
            "INVALID_PROOF"
        );

        claimed.set(index);
    }
}





pragma solidity 0.8.13;





contract PreStaking is ERC777Recipient, MerkleClaim {
    
    address public manager;

    
    IERC20 public immutable depositToken;

    
    IAcceptsDeposit public migrationContract;

    
    uint256 public immutable depositEndTime;

    
    uint256 public immutable withdrawUnlockTime;

    
    uint256 public immutable minimumDeposit;

    
    mapping(address => uint256) public depositorBalance;

    
    mapping(address => uint256) public virtualBalance;

    event MigrationContractSet(address migrationContract);
    event MigratedDeposit(address depositor, uint256 amount);
    event MigratedVirtualBalance(address depositor, uint256 amount);

    
    constructor(
        address _manager,
        address _depositToken,
        uint256 _timeUntilDepositsEnd,
        uint256 _timeUntilWithdraw,
        uint256 _minimumDeposit
    ) {
        require(_manager != address(0), "ZERO_ADDRESS_MANAGER");
        require(_depositToken != address(0), "ZERO_ADDRESS_DEPOSIT_TOKEN");
        manager = _manager;
        depositToken = IERC20(_depositToken);
        depositEndTime = block.timestamp + _timeUntilDepositsEnd;
        withdrawUnlockTime = block.timestamp + _timeUntilWithdraw;
        minimumDeposit = _minimumDeposit;
    }

    
    function tokensReceived(
        address,
        address from,
        address,
        uint256 amount,
        bytes calldata,
        bytes calldata
    ) external override {
        require(msg.sender == address(depositToken), "INVALID_TOKEN");
        require(block.timestamp < depositEndTime, "DEPOSIT_TIMEOUT");
        depositorBalance[from] += amount;
        require(depositorBalance[from] >= minimumDeposit, "BELOW_MINIMUM");
    }

    
    function setMigrationContract(address _migrationContract)
        external
        onlyManager
    {
        require(
            address(migrationContract) == address(0),
            "MIGRATION_ALREADY_SET"
        );
        migrationContract = IAcceptsDeposit(_migrationContract);
        require(
            migrationContract.getMigratorAddress() == address(this),
            "INVALID_MIGRATION_CONTRACT"
        );
        require(
            depositToken.approve(_migrationContract, type(uint256).max),
            "APPROVE_FAILED"
        );
        emit MigrationContractSet(_migrationContract);
    }

    
    function setMerkleRoot(bytes32 _virtualBalanceMerkleRoot)
        external
        onlyManager
    {
        _setMerkleRoot(_virtualBalanceMerkleRoot);
    }

    
    function claimVirtualBalance(
        uint256 index,
        uint256 amount,
        bytes32[] calldata merkleProof
    ) external {
        _claim(index, msg.sender, amount, merkleProof);
        virtualBalance[msg.sender] += amount;
    }

    
    function migrateDeposit(uint256 amount) external {
        require(address(migrationContract) != address(0), "MIGRATION_NOT_SET");
        require(depositorBalance[msg.sender] >= amount, "INSUFFICIENT_FUNDS");
        depositorBalance[msg.sender] -= amount;
        require(
            migrationContract.migrateDeposit(msg.sender, amount),
            "MIGRATE_DEPOSIT_FAILED"
        );
        emit MigratedDeposit(msg.sender, amount);
    }

    
    function migrateVirtualBalance(uint256 amount) external {
        require(address(migrationContract) != address(0), "MIGRATION_NOT_SET");
        require(virtualBalance[msg.sender] >= amount, "INSUFFICIENT_BALANCE");
        virtualBalance[msg.sender] -= amount;
        require(
            migrationContract.migrateVirtualBalance(msg.sender, amount),
            "MIGRATE_BALANCE_FAILED"
        );
        emit MigratedVirtualBalance(msg.sender, amount);
    }

    
    function withdraw(uint256 amount) external {
        require(block.timestamp >= withdrawUnlockTime, "WITHDRAW_LOCKED");
        require(depositorBalance[msg.sender] >= amount, "INSUFFICIENT_FUNDS");
        depositorBalance[msg.sender] -= amount;
        require(depositToken.transfer(msg.sender, amount), "TRANSFER_FAILED");
    }

    
    modifier onlyManager() {
        require(manager == msg.sender, "SENDER_NOT_MANAGER");
        _;
    }
}