

























































pragma solidity =0.6.12;

interface IExtendedAggregator {
    enum TokenType {Invalid, Simple, Complex}

    enum PlatformId {Invalid, Simple, Uniswap, Balancer, GUni}

    
    function getToken() external view returns (address);

    
    function getSubTokens() external view returns (address[] memory);
    
    
    function latestAnswer() external view returns (int256);

    
    function decimals() external pure returns (uint8);
    
    
    function getPlatformId() external pure returns (PlatformId);

    
    function getTokenType() external pure returns (TokenType);
}

interface IGUniPool {
    function token0() external view returns (address);
    function token1() external view returns (address);
    function getUnderlyingBalancesAtPrice(uint160) external view returns (uint256, uint256);
    function getUnderlyingBalances() external view returns (uint256, uint256);
    function totalSupply() external view returns (uint256);
}

contract GUniOracle is IExtendedAggregator {
    
    uint256 private immutable UNIT_0;
    uint256 private immutable UNIT_1;
    uint256 private immutable TO_WAD_0;
    uint256 private immutable TO_WAD_1;
    uint256 private immutable TO_WAD_ORACLE_0;
    uint256 private immutable TO_WAD_ORACLE_1;

    address public immutable pool;
    address public immutable priceFeed0;
    address public immutable priceFeed1;

    constructor(address _pool, address _feed0, address _feed1) public {
        uint256 dec0 = uint256(IExtendedAggregator(IGUniPool(_pool).token0()).decimals());
        require(dec0 <= 18, "token0-dec-gt-18");
        UNIT_0 = 10 ** dec0;
        TO_WAD_0 = 10 ** (18 - dec0);
        uint256 dec1 = uint256(IExtendedAggregator(IGUniPool(_pool).token1()).decimals());
        require(dec1 <= 18, "token1-dec-gt-18");
        UNIT_1 = 10 ** dec1;
        TO_WAD_1 = 10 ** (18 - dec1);
        uint256 decOracle0 = uint256(IExtendedAggregator(_feed0).decimals());
        require(decOracle0 <= 18, "oracle0-dec-gt-18");
        TO_WAD_ORACLE_0 = 10 ** (18 - decOracle0);
        uint256 decOracle1 = uint256(IExtendedAggregator(_feed1).decimals());
        require(decOracle1 <= 18, "oracle1-dec-gt-18");
        TO_WAD_ORACLE_1 = 10 ** (18 - decOracle1);
        pool = _pool;
        priceFeed0 = _feed0;
        priceFeed1 = _feed1;
    }

    function latestAnswer() external view override returns (int256) {
        
        uint256 p0 = _getWADPrice(true);  
        uint256 p1 = _getWADPrice(false);  
        uint160 sqrtPriceX96 =
            _toUint160(_sqrt(_mul(_mul(p0, UNIT_1), (1 << 96)) / (_mul(p1, UNIT_0))) << 48);

        
        (uint256 r0, uint256 r1) = IGUniPool(pool).getUnderlyingBalancesAtPrice(sqrtPriceX96);
        require(r0 > 0 || r1 > 0, "invalid-balances");
        uint256 totalSupply = IGUniPool(pool).totalSupply();
        
        require(totalSupply >= 1e9, "total-supply-too-small");

        
        uint256 preq = _add(
            _mul(p0, _mul(r0, TO_WAD_0)),
            _mul(p1, _mul(r1, TO_WAD_1))
        ) / totalSupply;
        
        return int256(preq);
    }

    function getToken() external view override returns (address) {
        return pool;
    }

    function getSubTokens() external view override returns (address[] memory) {
        address[] memory arr = new address[](2);
        arr[0] = IGUniPool(pool).token0();
        arr[1] = IGUniPool(pool).token1();
        return arr;
    }

    function getPlatformId() external pure override returns (IExtendedAggregator.PlatformId) {
        return IExtendedAggregator.PlatformId.GUni;
    }

    function getTokenType() external pure override returns (IExtendedAggregator.TokenType) {
        return IExtendedAggregator.TokenType.Complex;
    }

    function decimals() external pure override returns (uint8) {
        return 18;
    }

    function _getWADPrice(bool isToken0)
        internal
        view
        returns (uint256)
    {
        int256 price = IExtendedAggregator(isToken0 ? priceFeed0 : priceFeed1).latestAnswer();
        require(price > 0, "negative-price");
        return _mul(uint256(price), isToken0 ? TO_WAD_ORACLE_0 : TO_WAD_ORACLE_1);
    }

    function _add(uint256 _x, uint256 _y) internal pure returns (uint256 z) {
        require((z = _x + _y) >= _x, "add-overflow");
    }
    function _sub(uint256 _x, uint256 _y) internal pure returns (uint256 z) {
        require((z = _x - _y) <= _x, "sub-underflow");
    }
    function _mul(uint256 _x, uint256 _y) internal pure returns (uint256 z) {
        require(_y == 0 || (z = _x * _y) / _y == _x, "mul-overflow");
    }
    function _toUint160(uint256 x) internal pure returns (uint160 z) {
        require((z = uint160(x)) == x, "uint160-overflow");
    }

    
    
    
    function _sqrt(uint256 _x) private pure returns (uint128) {
        if (_x == 0) return 0;
        else {
            uint256 xx = _x;
            uint256 r = 1;
            if (xx >= 0x100000000000000000000000000000000) { xx >>= 128; r <<= 64; }
            if (xx >= 0x10000000000000000) { xx >>= 64; r <<= 32; }
            if (xx >= 0x100000000) { xx >>= 32; r <<= 16; }
            if (xx >= 0x10000) { xx >>= 16; r <<= 8; }
            if (xx >= 0x100) { xx >>= 8; r <<= 4; }
            if (xx >= 0x10) { xx >>= 4; r <<= 2; }
            if (xx >= 0x8) { r <<= 1; }
            r = (r + _x / r) >> 1;
            r = (r + _x / r) >> 1;
            r = (r + _x / r) >> 1;
            r = (r + _x / r) >> 1;
            r = (r + _x / r) >> 1;
            r = (r + _x / r) >> 1;
            r = (r + _x / r) >> 1; 
            uint256 r1 = _x / r;
            return uint128 (r < r1 ? r : r1);
        }
    }
}