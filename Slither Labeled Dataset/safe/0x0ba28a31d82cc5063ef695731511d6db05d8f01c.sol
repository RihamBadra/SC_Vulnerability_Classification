





pragma solidity ^0.8.4;


abstract contract Context {
    function _msgSender() internal view virtual returns (address) {
        return msg.sender;
    }

    function _msgData() internal view virtual returns (bytes calldata) {
        this; 
        return msg.data;
    }
}








abstract contract Ownable is Context {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    
    constructor () {
        address msgSender = _msgSender();
        _owner = msgSender;
        emit OwnershipTransferred(address(0), msgSender);
    }

    
    function owner() public view virtual returns (address) {
        return _owner;
    }

    
    modifier onlyOwner() {
        require(owner() == _msgSender(), "Ownable: caller is not the owner");
        _;
    }

    
    function renounceOwnership() public virtual onlyOwner {
        emit OwnershipTransferred(_owner, address(0));
        _owner = address(0);
    }

    
    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), "Ownable: new owner is the zero address");
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }
}








interface IERC20 {
    
    function totalSupply() external view returns (uint256);

    
    function balanceOf(address account) external view returns (uint256);

    
    function transfer(address recipient, uint256 amount) external returns (bool);

    
    function allowance(address owner, address spender) external view returns (uint256);

    
    function approve(address spender, uint256 amount) external returns (bool);

    
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);

    
    event Transfer(address indexed from, address indexed to, uint256 value);

    
    event Approval(address indexed owner, address indexed spender, uint256 value);
}










contract ERC20 is Context, IERC20 {
    mapping (address => uint256) internal _balances;

    mapping (address => mapping (address => uint256)) private _allowances;

    uint256 private _totalSupply;

    string private _name;
    string private _symbol;
    uint8 internal _decimals;

    
    constructor (string memory name_, string memory symbol_, uint8 decimals_) {
        _name = name_;
        _symbol = symbol_;
        _decimals = decimals_;
    }

    
    function name() public view virtual returns (string memory) {
        return _name;
    }

    
    function symbol() public view virtual returns (string memory) {
        return _symbol;
    }

    
    function decimals() public view virtual returns (uint8) {
        return 18;
    }

    
    function totalSupply() public view virtual override returns (uint256) {
        return _totalSupply;
    }

    
    function balanceOf(address account) public view virtual override returns (uint256) {
        return _balances[account];
    }

    
    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {
        _transfer(_msgSender(), recipient, amount);
        return true;
    }

    
    function allowance(address owner, address spender) public view virtual override returns (uint256) {
        return _allowances[owner][spender];
    }

    
    function approve(address spender, uint256 amount) public virtual override returns (bool) {
        _approve(_msgSender(), spender, amount);
        return true;
    }

    
    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {
        _transfer(sender, recipient, amount);

        uint256 currentAllowance = _allowances[sender][_msgSender()];
        require(currentAllowance >= amount, "ERC20: transfer amount exceeds allowance");
        _approve(sender, _msgSender(), currentAllowance - amount);

        return true;
    }

    
    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {
        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);
        return true;
    }

    
    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {
        uint256 currentAllowance = _allowances[_msgSender()][spender];
        require(currentAllowance >= subtractedValue, "ERC20: decreased allowance below zero");
        _approve(_msgSender(), spender, currentAllowance - subtractedValue);

        return true;
    }

    
    function _transfer(address sender, address recipient, uint256 amount) internal virtual {
        require(sender != address(0), "ERC20: transfer from the zero address");
        require(recipient != address(0), "ERC20: transfer to the zero address");

        _beforeTokenTransfer(sender, recipient, amount);

        uint256 senderBalance = _balances[sender];
        require(senderBalance >= amount, "ERC20: transfer amount exceeds balance");
        _balances[sender] = senderBalance - amount;
        _balances[recipient] += amount;

        emit Transfer(sender, recipient, amount);
    }

    
    function _mint(address account, uint256 amount) internal virtual {
        require(account != address(0), "ERC20: mint to the zero address");

        _beforeTokenTransfer(address(0), account, amount);

        _totalSupply += amount;
        _balances[account] += amount;
        emit Transfer(address(0), account, amount);
    }

    
    function _burn(address account, uint256 amount) internal virtual {
        require(account != address(0), "ERC20: burn from the zero address");

        _beforeTokenTransfer(account, address(0), amount);

        uint256 accountBalance = _balances[account];
        require(accountBalance >= amount, "ERC20: burn amount exceeds balance");
        _balances[account] = accountBalance - amount;
        _totalSupply -= amount;

        emit Transfer(account, address(0), amount);
    }

    function _approve(address owner, address spender, uint256 amount) internal virtual {
        require(owner != address(0), "ERC20: approve from the zero address");
        require(spender != address(0), "ERC20: approve to the zero address");

        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }

    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }
}


contract Funganomics is ERC20("Funganomics", "FUNG", 18), Ownable {
    

    
    
    struct UnlockedType {
        address address_unlocked;
        uint8 percent_unlocked;
    }
    
        
        UnlockedType public public_sale = UnlockedType(
                0xB0af73e9dc7c90D6CBb4E33595Afb38ae3ec9244, 
                40 
            );
    
        
        UnlockedType public liquidity_and_exchanges = UnlockedType(
                0x8c9DEDE329297D15cc54D1e6d4124b627cFC1322, 
                5 
            );
        
        
    
    struct PresaleUnlockedType {
        address presale_wallet;
        address funding_address;
        uint8 percent_unlocked;
        uint8 percent_on_purchase;
        uint256 token_rate;
        uint256 max_buy_limit;
        uint256 token_sold;
        bool is_started;
    }
    
    mapping(address => uint256) public presale_purchased_per_user;  
    mapping(address => uint256) public presale_received_per_user; 
    mapping(address => uint256) public amount_spend_per_user; 
        
        PresaleUnlockedType public presale = PresaleUnlockedType(
                0xC31e40De61108Fc2950034Af0aAC6681C7b88D18, 
                0x84eFb54fDccf3d53a6B79B28AA0C5A58E2CE08B4, 
                20, 
                25, 
                76923076923076920000000, 
                2250000000000000000,  
                0, 
                false
            );
        

uint256 private month = 2628000;

    
    struct LockedType {
        address[] address_locked;
        uint8 percent_locked;
        uint256 locked_timestamp;
    }
    
        
        LockedType public team_locked = LockedType(
                new address[](4), 
                9, 
                block.timestamp + (24*month)  
            );
            
        
        LockedType public  makt_and_pship_locked = LockedType(
                new address[](4), 
                11, 
                block.timestamp + (12*month)  
            );
        
        
        LockedType public company_reserve_locked = LockedType(
                new address[](4), 
                5, 
                block.timestamp + (12*month)  
            );
        
        
        
        LockedType public staking_locked = LockedType(
                new address[](4), 
                10, 
                block.timestamp + (6*month)  
            );
            
    
    address[] private blacklist;
    
    constructor(){
        
        team_locked.address_locked = [
                0x0A7A94833CA1f32Ec707F97c1be193410471b59E,
                0x0A7A94833CA1f32Ec707F97c1be193410471b59E,
                0x526aE735a19008910Dade55E3A587BC5E78b4368,
                0x73BA7073388D98609F17eFd087DcD707eD7E6fE8
            ];
        
        makt_and_pship_locked.address_locked = [
                0xDEBa010B3C73C8ADf8d2F2a10FC4Ae7eCB006D48,
                0x39712e58faadb17E1b2f51C02a334D46191D6265,
                0x06cD22D223F6683caa02711a85Dbe5F7499BBB52,
                0xddA3D202033d50025Dda495155696eA1F3066EFD
            ];
        
        company_reserve_locked.address_locked = [
                0x0026aAb86819037a62E29CC33a0d3Bf12b2E3F6b,
                0xCB949451804cEaAf26d0845903024F41222C4E98,
                0x7973F5e40A783dA46A41d1dc3a6803DeBF1068cA,
                0x051Bf1962810AbAd76c5cA87C6678BB144fC73b0
            ];
        
        staking_locked.address_locked = [
                0x75ff174d2929c69C5993F9FB5939f11F3c646Aa3,
                0x570160e09A5E54B4B014a1eEa5Fa99F72f17551b,
                0x0eE21b5F738A51e40dd9E0747Bd13716F66a49bd,
                0x6F657b9f0f77977F159E4F9fBEBb2aA4F6052bB2
            ];
        
        uint256 supply = 1000000000*(10**_decimals);
        
        
        _mint(presale.presale_wallet, (presale.percent_unlocked*supply)/100);
        _mint(public_sale.address_unlocked, (public_sale.percent_unlocked*supply)/100);
        _mint(liquidity_and_exchanges.address_unlocked, (liquidity_and_exchanges.percent_unlocked*supply)/100);
        
        
        
            
            
            for(uint i=0; i < team_locked.address_locked.length; i++){
                _mint(team_locked.address_locked[i], (team_locked.percent_locked*supply)/(100*team_locked.address_locked.length));
            }
            
            for(uint i=0; i < makt_and_pship_locked.address_locked.length; i++){
                _mint(makt_and_pship_locked.address_locked[i], (makt_and_pship_locked.percent_locked*supply)/(100*makt_and_pship_locked.address_locked.length));
            }
            
            for(uint i=0; i < company_reserve_locked.address_locked.length; i++){
                _mint(company_reserve_locked.address_locked[i], (company_reserve_locked.percent_locked*supply)/(100*company_reserve_locked.address_locked.length));
            }
            
            for(uint i=0; i < staking_locked.address_locked.length; i++){
                _mint(staking_locked.address_locked[i], (staking_locked.percent_locked*supply)/(100*staking_locked.address_locked.length));
            }
        
    }
    
    function _transfer(address sender, address recipient, uint256 amount) internal virtual override {
        require(sender != address(0), "ERC20: transfer from the zero address");
        require(recipient != address(0), "ERC20: transfer to the zero address");
        require(filter_blacklist(msg.sender)==false, "Transfer: Address Blacklisted.");
        
            for(uint i=0; i < team_locked.address_locked.length; i++){
                if(sender == team_locked.address_locked[i]){
                    require(team_locked.locked_timestamp < block.timestamp, "Time Remaining for the locked address");
                }
            }
            
            for(uint i=0; i < makt_and_pship_locked.address_locked.length; i++){
                if(sender == makt_and_pship_locked.address_locked[i]){
                    require(makt_and_pship_locked.locked_timestamp < block.timestamp, "Time Remaining for the locked address");
                }
            }
            
            for(uint i=0; i < company_reserve_locked.address_locked.length; i++){
                if(sender == company_reserve_locked.address_locked[i]){
                    require(company_reserve_locked.locked_timestamp < block.timestamp, "Time Remaining for the locked address");
                }
            }
            
            for(uint i=0; i < staking_locked.address_locked.length; i++){
                if(sender == staking_locked.address_locked[i]){
                    require(staking_locked.locked_timestamp < block.timestamp, "Time Remaining for the locked address");
                }
            }
        

        _beforeTokenTransfer(sender, recipient, amount);

        uint256 senderBalance = _balances[sender];
        require(senderBalance >= amount, "ERC20: transfer amount exceeds balance");
        _balances[sender] = senderBalance - amount;
        _balances[recipient] += amount;

        emit Transfer(sender, recipient, amount); 
    }
    
    function buyToken() public payable{
        require(msg.sender!=address(0), "Presale: buyer cannot be address zero.");
        require(msg.value > 0, "Presale: value can't be zero");
        require(filter_blacklist(msg.sender)==false, "Presale: Address Blacklisted.");
        require(buy_allowance_left_by_user(msg.sender)>msg.value, "Presale: Allowance per buyer Exceed.");
        
        uint256 total_transfer_amount = predict_token_value(msg.value);
        presale.token_sold += total_transfer_amount;
        uint256 transfer_amount = (total_transfer_amount*presale.percent_on_purchase)/100;
        
        amount_spend_per_user[msg.sender] += msg.value;
        presale_purchased_per_user[msg.sender] += total_transfer_amount;
        presale_received_per_user[msg.sender] += transfer_amount;
        
        payable(presale.funding_address).transfer(msg.value); 
        _transfer(presale.presale_wallet, msg.sender, transfer_amount); 
    }
    
    function predict_token_value(uint256 amount_in_wei) public view returns(uint256) {
        return (amount_in_wei*presale.token_rate)/(10**18);
    }
    
    function changeTokenRate(uint256 tokens_with_decimals_per_eth) public onlyOwner {
        presale.token_rate = tokens_with_decimals_per_eth;
    }
    
    function startPresale() public onlyOwner {
        presale.is_started = true;
    }
    
    function endPresale() public onlyOwner {
        presale.is_started = false;
    }
    
    function change_max_buy_limit(uint256 new_buy_limit_in_eth) public onlyOwner {
        presale.max_buy_limit = new_buy_limit_in_eth;
    }
    
    function add_to_blacklist(address[] memory address_array) public onlyOwner {
        for(uint i = 0; i < address_array.length; i ++ ){
            blacklist.push(address_array[i]);
        }
    }
    
    function get_blacklist() public view returns(address[] memory) {
        return blacklist;
    }
    
    function filter_blacklist(address _address) private view returns(bool) {
        bool is_exist = false;
        for(uint i = 0; i < blacklist.length; i++){
            if(blacklist[i]==_address){
                is_exist = true;
            }
        }
        return is_exist;
    }
    
    function buy_allowance_left_by_user(address _address) public view returns(uint256) {
        return presale.max_buy_limit - amount_spend_per_user[_address];
    }
    
    function Airdrop_for_presale(address[] memory address_array, uint256[] memory amount_array) public onlyOwner {
        
        
        
        for(uint i = 0; i < address_array.length; i++){
            _transfer(msg.sender, address_array[i], amount_array[i]);
            presale_received_per_user[address_array[i]] += amount_array[i];
        }
    }
    
    function Airdrop(address[] memory address_array, uint256[] memory amount_array) public {
        for(uint i =0; i< address_array.length; i++){
            _transfer(msg.sender, address_array[i], amount_array[i]);
        }
    }
}