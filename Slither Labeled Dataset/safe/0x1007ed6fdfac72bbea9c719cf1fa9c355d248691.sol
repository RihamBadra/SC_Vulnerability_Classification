





pragma solidity ^0.8.2;


interface IEarnToken {
    function token() external view returns (address);

    function calcPoolValueInToken() external view returns (uint256);
}

interface IERC20 {
    function decimals() external view returns (uint8);
}

interface IOracle {
    function getNormalizedValueUsdc(address tokenAddress, uint256 amount)
        external
        view
        returns (uint256);

    function getNormalizedValueUsdc(
        address tokenAddress,
        uint256 amount,
        uint256 priceUsdc
    ) external view returns (uint256);

    function getPriceUsdcRecommended(address tokenAddress)
        external
        view
        returns (uint256);
}

interface IDelegationMapping {
    function assetBalanceIsDelegated(address) external view returns (bool);
}

interface IAddressesGenerator {
    function assetsAddresses() external view returns (address[] memory);

    function assetsLength() external view returns (uint256);
}


contract TvlAdapterEarn {
    

    IOracle public oracle; 
    IAddressesGenerator public addressesGenerator; 
    IDelegationMapping public delegationMapping;

    
    struct AssetTvlBreakdown {
        address assetId; 
        address tokenId; 
        uint256 tokenPriceUsdc; 
        uint256 underlyingTokenBalance; 
        uint256 delegatedBalance; 
        uint256 adjustedBalance; 
        uint256 adjustedBalanceUsdc; 
    }

    
    struct AdapterInfo {
        address id; 
        string typeId; 
        string categoryId; 
    }

    
    constructor(
        address _oracleAddress,
        address _addressesGeneratorAddress,
        address _delegationMappingAddress
    ) {
        oracle = IOracle(_oracleAddress);
        addressesGenerator = IAddressesGenerator(_addressesGeneratorAddress);
        delegationMapping = IDelegationMapping(_delegationMappingAddress);
    }

    
    function assetsLength() public view returns (uint256) {
        return addressesGenerator.assetsLength();
    }

    
    function assetsAddresses() public view returns (address[] memory) {
        return addressesGenerator.assetsAddresses();
    }

    
    function assetsTvlBreakdown(address[] memory _assetsAddresses)
        public
        view
        returns (AssetTvlBreakdown[] memory)
    {
        uint256 numberOfAssets = _assetsAddresses.length;

        AssetTvlBreakdown[] memory tvlData =
            new AssetTvlBreakdown[](numberOfAssets);
        for (uint256 assetIdx = 0; assetIdx < numberOfAssets; assetIdx++) {
            address assetAddress = _assetsAddresses[assetIdx];
            tvlData[assetIdx] = assetTvlBreakdown(assetAddress);
        }
        return tvlData;
    }

    
    function assetsTvlBreakdown()
        external
        view
        returns (AssetTvlBreakdown[] memory)
    {
        address[] memory _assetsAddresses = assetsAddresses();
        return assetsTvlBreakdown(_assetsAddresses);
    }

    
    function assetTvlBreakdown(address assetAddress)
        public
        view
        returns (AssetTvlBreakdown memory)
    {
        address tokenAddress = underlyingTokenAddress(assetAddress);
        uint256 underlyingBalanceAmount = assetBalance(assetAddress);
        uint256 delegatedBalanceAmount = assetDelegatedBalance(assetAddress);
        uint256 adjustedBalance =
            underlyingBalanceAmount - delegatedBalanceAmount;
        uint256 tokenPriceUsdc = oracle.getPriceUsdcRecommended(tokenAddress);
        return
            AssetTvlBreakdown({
                assetId: assetAddress,
                tokenId: tokenAddress,
                tokenPriceUsdc: tokenPriceUsdc,
                underlyingTokenBalance: underlyingBalanceAmount,
                delegatedBalance: delegatedBalanceAmount,
                adjustedBalance: adjustedBalance,
                adjustedBalanceUsdc: oracle.getNormalizedValueUsdc(
                    tokenAddress,
                    adjustedBalance,
                    tokenPriceUsdc
                )
            });
    }

    
    function assetsTvlUsdc(address[] memory _assetsAddresses)
        public
        view
        returns (uint256)
    {
        uint256 tvl;
        uint256 numberOfAssets = assetsLength();
        for (uint256 assetIdx = 0; assetIdx < numberOfAssets; assetIdx++) {
            address assetAddress = _assetsAddresses[assetIdx];
            uint256 _assetTvl = assetTvlUsdc(assetAddress);
            tvl += _assetTvl;
        }
        return tvl;
    }

    
    function assetsTvlUsdc() external view returns (uint256) {
        address[] memory _assetsAddresses = assetsAddresses();
        return assetsTvlUsdc(_assetsAddresses);
    }

    
    function assetTvlUsdc(address assetAddress) public view returns (uint256) {
        address tokenAddress = underlyingTokenAddress(assetAddress);
        uint256 underlyingBalanceAmount = assetBalance(assetAddress);
        uint256 delegatedBalanceAmount = assetDelegatedBalance(assetAddress);
        uint256 adjustedBalanceAmount =
            underlyingBalanceAmount - delegatedBalanceAmount;
        uint256 adjustedBalanceUsdc =
            oracle.getNormalizedValueUsdc(tokenAddress, adjustedBalanceAmount);
        return adjustedBalanceUsdc;
    }

    

    
    function adapterInfo() public view returns (AdapterInfo memory) {
        return
            AdapterInfo({
                id: address(this),
                typeId: "EARN",
                categoryId: "SAFE"
            });
    }

    
    function underlyingTokenAddress(address assetAddress)
        public
        view
        returns (address)
    {
        IEarnToken earnToken = IEarnToken(assetAddress);
        address tokenAddress = earnToken.token();
        return tokenAddress;
    }

    
    function assetBalance(address assetAddress) public view returns (uint256) {
        IEarnToken earnToken = IEarnToken(assetAddress);
        return earnToken.calcPoolValueInToken();
    }

    
    function assetDelegatedBalance(address assetAddress)
        public
        view
        returns (uint256)
    {
        bool balanceIsDelegated =
            delegationMapping.assetBalanceIsDelegated(assetAddress);
        if (balanceIsDelegated) {
            return assetBalance(assetAddress);
        }
        return 0;
    }
}