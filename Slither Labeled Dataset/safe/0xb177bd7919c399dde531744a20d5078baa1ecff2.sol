pragma solidity 0.7.2;

contract Context {


    


    


    constructor () { }


    





    function _msgSender() internal view returns (address payable) {


        return msg.sender;


    }





    function _msgData() internal view returns (bytes memory) {


        this; 


        return msg.data;


    }


}

contract ERC20 is Context {


    using SafeMath for uint256;





    mapping (address => uint256) public _balances;


    mapping (address => mapping (address => uint256)) public _allowances;


    


    uint256 public _totalSupply;








    event Transfer(address indexed from, address indexed to, uint256 value);


    event Approval(address indexed owner, address indexed spender, uint256 value);











    


    function balanceOf(address account) public view returns (uint256) {


        return _balances[account];


    }





    


    function transfer(address recipient, uint256 amount) public virtual returns (bool) {


        _transfer(_msgSender(), recipient, amount);


        return true;


    }





    


    function allowance(address owner, address spender) public view returns (uint256) {


        return _allowances[owner][spender];


    }





    


    function approve(address spender, uint256 amount) public returns (bool) {


        _approve(_msgSender(), spender, amount);


        return true;


    }





    


    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {


        _transfer(sender, recipient, amount);


        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, "ERC20: transfer amount exceeds allowance"));


        return true;


    }





    


    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {


        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));


        return true;


    }





    


    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {


        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, "ERC20: decreased allowance below zero"));


        return true;


    }





    


    function _transfer(address sender, address recipient, uint256 amount) virtual internal  {


        require(sender != address(0), "ERC20: transfer from the zero address");


        require(recipient != address(0), "ERC20: transfer to the zero address");





        _balances[sender] = _balances[sender].sub(amount, "ERC20: transfer amount exceeds balance");


        _balances[recipient] = _balances[recipient].add(amount);


        emit Transfer(sender, recipient, amount);


    }





    


    function _mint(address account, uint256 amount) internal virtual {


        require(account != address(0), "ERC20: mint to the zero address");





        _totalSupply = _totalSupply.add(amount);


        _balances[account] = _balances[account].add(amount);


        emit Transfer(address(0), account, amount);


    }





    


    function _burn(address account, uint256 amount) internal {


        require(account != address(0), "ERC20: burn from the zero address");





        _balances[account] = _balances[account].sub(amount, "ERC20: burn amount exceeds balance");


        _totalSupply = _totalSupply.sub(amount);


        emit Transfer(account, address(0), amount);


    }





    


    function _approve(address owner, address spender, uint256 amount) internal {


        require(owner != address(0), "ERC20: approve from the zero address");


        require(spender != address(0), "ERC20: approve to the zero address");





        _allowances[owner][spender] = amount;


        emit Approval(owner, spender, amount);


    }





    


    function _burnFrom(address account, uint256 amount) internal {


        _burn(account, amount);


        _approve(account, _msgSender(), _allowances[account][_msgSender()].sub(amount, "ERC20: burn amount exceeds allowance"));


    }


}

interface IERC20 {


    function totalSupply() external view returns (uint256);


    function balanceOf(address account) external view returns (uint256);


    function transfer(address recipient, uint256 amount) external returns (bool);


    function allowance(address owner, address spender) external view returns (uint256);


    function approve(address spender, uint256 amount) external returns (bool);


    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);


    event Transfer(address indexed from, address indexed to, uint256 value);


    event Approval(address indexed owner, address indexed spender, uint256 value);


}

library SafeMath{


    


    function add(uint256 a, uint256 b) internal pure returns (uint256) {


        uint256 c = a + b;


        require(c >= a, "SafeMath: addition overflow");





        return c;


    }





    


    function sub(uint256 a, uint256 b) internal pure returns (uint256) {


        return sub(a, b, "SafeMath: subtraction overflow");


    }





    


    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {


        require(b <= a, errorMessage);


        uint256 c = a - b;





        return c;


    }





    


    function mul(uint256 a, uint256 b) internal pure returns (uint256) {


        


        


        


        if (a == 0) {


            return 0;


        }





        uint256 c = a * b;


        require(c / a == b, "SafeMath: multiplication overflow");





        return c;


    }





    


    function div(uint256 a, uint256 b) internal pure returns (uint256) {


        return div(a, b, "SafeMath: division by zero");


    }





    


    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {


        


        require(b > 0, errorMessage);


        uint256 c = a / b;


        





        return c;


    }





    


    function mod(uint256 a, uint256 b) internal pure returns (uint256) {


        return mod(a, b, "SafeMath: modulo by zero");


    }





    


    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {


        require(b != 0, errorMessage);


        return a % b;


    }





        


    function max(uint256 a, uint256 b) internal pure returns (uint256) {


        return a >= b ? a : b;


    }





    


    function min(uint256 a, uint256 b) internal pure returns (uint256) {


        return a < b ? a : b;


    }





    


    function average(uint256 a, uint256 b) internal pure returns (uint256) {


        


        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);


    }


}

contract $YUGE is ERC20 {








    using SafeMath for uint256;


    


    string private _name;


    string private _symbol;


    uint8 private _decimals;


    address private _uniswap;


    bool private _burning;


    bool private _minting;


    uint256 private _minted = 0;


    uint256 private _burned = 0;


    


    address private owner;


    address private holdings;


    mapping(address => bool) private owners;


    mapping(address => bool) private ownersVote;


    mapping(address => bool) private stakingAddress;


    uint256 private ownersCount = 0;


    bool private openHoldings = false;


    uint256 private yesToOpenHoldings = 10;


    uint256 private _maxSupply;


    mapping(address => uint256) private lastTransfer;


    uint256 private votePercent;


    


    function name() public view returns (string memory) {


        return _name;


    }


    function symbol() public view returns (string memory) {


        return _symbol;


    }


    function decimals() public view returns (uint8) {


        return _decimals;


    }


    function uniswap() public view returns (address) {


        return _uniswap;


    }


    function burning() public view returns (bool) {


        return _burning;


    }


    function minting() public view returns (bool) {


        return _minting;


    }


    function minted() public view returns (uint256) {


        return _minted;


    }


    function burned() public view returns (uint256) {


        return _burned;


    }


    function totalSupply() public view returns (uint256) {


        return _totalSupply;


    }


    function maxSupply() public view returns (uint256) {


        return _maxSupply;


    }


    function freeTransfer() public view returns (bool) {


        if (block.timestamp < (lastTransfer[_msgSender()] + 3 days) ){


            return false;


        } else{


            return true;


        }


    }


    


    function howLongTillFreeTransfer() public view returns (uint256) {


        if (block.timestamp < (lastTransfer[_msgSender()] + 3 days)) {


            return (lastTransfer[_msgSender()] + 3 days).sub(block.timestamp);


        } else {


            return 0;


        }


    }





    function getOwner() public view returns (address) {


        return owner;


    }





    function getHoldingsAddress() public view returns (address) {


        return holdings;


    }





    function getOwnersCount() public view returns (uint256) {


        return ownersCount;


    }


    


    function getOpenHoldings() public view returns (bool) {


        return openHoldings;


    }


    


    function getOpenHoldingsVotes() public view returns (uint256) {


        return yesToOpenHoldings;


    }


    


    function getLastTransfer(address _address) public view returns (uint256) {


        return lastTransfer[_address];


    }


    


    function getVotePercent() public view returns (uint256) {


        return votePercent; 


    }


    


    constructor(uint256 _supply)


    public {


        _name = "YUGE.WORKS"; 


        _symbol = "$YUGE";


        _decimals = 18;


        _minting = true;


        owner = _msgSender();


        _maxSupply = _supply.mul(1e18);


        _burning = false;


        _mint(_msgSender(), (_supply.mul(1e18)).div(20)); 


        _minted = _minted.add(_supply.mul(1e18).div(20));


        holdings = _msgSender();


        setOwners(_msgSender(), true);


    }





function transfer(address recipient, uint256 amount) public virtual override returns (bool){


        require(recipient != address(0), "ERC20: transfer to the zero address");


        require(amount != 0, "$YUGE: amount must be greater than 0");


        


    if (_msgSender() == _uniswap || recipient == _uniswap || stakingAddress[_msgSender()]) {


        


        lastTransfer[_msgSender()] = block.timestamp;


        lastTransfer[recipient] = block.timestamp;


        


        _transfer(_msgSender(), recipient, amount);


        emit Transfer(_msgSender(), recipient, amount);


        return true;


    }


    if(_msgSender() == holdings) {


        require(openHoldings);


    }


    if (lastTransfer[_msgSender()] == 0) {


        lastTransfer[_msgSender()] = block.timestamp;


    }


    if ((block.timestamp < (lastTransfer[_msgSender()] + 3 days)) && _burning) {


        lastTransfer[_msgSender()] = block.timestamp;


        lastTransfer[recipient] = block.timestamp;


        


        _burn(_msgSender(), amount.mul(10).div(100));


        _burned = _burned.add(amount.mul(10).div(100));


        


        _transfer(_msgSender(), holdings, amount.mul(10).div(100));


        


        _transfer(_msgSender(), recipient, amount.mul(80).div(100));


        


        emit Transfer(_msgSender(), address(0), amount.mul(10).div(100));


        emit Transfer(_msgSender(), holdings, amount.mul(10).div(100));


        emit Transfer(_msgSender(), recipient, amount.mul(80).div(100));


        return true;


    } else {


        lastTransfer[_msgSender()] = block.timestamp;


        lastTransfer[recipient] = block.timestamp;


        


        _transfer(_msgSender(), recipient, amount);


        


        emit Transfer(_msgSender(), recipient, amount);


        return true;


    }





}





    function setStakingAddress(address _address, bool _bool) public virtual onlyOwner {


        stakingAddress[_address] = _bool;


    }





    function setUniswap(address _address) public virtual onlyOwner {


        _uniswap = _address;


    }


    


    function mint(uint256 amount) public virtual onlyOwner {


        require(openHoldings, "$YUGE: openHoldings must be true");


        require(_minting == true, "$YUGE: minting is finished");


        require(_msgSender() == owner, "$YUGE: does not mint from owner address");


        require(_totalSupply + amount.mul(1e18) <= maxSupply(), "$YUGE: _totalSupply may not exceed maxSupply");


        require(_minted + amount.mul(1e18) <= maxSupply(), "$YUGE: _totalSupply may not exceed maxSupply");


        _mint(holdings, amount.mul(1e18));


        _minted = _minted.add(amount.mul(1e18));


    }


    


    function finishMinting() public onlyOwner() {


        _minting = false;


    }


    function setBurning(bool _bool) public onlyOwner() {


        _burning = _bool;


    }


    function revokeOwnership() public onlyOwner {


        


        owner = address(0);


    }


    modifier onlyOwners() {


        require(owners[_msgSender()], "onlyOwners");


        _;


    }


    modifier onlyOwner() {


        require(owner == _msgSender(), "onlyOwner");


        _;


    }


    


    function setOwners(address _address, bool _bool) public onlyOwner {


        require(owners[_address] != _bool, "$YUGE: Already set");


        if (owners[_address]) {


            ownersCount = ownersCount.sub(10);


            if(ownersVote[_address] == true) {


                yesToOpenHoldings = yesToOpenHoldings.sub(10);


                ownersVote[_address] = false;


            }


        } else {


            ownersCount = ownersCount.add(10);


            if(ownersVote[_address] == false) {


                yesToOpenHoldings = yesToOpenHoldings.add(10);


                ownersVote[_address] = true;


            }


            


        }


        if (yesToOpenHoldings.sub(ownersCount.mul(50).div(100)) > 10) {


            openHoldings = true;


        } else {


            openHoldings = false;


        }


        votePercent = yesToOpenHoldings.sub(ownersCount.mul(50).div(100));


        owners[_address] = _bool;


    }


    


    function setOwner(address _address) public onlyOwner {


        newOwner( _address);


        setOwners(_address, true);


    }


    


    function newOwner(address _address) internal virtual {


        owner = _address;


    }


    


    function setHoldings(address _address) public onlyOwner {


        holdings = _address;


    }





    function withdrawFromHoldings(address _address) public onlyOwner {


        require(openHoldings, "$YUGE: Holdings need to be enabled by the owners");


        transfer(_address, _balances[holdings]);


    }


    


  function vote(bool _bool) public onlyOwners returns(bool) {


    require(ownersVote[_msgSender()] != _bool, "$YUGE: Already voted this way");


    ownersVote[_msgSender()] = _bool;


    if (_bool == true) {


        yesToOpenHoldings = yesToOpenHoldings.add(10);


    } else {


        yesToOpenHoldings = yesToOpenHoldings.sub(10);


    }


        if (yesToOpenHoldings.sub(ownersCount.mul(50).div(100)) > 10) {


        openHoldings = true;


    } else {


        openHoldings = false;


    }


    votePercent = yesToOpenHoldings.sub(ownersCount.mul(50).div(100));


    return true;


  }








}
