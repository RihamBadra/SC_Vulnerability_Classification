pragma solidity 0.5.15;

library Addresses {

    function isContract(address account) internal view returns (bool) {

        uint256 size;

        

        assembly {

            size := extcodesize(account)

        }

        return size > 0;

    }



    function performEthTransfer(address recipient, uint256 amount) internal {

        

        (bool success, ) = recipient.call.value(amount)(""); 

        require(success, "ETH_TRANSFER_FAILED");

    }



    

    function safeTokenContractCall(address tokenAddress, bytes memory callData) internal {

        require(isContract(tokenAddress), "BAD_TOKEN_ADDRESS");

        

        

        (bool success, bytes memory returndata) = address(tokenAddress).call(callData);

        require(success, string(returndata));



        if (returndata.length > 0) {

            require(abi.decode(returndata, (bool)), "TOKEN_OPERATION_FAILED");

        }

    }

}

library StarkExTypes {



    

    

    

    

    

    

    

    struct ApprovalChainData {

        address[] list;

        

        

        

        mapping (address => uint256) unlockedForRemovalTime;

    }



}

contract ExternalInitializer {



    event LogExternalInitialize(bytes data);



    function initialize(bytes calldata data) external;

}

contract GovernanceStorage {



    struct GovernanceInfoStruct {

        mapping (address => bool) effectiveGovernors;

        address candidateGovernor;

        bool initialized;

    }



    

    mapping (string => GovernanceInfoStruct) internal governanceInfo;

}

contract IFactRegistry {

    

    function isValid(bytes32 fact)

        external view

        returns(bool);

}

contract Identity {



    

    function identify()

        external pure

        returns(string memory);

}

contract LibConstants {

    

    

    

    



    

    

    uint256 public constant DEPOSIT_CANCEL_DELAY = 1 days;



    

    

    uint256 public constant FREEZE_GRACE_PERIOD = 7 days;



    

    

    uint256 public constant UNFREEZE_DELAY = 365 days;



    

    uint256 public constant MAX_VERIFIER_COUNT = uint256(64);



    

    uint256 public constant VERIFIER_REMOVAL_DELAY = FREEZE_GRACE_PERIOD + (21 days);



    uint256 constant MAX_VAULT_ID = 2**31 - 1;

    uint256 constant MAX_QUANTUM = 2**128 - 1;



    address constant ZERO_ADDRESS = address(0x0);



    uint256 constant K_MODULUS =

    0x800000000000011000000000000000000000000000000000000000000000001;

    uint256 constant K_BETA =

    0x6f21413efbe40de150e596d72f7a8c5609ad26c15c915c1f4cdfcb99cee9e89;



    uint256 constant EXPIRATION_TIMESTAMP_BITS = 22;



    uint256 internal constant MASK_250 =

    0x03FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;

    uint256 internal constant MASK_240 =

    0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;

    uint256 internal constant MINTABLE_ASSET_ID_FLAG = 1<<250;

}

contract ProxyStorage is GovernanceStorage {



    

    

    

    mapping (address => bytes32) internal initializationHash;



    

    mapping (address => uint256) internal enabledTime;



    

    

    

    mapping (bytes32 => bool) internal initialized;

}

contract MainStorage is ProxyStorage {



    IFactRegistry escapeVerifier_;



    

    bool stateFrozen;                               



    

    uint256 unFreezeTime;                           



    

    

    mapping (uint256 => mapping (uint256 => mapping (uint256 => uint256))) pendingDeposits;



    

    

    mapping (uint256 => mapping (uint256 => mapping (uint256 => uint256))) cancellationRequests;



    

    

    mapping (uint256 => mapping (uint256 => uint256)) pendingWithdrawals;



    

    mapping (uint256 => bool) escapesUsed;



    

    uint256 escapesUsedCount;                       



    

    

    mapping (uint256 => mapping (uint256 => uint256)) fullWithdrawalRequests;



    

    uint256 sequenceNumber;                         



    

    uint256 vaultRoot;                              

    uint256 vaultTreeHeight;                        



    

    uint256 orderRoot;                              

    uint256 orderTreeHeight;                        



    

    mapping (address => bool) tokenAdmins;



    

    mapping (address => bool) userAdmins;



    

    mapping (address => bool) operators;



    

    mapping (uint256 => bytes) assetTypeToAssetInfo;    



    

    mapping (uint256 => bool) registeredAssetType;      



    

    mapping (uint256 => uint256) assetTypeToQuantum;    



    

    mapping (address => uint256) starkKeys_DEPRECATED;  



    

    mapping (uint256 => address) ethKeys;               



    

    StarkExTypes.ApprovalChainData verifiersChain;

    StarkExTypes.ApprovalChainData availabilityVerifiersChain;



    

    uint256 lastBatchId;                            



    

    mapping(uint256 => address) subContracts;       

}

contract ChangeVerifiersExternalInitializer is

    ExternalInitializer,

    MainStorage,

    LibConstants

{

    using Addresses for address;

    uint256 constant ENTRY_NOT_FOUND = uint256(~0);



    

    function initialize(bytes calldata data) external {

        require(data.length == 128, "UNEXPECTED_DATA_SIZE");

        address newVerifierAddress;

        bytes32 verifierIdHash;

        address newAvailabilityVerifierAddress;

        bytes32 availabilityVerifierIdHash;



        

        (

            newVerifierAddress,

            verifierIdHash,

            newAvailabilityVerifierAddress,

            availabilityVerifierIdHash

        ) = abi.decode(data, (address, bytes32, address, bytes32));



        

        delete verifiersChain.list;

        delete availabilityVerifiersChain.list;



        

        addEntry(verifiersChain, newVerifierAddress, MAX_VERIFIER_COUNT, verifierIdHash);

        addEntry(

            availabilityVerifiersChain, newAvailabilityVerifierAddress,

            MAX_VERIFIER_COUNT, availabilityVerifierIdHash);



        emit LogExternalInitialize(data);

    }



    

    function addEntry(

        StarkExTypes.ApprovalChainData storage chain,

        address entry, uint256 maxLength, bytes32 hashExpectedId)

        internal

    {

        address[] storage list = chain.list;

        require(entry.isContract(), "ADDRESS_NOT_CONTRACT");

        bytes32 hashRealId = keccak256(abi.encodePacked(Identity(entry).identify()));

        require(hashRealId == hashExpectedId, "UNEXPECTED_CONTRACT_IDENTIFIER");

        require(list.length < maxLength, "CHAIN_AT_MAX_CAPACITY");

        require(findEntry(list, entry) == ENTRY_NOT_FOUND, "ENTRY_ALREADY_EXISTS");

        chain.list.push(entry);

        chain.unlockedForRemovalTime[entry] = 0;

    }



    function findEntry(address[] storage list, address entry)

        internal view returns (uint256)

    {

        uint256 n_entries = list.length;

        for (uint256 i = 0; i < n_entries; i++) {

            if (list[i] == entry) {

                return i;

            }

        }

        return ENTRY_NOT_FOUND;

    }

}
