pragma solidity 0.5.16;

contract CarefulMath {



    

    enum MathError {

        NO_ERROR,

        DIVISION_BY_ZERO,

        INTEGER_OVERFLOW,

        INTEGER_UNDERFLOW

    }



    

    function mulUInt(uint a, uint b) internal pure returns (MathError, uint) {

        if (a == 0) {

            return (MathError.NO_ERROR, 0);

        }



        uint c = a * b;



        if (c / a != b) {

            return (MathError.INTEGER_OVERFLOW, 0);

        } else {

            return (MathError.NO_ERROR, c);

        }

    }



    

    function divUInt(uint a, uint b) internal pure returns (MathError, uint) {

        if (b == 0) {

            return (MathError.DIVISION_BY_ZERO, 0);

        }



        return (MathError.NO_ERROR, a / b);

    }



    

    function subUInt(uint a, uint b) internal pure returns (MathError, uint) {

        if (b <= a) {

            return (MathError.NO_ERROR, a - b);

        } else {

            return (MathError.INTEGER_UNDERFLOW, 0);

        }

    }



    

    function addUInt(uint a, uint b) internal pure returns (MathError, uint) {

        uint c = a + b;



        if (c >= a) {

            return (MathError.NO_ERROR, c);

        } else {

            return (MathError.INTEGER_OVERFLOW, 0);

        }

    }



    

    function addThenSubUInt(uint a, uint b, uint c) internal pure returns (MathError, uint) {

        (MathError err0, uint sum) = addUInt(a, b);



        if (err0 != MathError.NO_ERROR) {

            return (err0, 0);

        }



        return subUInt(sum, c);

    }

}

contract WanttrollerErrorReporter {

    enum Error {

        NO_ERROR,

        DIVISION_BY_ZERO,

        INTEGER_OVERFLOW,

        INTEGER_UNDERFLOW,

        UNAUTHORIZED

    }   



    enum FailureInfo {

      ACCEPT_ADMIN_PENDING_ADMIN_CHECK,

      ACCEPT_PENDING_IMPLEMENTATION_ADDRESS_CHECK,

      SET_PENDING_ADMIN_OWNER_CHECK,

      SET_PAUSE_GUARDIAN_OWNER_CHECK,

      SET_IMPLEMENTATION_OWNER_CHECK,

      SET_PENDING_IMPLEMENTATION_OWNER_CHECK

    }   



    

    event Failure(uint error, uint info, uint detail);



    

    function fail(Error err, FailureInfo info) internal returns (uint) {

        emit Failure(uint(err), uint(info), 0);

        return uint(err);

    }



    

    function failOpaque(Error err, FailureInfo info, uint opaqueError) internal returns (uint) {

        emit Failure(uint(err), uint(info), opaqueError);



        return uint(err);

    }

}

contract Exponential is CarefulMath {

    uint constant expScale = 1e18;

    uint constant doubleScale = 1e36;

    uint constant halfExpScale = expScale/2;

    uint constant mantissaOne = expScale;



    struct Exp {

        uint mantissa;

    }



    struct Double {

        uint mantissa;

    }



    

    function getExp(uint num, uint denom) pure internal returns (MathError, Exp memory) {

        (MathError err0, uint scaledNumerator) = mulUInt(num, expScale);

        if (err0 != MathError.NO_ERROR) {

            return (err0, Exp({mantissa: 0}));

        }



        (MathError err1, uint rational) = divUInt(scaledNumerator, denom);

        if (err1 != MathError.NO_ERROR) {

            return (err1, Exp({mantissa: 0}));

        }



        return (MathError.NO_ERROR, Exp({mantissa: rational}));

    }



    

    function addExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {

        (MathError error, uint result) = addUInt(a.mantissa, b.mantissa);



        return (error, Exp({mantissa: result}));

    }



    

    function subExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {

        (MathError error, uint result) = subUInt(a.mantissa, b.mantissa);



        return (error, Exp({mantissa: result}));

    }



    

    function mulScalar(Exp memory a, uint scalar) pure internal returns (MathError, Exp memory) {

        (MathError err0, uint scaledMantissa) = mulUInt(a.mantissa, scalar);

        if (err0 != MathError.NO_ERROR) {

            return (err0, Exp({mantissa: 0}));

        }



        return (MathError.NO_ERROR, Exp({mantissa: scaledMantissa}));

    }



    

    function mulScalarTruncate(Exp memory a, uint scalar) pure internal returns (MathError, uint) {

        (MathError err, Exp memory product) = mulScalar(a, scalar);

        if (err != MathError.NO_ERROR) {

            return (err, 0);

        }



        return (MathError.NO_ERROR, truncate(product));

    }



    

    function mulScalarTruncateAddUInt(Exp memory a, uint scalar, uint addend) pure internal returns (MathError, uint) {

        (MathError err, Exp memory product) = mulScalar(a, scalar);

        if (err != MathError.NO_ERROR) {

            return (err, 0);

        }



        return addUInt(truncate(product), addend);

    }



    

    function divScalar(Exp memory a, uint scalar) pure internal returns (MathError, Exp memory) {

        (MathError err0, uint descaledMantissa) = divUInt(a.mantissa, scalar);

        if (err0 != MathError.NO_ERROR) {

            return (err0, Exp({mantissa: 0}));

        }



        return (MathError.NO_ERROR, Exp({mantissa: descaledMantissa}));

    }



    

    function divScalarByExp(uint scalar, Exp memory divisor) pure internal returns (MathError, Exp memory) {

        

        (MathError err0, uint numerator) = mulUInt(expScale, scalar);

        if (err0 != MathError.NO_ERROR) {

            return (err0, Exp({mantissa: 0}));

        }

        return getExp(numerator, divisor.mantissa);

    }



    

    function divScalarByExpTruncate(uint scalar, Exp memory divisor) pure internal returns (MathError, uint) {

        (MathError err, Exp memory fraction) = divScalarByExp(scalar, divisor);

        if (err != MathError.NO_ERROR) {

            return (err, 0);

        }



        return (MathError.NO_ERROR, truncate(fraction));

    }



    

    function mulExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {



        (MathError err0, uint doubleScaledProduct) = mulUInt(a.mantissa, b.mantissa);

        if (err0 != MathError.NO_ERROR) {

            return (err0, Exp({mantissa: 0}));

        }



        

        

        

        (MathError err1, uint doubleScaledProductWithHalfScale) = addUInt(halfExpScale, doubleScaledProduct);

        if (err1 != MathError.NO_ERROR) {

            return (err1, Exp({mantissa: 0}));

        }



        (MathError err2, uint product) = divUInt(doubleScaledProductWithHalfScale, expScale);

        

        assert(err2 == MathError.NO_ERROR);



        return (MathError.NO_ERROR, Exp({mantissa: product}));

    }



    

    function mulExp(uint a, uint b) pure internal returns (MathError, Exp memory) {

        return mulExp(Exp({mantissa: a}), Exp({mantissa: b}));

    }



    

    function mulExp3(Exp memory a, Exp memory b, Exp memory c) pure internal returns (MathError, Exp memory) {

        (MathError err, Exp memory ab) = mulExp(a, b);

        if (err != MathError.NO_ERROR) {

            return (err, ab);

        }

        return mulExp(ab, c);

    }



    

    function divExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {

        return getExp(a.mantissa, b.mantissa);

    }



    

    function truncate(Exp memory exp) pure internal returns (uint) {

        

        return exp.mantissa / expScale;

    }



    

    function lessThanExp(Exp memory left, Exp memory right) pure internal returns (bool) {

        return left.mantissa < right.mantissa;

    }



    

    function lessThanOrEqualExp(Exp memory left, Exp memory right) pure internal returns (bool) {

        return left.mantissa <= right.mantissa;

    }



    

    function greaterThanExp(Exp memory left, Exp memory right) pure internal returns (bool) {

        return left.mantissa > right.mantissa;

    }



    

    function isZeroExp(Exp memory value) pure internal returns (bool) {

        return value.mantissa == 0;

    }



    function safe224(uint n, string memory errorMessage) pure internal returns (uint224) {

        require(n < 2**224, errorMessage);

        return uint224(n);

    }



    function safe32(uint n, string memory errorMessage) pure internal returns (uint32) {

        require(n < 2**32, errorMessage);

        return uint32(n);

    }



    function add_(Exp memory a, Exp memory b) pure internal returns (Exp memory) {

        return Exp({mantissa: add_(a.mantissa, b.mantissa)});

    }



    function add_(Double memory a, Double memory b) pure internal returns (Double memory) {

        return Double({mantissa: add_(a.mantissa, b.mantissa)});

    }



    function add_(uint a, uint b) pure internal returns (uint) {

        return add_(a, b, "addition overflow");

    }



    function add_(uint a, uint b, string memory errorMessage) pure internal returns (uint) {

        uint c = a + b;

        require(c >= a, errorMessage);

        return c;

    }



    function sub_(Exp memory a, Exp memory b) pure internal returns (Exp memory) {

        return Exp({mantissa: sub_(a.mantissa, b.mantissa)});

    }



    function sub_(Double memory a, Double memory b) pure internal returns (Double memory) {

        return Double({mantissa: sub_(a.mantissa, b.mantissa)});

    }



    function sub_(uint a, uint b) pure internal returns (uint) {

        return sub_(a, b, "subtraction underflow");

    }



    function sub_(uint a, uint b, string memory errorMessage) pure internal returns (uint) {

        require(b <= a, errorMessage);

        return a - b;

    }



    function mul_(Exp memory a, Exp memory b) pure internal returns (Exp memory) {

        return Exp({mantissa: mul_(a.mantissa, b.mantissa) / expScale});

    }



    function mul_(Exp memory a, uint b) pure internal returns (Exp memory) {

        return Exp({mantissa: mul_(a.mantissa, b)});

    }



    function mul_(uint a, Exp memory b) pure internal returns (uint) {

        return mul_(a, b.mantissa) / expScale;

    }



    function mul_(Double memory a, Double memory b) pure internal returns (Double memory) {

        return Double({mantissa: mul_(a.mantissa, b.mantissa) / doubleScale});

    }



    function mul_(Double memory a, uint b) pure internal returns (Double memory) {

        return Double({mantissa: mul_(a.mantissa, b)});

    }



    function mul_(uint a, Double memory b) pure internal returns (uint) {

        return mul_(a, b.mantissa) / doubleScale;

    }



    function mul_(uint a, uint b) pure internal returns (uint) {

        return mul_(a, b, "multiplication overflow");

    }



    function mul_(uint a, uint b, string memory errorMessage) pure internal returns (uint) {

        if (a == 0 || b == 0) {

            return 0;

        }

        uint c = a * b;

        require(c / a == b, errorMessage);

        return c;

    }



    function div_(Exp memory a, Exp memory b) pure internal returns (Exp memory) {

        return Exp({mantissa: div_(mul_(a.mantissa, expScale), b.mantissa)});

    }



    function div_(Exp memory a, uint b) pure internal returns (Exp memory) {

        return Exp({mantissa: div_(a.mantissa, b)});

    }



    function div_(uint a, Exp memory b) pure internal returns (uint) {

        return div_(mul_(a, expScale), b.mantissa);

    }



    function div_(Double memory a, Double memory b) pure internal returns (Double memory) {

        return Double({mantissa: div_(mul_(a.mantissa, doubleScale), b.mantissa)});

    }



    function div_(Double memory a, uint b) pure internal returns (Double memory) {

        return Double({mantissa: div_(a.mantissa, b)});

    }



    function div_(uint a, Double memory b) pure internal returns (uint) {

        return div_(mul_(a, doubleScale), b.mantissa);

    }



    function div_(uint a, uint b) pure internal returns (uint) {

        return div_(a, b, "divide by zero");

    }



    function div_(uint a, uint b, string memory errorMessage) pure internal returns (uint) {

        require(b > 0, errorMessage);

        return a / b;

    }



    function fraction(uint a, uint b) pure internal returns (Double memory) {

        return Double({mantissa: div_(mul_(a, doubleScale), b)});

    }

}

contract UnitrollerAdminStorage {

    

    address public admin;



    

    address public pendingAdmin;



    

    address public wanttrollerImplementation;



    

    address public pendingWanttrollerImplementation;

}

contract WanttrollerV1Storage is UnitrollerAdminStorage, Exponential {

  struct WantDrop {

    

    uint numRegistrants;

    

    

    uint totalDrop;

  }



  

  uint public totalDropped;

  

  

  uint public waitblocks = 200; 



  

  uint public currentDropStartBlock;

  

  

  uint public currentDropIndex;

  

  

  mapping(uint => WantDrop) public wantDropState;



  

  mapping(address => uint) public accruedRewards;

  

  

  mapping(address => uint) public lastDropRegistered;



  address wantTokenAddress;



  address[] public accountsRegisteredForDrop;



  

  uint public currentReward;

  

  

  uint public discountFactor = 0.9995e18;



  

  address public wantFaucetAddress;

}

contract Unitroller is UnitrollerAdminStorage, WanttrollerErrorReporter {



    

    event NewPendingImplementation(address oldPendingImplementation, address newPendingImplementation);



    

    event NewImplementation(address oldImplementation, address newImplementation);



    

    event NewPendingAdmin(address oldPendingAdmin, address newPendingAdmin);



    

    event NewAdmin(address oldAdmin, address newAdmin);



    constructor() public {

        

        admin = msg.sender;

    }



    

    function _setPendingImplementation(address newPendingImplementation) public returns (uint) {



        if (msg.sender != admin) {

            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_IMPLEMENTATION_OWNER_CHECK);

        }



        address oldPendingImplementation = pendingWanttrollerImplementation;



        pendingWanttrollerImplementation = newPendingImplementation;



        emit NewPendingImplementation(oldPendingImplementation, pendingWanttrollerImplementation);



        return uint(Error.NO_ERROR);

    }



    

    function _acceptImplementation() public returns (uint) {

        

        if (msg.sender != pendingWanttrollerImplementation || pendingWanttrollerImplementation == address(0)) {

            return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_PENDING_IMPLEMENTATION_ADDRESS_CHECK);

        }



        

        address oldImplementation = wanttrollerImplementation;

        address oldPendingImplementation = pendingWanttrollerImplementation;



        wanttrollerImplementation = pendingWanttrollerImplementation;



        pendingWanttrollerImplementation = address(0);



        emit NewImplementation(oldImplementation, wanttrollerImplementation);

        emit NewPendingImplementation(oldPendingImplementation, pendingWanttrollerImplementation);



        return uint(Error.NO_ERROR);

    }





    function _transferOwnership(address newAdmin) public returns (uint) {

        

        if (msg.sender != admin) {

            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_ADMIN_OWNER_CHECK);

        }

        emit NewAdmin(admin, newAdmin);

        admin = newAdmin;



        return uint(Error.NO_ERROR);

    }



    

    function _setPendingAdmin(address newPendingAdmin) public returns (uint) {

        

        if (msg.sender != admin) {

            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_ADMIN_OWNER_CHECK);

        }



        

        address oldPendingAdmin = pendingAdmin;



        

        pendingAdmin = newPendingAdmin;



        

        emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);



        return uint(Error.NO_ERROR);

    }



    

    function _acceptAdmin() public returns (uint) {

        

        if (msg.sender != pendingAdmin || msg.sender == address(0)) {

            return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_ADMIN_PENDING_ADMIN_CHECK);

        }



        

        address oldAdmin = admin;

        address oldPendingAdmin = pendingAdmin;



        

        admin = pendingAdmin;



        

        pendingAdmin = address(0);



        emit NewAdmin(oldAdmin, admin);

        emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);



        return uint(Error.NO_ERROR);

    }



    

    function () payable external {

        

        (bool success, ) = wanttrollerImplementation.delegatecall(msg.data);



        assembly {

              let free_mem_ptr := mload(0x40)

              returndatacopy(free_mem_ptr, 0, returndatasize)



              switch success

              case 0 { revert(free_mem_ptr, returndatasize) }

              default { return(free_mem_ptr, returndatasize) }

        }

    }

}


