pragma solidity 0.5.2;

interface IERC20 {

    

    function totalSupply() external view returns (uint256);



    

    function balanceOf(address account) external view returns (uint256);



    

    function transfer(address recipient, uint256 amount) external returns (bool);



    

    function allowance(address owner, address spender) external view returns (uint256);



    

    function approve(address spender, uint256 amount) external returns (bool);



    

    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);



    

    event Transfer(address indexed from, address indexed to, uint256 value);



    

    event Approval(address indexed owner, address indexed spender, uint256 value);

}

contract MultiOwnable {

    using SafeMath for uint256;



    address public root; 

    address public superOwner;

    mapping (address => bool) public owners;

    address[] public ownerList;



    

    

    mapping(address => address) public candidateSuperOwnerMap;





    event ChangedRoot(address newRoot);

    event ChangedSuperOwner(address newSuperOwner);

    event AddedNewOwner(address newOwner);

    event DeletedOwner(address deletedOwner);



    constructor() public {

        root = msg.sender;

        superOwner = msg.sender;

        owners[root] = true;



        ownerList.push(msg.sender);



    }



    modifier onlyRoot() {

        require(msg.sender == root, "Root privilege is required.");

        _;

    }



    modifier onlySuperOwner() {

        require(msg.sender == superOwner, "SuperOwner priviledge is required.");

        _;

    }



    modifier onlyOwner() {

        require(owners[msg.sender], "Owner priviledge is required.");

        _;

    }



    

    function changeRoot(address newRoot) onlyRoot public returns (bool) {

        require(newRoot != address(0), "This address to be set is zero address(0). Check the input address.");



        root = newRoot;



        emit ChangedRoot(newRoot);

        return true;

    }



    

    function changeSuperOwner(address newSuperOwner) onlyRoot public returns (bool) {

        require(newSuperOwner != address(0), "This address to be set is zero address(0). Check the input address.");



        superOwner = newSuperOwner;



        emit ChangedSuperOwner(newSuperOwner);

        return true;

    }



    

    function changeSuperOwnerByDAO(address newSuperOwner) onlyOwner public returns (bool) {

        require(newSuperOwner != address(0), "This address to be set is zero address(0). Check the input address.");

        require(newSuperOwner != candidateSuperOwnerMap[msg.sender], "You have already voted for this account.");



        candidateSuperOwnerMap[msg.sender] = newSuperOwner;



        uint8 votingNumForSuperOwner = 0;

        uint8 i = 0;



        for (i = 0; i < ownerList.length; i++) {

            if (candidateSuperOwnerMap[ownerList[i]] == newSuperOwner)

                votingNumForSuperOwner++;

        }



        if (votingNumForSuperOwner > ownerList.length / 2) { 

            superOwner = newSuperOwner;



            

            for (i = 0; i < ownerList.length; i++) {

                delete candidateSuperOwnerMap[ownerList[i]];

            }



            emit ChangedSuperOwner(newSuperOwner);

        }



        return true;

    }



    function newOwner(address owner) onlySuperOwner public returns (bool) {

        require(owner != address(0), "This address to be set is zero address(0). Check the input address.");

        require(!owners[owner], "This address is already registered.");



        owners[owner] = true;

        ownerList.push(owner);



        emit AddedNewOwner(owner);

        return true;

    }



    function deleteOwner(address owner) onlySuperOwner public returns (bool) {

        require(owners[owner], "This input address is not a super owner.");

        delete owners[owner];



        for (uint256 i = 0; i < ownerList.length; i++) {

            if (ownerList[i] == owner) {

                ownerList[i] = ownerList[ownerList.length.sub(1)];

                ownerList.length = ownerList.length.sub(1);

                break;

            }

        }



        emit DeletedOwner(owner);

        return true;

    }

}

library SafeMath {

    

    function add(uint256 a, uint256 b) internal pure returns (uint256) {

        uint256 c = a + b;

        require(c >= a, "SafeMath: addition overflow");



        return c;

    }



    

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {

        require(b <= a, "SafeMath: subtraction overflow");

        uint256 c = a - b;



        return c;

    }



    

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {

        

        

        

        if (a == 0) {

            return 0;

        }



        uint256 c = a * b;

        require(c / a == b, "SafeMath: multiplication overflow");



        return c;

    }



    

    function div(uint256 a, uint256 b) internal pure returns (uint256) {

        

        require(b > 0, "SafeMath: division by zero");

        uint256 c = a / b;

        



        return c;

    }



    

    function mod(uint256 a, uint256 b) internal pure returns (uint256) {

        require(b != 0, "SafeMath: modulo by zero");

        return a % b;

    }

}

contract ERC20 is IERC20 {

    using SafeMath for uint256;



    mapping (address => uint256) public _balances;



    mapping (address => mapping (address => uint256)) public _allowances;



    uint256 private _totalSupply;



    

    function totalSupply() public view returns (uint256) {

        return _totalSupply;

    }



    

    function balanceOf(address account) public view returns (uint256) {

        return _balances[account];

    }



    

    function transfer(address recipient, uint256 amount) public returns (bool) {

        _transfer(msg.sender, recipient, amount);

        return true;

    }



    

    function allowance(address owner, address spender) public view returns (uint256) {

        return _allowances[owner][spender];

    }



    

    function approve(address spender, uint256 value) public returns (bool) {

        _approve(msg.sender, spender, value);

        return true;

    }



    

    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {

        _transfer(sender, recipient, amount);

        _approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount));

        return true;

    }



    

    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {

        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));

        return true;

    }



    

    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {

        _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue));

        return true;

    }



    

    function _transfer(address sender, address recipient, uint256 amount) internal {

        require(sender != address(0), "ERC20: transfer from the zero address");

        require(recipient != address(0), "ERC20: transfer to the zero address");



        _balances[sender] = _balances[sender].sub(amount);

        _balances[recipient] = _balances[recipient].add(amount);

        emit Transfer(sender, recipient, amount);

    }



    

    function _mint(address account, uint256 amount) internal {

        require(account != address(0), "ERC20: mint to the zero address");



        _totalSupply = _totalSupply.add(amount);

        _balances[account] = _balances[account].add(amount);

        emit Transfer(address(0), account, amount);

    }



     

    function _burn(address account, uint256 value) internal {

        require(account != address(0), "ERC20: burn from the zero address");



        _totalSupply = _totalSupply.sub(value);

        _balances[account] = _balances[account].sub(value);

        emit Transfer(account, address(0), value);

    }



    

    function _approve(address owner, address spender, uint256 value) internal {

        require(owner != address(0), "ERC20: approve from the zero address");

        require(spender != address(0), "ERC20: approve to the zero address");



        _allowances[owner][spender] = value;

        emit Approval(owner, spender, value);

    }



    

    function _burnFrom(address account, uint256 amount) internal {

        _burn(account, amount);

        _approve(account, msg.sender, _allowances[account][msg.sender].sub(amount));

    }

}

contract ERC20Burnable is ERC20 {

    

    function burn(uint256 amount) public {

        _burn(msg.sender, amount);

    }



    

    function burnFrom(address account, uint256 amount) public {

        _burnFrom(account, amount);

    }

}

contract LockableToken is ERC20, MultiOwnable, ERC20Burnable {

    bool public locked = true;

    uint256 public constant LOCK_MAX = uint256(-1);



    

    mapping(address => bool) public unlockAddrs;

    

    mapping(address => uint256) public lockValues;



    event Locked(bool locked, string note);

    event LockedTo(address indexed addr, bool locked, string note);

    event SetLockValue(address indexed addr, uint256 value, string note);



    constructor() public {

        unlockTo(msg.sender,  "");

    }



    modifier checkUnlock (address addr, uint256 value) {

        require(!locked || unlockAddrs[addr], "The account is currently locked.");

        require(_balances[addr].sub(value) >= lockValues[addr], "Transferable limit exceeded. Check the status of the lock value.");

        _;

    }



    function lock(string memory note) onlyOwner public {

        locked = true;

        emit Locked(locked, note);

    }



    function unlock(string memory note) onlyOwner public {

        locked = false;

        emit Locked(locked, note);

    }



    function lockTo(address addr, string memory note) onlyOwner public {

        setLockValue(addr, LOCK_MAX, note);

        unlockAddrs[addr] = false;



        emit LockedTo(addr, true, note);

    }



    function unlockTo(address addr, string memory note) onlyOwner public {

        if (lockValues[addr] == LOCK_MAX)

            setLockValue(addr, 0, note);

        unlockAddrs[addr] = true;



        emit LockedTo(addr, false, note);

    }



    function setLockValue(address addr, uint256 value, string memory note) onlyOwner public {

        lockValues[addr] = value;

        emit SetLockValue(addr, value, note);

    }



    

    function getMyUnlockValue() public view returns (uint256) {

        address addr = msg.sender;

        if ((!locked || unlockAddrs[addr]) && _balances[addr] > lockValues[addr])

            return _balances[addr].sub(lockValues[addr]);

        else

            return 0;

    }



    function transfer(address to, uint256 value) checkUnlock(msg.sender, value) public returns (bool) {

        return super.transfer(to, value);

    }



    function transferFrom(address from, address to, uint256 value) checkUnlock(from, value) public returns (bool) {

        return super.transferFrom(from, to, value);

    }

    

    function burn(uint256 amount) onlyOwner public {

        return super.burn(amount);

    }

    

    function burnFrom(address account, uint256 amount) onlyOwner public {

        return super.burnFrom(account,amount);

    }

    

}

contract MyToken is LockableToken {

  string public constant name = "FANZY EXCHANGE";

  string public constant symbol = "FX";

  uint public constant decimals = 18; 

  uint public constant INITIAL_SUPPLY = 7000000000 * 10 ** decimals; 



  constructor() public {

    _mint(msg.sender, INITIAL_SUPPLY);

  }

}


