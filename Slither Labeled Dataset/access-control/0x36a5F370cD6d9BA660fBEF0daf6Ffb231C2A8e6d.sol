pragma solidity 0.5.17;

interface IUniswapV2Pair {

    event Approval(address indexed owner, address indexed spender, uint value);

    event Transfer(address indexed from, address indexed to, uint value);



    function name() external pure returns (string memory);

    function symbol() external pure returns (string memory);

    function decimals() external pure returns (uint8);

    function totalSupply() external view returns (uint);

    function balanceOf(address owner) external view returns (uint);

    function allowance(address owner, address spender) external view returns (uint);



    function approve(address spender, uint value) external returns (bool);

    function transfer(address to, uint value) external returns (bool);

    function transferFrom(address from, address to, uint value) external returns (bool);



    function DOMAIN_SEPARATOR() external view returns (bytes32);

    function PERMIT_TYPEHASH() external pure returns (bytes32);

    function nonces(address owner) external view returns (uint);



    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;



    event Mint(address indexed sender, uint amount0, uint amount1);

    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);

    event Swap(

        address indexed sender,

        uint amount0In,

        uint amount1In,

        uint amount0Out,

        uint amount1Out,

        address indexed to

    );

    event Sync(uint112 reserve0, uint112 reserve1);



    function MINIMUM_LIQUIDITY() external pure returns (uint);

    function factory() external view returns (address);

    function token0() external view returns (address);

    function token1() external view returns (address);

    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);

    function price0CumulativeLast() external view returns (uint);

    function price1CumulativeLast() external view returns (uint);

    function kLast() external view returns (uint);



    function mint(address to) external returns (uint liquidity);

    function burn(address to) external returns (uint amount0, uint amount1);

    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;

    function skim(address to) external;

    function sync() external;



    function initialize(address, address) external;

}

library Math {

    

    function max(uint256 a, uint256 b) internal pure returns (uint256) {

        return a >= b ? a : b;

    }



    

    function min(uint256 a, uint256 b) internal pure returns (uint256) {

        return a < b ? a : b;

    }



    

    function average(uint256 a, uint256 b) internal pure returns (uint256) {

        

        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);

    }

}

library SafeMath {

    

    function add(uint256 a, uint256 b) internal pure returns (uint256) {

        uint256 c = a + b;

        require(c >= a, "SafeMath: addition overflow");



        return c;

    }



    

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {

        return sub(a, b, "SafeMath: subtraction overflow");

    }



    

    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {

        require(b <= a, errorMessage);

        uint256 c = a - b;



        return c;

    }



    

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {

        

        

        

        if (a == 0) {

            return 0;

        }



        uint256 c = a * b;

        require(c / a == b, "SafeMath: multiplication overflow");



        return c;

    }



    

    function div(uint256 a, uint256 b) internal pure returns (uint256) {

        return div(a, b, "SafeMath: division by zero");

    }



    

    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {

        

        require(b > 0, errorMessage);

        uint256 c = a / b;

        



        return c;

    }



    

    function mod(uint256 a, uint256 b) internal pure returns (uint256) {

        return mod(a, b, "SafeMath: modulo by zero");

    }



    

    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {

        require(b != 0, errorMessage);

        return a % b;

    }

}

contract Context {

    

    

    constructor () internal { }

    



    function _msgSender() internal view returns (address payable) {

        return msg.sender;

    }



    function _msgData() internal view returns (bytes memory) {

        this; 

        return msg.data;

    }

}

contract Ownable is Context {

    address private _owner;



    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);



    

    constructor () internal {

        _owner = _msgSender();

        emit OwnershipTransferred(address(0), _owner);

    }



    

    function owner() public view returns (address) {

        return _owner;

    }



    

    modifier onlyOwner() {

        require(isOwner(), "Ownable: caller is not the owner");

        _;

    }



    

    function isOwner() public view returns (bool) {

        return _msgSender() == _owner;

    }



    

    function renounceOwnership() public onlyOwner {

        emit OwnershipTransferred(_owner, address(0));

        _owner = address(0);

    }



    

    function transferOwnership(address newOwner) public onlyOwner {

        _transferOwnership(newOwner);

    }



    

    function _transferOwnership(address newOwner) internal {

        require(newOwner != address(0), "Ownable: new owner is the zero address");

        emit OwnershipTransferred(_owner, newOwner);

        _owner = newOwner;

    }

}

interface IERC20 {

    

    function totalSupply() external view returns (uint256);



    

    function balanceOf(address account) external view returns (uint256);



    

    function transfer(address recipient, uint256 amount) external returns (bool);



    

    function allowance(address owner, address spender) external view returns (uint256);



    

    function approve(address spender, uint256 amount) external returns (bool);



    

    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);



    

    event Transfer(address indexed from, address indexed to, uint256 value);



    

    event Approval(address indexed owner, address indexed spender, uint256 value);

}

library Address {

    

    function isContract(address account) internal view returns (bool) {

        

        

        



        

        

        

        bytes32 codehash;

        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;

        

        assembly { codehash := extcodehash(account) }

        return (codehash != 0x0 && codehash != accountHash);

    }



    

    function toPayable(address account) internal pure returns (address payable) {

        return address(uint160(account));

    }



    

    function sendValue(address payable recipient, uint256 amount) internal {

        require(address(this).balance >= amount, "Address: insufficient balance");



        

        (bool success, ) = recipient.call.value(amount)("");

        require(success, "Address: unable to send value, recipient may have reverted");

    }

}

library SafeERC20 {

    using SafeMath for uint256;

    using Address for address;



    function safeTransfer(IERC20 token, address to, uint256 value) internal {

        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));

    }



    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {

        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));

    }



    function safeApprove(IERC20 token, address spender, uint256 value) internal {

        

        

        

        

        require((value == 0) || (token.allowance(address(this), spender) == 0),

            "SafeERC20: approve from non-zero to non-zero allowance"

        );

        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));

    }



    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {

        uint256 newAllowance = token.allowance(address(this), spender).add(value);

        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));

    }



    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {

        uint256 newAllowance = token.allowance(address(this), spender).sub(value, "SafeERC20: decreased allowance below zero");

        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));

    }



    

    function callOptionalReturn(IERC20 token, bytes memory data) private {

        

        



        

        

        

        

        

        require(address(token).isContract(), "SafeERC20: call to non-contract");



        

        (bool success, bytes memory returndata) = address(token).call(data);

        require(success, "SafeERC20: low-level call failed");



        if (returndata.length > 0) { 

            

            require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");

        }

    }

}

contract IRewardDistributionRecipient is Ownable {

    address public rewardDistribution;



    function notifyRewardAmount(uint256 reward) external;



    modifier onlyRewardDistribution() {

        require(_msgSender() == rewardDistribution, "Caller is not reward distribution");

        _;

    }



    function setRewardDistribution(address _rewardDistribution)

        external

        onlyOwner

    {

        rewardDistribution = _rewardDistribution;

    }

}

contract LPTokenWrapper {

    using SafeMath for uint256;

    using SafeERC20 for IERC20;



    IERC20 public wrappedToken;



    uint256 public _totalSupply;

    mapping(address => uint256) public _balances;



    constructor(IERC20 _wrappedToken) public {

        wrappedToken = _wrappedToken;

    }



    function totalSupply() public view returns (uint256) {

        return _totalSupply;

    }



    function balanceOf(address account) public view returns (uint256) {

        return _balances[account];

    }



    function stake(uint256 amount) public {

        _totalSupply = _totalSupply.add(amount);

        _balances[msg.sender] = _balances[msg.sender].add(amount);

        wrappedToken.safeTransferFrom(msg.sender, address(this), amount);

    }



    function withdraw(uint256 amount) public {

        _totalSupply = _totalSupply.sub(amount);

        _balances[msg.sender] = _balances[msg.sender].sub(amount);

        wrappedToken.safeTransfer(msg.sender, amount);

    }

}

interface HAM {

    function hamsScalingFactor() external returns (uint256);

    function mint(address to, uint256 amount) external;

}

contract Farm is LPTokenWrapper, IRewardDistributionRecipient {

    IERC20 public ham;

    uint256 public duration;

    uint256 public startTime;



    uint256 public periodFinish = 0;

    uint256 public rewardRate = 0;

    uint256 public lastUpdateTime;

    uint256 public rewardPerTokenStored;

    mapping(address => uint256) public userRewardPerTokenPaid;

    mapping(address => uint256) public rewards;



    event RewardAdded(uint256 reward);

    event Staked(address indexed user, uint256 amount);

    event Withdrawn(address indexed user, uint256 amount);

    event RewardPaid(address indexed user, uint256 reward);



    constructor(

        IERC20 _ham,

        IERC20 _wrappedToken

    ) LPTokenWrapper(_wrappedToken) public {

        ham = _ham;

    }



    function initialize(uint256 _startTime, uint256 _duration) public onlyOwner {

        require(startTime == 0, "already initialized");

        startTime = _startTime;

        duration = _duration;

    }



    modifier checkStart() {

        require(startTime > 0,"not initialized");

        require(block.timestamp >= startTime,"not start");

        _;

    }



    modifier updateReward(address account) {

        rewardPerTokenStored = rewardPerToken();

        lastUpdateTime = lastTimeRewardApplicable();

        if (account != address(0)) {

            rewards[account] = earned(account);

            userRewardPerTokenPaid[account] = rewardPerTokenStored;

        }

        _;

    }



    function lastTimeRewardApplicable() public view returns (uint256) {

        return Math.min(block.timestamp, periodFinish);

    }



    function rewardPerToken() public view returns (uint256) {

        if (totalSupply() == 0) {

            return rewardPerTokenStored;

        }

        return

            rewardPerTokenStored.add(

                lastTimeRewardApplicable()

                    .sub(lastUpdateTime)

                    .mul(rewardRate)

                    .mul(1e18)

                    .div(totalSupply())

            );

    }



    function earned(address account) public view returns (uint256) {

        return

            balanceOf(account)

                .mul(rewardPerToken().sub(userRewardPerTokenPaid[account]))

                .div(1e18)

                .add(rewards[account]);

    }



    

    function stake(uint256 amount) public updateReward(msg.sender) checkStart {

        require(amount > 0, "Cannot stake 0");

        super.stake(amount);

        emit Staked(msg.sender, amount);

    }



    function withdraw(uint256 amount) public updateReward(msg.sender) checkStart {

        require(amount > 0, "Cannot withdraw 0");

        super.withdraw(amount);

        emit Withdrawn(msg.sender, amount);

    }



    function exit() external {

        if (balanceOf(msg.sender) > 0) {

            withdraw(balanceOf(msg.sender));

        }

        getReward();

    }



    function getReward() public updateReward(msg.sender) checkStart {

        uint256 reward = earned(msg.sender);

        if (reward > 0) {

            rewards[msg.sender] = 0;

            uint256 scalingFactor = HAM(address(ham)).hamsScalingFactor();

            uint256 trueReward = reward.mul(scalingFactor).div(10**18);

            ham.safeTransfer(msg.sender, trueReward);

            emit RewardPaid(msg.sender, trueReward);

        }

    }



    function notifyRewardAmount(uint256 reward)

        public

        onlyRewardDistribution

        updateReward(address(0))

    {

        if (block.timestamp > startTime) {

          if (block.timestamp >= periodFinish) {

              rewardRate = reward.div(duration);

          } else {

              uint256 remaining = periodFinish.sub(block.timestamp);

              uint256 leftover = remaining.mul(rewardRate);

              rewardRate = reward.add(leftover).div(duration);

          }

          lastUpdateTime = block.timestamp;

          periodFinish = block.timestamp.add(duration);

          emit RewardAdded(reward);

        } else {

          rewardRate = reward.div(duration);

          lastUpdateTime = startTime;

          periodFinish = startTime.add(duration);

          emit RewardAdded(reward);

        }

    }

}

interface IUniswapV2Router02 {

    function factory() external pure returns (address);

    function WETH() external pure returns (address);



    function addLiquidity(

        address tokenA,

        address tokenB,

        uint amountADesired,

        uint amountBDesired,

        uint amountAMin,

        uint amountBMin,

        address to,

        uint deadline

    ) external returns (uint amountA, uint amountB, uint liquidity);

    function addLiquidityETH(

        address token,

        uint amountTokenDesired,

        uint amountTokenMin,

        uint amountETHMin,

        address to,

        uint deadline

    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);

    function removeLiquidity(

        address tokenA,

        address tokenB,

        uint liquidity,

        uint amountAMin,

        uint amountBMin,

        address to,

        uint deadline

    ) external returns (uint amountA, uint amountB);

    function removeLiquidityETH(

        address token,

        uint liquidity,

        uint amountTokenMin,

        uint amountETHMin,

        address to,

        uint deadline

    ) external returns (uint amountToken, uint amountETH);

    function removeLiquidityWithPermit(

        address tokenA,

        address tokenB,

        uint liquidity,

        uint amountAMin,

        uint amountBMin,

        address to,

        uint deadline,

        bool approveMax, uint8 v, bytes32 r, bytes32 s

    ) external returns (uint amountA, uint amountB);

    function removeLiquidityETHWithPermit(

        address token,

        uint liquidity,

        uint amountTokenMin,

        uint amountETHMin,

        address to,

        uint deadline,

        bool approveMax, uint8 v, bytes32 r, bytes32 s

    ) external returns (uint amountToken, uint amountETH);

    function swapExactTokensForTokens(

        uint amountIn,

        uint amountOutMin,

        address[] calldata path,

        address to,

        uint deadline

    ) external returns (uint[] memory amounts);

    function swapTokensForExactTokens(

        uint amountOut,

        uint amountInMax,

        address[] calldata path,

        address to,

        uint deadline

    ) external returns (uint[] memory amounts);

    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)

        external

        payable

        returns (uint[] memory amounts);

    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)

        external

        returns (uint[] memory amounts);

    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)

        external

        returns (uint[] memory amounts);

    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)

        external

        payable

        returns (uint[] memory amounts);



    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);

    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);

    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);

    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);

    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);



    function removeLiquidityETHSupportingFeeOnTransferTokens(

        address token,

        uint liquidity,

        uint amountTokenMin,

        uint amountETHMin,

        address to,

        uint deadline

    ) external returns (uint amountETH);

    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(

        address token,

        uint liquidity,

        uint amountTokenMin,

        uint amountETHMin,

        address to,

        uint deadline,

        bool approveMax, uint8 v, bytes32 r, bytes32 s

    ) external returns (uint amountETH);



    function swapExactTokensForTokensSupportingFeeOnTransferTokens(

        uint amountIn,

        uint amountOutMin,

        address[] calldata path,

        address to,

        uint deadline

    ) external;

    function swapExactETHForTokensSupportingFeeOnTransferTokens(

        uint amountOutMin,

        address[] calldata path,

        address to,

        uint deadline

    ) external payable;

    function swapExactTokensForETHSupportingFeeOnTransferTokens(

        uint amountIn,

        uint amountOutMin,

        address[] calldata path,

        address to,

        uint deadline

    ) external;

}

contract Dam is Farm {

    using SafeMath for uint256;

    using SafeERC20 for IERC20;



    mapping(address => bool) public acceptedPairs;

    IERC20[] public unwrappedTokens;

    mapping(address => mapping(address => uint256)) public unwrappedBalances;

    IUniswapV2Router02 public uniswapRouter;



    event Staked(address indexed user, address uniswapPair, uint256 amount);

    event Withdrawn(address indexed user, address token, uint256 amount);



    constructor(

        IERC20 _ham,

        IUniswapV2Pair[] memory _acceptedPairs,

        IUniswapV2Router02 _uniswapRouter

    ) Farm(_ham, IERC20(address(0))) public {

        uniswapRouter = _uniswapRouter;

        wrappedToken = IERC20(_uniswapRouter.WETH());

        for (uint i = 0; i<_acceptedPairs.length; i++) {

            address token0 = _acceptedPairs[i].token0();

            address token1 = _acceptedPairs[i].token1();

            require(

                token0 == address(wrappedToken) || token1 == address(wrappedToken),

                "pairs must be against weth"

            );

            acceptedPairs[address(_acceptedPairs[i])] = true;

            unwrappedTokens.push(token0 == address(wrappedToken) ? IERC20(token1) : IERC20(token0));

        }

    }



    function stakeAndUnwrap(IUniswapV2Pair pair, uint256 amount) public updateReward(msg.sender) checkStart {

        require(amount > 0, "can't stake 0");

        require(acceptedPairs[address(pair)], "token not accepted");

        IERC20(address(pair)).safeTransferFrom(msg.sender, address(this), amount);

        require(pair.approve(address(uniswapRouter), amount), 'failed approve');



        address otherToken = pair.token0();

        if (otherToken == address(wrappedToken)) {

            otherToken = pair.token1();

        }



        (uint256 amountOther, uint256 amountWrapped) = uniswapRouter.removeLiquidity(otherToken, address(wrappedToken), amount, 0, 0, address(this), block.timestamp);



        _balances[msg.sender] = _balances[msg.sender].add(amountWrapped);

        _totalSupply = _totalSupply.add(amount);

        unwrappedBalances[otherToken][msg.sender] = unwrappedBalances[otherToken][msg.sender].add(amountOther);



        emit Staked(msg.sender, amountWrapped);

    }



    function stake(uint256 amount) public {

        revert("cant stake without unwrapping");

    }



    function withdraw(uint256 amount) public {

        revert("cant withdraw, use exit");

    }



	

    function exit() external updateReward(msg.sender) checkStart {

		uint256 amount = balanceOf(msg.sender);

        super.withdraw(amount);

        emit Withdrawn(msg.sender, address(wrappedToken), amount);

        for (uint i = 0; i<unwrappedTokens.length; i++) {

			address ti = address(unwrappedTokens[i]);

            if (unwrappedBalances[ti][msg.sender] > 0) {

                uint256 toSend = unwrappedBalances[ti][msg.sender];

                unwrappedBalances[ti][msg.sender] = 0;

                unwrappedTokens[i].safeTransfer(msg.sender, toSend);

            }

        }

        getReward();

    }

}
