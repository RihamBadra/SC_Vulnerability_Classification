pragma solidity 0.6.10;

library Address {

    

    function isContract(address account) internal view returns (bool) {

        

        

        

        bytes32 codehash;

        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;

        

        assembly { codehash := extcodehash(account) }

        return (codehash != accountHash && codehash != 0x0);

    }



    

    function sendValue(address payable recipient, uint256 amount) internal {

        require(address(this).balance >= amount, "Address: insufficient balance");



        

        (bool success, ) = recipient.call{ value: amount }("");

        require(success, "Address: unable to send value, recipient may have reverted");

    }

}

contract ArtSteward {

    

    

    using SafeMath for uint256;

    

    uint256 public price; 

    IERC721 public art; 

    

    uint256 public totalCollected; 



    

    uint256 public timeLastCollected; 

    uint256 public deposit; 

    address payable public artist; 

    uint256 public artistFund; 



    

    mapping (address => uint256) public pullFunds; 

    mapping (address => bool) public patrons; 

    mapping (address => uint256) public timeHeld; 



    uint256 public timeAcquired; 

    

    

    

    uint256 patronageNumerator; 

    uint256 patronageDenominator;



    bool init;



    constructor(address payable _artist, address _artwork) public {

    

        

        require(init == false, "Steward already initialized.");

        

        patronageNumerator = 1000000000000;

        patronageDenominator = 1000000000000;

        art = IERC721(_artwork);

        art.setup();

        artist = _artist;



        

        _forecloseIfNecessary();



        init = true;

    }



    event LogBuy(address indexed owner, uint256 indexed price);

    event LogPriceChange(uint256 indexed newPrice);

    event LogForeclosure(address indexed prevOwner);

    event LogCollection(uint256 indexed collected);

    

    modifier onlyPatron() {

        require(msg.sender == art.ownerOf(42), "Not patron");

        _;

    }



    modifier collectPatronage() {

       _collectPatronage(); 

       _;

    }



    

    



    

    function patronageOwed() public view returns (uint256 patronageDue) {

        

        return price.mul(now.sub(timeLastCollected)).div(365 days);

    }



    

    function patronageOwedRange(uint256 _time) public view returns (uint256 patronageDue) {

        

        return price.mul(_time).div(365 days);

    }



    function currentCollected() public view returns (uint256 patronageDue) {

        if(timeLastCollected > timeAcquired) {

            return patronageOwedRange(timeLastCollected.sub(timeAcquired));

        } else { return 0; }

    }



    function patronageOwedWithTimestamp() public view returns (uint256 patronageDue, uint256 timestamp) {

        return (patronageOwed(), now);

    }



    function foreclosed() public view returns (bool) {

        

        

        

        uint256 collection = patronageOwed();

        if(collection >= deposit) {

            return true;

        } else {

            return false;

        }

    }



    

    function depositAbleToWithdraw() public view returns (uint256) {

        uint256 collection = patronageOwed();

        if(collection >= deposit) {

            return 0;

        } else {

            return deposit.sub(collection);

        }

    }



    

    function foreclosureTime() public view returns (uint256) {

        

        uint256 pps = price.mul(patronageNumerator).div(patronageDenominator).div(365 days);

        uint256 daw = depositAbleToWithdraw();

        if(daw > 0) {

            return now + depositAbleToWithdraw().div(pps);

        } else if (pps > 0) {

            

            

            uint256 collection = patronageOwed();

            return timeLastCollected.add(((now.sub(timeLastCollected)).mul(deposit).div(collection)));

        } else {

            

            return timeLastCollected; 

        }

    }



    

    

    function _collectPatronage() public {



        if (price != 0) { 

            uint256 collection = patronageOwed();

            

            if (collection >= deposit) { 



                

                

                timeLastCollected = timeLastCollected.add((now.sub(timeLastCollected)).mul(deposit).div(collection));

                collection = deposit; 

            } else { 

                timeLastCollected = now; 

            } 



            deposit = deposit.sub(collection);

            totalCollected = totalCollected.add(collection);

            artistFund = artistFund.add(collection);

            emit LogCollection(collection);



            _forecloseIfNecessary();

        }



    }



    function buy(uint256 _newPrice, uint256 _currentPrice) public payable collectPatronage {

        

        require(price == _currentPrice, "Current Price incorrect");

        require(_newPrice > 0, "Price is zero");

        require(msg.value > price, "Not enough"); 



        address currentOwner = art.ownerOf(42);



        uint256 totalToPayBack = price.add(deposit);

        if(totalToPayBack > 0) { 

            

            address payable payableCurrentOwner = address(uint160(currentOwner));

            bool transferSuccess = payableCurrentOwner.send(totalToPayBack);



            

            if(!transferSuccess) { pullFunds[currentOwner] = pullFunds[currentOwner].add(totalToPayBack); }

        }



        

        timeLastCollected = now;

        

        deposit = msg.value.sub(price);

        transferArtworkTo(currentOwner, msg.sender, _newPrice);

        emit LogBuy(msg.sender, _newPrice);

    }



    

    function depositWei() public payable collectPatronage onlyPatron {

        deposit = deposit.add(msg.value);

    }



    function changePrice(uint256 _newPrice) public collectPatronage onlyPatron {

        require(_newPrice > 0, 'Price is zero'); 

        price = _newPrice;

        emit LogPriceChange(price);

    }

    

    function withdrawDeposit(uint256 _wei) public collectPatronage onlyPatron {

        _withdrawDeposit(_wei);

    }



    function exit() public collectPatronage onlyPatron {

        _withdrawDeposit(deposit);

    }



    

    

    function withdrawArtistFunds() public {

        require(msg.sender == artist, "Not artist");

        uint256 toSend = artistFund;

        artistFund = 0;

        artist.transfer(toSend);

    }



    

    

    function withdrawPullFunds() public {

        require(pullFunds[msg.sender] > 0, "No pull funds available.");

        uint256 toSend = pullFunds[msg.sender];

        pullFunds[msg.sender] = 0;

        msg.sender.transfer(toSend);

    }



    

    function _withdrawDeposit(uint256 _wei) internal {

        

        require(deposit >= _wei, 'Withdrawing too much');



        deposit = deposit.sub(_wei);

        msg.sender.transfer(_wei); 



        _forecloseIfNecessary();

    }



    function _forecloseIfNecessary() internal {

        if(deposit == 0) {

            

            address currentOwner = art.ownerOf(42);

            transferArtworkTo(currentOwner, address(this), 0);

            emit LogForeclosure(currentOwner);

        }

    }



    function transferArtworkTo(address _currentOwner, address _newOwner, uint256 _newPrice) internal {

        

        timeHeld[_currentOwner] = timeHeld[_currentOwner].add((timeLastCollected.sub(timeAcquired)));

        

        art.transferFrom(_currentOwner, _newOwner, 42);



        price = _newPrice;

        timeAcquired = now;

        patrons[_newOwner] = true;

    }

}

contract BlockReceiver {



    ArtSteward steward;



    constructor (address _steward) public {

        steward = ArtSteward(_steward);

    }



    function buy(uint256 currentPrice) public payable {

        uint256 price = 1 ether;

        

        

        

        address(steward).call.value(msg.value)(abi.encodeWithSignature("buy(uint256,uint256)", price, currentPrice));

    }



    function withdrawPullFunds() public {

        steward.withdrawPullFunds();

    }



    

    

    

}

library Counters {

    using SafeMath for uint256;



    struct Counter {

        

        

        

        uint256 _value; 

    }



    function current(Counter storage counter) internal view returns (uint256) {

        return counter._value;

    }



    function increment(Counter storage counter) internal {

        

        counter._value += 1;

    }



    function decrement(Counter storage counter) internal {

        counter._value = counter._value.sub(1);

    }

}

library EnumerableMap {

    

    

    

    

    

    

    

    



    struct MapEntry {

        bytes32 _key;

        bytes32 _value;

    }



    struct Map {

        

        MapEntry[] _entries;



        

        

        mapping (bytes32 => uint256) _indexes;

    }



    

    function _set(Map storage map, bytes32 key, bytes32 value) private returns (bool) {

        

        uint256 keyIndex = map._indexes[key];



        if (keyIndex == 0) { 

            map._entries.push(MapEntry({ _key: key, _value: value }));

            

            

            map._indexes[key] = map._entries.length;

            return true;

        } else {

            map._entries[keyIndex - 1]._value = value;

            return false;

        }

    }



    

    function _remove(Map storage map, bytes32 key) private returns (bool) {

        

        uint256 keyIndex = map._indexes[key];



        if (keyIndex != 0) { 

            

            

            



            uint256 toDeleteIndex = keyIndex - 1;

            uint256 lastIndex = map._entries.length - 1;



            

            



            MapEntry storage lastEntry = map._entries[lastIndex];



            

            map._entries[toDeleteIndex] = lastEntry;

            

            map._indexes[lastEntry._key] = toDeleteIndex + 1; 



            

            map._entries.pop();



            

            delete map._indexes[key];



            return true;

        } else {

            return false;

        }

    }



    

    function _contains(Map storage map, bytes32 key) private view returns (bool) {

        return map._indexes[key] != 0;

    }



    

    function _length(Map storage map) private view returns (uint256) {

        return map._entries.length;

    }



   

    function _at(Map storage map, uint256 index) private view returns (bytes32, bytes32) {

        require(map._entries.length > index, "EnumerableMap: index out of bounds");



        MapEntry storage entry = map._entries[index];

        return (entry._key, entry._value);

    }



    

    function _get(Map storage map, bytes32 key) private view returns (bytes32) {

        return _get(map, key, "EnumerableMap: nonexistent key");

    }



    

    function _get(Map storage map, bytes32 key, string memory errorMessage) private view returns (bytes32) {

        uint256 keyIndex = map._indexes[key];

        require(keyIndex != 0, errorMessage); 

        return map._entries[keyIndex - 1]._value; 

    }



    



    struct UintToAddressMap {

        Map _inner;

    }



    

    function set(UintToAddressMap storage map, uint256 key, address value) internal returns (bool) {

        return _set(map._inner, bytes32(key), bytes32(uint256(value)));

    }



    

    function remove(UintToAddressMap storage map, uint256 key) internal returns (bool) {

        return _remove(map._inner, bytes32(key));

    }



    

    function contains(UintToAddressMap storage map, uint256 key) internal view returns (bool) {

        return _contains(map._inner, bytes32(key));

    }



    

    function length(UintToAddressMap storage map) internal view returns (uint256) {

        return _length(map._inner);

    }



   

    function at(UintToAddressMap storage map, uint256 index) internal view returns (uint256, address) {

        (bytes32 key, bytes32 value) = _at(map._inner, index);

        return (uint256(key), address(uint256(value)));

    }



    

    function get(UintToAddressMap storage map, uint256 key) internal view returns (address) {

        return address(uint256(_get(map._inner, bytes32(key))));

    }



    

    function get(UintToAddressMap storage map, uint256 key, string memory errorMessage) internal view returns (address) {

        return address(uint256(_get(map._inner, bytes32(key), errorMessage)));

    }

}

library EnumerableSet {

    

    

    

    

    

    

    

    



    struct Set {

        

        bytes32[] _values;



        

        

        mapping (bytes32 => uint256) _indexes;

    }



    

    function _add(Set storage set, bytes32 value) private returns (bool) {

        if (!_contains(set, value)) {

            set._values.push(value);

            

            

            set._indexes[value] = set._values.length;

            return true;

        } else {

            return false;

        }

    }



    

    function _remove(Set storage set, bytes32 value) private returns (bool) {

        

        uint256 valueIndex = set._indexes[value];



        if (valueIndex != 0) { 

            

            

            



            uint256 toDeleteIndex = valueIndex - 1;

            uint256 lastIndex = set._values.length - 1;



            

            



            bytes32 lastvalue = set._values[lastIndex];



            

            set._values[toDeleteIndex] = lastvalue;

            

            set._indexes[lastvalue] = toDeleteIndex + 1; 



            

            set._values.pop();



            

            delete set._indexes[value];



            return true;

        } else {

            return false;

        }

    }



    

    function _contains(Set storage set, bytes32 value) private view returns (bool) {

        return set._indexes[value] != 0;

    }



    

    function _length(Set storage set) private view returns (uint256) {

        return set._values.length;

    }



   

    function _at(Set storage set, uint256 index) private view returns (bytes32) {

        require(set._values.length > index, "EnumerableSet: index out of bounds");

        return set._values[index];

    }



    



    struct AddressSet {

        Set _inner;

    }



    

    function add(AddressSet storage set, address value) internal returns (bool) {

        return _add(set._inner, bytes32(uint256(value)));

    }



    

    function remove(AddressSet storage set, address value) internal returns (bool) {

        return _remove(set._inner, bytes32(uint256(value)));

    }



    

    function contains(AddressSet storage set, address value) internal view returns (bool) {

        return _contains(set._inner, bytes32(uint256(value)));

    }



    

    function length(AddressSet storage set) internal view returns (uint256) {

        return _length(set._inner);

    }



   

    function at(AddressSet storage set, uint256 index) internal view returns (address) {

        return address(uint256(_at(set._inner, index)));

    }





    



    struct UintSet {

        Set _inner;

    }



    

    function add(UintSet storage set, uint256 value) internal returns (bool) {

        return _add(set._inner, bytes32(value));

    }



    

    function remove(UintSet storage set, uint256 value) internal returns (bool) {

        return _remove(set._inner, bytes32(value));

    }



    

    function contains(UintSet storage set, uint256 value) internal view returns (bool) {

        return _contains(set._inner, bytes32(value));

    }



    

    function length(UintSet storage set) internal view returns (uint256) {

        return _length(set._inner);

    }



   

    function at(UintSet storage set, uint256 index) internal view returns (uint256) {

        return uint256(_at(set._inner, index));

    }

}

interface IERC165 {

    

    function supportsInterface(bytes4 interfaceId) external view returns (bool);

}

interface IERC721 is IERC165 {

    

    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);



    

    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);



    

    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);



    

    function balanceOf(address owner) external view returns (uint256 balance);



    

    function ownerOf(uint256 tokenId) external view returns (address owner);



    

    



    

    function transferFrom(address from, address to, uint256 tokenId) external;



    

    function approve(address to, uint256 tokenId) external;



    

    function getApproved(uint256 tokenId) external view returns (address operator);



    

    function setApprovalForAll(address operator, bool _approved) external;



    

    function isApprovedForAll(address owner, address operator) external view returns (bool);



    

    



    function setup() external;

}

interface IERC721Enumerable is IERC721 {



    

    function totalSupply() external view returns (uint256);



    

    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256 tokenId);



    

    function tokenByIndex(uint256 index) external view returns (uint256);

}

interface IERC721Metadata is IERC721 {



    

    function name() external view returns (string memory);



    

    function symbol() external view returns (string memory);



    

    function tokenURI(uint256 tokenId) external view returns (string memory);

}

contract Initializable {



  

  bool private initialized;



  

  bool private initializing;



  

  modifier initializer() {

    require(initializing || isConstructor() || !initialized, "Contract instance has already been initialized");



    bool isTopLevelCall = !initializing;

    if (isTopLevelCall) {

      initializing = true;

      initialized = true;

    }



    _;



    if (isTopLevelCall) {

      initializing = false;

    }

  }



  

  function isConstructor() private view returns (bool) {

    

    

    

    

    

    address self = address(this);

    uint256 cs;

    assembly { cs := extcodesize(self) }

    return cs == 0;

  }



  

  uint256[50] private ______gap;

}

contract Router {



    ArtSteward steward;

    bool public toBlock = true;



    constructor (address _steward) public {

        steward = ArtSteward(_steward);

    }



    function buy(uint256 currentPrice) public payable {

        

        

        

        address(steward).call.value(msg.value)(abi.encodeWithSignature("buy(uint256,uint256)", 1 ether, currentPrice));

    }



    function withdrawPullFunds() public {

        steward.withdrawPullFunds();

    }



    fallback() external payable {

        if(toBlock) { revert('blocked'); }

    }



    function setBlock(bool _tb) public {

        toBlock = _tb;

    }

}

library SafeMath {

    

    function add(uint256 a, uint256 b) internal pure returns (uint256) {

        uint256 c = a + b;

        require(c >= a, "SafeMath: addition overflow");



        return c;

    }



    

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {

        return sub(a, b, "SafeMath: subtraction overflow");

    }



    

    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {

        require(b <= a, errorMessage);

        uint256 c = a - b;



        return c;

    }



    

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {

        

        

        

        if (a == 0) {

            return 0;

        }



        uint256 c = a * b;

        require(c / a == b, "SafeMath: multiplication overflow");



        return c;

    }



    

    function div(uint256 a, uint256 b) internal pure returns (uint256) {

        return div(a, b, "SafeMath: division by zero");

    }



    

    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {

        require(b > 0, errorMessage);

        uint256 c = a / b;

        



        return c;

    }



    

    function mod(uint256 a, uint256 b) internal pure returns (uint256) {

        return mod(a, b, "SafeMath: modulo by zero");

    }



    

    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {

        require(b != 0, errorMessage);

        return a % b;

    }

}

library Strings {

    

    function toString(uint256 value) internal pure returns (string memory) {

        

        



        if (value == 0) {

            return "0";

        }

        uint256 temp = value;

        uint256 digits;

        while (temp != 0) {

            digits++;

            temp /= 10;

        }

        bytes memory buffer = new bytes(digits);

        uint256 index = digits - 1;

        temp = value;

        while (temp != 0) {

            buffer[index--] = byte(uint8(48 + temp % 10));

            temp /= 10;

        }

        return string(buffer);

    }

}

contract ERC165 is IERC165 {

    



    

    mapping(bytes4 => bool) private _supportedInterfaces;



    



    

    function supportsInterface(bytes4 interfaceId) public view override returns (bool) {

        return _supportedInterfaces[interfaceId];

    }



    

    function _registerInterface(bytes4 interfaceId) internal virtual {

        require(interfaceId != 0xffffffff, "ERC165: invalid interface id");

        _supportedInterfaces[interfaceId] = true;

    }

}

contract ERC721 is ERC165, IERC721, IERC721Metadata, IERC721Enumerable {

    using SafeMath for uint256;

    using Address for address;

    using EnumerableSet for EnumerableSet.UintSet;

    using EnumerableMap for EnumerableMap.UintToAddressMap;

    using Strings for uint256;



    

    

    



    

    mapping (address => EnumerableSet.UintSet) private _holderTokens;



    

    EnumerableMap.UintToAddressMap private _tokenOwners;



    

    mapping (uint256 => address) private _tokenApprovals;



    

    mapping (address => mapping (address => bool)) private _operatorApprovals;



    

    string private _name;



    

    string private _symbol;



    

    mapping(uint256 => string) private _tokenURIs;



    

    string private _baseURI;



    

    bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;



    

    bytes4 private constant _INTERFACE_ID_ERC721_METADATA = 0x5b5e139f;



    

    bytes4 private constant _INTERFACE_ID_ERC721_ENUMERABLE = 0x780e9d63;



    

    bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;



    

    address public steward;

    bool public init;



    function setup() public override {

        require(init == false, "Artwork already initialized.");



        _name = "This Artwork Is Always On Sale 2";

        _symbol = "TAIAOS2";

        steward = msg.sender;

        

        _mint(steward, 42); 

        _setTokenURI(42, "https:



        

        _registerInterface(_INTERFACE_ID_ERC165);

        _registerInterface(_INTERFACE_ID_ERC721);

        _registerInterface(_INTERFACE_ID_ERC721_METADATA);

        _registerInterface(_INTERFACE_ID_ERC721_ENUMERABLE);



        init=true;

    }



    

    function balanceOf(address owner) public view override returns (uint256) {

        require(owner != address(0), "ERC721: balance query for the zero address");



        return _holderTokens[owner].length();

    }



    

    function ownerOf(uint256 tokenId) public view override returns (address) {

        return _tokenOwners.get(tokenId, "ERC721: owner query for nonexistent token");

    }



    

    function name() public view override returns (string memory) {

        return _name;

    }



    

    function symbol() public view override returns (string memory) {

        return _symbol;

    }



    

    function tokenURI(uint256 tokenId) public view override returns (string memory) {

        require(_exists(tokenId), "ERC721Metadata: URI query for nonexistent token");



        string memory _tokenURI = _tokenURIs[tokenId];



        

        if (bytes(_baseURI).length == 0) {

            return _tokenURI;

        }

        

        if (bytes(_tokenURI).length > 0) {

            return string(abi.encodePacked(_baseURI, _tokenURI));

        }

        

        return string(abi.encodePacked(_baseURI, tokenId.toString()));

    }



    

    function baseURI() public view returns (string memory) {

        return _baseURI;

    }



    

    function tokenOfOwnerByIndex(address owner, uint256 index) public view override returns (uint256) {

        return _holderTokens[owner].at(index);

    }



    

    function totalSupply() public view override returns (uint256) {

        

        return _tokenOwners.length();

    }



    

    function tokenByIndex(uint256 index) public view override returns (uint256) {

        (uint256 tokenId, ) = _tokenOwners.at(index);

        return tokenId;

    }



    

    function approve(address to, uint256 tokenId) public virtual override {

        address owner = ownerOf(tokenId);

        require(to != owner, "ERC721: approval to current owner");



        require(msg.sender == owner || isApprovedForAll(owner, msg.sender),

            "ERC721: approve caller is not owner nor approved for all"

        );



        _approve(to, tokenId);

    }



    

    function getApproved(uint256 tokenId) public view override returns (address) {

        require(_exists(tokenId), "ERC721: approved query for nonexistent token");



        return _tokenApprovals[tokenId];

    }



    

    function setApprovalForAll(address operator, bool approved) public virtual override {

        require(operator != msg.sender, "ERC721: approve to caller");



        _operatorApprovals[msg.sender][operator] = approved;

        emit ApprovalForAll(msg.sender, operator, approved);

    }



    

    function isApprovedForAll(address owner, address operator) public view override returns (bool) {

        return _operatorApprovals[owner][operator];

    }



    

    function transferFrom(address from, address to, uint256 tokenId) public virtual override {

        

        require(_isApprovedOrOwner(msg.sender, tokenId), "ERC721: transfer caller is not steward.");



        _transfer(from, to, tokenId);

    }



    

    



    

    



    

    



    

    function _exists(uint256 tokenId) internal view returns (bool) {

        return _tokenOwners.contains(tokenId);

    }



    

    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view returns (bool) {

        require(_exists(tokenId), "ERC721: operator query for nonexistent token");

        

        



        

        

        return (spender == steward); 

    }



    

    



    

    



    

    function _mint(address to, uint256 tokenId) internal virtual {

        require(to != address(0), "ERC721: mint to the zero address");

        require(!_exists(tokenId), "ERC721: token already minted");



        _beforeTokenTransfer(address(0), to, tokenId);



        _holderTokens[to].add(tokenId);



        _tokenOwners.set(tokenId, to);



        emit Transfer(address(0), to, tokenId);

    }



    

    function _burn(uint256 tokenId) internal virtual {

        address owner = ownerOf(tokenId);



        _beforeTokenTransfer(owner, address(0), tokenId);



        

        _approve(address(0), tokenId);



        

        if (bytes(_tokenURIs[tokenId]).length != 0) {

            delete _tokenURIs[tokenId];

        }



        _holderTokens[owner].remove(tokenId);



        _tokenOwners.remove(tokenId);



        emit Transfer(owner, address(0), tokenId);

    }



    

    function _transfer(address from, address to, uint256 tokenId) internal virtual {

        require(ownerOf(tokenId) == from, "ERC721: transfer of token that is not own");

        require(to != address(0), "ERC721: transfer to the zero address");



        _beforeTokenTransfer(from, to, tokenId);



        

        _approve(address(0), tokenId);



        _holderTokens[from].remove(tokenId);

        _holderTokens[to].add(tokenId);



        _tokenOwners.set(tokenId, to);



        emit Transfer(from, to, tokenId);

    }



    

    function _setTokenURI(uint256 tokenId, string memory _tokenURI) internal virtual {

        require(_exists(tokenId), "ERC721Metadata: URI set of nonexistent token");

        _tokenURIs[tokenId] = _tokenURI;

    }



    

    function _setBaseURI(string memory baseURI_) internal virtual {

        _baseURI = baseURI_;

    }



    

    



    function _approve(address to, uint256 tokenId) private {

        _tokenApprovals[tokenId] = to;

        emit Approval(ownerOf(tokenId), to, tokenId);

    }



    

    function _beforeTokenTransfer(address from, address to, uint256 tokenId) internal virtual { }

}
