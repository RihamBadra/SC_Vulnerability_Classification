pragma solidity 0.6.12;

contract Initializable {





  


  bool private initialized;





  


  bool private initializing;





  


  modifier initializer() {


    require(initializing || isConstructor() || !initialized, "Contract instance has already been initialized");





    bool isTopLevelCall = !initializing;


    if (isTopLevelCall) {


      initializing = true;


      initialized = true;


    }





    _;





    if (isTopLevelCall) {


      initializing = false;


    }


  }





  


  modifier initializerEven() {


    require(initializing || isConstructor() || initialized, "Contract instance has already been initialized EVEN times");





    bool isTopLevelCall = !initializing;


    if (isTopLevelCall) {


      initializing = true;


      initialized = false;


    }





    _;





    if (isTopLevelCall) {


      initializing = false;


    }


  }





  


  function isConstructor() private view returns (bool) {


    


    


    


    


    


    address self = address(this);


    uint256 cs;


    assembly { cs := extcodesize(self) }


    return cs == 0;


  }





  


  uint256[50] private ______gap;


}

contract Governable is Initializable {


    address public governor;





    event GovernorshipTransferred(address indexed previousGovernor, address indexed newGovernor);





    


    function initialize(address governor_) virtual public initializer {


        governor = governor_;


        emit GovernorshipTransferred(address(0), governor);


    }





    modifier governance() {


        require(msg.sender == governor);


        _;


    }





    


    function renounceGovernorship() public governance {


        emit GovernorshipTransferred(governor, address(0));


        governor = address(0);


    }





    


    function transferGovernorship(address newGovernor) public governance {


        _transferGovernorship(newGovernor);


    }





    


    function _transferGovernorship(address newGovernor) internal {


        require(newGovernor != address(0));


        emit GovernorshipTransferred(governor, newGovernor);


        governor = newGovernor;


    }


}

contract Configurable is Governable {





    mapping (bytes32 => uint) internal config;


    


    function getConfig(bytes32 key) public view returns (uint) {


        return config[key];


    }


    function getConfig(bytes32 key, uint index) public view returns (uint) {


        return config[bytes32(uint(key) ^ index)];


    }


    function getConfig(bytes32 key, address addr) public view returns (uint) {


        return config[bytes32(uint(key) ^ uint(addr))];


    }





    function _setConfig(bytes32 key, uint value) internal {


        if(config[key] != value)


            config[key] = value;


    }


    function _setConfig(bytes32 key, uint index, uint value) internal {


        _setConfig(bytes32(uint(key) ^ index), value);


    }


    function _setConfig(bytes32 key, address addr, uint value) internal {


        _setConfig(bytes32(uint(key) ^ uint(addr)), value);


    }


    


    function setConfig(bytes32 key, uint value) external governance {


        _setConfig(key, value);


    }


    function setConfig(bytes32 key, uint index, uint value) external governance {


        _setConfig(bytes32(uint(key) ^ index), value);


    }


    function setConfig(bytes32 key, address addr, uint value) external governance {


        _setConfig(bytes32(uint(key) ^ uint(addr)), value);


    }


}

interface Minter {


    event Minted(address indexed recipient, address reward_contract, uint minted);





    function token() external view returns (address);


    function controller() external view returns (address);


    function minted(address, address) external view returns (uint);


    function allowed_to_mint_for(address, address) external view returns (bool);


    


    function mint(address gauge) external;


    function mint_many(address[8] calldata gauges) external;


    function mint_for(address gauge, address _for) external;


    function toggle_approve_mint(address minting_user) external;


}

interface LiquidityGauge {


    event Deposit(address indexed provider, uint value);


    event Withdraw(address indexed provider, uint value);


    event UpdateLiquidityLimit(address user, uint original_balance, uint original_supply, uint working_balance, uint working_supply);





    function user_checkpoint (address addr) external returns (bool);


    function claimable_tokens(address addr) external view returns (uint);


    function claimable_reward(address addr) external view returns (uint);


    function integrate_checkpoint()         external view returns (uint);





    function kick(address addr) external;


    function set_approve_deposit(address addr, bool can_deposit) external;


    function deposit(uint _value) external;


    function deposit(uint _value, address addr) external;


    function withdraw(uint _value) external;


    function withdraw(uint _value, bool claim_rewards) external;


    function claim_rewards() external;


    function claim_rewards(address addr) external;





    function minter()                       external view returns (address);


    function crv_token()                    external view returns (address);


    function lp_token()                     external view returns (address);


    function controller()                   external view returns (address);


    function voting_escrow()                external view returns (address);


    function balanceOf(address)             external view returns (uint);


    function totalSupply()                  external view returns (uint);


    function future_epoch_time()            external view returns (uint);


    function approved_to_deposit(address, address)   external view returns (bool);


    function working_balances(address)      external view returns (uint);


    function working_supply()               external view returns (uint);


    function period()                       external view returns (int128);


    function period_timestamp(uint)         external view returns (uint);


    function integrate_inv_supply(uint)     external view returns (uint);


    function integrate_inv_supply_of(address) external view returns (uint);


    function integrate_checkpoint_of(address) external view returns (uint);


    function integrate_fraction(address)    external view returns (uint);


    function inflation_rate()               external view returns (uint);


    function reward_contract()              external view returns (address);


    function rewarded_token()               external view returns (address);


    function reward_integral()              external view returns (uint);


    function reward_integral_for(address)   external view returns (uint);


    function rewards_for(address)           external view returns (uint);


    function claimed_rewards_for(address)   external view returns (uint);


}

contract SSimpleGauge is LiquidityGauge, Configurable {


    using SafeMath for uint;


    using TransferHelper for address;





    address override public minter;


    address override public crv_token;


    address override public lp_token;


    address override public controller;


    address override public voting_escrow;


    mapping(address => uint) override public balanceOf;


    uint override public totalSupply;


    uint override public future_epoch_time;


    


    


    mapping(address => mapping(address => bool)) override public approved_to_deposit;


    


    mapping(address => uint) override public working_balances;


    uint override public working_supply;


    


    


    


    int128 override public period;


    uint256[100000000000000000000000000000] override public period_timestamp;


    


    


    uint256[100000000000000000000000000000] override public integrate_inv_supply;  


    


    


    mapping(address => uint) override public integrate_inv_supply_of;


    mapping(address => uint) override public integrate_checkpoint_of;


    


    


    


    mapping(address => uint) override public integrate_fraction;


    


    uint override public inflation_rate;


    


    


    address override public reward_contract;


    address override public rewarded_token;


    


    uint override public reward_integral;


    mapping(address => uint) override public reward_integral_for;


    mapping(address => uint) override public rewards_for;


    mapping(address => uint) override public claimed_rewards_for;


    





	uint public span;


	uint public end;


	uint public begin;





	function initialize(address governor, address _minter, address _lp_token) public initializer {


	    super.initialize(governor);


	    


	    minter      = _minter;


	    crv_token   = Minter(_minter).token();


	    lp_token    = _lp_token;


	    IERC20(lp_token).totalSupply();          


	}


    


    function setSpan(uint _begin, uint _span, bool isLinear) virtual external governance {


        if( _begin == 0)


            _begin = now;


            


        span = _span;


        


        if(isLinear)


            end = _begin + _span;


        else


            end = 0;


    }


    


    function kick(address addr) virtual override external {


        _checkpoint(addr, true);


    }


    


    function set_approve_deposit(address addr, bool can_deposit) virtual override external {


        approved_to_deposit[addr][msg.sender] = can_deposit;


    }


    


    function deposit(uint amount) virtual override external {


        deposit(amount, msg.sender);


    }


    function deposit(uint amount, address addr) virtual override public {


        require(addr == msg.sender || approved_to_deposit[msg.sender][addr], 'Not approved');





        _checkpoint(addr, true);


        


        _deposit(addr, amount);


        


        balanceOf[addr] = balanceOf[addr].add(amount);


        totalSupply = totalSupply.add(amount);


        


        emit Deposit(addr, amount);


    }


    function _deposit(address addr, uint amount) virtual internal {


        lp_token.safeTransferFrom(addr, address(this), amount);


    }


    


    function withdraw() virtual  external {


        withdraw(balanceOf[msg.sender], true);


    }


    function withdraw(uint amount) virtual override external {


        withdraw(amount, true);


    }


    function withdraw(uint amount, bool claim_rewards) virtual override public {


        _checkpoint(msg.sender, claim_rewards);


        


        totalSupply = totalSupply.sub(amount);


        balanceOf[msg.sender] = balanceOf[msg.sender].sub(amount);


        


        _withdraw(msg.sender, amount);


        


        emit Withdraw(msg.sender, amount);


    }


    function _withdraw(address to, uint amount) virtual internal {


        lp_token.safeTransfer(to, amount);


    }


    


    function claimable_reward(address) virtual override public view returns (uint) {


        return 0;


    }





    function claim_rewards() virtual override public {


        return claim_rewards(msg.sender);


    }


    function claim_rewards(address) virtual override public {


        return;


    }


    function _checkpoint_rewards(address, bool) virtual internal {


        return;


    }


    


    function claimable_tokens(address addr) virtual override public view returns (uint amount) {


        if(now < begin || span == 0 || totalSupply == 0)


            return 0;


        


        amount = SMinter(minter).quotas(address(this));


        amount = amount.mul(balanceOf[addr]).div(totalSupply);


        


        uint lasttime = integrate_checkpoint_of[addr];


        if(end == 0) {                                                         


            if(now.sub(lasttime) < span)


                amount = amount.mul(now.sub(lasttime)).div(span);


        }else if(now < end)


            amount = amount.mul(now.sub(lasttime)).div(end.sub(lasttime));


        else if(lasttime >= end)


            amount = 0;


    }


    


    function _checkpoint(address addr, uint amount) virtual internal {


        if(amount > 0) {


            integrate_fraction[addr] = integrate_fraction[addr].add(amount);


            


            address teamAddr = address(config['teamAddr']);


            uint teamRatio = config['teamRatio'];


            if(teamAddr != address(0) && teamRatio != 0)


                integrate_fraction[teamAddr] = integrate_fraction[teamAddr].add(amount.mul(teamRatio).div(1 ether));


        }


    }





    function _checkpoint(address addr, bool _claim_rewards) virtual internal {


        uint amount = claimable_tokens(addr);


        _checkpoint(addr, amount);


        _checkpoint_rewards(addr, _claim_rewards);


    


        integrate_checkpoint_of[addr] = now;


    }


    


    function user_checkpoint(address addr) virtual override external returns (bool) {


        _checkpoint(addr, true);


        return true;


    }





    function integrate_checkpoint() override external view returns (uint) {


        return now;


    }


} 





c

 SExactGauge is LiquidityGauge, Configurable {


    using SafeMath for uint;


    using TransferHelper for address;


    


    bytes32 internal constant _devAddr_         = 'devAddr';


    bytes32 internal constant _devRatio_        = 'devRatio';


    bytes32 internal constant _ecoAddr_         = 'ecoAddr';


    bytes32 internal constant _ecoRatio_        = 'ecoRatio';


    bytes32 internal constant _claim_rewards_   = 'claim_rewards';


    


    address override public minter;


    address override public crv_token;


    address override public lp_token;


    address override public controller;


    address override public voting_escrow;


    mapping(address => uint) override public balanceOf;


    uint override public totalSupply;


    uint override public future_epoch_time;


    


    


    mapping(address => mapping(address => bool)) override public approved_to_deposit;


    


    mapping(address => uint) override public working_balances;


    uint override public working_supply;


    


    


    


    int128 override public period;


    uint256[100000000000000000000000000000] override public period_timestamp;


    


    


    uint256[100000000000000000000000000000] override public integrate_inv_supply;  


    


    


    mapping(address => uint) override public integrate_inv_supply_of;


    mapping(address => uint) override public integrate_checkpoint_of;


    


    


    


    mapping(address => uint) override public integrate_fraction;


    


    uint override public inflation_rate;


    


    


    address override public reward_contract;


    address override public rewarded_token;


    


    mapping(address => uint) public reward_integral_;                             


    mapping(address => mapping(address => uint)) public reward_integral_for_;     


    mapping(address => mapping(address => uint)) public rewards_for_; 


    mapping(address => mapping(address => uint)) public claimed_rewards_for_; 





	uint public span;


	uint public end;


	mapping(address => uint) public sumMiningPerOf;


	uint public sumMiningPer;


	uint public bufReward;


	uint public lasttime;


	uint public begin;


	


	function initialize(address governor, address _minter, address _lp_token) public initializer {


	    super.initialize(governor);


	    


	    minter      = _minter;


	    crv_token   = Minter(_minter).token();


	    lp_token    = _lp_token;


	    IERC20(lp_token).totalSupply();                 


	}


    


    function setSpan(uint _begin, uint _span, bool isLinear) virtual external governance {


        if( _begin == 0)


            _begin = now;


            


        span = _span;


        


        if(isLinear)


            end = _begin + _span;


        else


            end = 0;


            


        if(lasttime == 0)


            lasttime = _begin;


    }


    


    function kick(address addr) virtual override external {


        _checkpoint(addr, true);


    }


    


    function set_approve_deposit(address addr, bool can_deposit) virtual override external {


        approved_to_deposit[addr][msg.sender] = can_deposit;


    }


    


    function deposit(uint amount) virtual override external {


        deposit(amount, msg.sender);


    }


    function deposit(uint amount, address addr) virtual override public {


        require(addr == msg.sender || approved_to_deposit[msg.sender][addr], 'Not approved');





        _checkpoint(addr, config[_claim_rewards_] == 0 ? false : true);


        


        _deposit(addr, amount);





        balanceOf[msg.sender] = balanceOf[msg.sender].add(amount);


        totalSupply = totalSupply.add(amount);


        


        emit Deposit(msg.sender, amount);


    }


    function _deposit(address addr, uint amount) virtual internal {


        lp_token.safeTransferFrom(addr, address(this), amount);


    }


    


    function withdraw() virtual external {


        withdraw(balanceOf[msg.sender]);


    }


    function withdraw(uint amount) virtual override public {


        withdraw(amount, config[_claim_rewards_] == 0 ? false : true);


    }


    function withdraw(uint amount, bool _claim_rewards) virtual override public {


        _checkpoint(msg.sender, _claim_rewards);


        


        totalSupply = totalSupply.sub(amount);


        balanceOf[msg.sender] = balanceOf[msg.sender].sub(amount);


        


        _withdraw(msg.sender, amount);


        


        emit Withdraw(msg.sender, amount);


    }


    function _withdraw(address to, uint amount) virtual internal {


        lp_token.safeTransfer(to, amount);


    }


    


    function claimable_reward(address addr) virtual override public view returns (uint) {


        addr;


        return 0;


    }





    function claim_rewards() virtual override public {


        return claim_rewards(msg.sender);


    }


    function claim_rewards(address) virtual override public {


        return;


    }


    function _checkpoint_rewards(address, bool) virtual internal {


        return;


    }


    


    function claimable_tokens(address addr) virtual override public view returns (uint r) {


        r = integrate_fraction[addr].sub(Minter(minter).minted(addr, address(this)));


        r = r.add(_claimable_last(addr, claimableDelta(), sumMiningPer, sumMiningPerOf[addr]));


    }


    


    function _claimable_last(address addr, uint delta, uint sumPer, uint lastSumPer) virtual internal view returns (uint amount) {


        if(now < begin || span == 0 || totalSupply == 0)


            return 0;


        


        amount = sumPer.sub(lastSumPer);


        amount = amount.add(delta.mul(1 ether).div(totalSupply));


        amount = amount.mul(balanceOf[addr]).div(1 ether);


    }


    function claimableDelta() virtual internal view returns(uint amount) {


        if(now < begin || span == 0 || totalSupply == 0)


            return 0;


        


        amount = SMinter(minter).quotas(address(this)).sub(bufReward);





        if(end == 0) {                                                         


            if(now.sub(lasttime) < span)


                amount = amount.mul(now.sub(lasttime)).div(span);


        }else if(now < end)


            amount = amount.mul(now.sub(lasttime)).div(end.sub(lasttime));


        else if(lasttime >= end)


            amount = 0;


    }





    function _checkpoint(address addr, uint amount) virtual internal {


        if(amount > 0) {


            integrate_fraction[addr] = integrate_fraction[addr].add(amount);


            


            addr = address(config[_devAddr_]);


            uint ratio = config[_devRatio_];


            if(addr != address(0) && ratio != 0)


                integrate_fraction[addr] = integrate_fraction[addr].add(amount.mul(ratio).div(1 ether));





            addr = address(config[_ecoAddr_]);


            ratio = config[_ecoRatio_];


            if(addr != address(0) && ratio != 0)


                integrate_fraction[addr] = integrate_fraction[addr].add(amount.mul(ratio).div(1 ether));


        }


    }


    


    function _checkpoint(address addr, bool _claim_rewards) virtual internal {


        if(now < begin || span == 0 || totalSupply == 0)


            return;


        


        uint delta = claimableDelta();


        uint amount = _claimable_last(addr, delta, sumMiningPer, sumMiningPerOf[addr]);


        


        if(delta != amount)


            bufReward = bufReward.add(delta).sub(amount);


        if(delta > 0)


            sumMiningPer = sumMiningPer.add(delta.mul(1 ether).div(totalSupply));


        if(sumMiningPerOf[addr] != sumMiningPer)


            sumMiningPerOf[addr] = sumMiningPer;


        lasttime = now;





        _checkpoint(addr, amount);


        _checkpoint_rewards(addr, _claim_rewards);


    }





    function user_checkpoint(address addr) virtual override external returns (bool) {


        _checkpoint(addr, config[_claim_rewards_] == 0 ? false : true);


        return true;


    }





    function integrate_checkpoint() override external view returns (uint) {


        return lasttime;


    }


    


    function reward_integral() virtual override external view returns (uint) {


        return reward_integral_[rewarded_token];


    }


    


    function reward_integral_for(address addr) virtual override external view returns (uint) {


        return reward_integral_for_[addr][rewarded_token];


    }


    


    function rewards_for(address addr) virtual override external view returns (uint) {


        return rewards_for_[addr][rewarded_token];


    }


    


    function claimed_rewards_for(address addr) virtual override external view returns (uint) {


        return claimed_rewards_for_[addr][rewarded_token];


    }


} 








contra

uge is SExactGauge {


	address[] public rewards;


	


	





	function initialize(address governor, address _minter, address _lp_token, address _nestGauge, address[] memory _moreRewards) public initializer {


	    super.initialize(governor, _minter, _lp_token);


	    


	    reward_contract = _nestGauge;


	    rewarded_token  = LiquidityGauge(_nestGauge).crv_token();


	    rewards         = _moreRewards;


	    rewards.push(rewarded_token);


	    address rewarded_token2 = LiquidityGauge(_nestGauge).rewarded_token();


	    if(rewarded_token2 != address(0))


    	    rewards.push(rewarded_token2);


	    


	    LiquidityGauge(_nestGauge).integrate_checkpoint();      


	    for(uint i=0; i<_moreRewards.length; i++)


	        IERC20(_moreRewards[i]).totalSupply();              


	}


    


    function _deposit(address from, uint amount) virtual override internal {


        super._deposit(from, amount);                           


        lp_token.safeApprove(reward_contract, amount);


        LiquidityGauge(reward_contract).deposit(amount);


    }





    function _withdraw(address to, uint amount) virtual override internal {


        LiquidityGauge(reward_contract).withdraw(amount);


        super._withdraw(to, amount);                            


    }


    


    function claim_rewards(address to) virtual override public {


        if(now < begin || span == 0 || totalSupply == 0)


            return;


        


        _checkpoint_rewards(to, true);


        


        for(uint i=0; i<rewards.length; i++) {


            uint amount = rewards_for_[to][rewards[i]].sub(claimed_rewards_for_[to][rewards[i]]);


            if(amount > 0) {


                rewards[i].safeTransfer(to, amount);


                claimed_rewards_for_[to][rewards[i]] = rewards_for_[to][rewards[i]];


            }


        }


    }





    function _checkpoint_rewards(address addr, bool _claim_rewards) virtual override internal {


        if(now < begin || span == 0 || totalSupply == 0)


            return;


        


        uint[] memory drs = new uint[](rewards.length);


        


        if(_claim_rewards) {


            for(uint i=0; i<drs.length; i++)


                drs[i] = IERC20(rewards[i]).balanceOf(address(this));


                


            Minter(LiquidityGauge(reward_contract).minter()).mint(reward_contract);


            LiquidityGauge(reward_contract).claim_rewards();


            


            for(uint i=0; i<drs.length; i++)


                drs[i] = IERC20(rewards[i]).balanceOf(address(this)).sub(drs[i]);


        }





        for(uint i=0; i<drs.length; i++) {


            uint amount = _claimable_last(addr, drs[i], reward_integral_[rewards[i]], reward_integral_for_[msg.sender][rewards[i]]);


            if(amount > 0)


                rewards_for_[addr][rewards[i]] = rewards_for_[addr][rewards[i]].add(amount);


            


            if(drs[i] > 0)


                reward_integral_[rewards[i]] = reward_integral_[rewards[i]].add(drs[i].mul(1 ether).div(totalSupply));


            if(reward_integral_for_[addr][rewards[i]] != reward_integral_[rewards[i]])


                reward_integral_for_[addr][rewards[i]] = reward_integral_[rewards[i]];


        }


    }





    function claimable_reward(address addr) virtual override public view returns (uint r) {


        


        uint delta = LiquidityGauge(reward_contract).integrate_fraction(address(this)).sub(Minter(LiquidityGauge(reward_contract).minter()).minted(address(this), reward_contract));


        r = _claimable_last(addr, delta, reward_integral_[rewarded_token], reward_integral_for_[addr][rewarded_token]);


        r = r.add(rewards_for_[addr][rewarded_token].sub(claimed_rewards_for_[addr][rewarded_token]));


    }


    


    function claimable_reward2(address addr) virtual public view returns (uint r) {


        uint delta = LiquidityGauge(reward_contract).claimable_reward(address(this));


        address reward2 = LiquidityGauge(reward_contract).rewarded_token();


        r = _claimable_last(addr, delta, reward_integral_[reward2], reward_integral_for_[addr][reward2]);


        r = r.add(rewards_for_[addr][reward2].sub(claimed_rewards_for_[addr][reward2]));


    }    





    function claimable_reward(address addr, address reward) virtual public view returns (uint r) {


        r = _claimable_last(addr, 0, reward_integral_[reward], reward_integral_for_[addr][reward]);


        r = r.add(rewards_for_[addr][reward].sub(claimed_rewards_for_[addr][reward]));


    }


    


    function claimed_rewards_for2(address addr) virtual public view returns (uint) {


        return claimed_rewards_for_[addr][LiquidityGauge(reward_contract).rewarded_token()];


    }


    


    function rewards_for2(address addr) virtual public view returns (uint) {


        return rewards_for_[addr][LiquidityGauge(reward_contract).rewarded_token()];


    }


    


}








contrac

 is Minter, Configurable {


    using SafeMath for uint;


    using Address for address payable;


    using TransferHelper for address;


    


	bytes32 internal constant _allowContract_   = 'allowContract';


	bytes32 internal constant _allowlist_       = 'allowlist';


	bytes32 internal constant _blocklist_       = 'blocklist';





    address override public token;


    address override public controller;


    mapping(address => mapping(address => uint)) override public minted;                    


    mapping(address => mapping(address => bool)) override public allowed_to_mint_for;       


    mapping(address => uint) public quotas;                                                 





    function initialize(address governor, address token_) public initializer {


        super.initialize(governor);


        token = token_;


    }


    


    function setGaugeQuota(address gauge, uint quota) public governance {


       quotas[gauge] = quota;


    }


    


    function mint(address gauge) virtual override public {


        mint_for(gauge, msg.sender);   


    }


    


    function mint_many(address[8] calldata gauges) virtual override external {


        for(uint i=0; i<gauges.length; i++)


            mint(gauges[i]);


    }


    


    function mint_many(address[] calldata gauges) virtual external {


        for(uint i=0; i<gauges.length; i++)


            mint(gauges[i]);


    }


    


    function mint_for(address gauge, address _for) virtual override public {


        require(_for == msg.sender || allowed_to_mint_for[msg.sender][_for], 'Not approved');


        require(quotas[gauge] > 0, 'No quota');


        


        require(getConfig(_blocklist_, msg.sender) == 0, 'In blocklist');


        bool isContract = msg.sender.isContract();


        require(!isContract || config[_allowContract_] != 0 || getConfig(_allowlist_, msg.sender) != 0, 'No allowContract');





        LiquidityGauge(gauge).user_checkpoint(_for);


        uint total_mint = LiquidityGauge(gauge).integrate_fraction(_for);


        uint to_mint = total_mint.sub(minted[_for][gauge]);


    


        if(to_mint != 0) {


            quotas[gauge] = quotas[gauge].sub(to_mint);


            token.safeTransfer(_for, to_mint);


            minted[_for][gauge] = total_mint;


    


            emit Minted(_for, gauge, total_mint);


        }


    }


    


    function toggle_approve_mint(address minting_user) virtual override external {


        allowed_to_mint_for[minting_user][msg.sender] = !allowed_to_mint_for[minting_user][msg.sender];


    }


}








    function add(uint256 a, uint256 b) internal pure returns (uint256) {


        uint256 c = a + b;


        require(c >= a, "SafeMath: addition overflow");





        return c;


    }





    


    function sub(uint256 a, uint256 b) internal pure returns (uint256) {


        return sub(a, b, "SafeMath: subtraction overflow");


    }





    


    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {


        require(b <= a, errorMessage);


        uint256 c = a - b;





        return c;


    }





    


    function mul(uint256 a, uint256 b) internal pure returns (uint256) {


        


        


        


        if (a == 0) {


            return 0;


        }





        uint256 c = a * b;


        require(c / a == b, "SafeMath: multiplication overflow");





        return c;


    }





    


    function div(uint256 a, uint256 b) internal pure returns (uint256) {


        return div(a, b, "SafeMath: division by zero");


    }





    


    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {


        require(b > 0, errorMessage);


        uint256 c = a / b;


        





        return c;


    }





    


    function mod(uint256 a, uint256 b) internal pure returns (uint256) {


        return mod(a, b, "SafeMath: modulo by zero");


    }





    


    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {


        require(b != 0, errorMessage);


        return a % b;


    }


    


	function sqrt(uint x)public pure returns(uint y) {


        uint z = (x + 1) / 2;


        y = x;


        while (z < y) {


            y = z;


            z = (x / z + z) / 2;


        }


    }


}

library Address {


    


    function isContract(address account) internal view returns (bool) {


        


        


        





        uint256 size;


        


        assembly { size := extcodesize(account) }


        return size > 0;


    }





    


    function sendValue(address payable recipient, uint256 amount) internal {


        require(address(this).balance >= amount, "Address: insufficient balance");





        


        (bool success, ) = recipient.call{ value: amount }("");


        require(success, "Address: unable to send value, recipient may have reverted");


    }





    


    function functionCall(address target, bytes memory data) internal returns (bytes memory) {


      return functionCall(target, data, "Address: low-level call failed");


    }





    


    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {


        return _functionCallWithValue(target, data, 0, errorMessage);


    }





    


    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {


        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");


    }





    


    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {


        require(address(this).balance >= value, "Address: insufficient balance for call");


        return _functionCallWithValue(target, data, value, errorMessage);


    }





    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {


        require(isContract(target), "Address: call to non-contract");





        


        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);


        if (success) {


            return returndata;


        } else {


            


            if (returndata.length > 0) {


                





                


                assembly {


                    let returndata_size := mload(returndata)


                    revert(add(32, returndata), returndata_size)


                }


            } else {


                revert(errorMessage);


            }


        }


    }


}

interface IERC20 {


    


    function totalSupply() external view returns (uint256);





    


    function balanceOf(address account) external view returns (uint256);





    


    function transfer(address recipient, uint256 amount) external returns (bool);





    


    function allowance(address owner, address spender) external view returns (uint256);





    


    function approve(address spender, uint256 amount) external returns (bool);





    


    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);





    


    event Transfer(address indexed from, address indexed to, uint256 value);





    


    event Approval(address indexed owner, address indexed spender, uint256 value);


}

contract ERC20 is Context, IERC20 {


    using SafeMath for uint256;


    using Address for address;





    mapping (address => uint256) public _balances;





    mapping (address => mapping (address => uint256)) internal _allowances;





    uint256 public _totalSupply;





    string internal _name;


    string internal _symbol;


    uint8 internal _decimals;





    


    constructor (string memory name, string memory symbol) public {


        _name = name;


        _symbol = symbol;


        _decimals = 18;


    }


    


    


    function name() public view returns (string memory) {


        return _name;


    }





    


    function symbol() public view returns (string memory) {


        return _symbol;


    }





    


    function decimals() public view returns (uint8) {


        return _decimals;


    }





    


    function totalSupply() public view virtual override returns (uint256) {


        return _totalSupply;


    }





    


    function balanceOf(address account) public view virtual override returns (uint256) {


        return _balances[account];


    }





    


    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {


        _transfer(_msgSender(), recipient, amount);


        return true;


    }





    


    function allowance(address owner, address spender) public view virtual override returns (uint256) {


        return _allowances[owner][spender];


    }





    


    function approve(address spender, uint256 amount) public virtual override returns (bool) {


        _approve(_msgSender(), spender, amount);


        return true;


    }





    


    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {


        _transfer(sender, recipient, amount);


        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, "ERC20: transfer amount exceeds allowance"));


        return true;


    }





    


    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {


        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));


        return true;


    }





    


    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {


        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, "ERC20: decreased allowance below zero"));


        return true;


    }





    


    function _transfer(address sender, address recipient, uint256 amount) internal virtual {


        require(sender != address(0), "ERC20: transfer from the zero address");


        require(recipient != address(0), "ERC20: transfer to the zero address");





        _beforeTokenTransfer(sender, recipient, amount);





        _balances[sender] = _balances[sender].sub(amount, "ERC20: transfer amount exceeds balance");


        _balances[recipient] = _balances[recipient].add(amount);


        emit Transfer(sender, recipient, amount);


    }





    


    function _mint(address account, uint256 amount) internal virtual {


        require(account != address(0), "ERC20: mint to the zero address");





        _beforeTokenTransfer(address(0), account, amount);





        _totalSupply = _totalSupply.add(amount);


        _balances[account] = _balances[account].add(amount);


        emit Transfer(address(0), account, amount);


    }





    


    function _burn(address account, uint256 amount) internal virtual {


        require(account != address(0), "ERC20: burn from the zero address");





        _beforeTokenTransfer(account, address(0), amount);





        _balances[account] = _balances[account].sub(amount, "ERC20: burn amount exceeds balance");


        _totalSupply = _totalSupply.sub(amount);


        emit Transfer(account, address(0), amount);


    }





    


    function _approve(address owner, address spender, uint256 amount) internal virtual {


        require(owner != address(0), "ERC20: approve from the zero address");


        require(spender != address(0), "ERC20: approve to the zero address");





        _allowances[owner][spender] = amount;


        emit Approval(owner, spender, amount);


    }





    


    function _setupDecimals(uint8 decimals_) internal {


        _decimals = decimals_;


    }





    


    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }


    


}

contract SfgToken is ERC20 {





	constructor(address SfgFarm) ERC20("Stable Finance Governance Token", "SFG") public {


		uint8 decimals = 18;


		_setupDecimals(decimals);


		


		_mint(SfgFarm,  21000000 * 10 ** uint256(decimals));       


	}


}

contract SfyToken is ERC20 {





	constructor(address SfyFarm) ERC20("Stable Finance Yield Token", "SFY") public {


		uint8 decimals = 18;


		_setupDecimals(decimals);


		


		_mint(SfyFarm,  21000000 * 10 ** uint256(decimals));       


	}


}

library TransferHelper {


    function safeApprove(address token, address to, uint value) internal {


        


        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));


        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');


    }





    function safeTransfer(address token, address to, uint value) internal {


        


        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));


        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');


    }





    function safeTransferFrom(address token, address from, address to, uint value) internal {


        


        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));


        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');


    }





    function safeTransferETH(address to, uint value) internal {


        (bool success,) = to.call{value:value}(new bytes(0));


        require(success, 'TransferHelper: ETH_TRANSFER_FAILED');


    }


}
