



pragma solidity 0.5.16;
pragma experimental ABIEncoderV2;


contract LibDerivative {
    
    struct Derivative {
        
        uint256 margin;
        
        uint256 endTime;
        
        uint256[] params;
        
        address oracleId;
        
        address token;
        
        address syntheticId;
    }

    
    
    
    function getDerivativeHash(Derivative memory _derivative) public pure returns (bytes32 derivativeHash) {
        derivativeHash = keccak256(abi.encodePacked(
            _derivative.margin,
            _derivative.endTime,
            _derivative.params,
            _derivative.oracleId,
            _derivative.token,
            _derivative.syntheticId
        ));
    }
}



pragma solidity ^0.5.0;


interface IERC20 {
    
    function totalSupply() external view returns (uint256);

    
    function balanceOf(address account) external view returns (uint256);

    
    function transfer(address recipient, uint256 amount) external returns (bool);

    
    function allowance(address owner, address spender) external view returns (uint256);

    
    function approve(address spender, uint256 amount) external returns (bool);

    
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);

    
    event Transfer(address indexed from, address indexed to, uint256 value);

    
    event Approval(address indexed owner, address indexed spender, uint256 value);
}



pragma solidity ^0.5.0;


library SafeMath {
    
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, "SafeMath: addition overflow");

        return c;
    }

    
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        return sub(a, b, "SafeMath: subtraction overflow");
    }

    
    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b <= a, errorMessage);
        uint256 c = a - b;

        return c;
    }

    
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        
        
        
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b, "SafeMath: multiplication overflow");

        return c;
    }

    
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        return div(a, b, "SafeMath: division by zero");
    }

    
    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        
        require(b > 0, errorMessage);
        uint256 c = a / b;
        

        return c;
    }

    
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        return mod(a, b, "SafeMath: modulo by zero");
    }

    
    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b != 0, errorMessage);
        return a % b;
    }
}



pragma solidity ^0.5.5;


library Address {
    
    function isContract(address account) internal view returns (bool) {
        
        
        

        
        
        
        bytes32 codehash;
        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;
        
        assembly { codehash := extcodehash(account) }
        return (codehash != 0x0 && codehash != accountHash);
    }

    
    function toPayable(address account) internal pure returns (address payable) {
        return address(uint160(account));
    }

    
    function sendValue(address payable recipient, uint256 amount) internal {
        require(address(this).balance >= amount, "Address: insufficient balance");

        
        (bool success, ) = recipient.call.value(amount)("");
        require(success, "Address: unable to send value, recipient may have reverted");
    }
}



pragma solidity ^0.5.0;





library SafeERC20 {
    using SafeMath for uint256;
    using Address for address;

    function safeTransfer(IERC20 token, address to, uint256 value) internal {
        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));
    }

    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {
        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));
    }

    function safeApprove(IERC20 token, address spender, uint256 value) internal {
        
        
        
        
        require((value == 0) || (token.allowance(address(this), spender) == 0),
            "SafeERC20: approve from non-zero to non-zero allowance"
        );
        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));
    }

    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {
        uint256 newAllowance = token.allowance(address(this), spender).add(value);
        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
    }

    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {
        uint256 newAllowance = token.allowance(address(this), spender).sub(value, "SafeERC20: decreased allowance below zero");
        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
    }

    
    function callOptionalReturn(IERC20 token, bytes memory data) private {
        
        

        
        
        
        
        
        require(address(token).isContract(), "SafeERC20: call to non-contract");

        
        (bool success, bytes memory returndata) = address(token).call(data);
        require(success, "SafeERC20: low-level call failed");

        if (returndata.length > 0) { 
            
            require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");
        }
    }
}



pragma solidity ^0.5.0;


contract ReentrancyGuard {
    
    uint256 private _guardCounter;

    constructor () internal {
        
        
        _guardCounter = 1;
    }

    
    modifier nonReentrant() {
        _guardCounter += 1;
        uint256 localCounter = _guardCounter;
        _;
        require(localCounter == _guardCounter, "ReentrancyGuard: reentrant call");
    }
}



pragma solidity ^0.5.4;

library LibPosition {
  function getLongTokenId(bytes32 _hash) public pure returns (uint256 tokenId) {
    tokenId = uint256(keccak256(abi.encodePacked(_hash, "LONG")));
  }

  function getShortTokenId(bytes32 _hash) public pure returns (uint256 tokenId) {
    tokenId = uint256(keccak256(abi.encodePacked(_hash, "SHORT")));
  }
}



pragma solidity 0.5.16;



contract IDerivativeLogic is LibDerivative {
    
    
    
    function validateInput(Derivative memory _derivative) public view returns (bool);

    
    
    
    
    function getMargin(Derivative memory _derivative) public view returns (uint256 buyerMargin, uint256 sellerMargin);

    
    
    
    
    
    function getExecutionPayout(Derivative memory _derivative, uint256 _result)	public view returns (uint256 buyerPayout, uint256 sellerPayout);

    
    
    function getAuthorAddress() public view returns (address authorAddress);

    
    
    function getAuthorCommission() public view returns (uint256 commission);

    
    
    
    function thirdpartyExecutionAllowed(address _derivativeOwner) public view returns (bool);

    
    
    function isPool() public view returns (bool);

    
    
    function allowThirdpartyExecution(bool _allow) public;

    
    event MetadataSet(string metadata);
}



pragma solidity 0.5.16;

contract CoreErrors {
    string constant internal ERROR_CORE_NOT_POOL = "CORE:NOT_POOL";
    string constant internal ERROR_CORE_CANT_BE_POOL = "CORE:CANT_BE_POOL";

    string constant internal ERROR_CORE_TICKER_WAS_CANCELLED = "CORE:TICKER_WAS_CANCELLED";
    string constant internal ERROR_CORE_SYNTHETIC_VALIDATION_ERROR = "CORE:SYNTHETIC_VALIDATION_ERROR";
    string constant internal ERROR_CORE_NOT_ENOUGH_TOKEN_ALLOWANCE = "CORE:NOT_ENOUGH_TOKEN_ALLOWANCE";

    string constant internal ERROR_CORE_TOKEN_IDS_AND_QUANTITIES_LENGTH_DOES_NOT_MATCH = "CORE:TOKEN_IDS_AND_QUANTITIES_LENGTH_DOES_NOT_MATCH";
    string constant internal ERROR_CORE_TOKEN_IDS_AND_DERIVATIVES_LENGTH_DOES_NOT_MATCH = "CORE:TOKEN_IDS_AND_DERIVATIVES_LENGTH_DOES_NOT_MATCH";

    string constant internal ERROR_CORE_EXECUTION_BEFORE_MATURITY_NOT_ALLOWED = "CORE:EXECUTION_BEFORE_MATURITY_NOT_ALLOWED";
    string constant internal ERROR_CORE_SYNTHETIC_EXECUTION_WAS_NOT_ALLOWED = "CORE:SYNTHETIC_EXECUTION_WAS_NOT_ALLOWED";
    string constant internal ERROR_CORE_INSUFFICIENT_POOL_BALANCE = "CORE:INSUFFICIENT_POOL_BALANCE";
    string constant internal ERROR_CORE_INSUFFICIENT_P2P_BALANCE = "CORE:INSUFFICIENT_P2P_BALANCE";

    string constant internal ERROR_CORE_CANT_CANCEL_DUMMY_ORACLE_ID = "CORE:CANT_CANCEL_DUMMY_ORACLE_ID";
    string constant internal ERROR_CORE_CANCELLATION_IS_NOT_ALLOWED = "CORE:CANCELLATION_IS_NOT_ALLOWED";

    string constant internal ERROR_CORE_UNKNOWN_POSITION_TYPE = "CORE:UNKNOWN_POSITION_TYPE";
}



pragma solidity 0.5.16;

contract RegistryErrors {
    string constant internal ERROR_REGISTRY_ONLY_INITIALIZER = "REGISTRY:ONLY_INITIALIZER";
    string constant internal ERROR_REGISTRY_ONLY_OPIUM_ADDRESS_ALLOWED = "REGISTRY:ONLY_OPIUM_ADDRESS_ALLOWED";
    
    string constant internal ERROR_REGISTRY_CANT_BE_ZERO_ADDRESS = "REGISTRY:CANT_BE_ZERO_ADDRESS";

    string constant internal ERROR_REGISTRY_ALREADY_SET = "REGISTRY:ALREADY_SET";
}



pragma solidity 0.5.16;



contract Registry is RegistryErrors {

    
    address private minter;

    
    address private core;

    
    address private oracleAggregator;

    
    address private syntheticAggregator;

    
    address private tokenSpender;

    
    address private opiumAddress;

    
    address public initializer;

    
    modifier onlyInitializer() {
        require(msg.sender == initializer, ERROR_REGISTRY_ONLY_INITIALIZER);
        _;
    }

    
    constructor() public {
        initializer = msg.sender;
    }

    

    
    
    
    
    
    
    
    function init(
        address _minter,
        address _core,
        address _oracleAggregator,
        address _syntheticAggregator,
        address _tokenSpender,
        address _opiumAddress
    ) external onlyInitializer {
        require(
            minter == address(0) &&
            core == address(0) &&
            oracleAggregator == address(0) &&
            syntheticAggregator == address(0) &&
            tokenSpender == address(0) &&
            opiumAddress == address(0),
            ERROR_REGISTRY_ALREADY_SET
        );

        require(
            _minter != address(0) &&
            _core != address(0) &&
            _oracleAggregator != address(0) &&
            _syntheticAggregator != address(0) &&
            _tokenSpender != address(0) &&
            _opiumAddress != address(0),
            ERROR_REGISTRY_CANT_BE_ZERO_ADDRESS
        );

        minter = _minter;
        core = _core;
        oracleAggregator = _oracleAggregator;
        syntheticAggregator = _syntheticAggregator;
        tokenSpender = _tokenSpender;
        opiumAddress = _opiumAddress;
    }

    
    
    function changeOpiumAddress(address _opiumAddress) external {
        require(opiumAddress == msg.sender, ERROR_REGISTRY_ONLY_OPIUM_ADDRESS_ALLOWED);
        require(_opiumAddress != address(0), ERROR_REGISTRY_CANT_BE_ZERO_ADDRESS);
        opiumAddress = _opiumAddress;
    }

    

    
    
    function getMinter() external view returns (address result) {
        return minter;
    }

    
    
    function getCore() external view returns (address result) {
        return core;
    }

    
    
    function getOracleAggregator() external view returns (address result) {
        return oracleAggregator;
    }

    
    
    function getSyntheticAggregator() external view returns (address result) {
        return syntheticAggregator;
    }

    
    
    function getTokenSpender() external view returns (address result) {
        return tokenSpender;
    }

    
    
    function getOpiumAddress() external view returns (address result) {
        return opiumAddress;
    }
}



pragma solidity 0.5.16;

contract UsingRegistryErrors {
    string constant internal ERROR_USING_REGISTRY_ONLY_CORE_ALLOWED = "USING_REGISTRY:ONLY_CORE_ALLOWED";
}



pragma solidity 0.5.16;




contract UsingRegistry is UsingRegistryErrors {
    
    event RegistrySet(address registry);

    
    Registry internal registry;

    
    modifier onlyCore() {
        require(msg.sender == registry.getCore(), ERROR_USING_REGISTRY_ONLY_CORE_ALLOWED);
        _;
    }

    
    constructor(address _registry) public {
        registry = Registry(_registry);
        emit RegistrySet(_registry);
    }

    
    
    function getRegistry() external view returns (address) {
        return address(registry);
    }
}



pragma solidity 0.5.16;


contract LibCommission {
    
    uint256 constant public COMMISSION_BASE = 10000;

    
    uint256 constant public OPIUM_COMMISSION_BASE = 10;

    
    uint256 constant public OPIUM_COMMISSION_PART = 0;
}



pragma solidity ^0.5.0;


contract IERC721Receiver {
    
    function onERC721Received(address operator, address from, uint256 tokenId, bytes memory data)
    public returns (bytes4);
}



pragma solidity ^0.5.4;

library UintArray {
  function indexOf(uint256[] memory A, uint256 a) internal pure returns (uint256, bool) {
    uint256 length = A.length;
    for (uint256 i = 0; i < length; i++) {
      if (A[i] == a) {
        return (i, true);
      }
    }
    return (0, false);
  }

  function contains(uint256[] memory A, uint256 a) internal pure returns (bool) {
    (, bool isIn) = indexOf(A, a);
    return isIn;
  }

  function difference(uint256[] memory A, uint256[] memory B) internal pure returns (uint256[] memory, uint256[] memory) {
    uint256 length = A.length;
    bool[] memory includeMap = new bool[](length);
    uint256 count = 0;
    
    for (uint256 i = 0; i < length; i++) {
      uint256 e = A[i];
      if (!contains(B, e)) {
        includeMap[i] = true;
        count++;
      }
    }
    uint256[] memory newUints = new uint256[](count);
    uint256[] memory newUintsIdxs = new uint256[](count);
    uint256 j = 0;
    for (uint256 i = 0; i < length; i++) {
      if (includeMap[i]) {
        newUints[j] = A[i];
        newUintsIdxs[j] = i;
        j++;
      }
    }
    return (newUints, newUintsIdxs);
  }

  function intersect(uint256[] memory A, uint256[] memory B) internal pure returns (uint256[] memory, uint256[] memory, uint256[] memory) {
    uint256 length = A.length;
    bool[] memory includeMap = new bool[](length);
    uint256 newLength = 0;
    for (uint256 i = 0; i < length; i++) {
      if (contains(B, A[i])) {
        includeMap[i] = true;
        newLength++;
      }
    }
    uint256[] memory newUints = new uint256[](newLength);
    uint256[] memory newUintsAIdxs = new uint256[](newLength);
    uint256[] memory newUintsBIdxs = new uint256[](newLength);
    uint256 j = 0;
    for (uint256 i = 0; i < length; i++) {
      if (includeMap[i]) {
        newUints[j] = A[i];
        newUintsAIdxs[j] = i;
        (newUintsBIdxs[j], ) = indexOf(B, A[i]);
        j++;
      }
    }
    return (newUints, newUintsAIdxs, newUintsBIdxs);
  }

  function isUnique(uint256[] memory A) internal pure returns (bool) {
    uint256 length = A.length;

    for (uint256 i = 0; i < length; i++) {
      (uint256 idx, bool isIn) = indexOf(A, A[i]);

      if (isIn && idx < i) {
        return false;
      }
    }

    return true;
  }
}



pragma solidity ^0.5.0;


interface IERC165 {
    
    function supportsInterface(bytes4 interfaceId) external view returns (bool);
}



pragma solidity ^0.5.0;



contract ERC165 is IERC165 {
    
    bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;

    
    mapping(bytes4 => bool) private _supportedInterfaces;

    constructor () internal {
        
        
        _registerInterface(_INTERFACE_ID_ERC165);
    }

    
    function supportsInterface(bytes4 interfaceId) external view returns (bool) {
        return _supportedInterfaces[interfaceId];
    }

    
    function _registerInterface(bytes4 interfaceId) internal {
        require(interfaceId != 0xffffffff, "ERC165: invalid interface id");
        _supportedInterfaces[interfaceId] = true;
    }
}



pragma solidity ^0.5.0;



contract IERC721 is IERC165 {
    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);
    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);
    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);

    
    function balanceOf(address owner) public view returns (uint256 balance);

    
    function ownerOf(uint256 tokenId) public view returns (address owner);

    
    function safeTransferFrom(address from, address to, uint256 tokenId) public;
    
    function transferFrom(address from, address to, uint256 tokenId) public;
    function approve(address to, uint256 tokenId) public;
    function getApproved(uint256 tokenId) public view returns (address operator);

    function setApprovalForAll(address operator, bool _approved) public;
    function isApprovedForAll(address owner, address operator) public view returns (bool);


    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public;
}



pragma solidity ^0.5.4;

contract IERC721O {
  
  function name() external view returns (string memory);
  function symbol() external view returns (string memory);
  function totalSupply() public view returns (uint256);
  function exists(uint256 _tokenId) public view returns (bool);

  function implementsERC721() public pure returns (bool);
  function tokenByIndex(uint256 _index) public view returns (uint256);
  function tokenOfOwnerByIndex(address _owner, uint256 _index) public view returns (uint256 _tokenId);
  function tokenURI(uint256 _tokenId) public view returns (string memory tokenUri);
  function getApproved(uint256 _tokenId) public view returns (address);
  
  function implementsERC721O() public pure returns (bool);
  function ownerOf(uint256 _tokenId) public view returns (address _owner);
  function balanceOf(address owner) public view returns (uint256);
  function balanceOf(address _owner, uint256 _tokenId) public view returns (uint256);
  function tokensOwned(address _owner) public view returns (uint256[] memory, uint256[] memory);

  
  function safeTransferFrom(address _from, address _to, uint256 _tokenId) public;
  function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes memory _data) public;

  
  function transferFrom(address _from, address _to, uint256 _tokenId) public;

  
  function transfer(address _to, uint256 _tokenId, uint256 _quantity) public;

  
  function transferFrom(address _from, address _to, uint256 _tokenId, uint256 _quantity) public;

  
  function safeTransferFrom(address _from, address _to, uint256 _tokenId, uint256 _amount) public;
  function safeTransferFrom(address _from, address _to, uint256 _tokenId, uint256 _amount, bytes memory _data) public;

  
  function safeBatchTransferFrom(address _from, address _to, uint256[] memory _tokenIds, uint256[] memory _amounts) public;
  function safeBatchTransferFrom(address _from, address _to, uint256[] memory _tokenIds, uint256[] memory _amounts, bytes memory _data) public;

  
  function batchTransferFrom(address _from, address _to, uint256[] memory _tokenIds, uint256[] memory _amounts) public;

  
  function setApprovalForAll(address _operator, bool _approved) public;
  function approve(address _to, uint256 _tokenId) public;
  function getApproved(uint256 _tokenId, address _tokenOwner) public view returns (address);
  function isApprovedForAll(address _owner, address _operator) public view returns (bool isOperator);
  function isApprovedOrOwner(address _spender, address _owner, uint256 _tokenId) public view returns (bool);
  function permit(address _holder, address _spender, uint256 _nonce, uint256 _expiry, bool _allowed, bytes calldata _signature) external;

  
  function compose(uint256[] memory _tokenIds, uint256[] memory _tokenRatio, uint256 _quantity) public;
  function decompose(uint256 _portfolioId, uint256[] memory _tokenIds, uint256[] memory _tokenRatio, uint256 _quantity) public;
  function recompose(uint256 _portfolioId, uint256[] memory _initialTokenIds, uint256[] memory _initialTokenRatio, uint256[] memory _finalTokenIds, uint256[] memory _finalTokenRatio, uint256 _quantity) public;

  
  event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);
  event TransferWithQuantity(address indexed from, address indexed to, uint256 indexed tokenId, uint256 quantity);
  event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);
  event BatchTransfer(address indexed from, address indexed to, uint256[] tokenTypes, uint256[] amounts);
  event Composition(uint256 portfolioId, uint256[] tokenIds, uint256[] tokenRatio);
}



pragma solidity ^0.5.4;


contract IERC721OReceiver {
  
  bytes4 constant internal ERC721O_RECEIVED = 0xf891ffe0;
  bytes4 constant internal ERC721O_BATCH_RECEIVED = 0xd0e17c0b;

  function onERC721OReceived(
    address _operator,
    address _from,
    uint256 tokenId,
    uint256 amount,
    bytes memory data
  ) public returns(bytes4);

  function onERC721OBatchReceived(
    address _operator,
    address _from,
    uint256[] memory _types,
    uint256[] memory _amounts,
    bytes memory _data
  ) public returns (bytes4);
}



pragma solidity ^0.5.4;


library ObjectLib {
  
  using SafeMath for uint256;

  enum Operations { ADD, SUB, REPLACE }

  
  uint256 constant TYPES_BITS_SIZE   = 32;                     
  uint256 constant TYPES_PER_UINT256 = 256 / TYPES_BITS_SIZE; 

  
  
  

  
  function getTokenBinIndex(uint256 _tokenId) internal pure returns (uint256 bin, uint256 index) {
    bin = _tokenId * TYPES_BITS_SIZE / 256;
    index = _tokenId % TYPES_PER_UINT256;
    return (bin, index);
  }


  
  function updateTokenBalance(
    uint256 _binBalances,
    uint256 _index,
    uint256 _amount,
    Operations _operation) internal pure returns (uint256 newBinBalance)
  {
    uint256 objectBalance;
    if (_operation == Operations.ADD) {
      objectBalance = getValueInBin(_binBalances, _index);
      newBinBalance = writeValueInBin(_binBalances, _index, objectBalance.add(_amount));
    } else if (_operation == Operations.SUB) {
      objectBalance = getValueInBin(_binBalances, _index);
      newBinBalance = writeValueInBin(_binBalances, _index, objectBalance.sub(_amount));
    } else if (_operation == Operations.REPLACE) {
      newBinBalance = writeValueInBin(_binBalances, _index, _amount);
    } else {
      revert("Invalid operation"); 
    }

    return newBinBalance;
  }
  
  
  function getValueInBin(uint256 _binValue, uint256 _index) internal pure returns (uint256) {

    
    uint256 mask = (uint256(1) << TYPES_BITS_SIZE) - 1;

    
    uint256 rightShift = 256 - TYPES_BITS_SIZE * (_index + 1);
    return (_binValue >> rightShift) & mask;
  }

  
  function writeValueInBin(uint256 _binValue, uint256 _index, uint256 _amount) internal pure returns (uint256) {
    require(_amount < 2**TYPES_BITS_SIZE, "Amount to write in bin is too large");

    
    uint256 mask = (uint256(1) << TYPES_BITS_SIZE) - 1;

    
    uint256 leftShift = 256 - TYPES_BITS_SIZE * (_index + 1);
    return (_binValue & ~(mask << leftShift) ) | (_amount << leftShift);
  }

}



pragma solidity ^0.5.4;






contract ERC721OBase is IERC721O, ERC165, IERC721 {
  
  using ObjectLib for ObjectLib.Operations;
  using ObjectLib for uint256;

  
  uint256[] internal allTokens;

  
  mapping(address => mapping(uint256 => uint256)) internal packedTokenBalance;

  
  mapping(address => mapping(address => bool)) internal operators;

  
  
  mapping (uint256 => mapping (address => address)) internal tokenApprovals;

  
  mapping(uint256 => uint256) internal tokenTypes;

  uint256 constant internal INVALID = 0;
  uint256 constant internal POSITION = 1;
  uint256 constant internal PORTFOLIO = 2;

  
  bytes4 internal constant INTERFACE_ID_ERC721O = 0x12345678;

  
  bytes32 public DOMAIN_SEPARATOR;
  bytes32 public PERMIT_TYPEHASH;

  
  
  mapping (address => uint) public nonces;

  modifier isOperatorOrOwner(address _from) {
    require((msg.sender == _from) || operators[_from][msg.sender], "msg.sender is neither _from nor operator");
    _;
  }

  constructor() public {
    _registerInterface(INTERFACE_ID_ERC721O);
    
    
    DOMAIN_SEPARATOR = keccak256(abi.encode(
      keccak256("EIP712Domain(string name,string version,address verifyingContract)"),
      keccak256(bytes("ERC721o")),
      keccak256(bytes("1")),
      address(this)
    ));
    PERMIT_TYPEHASH = keccak256("Permit(address holder,address spender,uint256 nonce,uint256 expiry,bool allowed)");
  }

  function implementsERC721O() public pure returns (bool) {
    return true;
  }

  
  function exists(uint256 _tokenId) public view returns (bool) {
    return tokenTypes[_tokenId] != INVALID;
  }

  
  function balanceOf(address _address, uint256 _tokenId) public view returns (uint256) {
    (uint256 bin, uint256 index) = _tokenId.getTokenBinIndex();
    return packedTokenBalance[_address][bin].getValueInBin(index);
  }

  
  function totalSupply() public view returns (uint256) {
    return allTokens.length;
  }

  
  function tokensOwned(address _owner) public view returns (uint256[] memory indexes, uint256[] memory balances) {
    uint256 numTokens = totalSupply();
    uint256[] memory tokenIndexes = new uint256[](numTokens);
    uint256[] memory tempTokens = new uint256[](numTokens);

    uint256 count;
    for (uint256 i = 0; i < numTokens; i++) {
      uint256 tokenId = allTokens[i];
      if (balanceOf(_owner, tokenId) > 0) {
        tempTokens[count] = balanceOf(_owner, tokenId);
        tokenIndexes[count] = tokenId;
        count++;
      }
    }

    
    uint256[] memory _ownedTokens = new uint256[](count);
    uint256[] memory _ownedTokensIndexes = new uint256[](count);

    for (uint256 i = 0; i < count; i++) {
      _ownedTokens[i] = tempTokens[i];
      _ownedTokensIndexes[i] = tokenIndexes[i];
    }

    return (_ownedTokensIndexes, _ownedTokens);
  }

  
  function setApprovalForAll(address _operator, bool _approved) public {
    
    operators[msg.sender][_operator] = _approved;
    emit ApprovalForAll(msg.sender, _operator, _approved);
  }

  
  function permit(address _holder, address _spender, uint256 _nonce, uint256 _expiry, bool _allowed, bytes calldata _signature) external {
    
    bytes32 digest =
      keccak256(abi.encodePacked(
        "\x19\x01",
        DOMAIN_SEPARATOR,
        keccak256(abi.encode(
          PERMIT_TYPEHASH,
          _holder,
          _spender,
          _nonce,
          _expiry,
          _allowed
        ))
    ));

    
    
    
    
    bytes32 r;
    bytes32 s;
    uint8 v;

    bytes memory signature = _signature;

    assembly {
      r := mload(add(signature, 32))
      s := mload(add(signature, 64))
      v := byte(0, mload(add(signature, 96)))
    }

    
    if (v < 27) {
      v += 27;
    }

    address recoveredAddress;

    
    if (v != 27 && v != 28) {
      recoveredAddress = address(0);
    } else {
      
      recoveredAddress = ecrecover(digest, v, r, s);
    }

    require(_holder != address(0), "Holder can't be zero address");
    require(_holder == recoveredAddress, "Signer address is invalid");
    require(_expiry == 0 || now <= _expiry, "Permission expired");
    require(_nonce == nonces[_holder]++, "Nonce is invalid");
    
    
    operators[_holder][_spender] = _allowed;
    emit ApprovalForAll(_holder, _spender, _allowed);
  }

  
  function approve(address _to, uint256 _tokenId) public {
    require(_to != msg.sender, "Can't approve to yourself");
    tokenApprovals[_tokenId][msg.sender] = _to;
    emit Approval(msg.sender, _to, _tokenId);
  }

  
  function getApproved(uint256 _tokenId, address _tokenOwner) public view returns (address) {
    return tokenApprovals[_tokenId][_tokenOwner];
  }

  
  function isApprovedForAll(address _owner, address _operator) public view returns (bool isOperator) {
    return operators[_owner][_operator];
  }

  function isApprovedOrOwner(
    address _spender,
    address _owner,
    uint256 _tokenId
  ) public view returns (bool) {
    return (
      _spender == _owner ||
      getApproved(_tokenId, _owner) == _spender ||
      isApprovedForAll(_owner, _spender)
    );
  }

  function _updateTokenBalance(
    address _from,
    uint256 _tokenId,
    uint256 _amount,
    ObjectLib.Operations op
  ) internal {
    (uint256 bin, uint256 index) = _tokenId.getTokenBinIndex();
    packedTokenBalance[_from][bin] = packedTokenBalance[_from][bin].updateTokenBalance(
      index, _amount, op
    );
  }
}



pragma solidity ^0.5.4;




contract ERC721OTransferable is ERC721OBase, ReentrancyGuard {
  
  using Address for address;

  
  bytes4 internal constant ERC721O_RECEIVED = 0xf891ffe0;
  bytes4 internal constant ERC721O_BATCH_RECEIVED = 0xd0e17c0b;

  function batchTransferFrom(address _from, address _to, uint256[] memory _tokenIds, uint256[] memory _amounts) public {
    
    _batchTransferFrom(_from, _to, _tokenIds, _amounts);
  }

  
  function safeBatchTransferFrom(
    address _from,
    address _to,
    uint256[] memory _tokenIds,
    uint256[] memory _amounts,
    bytes memory _data
  ) public nonReentrant {
    
    _batchTransferFrom(_from, _to, _tokenIds, _amounts);

    
    if (_to.isContract()) {
      bytes4 retval = IERC721OReceiver(_to).onERC721OBatchReceived(
        msg.sender, _from, _tokenIds, _amounts, _data
      );
      require(retval == ERC721O_BATCH_RECEIVED);
    }
  }

  function safeBatchTransferFrom(
    address _from,
    address _to,
    uint256[] memory _tokenIds,
    uint256[] memory _amounts
  ) public {
    safeBatchTransferFrom(_from, _to, _tokenIds, _amounts, "");
  }

  function transfer(address _to, uint256 _tokenId, uint256 _amount) public {
    _transferFrom(msg.sender, _to, _tokenId, _amount);
  }

  function transferFrom(address _from, address _to, uint256 _tokenId, uint256 _amount) public {
    _transferFrom(_from, _to, _tokenId, _amount);
  }

  function safeTransferFrom(address _from, address _to, uint256 _tokenId, uint256 _amount) public {
    safeTransferFrom(_from, _to, _tokenId, _amount, "");
  }

  function safeTransferFrom(address _from, address _to, uint256 _tokenId, uint256 _amount, bytes memory _data) public nonReentrant {
    _transferFrom(_from, _to, _tokenId, _amount);
    require(
      _checkAndCallSafeTransfer(_from, _to, _tokenId, _amount, _data),
      "Sent to a contract which is not an ERC721O receiver"
    );
  }

  
  function _batchTransferFrom(
    address _from,
    address _to,
    uint256[] memory _tokenIds,
    uint256[] memory _amounts
  ) internal isOperatorOrOwner(_from) {
    
    require(_tokenIds.length == _amounts.length, "Inconsistent array length between args");
    require(_to != address(0), "Invalid to address");

    
    uint256 nTransfer = _tokenIds.length;

    
    if (_from == _to) {
      for (uint256 i = 0; i < nTransfer; i++) {
        emit Transfer(_from, _to, _tokenIds[i]);
        emit TransferWithQuantity(_from, _to, _tokenIds[i], _amounts[i]);
      }
      return;
    }

    for (uint256 i = 0; i < nTransfer; i++) {
      require(_amounts[i] <= balanceOf(_from, _tokenIds[i]), "Quantity greater than from balance");
      _updateTokenBalance(_from, _tokenIds[i], _amounts[i], ObjectLib.Operations.SUB);
      _updateTokenBalance(_to, _tokenIds[i], _amounts[i], ObjectLib.Operations.ADD);

      emit Transfer(_from, _to, _tokenIds[i]);
      emit TransferWithQuantity(_from, _to, _tokenIds[i], _amounts[i]);
    }

    
    emit BatchTransfer(_from, _to, _tokenIds, _amounts);
  }

  function _transferFrom(address _from, address _to, uint256 _tokenId, uint256 _amount) internal {
    require(isApprovedOrOwner(msg.sender, _from, _tokenId), "Not approved");
    require(_amount <= balanceOf(_from, _tokenId), "Quantity greater than from balance");
    require(_to != address(0), "Invalid to address");

    _updateTokenBalance(_from, _tokenId, _amount, ObjectLib.Operations.SUB);
    _updateTokenBalance(_to, _tokenId, _amount, ObjectLib.Operations.ADD);
    emit Transfer(_from, _to, _tokenId);
    emit TransferWithQuantity(_from, _to, _tokenId, _amount);
  }

  function _checkAndCallSafeTransfer(
    address _from,
    address _to,
    uint256 _tokenId,
    uint256 _amount,
    bytes memory _data
  ) internal returns (bool) {
    if (!_to.isContract()) {
      return true;
    }

    bytes4 retval = IERC721OReceiver(_to).onERC721OReceived(msg.sender, _from, _tokenId, _amount, _data);
    return(retval == ERC721O_RECEIVED);
  }
}



pragma solidity ^0.5.4;



contract ERC721OMintable is ERC721OTransferable {
  
  using LibPosition for bytes32;

  
  function _mint(uint256 _tokenId, address _to, uint256 _supply) internal {
    
    if (!exists(_tokenId)) {
      tokenTypes[_tokenId] = POSITION;
      allTokens.push(_tokenId);
    }

    _updateTokenBalance(_to, _tokenId, _supply, ObjectLib.Operations.ADD);
    emit Transfer(address(0), _to, _tokenId);
    emit TransferWithQuantity(address(0), _to, _tokenId, _supply);
  }

  function _burn(address _tokenOwner, uint256 _tokenId, uint256 _quantity) internal {
    uint256 ownerBalance = balanceOf(_tokenOwner, _tokenId);
    require(ownerBalance >= _quantity, "TOKEN_MINTER:NOT_ENOUGH_POSITIONS");

    _updateTokenBalance(_tokenOwner, _tokenId, _quantity, ObjectLib.Operations.SUB);
    emit Transfer(_tokenOwner, address(0), _tokenId);
    emit TransferWithQuantity(_tokenOwner, address(0), _tokenId, _quantity);
  }

  function _mint(address _buyer, address _seller, bytes32 _derivativeHash, uint256 _quantity) internal {
    _mintLong(_buyer, _derivativeHash, _quantity);
    _mintShort(_seller, _derivativeHash, _quantity);
  }
  
  function _mintLong(address _buyer, bytes32 _derivativeHash, uint256 _quantity) internal {
    uint256 longTokenId = _derivativeHash.getLongTokenId();
    _mint(longTokenId, _buyer, _quantity);
  }
  
  function _mintShort(address _seller, bytes32 _derivativeHash, uint256 _quantity) internal {
    uint256 shortTokenId = _derivativeHash.getShortTokenId();
    _mint(shortTokenId, _seller, _quantity);
  }

  function _registerPortfolio(uint256 _portfolioId, uint256[] memory _tokenIds, uint256[] memory _tokenRatio) internal {
    if (!exists(_portfolioId)) {
      tokenTypes[_portfolioId] = PORTFOLIO;
      emit Composition(_portfolioId, _tokenIds, _tokenRatio);
    }
  }
}



pragma solidity ^0.5.4;




contract ERC721OComposable is ERC721OMintable {
  
  using UintArray for uint256[];
  using SafeMath for uint256;

  function compose(uint256[] memory _tokenIds, uint256[] memory _tokenRatio, uint256 _quantity) public {
    require(_tokenIds.length == _tokenRatio.length, "TOKEN_MINTER:TOKEN_IDS_AND_RATIO_LENGTH_DOES_NOT_MATCH");
    require(_quantity > 0, "TOKEN_MINTER:WRONG_QUANTITY");
    require(_tokenIds.length > 0, "TOKEN_MINTER:WRONG_QUANTITY");
    require(_tokenIds.isUnique(), "TOKEN_MINTER:TOKEN_IDS_NOT_UNIQUE");

    for (uint256 i = 0; i < _tokenIds.length; i++) {
      _burn(msg.sender, _tokenIds[i], _tokenRatio[i].mul(_quantity));
    }

    uint256 portfolioId = uint256(keccak256(abi.encodePacked(
      _tokenIds,
      _tokenRatio
    )));

    _registerPortfolio(portfolioId, _tokenIds, _tokenRatio);
    _mint(portfolioId, msg.sender, _quantity);
  }

  function decompose(uint256 _portfolioId, uint256[] memory _tokenIds, uint256[] memory _tokenRatio, uint256 _quantity) public {
    require(_tokenIds.length == _tokenRatio.length, "TOKEN_MINTER:TOKEN_IDS_AND_RATIO_LENGTH_DOES_NOT_MATCH");
    require(_quantity > 0, "TOKEN_MINTER:WRONG_QUANTITY");
    require(_tokenIds.length > 0, "TOKEN_MINTER:WRONG_QUANTITY");
    require(_tokenIds.isUnique(), "TOKEN_MINTER:TOKEN_IDS_NOT_UNIQUE");

    uint256 portfolioId = uint256(keccak256(abi.encodePacked(
      _tokenIds,
      _tokenRatio
    )));

    require(portfolioId == _portfolioId, "TOKEN_MINTER:WRONG_PORTFOLIO_ID");
    _burn(msg.sender, _portfolioId, _quantity);

    for (uint256 i = 0; i < _tokenIds.length; i++) {
      _mint(_tokenIds[i], msg.sender, _tokenRatio[i].mul(_quantity));
    }
  }

  function recompose(
    uint256 _portfolioId,
    uint256[] memory _initialTokenIds,
    uint256[] memory _initialTokenRatio,
    uint256[] memory _finalTokenIds,
    uint256[] memory _finalTokenRatio,
    uint256 _quantity
  ) public {
    require(_initialTokenIds.length == _initialTokenRatio.length, "TOKEN_MINTER:INITIAL_TOKEN_IDS_AND_RATIO_LENGTH_DOES_NOT_MATCH");
    require(_finalTokenIds.length == _finalTokenRatio.length, "TOKEN_MINTER:FINAL_TOKEN_IDS_AND_RATIO_LENGTH_DOES_NOT_MATCH");
    require(_quantity > 0, "TOKEN_MINTER:WRONG_QUANTITY");
    require(_initialTokenIds.length > 0, "TOKEN_MINTER:WRONG_QUANTITY");
    require(_finalTokenIds.length > 0, "TOKEN_MINTER:WRONG_QUANTITY");
    require(_initialTokenIds.isUnique(), "TOKEN_MINTER:TOKEN_IDS_NOT_UNIQUE");
    require(_finalTokenIds.isUnique(), "TOKEN_MINTER:TOKEN_IDS_NOT_UNIQUE");

    uint256 oldPortfolioId = uint256(keccak256(abi.encodePacked(
      _initialTokenIds,
      _initialTokenRatio
    )));

    require(oldPortfolioId == _portfolioId, "TOKEN_MINTER:WRONG_PORTFOLIO_ID");
    _burn(msg.sender, _portfolioId, _quantity);
    
    _removedIds(_initialTokenIds, _initialTokenRatio, _finalTokenIds, _finalTokenRatio, _quantity);
    _addedIds(_initialTokenIds, _initialTokenRatio, _finalTokenIds, _finalTokenRatio, _quantity);
    _keptIds(_initialTokenIds, _initialTokenRatio, _finalTokenIds, _finalTokenRatio, _quantity);

    uint256 newPortfolioId = uint256(keccak256(abi.encodePacked(
      _finalTokenIds,
      _finalTokenRatio
    )));

    _registerPortfolio(newPortfolioId, _finalTokenIds, _finalTokenRatio);
    _mint(newPortfolioId, msg.sender, _quantity);
  }

  function _removedIds(
    uint256[] memory _initialTokenIds,
    uint256[] memory _initialTokenRatio,
    uint256[] memory _finalTokenIds,
    uint256[] memory _finalTokenRatio,
    uint256 _quantity
  ) private {
    (uint256[] memory removedIds, uint256[] memory removedIdsIdxs) = _initialTokenIds.difference(_finalTokenIds);

    for (uint256 i = 0; i < removedIds.length; i++) {
      uint256 index = removedIdsIdxs[i];
      _mint(_initialTokenIds[index], msg.sender, _initialTokenRatio[index].mul(_quantity));
    }

    _finalTokenRatio;
  }

  function _addedIds(
      uint256[] memory _initialTokenIds,
      uint256[] memory _initialTokenRatio,
      uint256[] memory _finalTokenIds,
      uint256[] memory _finalTokenRatio,
      uint256 _quantity
  ) private {
    (uint256[] memory addedIds, uint256[] memory addedIdsIdxs) = _finalTokenIds.difference(_initialTokenIds);

    for (uint256 i = 0; i < addedIds.length; i++) {
      uint256 index = addedIdsIdxs[i];
      _burn(msg.sender, _finalTokenIds[index], _finalTokenRatio[index].mul(_quantity));
    }

    _initialTokenRatio;
  }

  function _keptIds(
      uint256[] memory _initialTokenIds,
      uint256[] memory _initialTokenRatio,
      uint256[] memory _finalTokenIds,
      uint256[] memory _finalTokenRatio,
      uint256 _quantity
  ) private {
    (uint256[] memory keptIds, uint256[] memory keptInitialIdxs, uint256[] memory keptFinalIdxs) = _initialTokenIds.intersect(_finalTokenIds);

    for (uint256 i = 0; i < keptIds.length; i++) {
      uint256 initialIndex = keptInitialIdxs[i];
      uint256 finalIndex = keptFinalIdxs[i];

      if (_initialTokenRatio[initialIndex] > _finalTokenRatio[finalIndex]) {
        uint256 diff = _initialTokenRatio[initialIndex] - _finalTokenRatio[finalIndex];
        _mint(_initialTokenIds[initialIndex], msg.sender, diff.mul(_quantity));
      } else if (_initialTokenRatio[initialIndex] < _finalTokenRatio[finalIndex]) {
        uint256 diff = _finalTokenRatio[finalIndex] - _initialTokenRatio[initialIndex];
        _burn(msg.sender, _initialTokenIds[initialIndex], diff.mul(_quantity));
      }
    }
  }
}



pragma solidity ^0.5.4;

library UintsLib {
  function uint2str(uint _i) internal pure returns (string memory _uintAsString) {
    if (_i == 0) {
      return "0";
    }

    uint j = _i;
    uint len;
    while (j != 0) {
      len++;
      j /= 10;
    }

    bytes memory bstr = new bytes(len);
    uint k = len - 1;
    while (_i != 0) {
      bstr[k--] = byte(uint8(48 + _i % 10));
      _i /= 10;
    }

    return string(bstr);
  }
}



pragma solidity ^0.5.4;




contract ERC721OBackwardCompatible is ERC721OComposable {
  using UintsLib for uint256;

  
  bytes4 internal constant INTERFACE_ID_ERC721 = 0x80ac58cd;
  bytes4 internal constant INTERFACE_ID_ERC721_ENUMERABLE = 0x780e9d63;
  bytes4 internal constant INTERFACE_ID_ERC721_METADATA = 0x5b5e139f;

  
  bytes4 internal constant ERC721_RECEIVED = 0x150b7a02;

  
  string internal baseTokenURI;

  constructor(string memory _baseTokenURI) public ERC721OBase() {
    baseTokenURI = _baseTokenURI;
    _registerInterface(INTERFACE_ID_ERC721);
    _registerInterface(INTERFACE_ID_ERC721_ENUMERABLE);
    _registerInterface(INTERFACE_ID_ERC721_METADATA);
  }

  
  function implementsERC721() public pure returns (bool) {
    return true;
  }

  
  function ownerOf(uint256 _tokenId) public view returns (address) {
    if (exists(_tokenId)) {
      return address(this);
    }

    return address(0);
  }

  
  function balanceOf(address _owner) public view returns (uint256 balance) {
    (, uint256[] memory tokens) = tokensOwned(_owner);
    return tokens.length;
  }

  
  
  function tokenByIndex(uint256 _index) public view returns (uint256) {
    require(_index < totalSupply());
    return allTokens[_index];
  }

  function tokenOfOwnerByIndex(address _owner, uint256 _index) public view returns (uint256 _tokenId) {
    (, uint256[] memory tokens) = tokensOwned(_owner);
    require(_index < tokens.length);
    return tokens[_index];
  }

  
  function tokenURI(uint256 _tokenId) public view returns (string memory tokenUri) {
    require(exists(_tokenId), "Token doesn't exist");
    return string(abi.encodePacked(
      baseTokenURI, 
      _tokenId.uint2str(),
      ".json"
    ));
  }

  
  function getApproved(uint256 _tokenId) public view returns (address) {
    if (exists(_tokenId)) {
      return address(this);
    }

    return address(0);
  }

  function safeTransferFrom(address _from, address _to, uint256 _tokenId) public {
    safeTransferFrom(_from, _to, _tokenId, "");
  }

  function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes memory _data) public nonReentrant {
    _transferFrom(_from, _to, _tokenId, 1);
    require(
      _checkAndCallSafeTransfer(_from, _to, _tokenId, _data),
      "Sent to a contract which is not an ERC721 receiver"
    );
  }

  function transferFrom(address _from, address _to, uint256 _tokenId) public {
    _transferFrom(_from, _to, _tokenId, 1);
  }

  
  function _checkAndCallSafeTransfer(
    address _from,
    address _to,
    uint256 _tokenId,
    bytes memory _data
  ) internal returns (bool) {
    if (!_to.isContract()) {
      return true;
    }
    bytes4 retval = IERC721Receiver(_to).onERC721Received(
        msg.sender, _from, _tokenId, _data
    );
    return (retval == ERC721_RECEIVED);
  }
}



pragma solidity 0.5.16;




contract TokenMinter is ERC721OBackwardCompatible, UsingRegistry {
    
    
    
    constructor(string memory _baseTokenURI, address _registry) public ERC721OBackwardCompatible(_baseTokenURI) UsingRegistry(_registry) {}

    
    
    
    
    
    function mint(address _buyer, address _seller, bytes32 _derivativeHash, uint256 _quantity) external onlyCore {
        _mint(_buyer, _seller, _derivativeHash, _quantity);
    }

    
    
    
    
    function mint(address _buyer, bytes32 _derivativeHash, uint256 _quantity) external onlyCore {
        _mintLong(_buyer, _derivativeHash, _quantity);
    }

    
    
    
    
    function burn(address _tokenOwner, uint256 _tokenId, uint256 _quantity) external onlyCore {
        _burn(_tokenOwner, _tokenId, _quantity);
    }

    
    
    function name() external view returns (string memory) {
        return "Opium Network Position Token";
    }

    
    
    function symbol() external view returns (string memory) {
        return "ONP";
    }

    

    
    
    
    
    
    function isApprovedOrOwner(
        address _spender,
        address _owner,
        uint256 _tokenId
    ) public view returns (bool) {
        return (
        _spender == _owner ||
        getApproved(_tokenId, _owner) == _spender ||
        isApprovedForAll(_owner, _spender) ||
        isOpiumSpender(_spender)
        );
    }

    
    
    function isOpiumSpender(address _spender) public view returns (bool) {
        return _spender == registry.getTokenSpender();
    }
}



pragma solidity 0.5.16;

contract OracleAggregatorErrors {
    string constant internal ERROR_ORACLE_AGGREGATOR_NOT_ENOUGH_ETHER = "ORACLE_AGGREGATOR:NOT_ENOUGH_ETHER";

    string constant internal ERROR_ORACLE_AGGREGATOR_QUERY_WAS_ALREADY_MADE = "ORACLE_AGGREGATOR:QUERY_WAS_ALREADY_MADE";

    string constant internal ERROR_ORACLE_AGGREGATOR_DATA_DOESNT_EXIST = "ORACLE_AGGREGATOR:DATA_DOESNT_EXIST";

    string constant internal ERROR_ORACLE_AGGREGATOR_DATA_ALREADY_EXIST = "ORACLE_AGGREGATOR:DATA_ALREADY_EXIST";
}



pragma solidity 0.5.16;


interface IOracleId {
    
    
    function fetchData(uint256 timestamp) external payable;

    
    
    
    
    function recursivelyFetchData(uint256 timestamp, uint256 period, uint256 times) external payable;

    
    
    function calculateFetchPrice() external returns (uint256 fetchPrice);

    
    event MetadataSet(string metadata);
}



pragma solidity 0.5.16;






contract OracleAggregator is OracleAggregatorErrors, ReentrancyGuard {
    using SafeMath for uint256;

    
    
    mapping (address => mapping(uint256 => uint256)) public dataCache;

    
    
    mapping (address => mapping(uint256 => bool)) public dataExist;

    
    
    mapping (address => mapping(uint256 => bool)) public dataRequested;

    

    
    
    
    modifier enoughEtherProvided(address oracleId, uint256 times) {
        
        uint256 oneTimePrice = calculateFetchPrice(oracleId);

        
        require(msg.value >= oneTimePrice.mul(times), ERROR_ORACLE_AGGREGATOR_NOT_ENOUGH_ETHER);
        _;
    }

    

    
    
    
    function fetchData(address oracleId, uint256 timestamp) public payable nonReentrant enoughEtherProvided(oracleId, 1) {
        
        _registerQuery(oracleId, timestamp);

        
        IOracleId(oracleId).fetchData.value(msg.value)(timestamp);
    }

    
    
    
    
    
    function recursivelyFetchData(address oracleId, uint256 timestamp, uint256 period, uint256 times) public payable nonReentrant enoughEtherProvided(oracleId, times) {
        
        for (uint256 i = 0; i < times; i++) {	
            _registerQuery(oracleId, timestamp + period * i);
        }

        
        IOracleId(oracleId).recursivelyFetchData.value(msg.value)(timestamp, period, times);
    }

    
    
    
    function __callback(uint256 timestamp, uint256 data) public {
        
        require(!dataExist[msg.sender][timestamp], ERROR_ORACLE_AGGREGATOR_DATA_ALREADY_EXIST);

        
        dataCache[msg.sender][timestamp] = data;

        
        dataExist[msg.sender][timestamp] = true;
    }

    
    
    
    function calculateFetchPrice(address oracleId) public returns(uint256 fetchPrice) {
        fetchPrice = IOracleId(oracleId).calculateFetchPrice();
    }

    

    
    
    
    function _registerQuery(address oracleId, uint256 timestamp) private {
        
        require(!dataRequested[oracleId][timestamp] && !dataExist[oracleId][timestamp], ERROR_ORACLE_AGGREGATOR_QUERY_WAS_ALREADY_MADE);

        
        dataRequested[oracleId][timestamp] = true;	
    }

    

    
    
    
    
    function getData(address oracleId, uint256 timestamp) public view returns(uint256 dataResult) {
        
        require(hasData(oracleId, timestamp), ERROR_ORACLE_AGGREGATOR_DATA_DOESNT_EXIST);

        
        dataResult = dataCache[oracleId][timestamp];
    }

    
    
    
    
    function hasData(address oracleId, uint256 timestamp) public view returns(bool result) {
        return dataExist[oracleId][timestamp];
    }
}



pragma solidity 0.5.16;

contract SyntheticAggregatorErrors {
    string constant internal ERROR_SYNTHETIC_AGGREGATOR_DERIVATIVE_HASH_NOT_MATCH = "SYNTHETIC_AGGREGATOR:DERIVATIVE_HASH_NOT_MATCH";
    string constant internal ERROR_SYNTHETIC_AGGREGATOR_WRONG_MARGIN = "SYNTHETIC_AGGREGATOR:WRONG_MARGIN";
    string constant internal ERROR_SYNTHETIC_AGGREGATOR_COMMISSION_TOO_BIG = "SYNTHETIC_AGGREGATOR:COMMISSION_TOO_BIG";
}



pragma solidity 0.5.16;








contract SyntheticAggregator is SyntheticAggregatorErrors, LibDerivative, LibCommission, ReentrancyGuard {
    
    event Create(Derivative derivative, bytes32 derivativeHash);

    
    
    
    
    enum SyntheticTypes { Invalid, NotPool, Pool }

    
    
    mapping (bytes32 => uint256) public buyerMarginByHash;

    
    
    mapping (bytes32 => uint256) public sellerMarginByHash;

    
    
    mapping (bytes32 => SyntheticTypes) public typeByHash;

    
    
    mapping (bytes32 => uint256) public commissionByHash;

    
    
    mapping (bytes32 => address) public authorAddressByHash;

    

    
    
    
    
    function getAuthorCommission(bytes32 _derivativeHash, Derivative memory _derivative) public nonReentrant returns (uint256 commission) {
        
        _initDerivative(_derivativeHash, _derivative);
        commission = commissionByHash[_derivativeHash];
    }

    
    
    
    
    function getAuthorAddress(bytes32 _derivativeHash, Derivative memory _derivative) public nonReentrant returns (address authorAddress) {
        
        _initDerivative(_derivativeHash, _derivative);
        authorAddress = authorAddressByHash[_derivativeHash];
    }

    
    
    
    
    
    function getMargin(bytes32 _derivativeHash, Derivative memory _derivative) public nonReentrant returns (uint256 buyerMargin, uint256 sellerMargin) {
        
        if (_isPool(_derivativeHash, _derivative)) {
            return IDerivativeLogic(_derivative.syntheticId).getMargin(_derivative); 
        }

        
        _initDerivative(_derivativeHash, _derivative);

        
        buyerMargin = buyerMarginByHash[_derivativeHash];
        sellerMargin = sellerMarginByHash[_derivativeHash];
    }

    
    
    
    
    function isPool(bytes32 _derivativeHash, Derivative memory _derivative) public nonReentrant returns (bool result) {
        result = _isPool(_derivativeHash, _derivative);
    }

    

    
    
    
    
    function _isPool(bytes32 _derivativeHash, Derivative memory _derivative) private returns (bool result) {
        
        _initDerivative(_derivativeHash, _derivative);
        result = typeByHash[_derivativeHash] == SyntheticTypes.Pool;
    }

    
    
    
    function _initDerivative(bytes32 _derivativeHash, Derivative memory _derivative) private {
        
        SyntheticTypes syntheticType = typeByHash[_derivativeHash];

        
        if (syntheticType != SyntheticTypes.Invalid) {
            return;
        }

        
        bytes32 derivativeHash = getDerivativeHash(_derivative);
        require(derivativeHash == _derivativeHash, ERROR_SYNTHETIC_AGGREGATOR_DERIVATIVE_HASH_NOT_MATCH);

        
        
        bool result = IDerivativeLogic(_derivative.syntheticId).isPool();
        
        typeByHash[derivativeHash] = result ? SyntheticTypes.Pool : SyntheticTypes.NotPool;

        
        
        (uint256 buyerMargin, uint256 sellerMargin) = IDerivativeLogic(_derivative.syntheticId).getMargin(_derivative);
        
        require(buyerMargin != 0 || sellerMargin != 0, ERROR_SYNTHETIC_AGGREGATOR_WRONG_MARGIN);
        
        buyerMarginByHash[derivativeHash] = buyerMargin;
        sellerMarginByHash[derivativeHash] = sellerMargin;

        
        
        authorAddressByHash[derivativeHash] = IDerivativeLogic(_derivative.syntheticId).getAuthorAddress();

        
        
        uint256 commission = IDerivativeLogic(_derivative.syntheticId).getAuthorCommission();
        
        require(commission <= COMMISSION_BASE, ERROR_SYNTHETIC_AGGREGATOR_COMMISSION_TOO_BIG);
        
        commissionByHash[derivativeHash] = commission;

        
        emit Create(_derivative, derivativeHash);
    }
}



pragma solidity 0.5.16;


contract Whitelisted {
    
    address[] internal whitelist;

    
    modifier onlyWhitelisted() {
        
        bool allowed = false;

        
        uint256 whitelistLength = whitelist.length;
        for (uint256 i = 0; i < whitelistLength; i++) {
            
            if (whitelist[i] == msg.sender) {
                allowed = true;
                break;
            }
        }

        
        require(allowed, "Only whitelisted allowed");
        _;
    }

    
    
    function getWhitelist() public view returns (address[] memory) {
        return whitelist;
    }
}



pragma solidity 0.5.16;



contract WhitelistedWithGovernance is Whitelisted {
    
    event GovernorSet(address governor);

    
    event Proposed(address[] whitelist);
    
    event Committed(address[] whitelist);

    
    uint256 public timeLockInterval;

    
    address public governor;

    
    uint256 public proposalTime;

    
    address[] public proposedWhitelist;

    
    modifier onlyGovernor() {
        require(msg.sender == governor, "Only governor allowed");
        _;
    }

    
    
    
    constructor(uint256 _timeLockInterval, address _governor) public {
        timeLockInterval = _timeLockInterval;
        governor = _governor;
        emit GovernorSet(governor);
    }

    
    function proposeWhitelist(address[] memory _whitelist) public onlyGovernor {
        
        require(_whitelist.length != 0, "Can't be empty");

        
        
        if (whitelist.length == 0) {
            whitelist = _whitelist;
            emit Committed(_whitelist);

        
        } else {
            proposalTime = now;
            proposedWhitelist = _whitelist;
            emit Proposed(_whitelist);
        }
    }

    
    function commitWhitelist() public onlyGovernor {
        
        require(proposalTime != 0, "Didn't proposed yet");

        
        require((proposalTime + timeLockInterval) < now, "Can't commit yet");
        
        
        whitelist = proposedWhitelist;
        emit Committed(whitelist);

        
        proposalTime = 0;
    }

    
    
    function setGovernor(address _governor) public onlyGovernor {
        require(_governor != address(0), "Can't set zero address");
        governor = _governor;
        emit GovernorSet(governor);
    }
}



pragma solidity 0.5.16;



contract WhitelistedWithGovernanceAndChangableTimelock is WhitelistedWithGovernance {
    
    event Proposed(uint256 timelock);
    
    event Committed(uint256 timelock);

    
    uint256 public timeLockProposalTime;
    
    uint256 public proposedTimeLock;

    
    
    function proposeTimelock(uint256 _timelock) public onlyGovernor {
        timeLockProposalTime = now;
        proposedTimeLock = _timelock;
        emit Proposed(_timelock);
    }

    
    function commitTimelock() public onlyGovernor {
        
        require(timeLockProposalTime != 0, "Didn't proposed yet");
        
        require((timeLockProposalTime + timeLockInterval) < now, "Can't commit yet");
        
        
        timeLockInterval = proposedTimeLock;
        emit Committed(proposedTimeLock);

        
        timeLockProposalTime = 0;
    }
}



pragma solidity 0.5.16;






contract TokenSpender is WhitelistedWithGovernanceAndChangableTimelock {
    using SafeERC20 for IERC20;

    
    uint256 public constant WHITELIST_TIMELOCK = 1 hours;

    
    
    constructor(address _governor) public WhitelistedWithGovernance(WHITELIST_TIMELOCK, _governor) {}

    
    
    
    
    
    function claimTokens(IERC20 token, address from, address to, uint256 amount) external onlyWhitelisted {
        token.safeTransferFrom(from, to, amount);
    }

    
    
    
    
    
    
    function claimPositions(IERC721O token, address from, address to, uint256 tokenId, uint256 amount) external onlyWhitelisted {
        token.safeTransferFrom(from, to, tokenId, amount);
    }
}



pragma solidity 0.5.16;

















contract Core is LibDerivative, LibCommission, UsingRegistry, CoreErrors, ReentrancyGuard {
    using SafeMath for uint256;
    using LibPosition for bytes32;
    using SafeERC20 for IERC20;

    
    event Created(address buyer, address seller, bytes32 derivativeHash, uint256 quantity);
    
    event Executed(address tokenOwner, uint256 tokenId, uint256 quantity);
    
    event Canceled(bytes32 derivativeHash);

    
    uint256 public constant NO_DATA_CANCELLATION_PERIOD = 2 weeks;

    
    
    
    mapping (address => mapping(address => uint256)) public poolVaults;

    
    
    
    mapping(bytes32 => uint256) public p2pVaults;

    
    
    mapping(bytes32 => uint256[2]) public derivativePayouts;

    
    
    
    mapping (address => mapping(address => uint256)) public feesVaults;

    
    mapping (bytes32 => bool) public cancelled;

    
    constructor(address _registry) public UsingRegistry(_registry) {}

    

    
    
    function withdrawFee(address _tokenAddress) public nonReentrant {
        uint256 balance = feesVaults[msg.sender][_tokenAddress];
        feesVaults[msg.sender][_tokenAddress] = 0;
        IERC20(_tokenAddress).safeTransfer(msg.sender, balance);
    }

    
    
    
    
    
    
    function create(Derivative memory _derivative, uint256 _quantity, address[2] memory _addresses) public nonReentrant {
        if (_addresses[1] == address(0)) {
            _createPooled(_derivative, _quantity, _addresses[0]);
        } else {
            _create(_derivative, _quantity, _addresses);
        }
    }

    
    
    
    
    function execute(uint256 _tokenId, uint256 _quantity, Derivative memory _derivative) public nonReentrant {
        uint256[] memory tokenIds = new uint256[](1);
        uint256[] memory quantities = new uint256[](1);
        Derivative[] memory derivatives = new Derivative[](1);

        tokenIds[0] = _tokenId;
        quantities[0] = _quantity;
        derivatives[0] = _derivative;

        _execute(msg.sender, tokenIds, quantities, derivatives);
    }

    
    
    
    
    
    function execute(address _tokenOwner, uint256 _tokenId, uint256 _quantity, Derivative memory _derivative) public nonReentrant {
        uint256[] memory tokenIds = new uint256[](1);
        uint256[] memory quantities = new uint256[](1);
        Derivative[] memory derivatives = new Derivative[](1);

        tokenIds[0] = _tokenId;
        quantities[0] = _quantity;
        derivatives[0] = _derivative;

        _execute(_tokenOwner, tokenIds, quantities, derivatives);
    }

    
    
    
    
    function execute(uint256[] memory _tokenIds, uint256[] memory _quantities, Derivative[] memory _derivatives) public nonReentrant {
        _execute(msg.sender, _tokenIds, _quantities, _derivatives);
    }

    
    
    
    
    
    function execute(address _tokenOwner, uint256[] memory _tokenIds, uint256[] memory _quantities, Derivative[] memory _derivatives) public nonReentrant {
        _execute(_tokenOwner, _tokenIds, _quantities, _derivatives);
    }

    
    
    
    
    function cancel(uint256 _tokenId, uint256 _quantity, Derivative memory _derivative) public nonReentrant {
        uint256[] memory tokenIds = new uint256[](1);
        uint256[] memory quantities = new uint256[](1);
        Derivative[] memory derivatives = new Derivative[](1);

        tokenIds[0] = _tokenId;
        quantities[0] = _quantity;
        derivatives[0] = _derivative;

        _cancel(tokenIds, quantities, derivatives);
    }

    
    
    
    
    function cancel(uint256[] memory _tokenIds, uint256[] memory _quantities, Derivative[] memory _derivatives) public nonReentrant {
        _cancel(_tokenIds, _quantities, _derivatives);
    }

    

    struct CreatePooledLocalVars {
        SyntheticAggregator syntheticAggregator;
        IDerivativeLogic derivativeLogic;
        IERC20 marginToken;
        TokenSpender tokenSpender;
        TokenMinter tokenMinter;
    }

    
    
    
    
    function _createPooled(Derivative memory _derivative, uint256 _quantity, address _address) private {
        
        CreatePooledLocalVars memory vars;

        
        
        
        
        
        vars.syntheticAggregator = SyntheticAggregator(registry.getSyntheticAggregator());
        vars.derivativeLogic = IDerivativeLogic(_derivative.syntheticId);
        vars.marginToken = IERC20(_derivative.token);
        vars.tokenSpender = TokenSpender(registry.getTokenSpender());
        vars.tokenMinter = TokenMinter(registry.getMinter());

        
        bytes32 derivativeHash = getDerivativeHash(_derivative);

        
        require(vars.syntheticAggregator.isPool(derivativeHash, _derivative), ERROR_CORE_NOT_POOL);

        
        require(!cancelled[derivativeHash], ERROR_CORE_TICKER_WAS_CANCELLED);

        
        require(vars.derivativeLogic.validateInput(_derivative), ERROR_CORE_SYNTHETIC_VALIDATION_ERROR);

        
        (uint256 margin, ) = vars.syntheticAggregator.getMargin(derivativeHash, _derivative);

        
        
        require(vars.marginToken.allowance(msg.sender, address(vars.tokenSpender)) >= margin.mul(_quantity), ERROR_CORE_NOT_ENOUGH_TOKEN_ALLOWANCE);

    	
        vars.tokenSpender.claimTokens(vars.marginToken, msg.sender, address(this), margin.mul(_quantity));

        
        poolVaults[_derivative.syntheticId][_derivative.token] = poolVaults[_derivative.syntheticId][_derivative.token].add(margin.mul(_quantity));

        
        vars.tokenMinter.mint(_address, derivativeHash, _quantity);

        emit Created(_address, address(0), derivativeHash, _quantity);
    }

    struct CreateLocalVars {
        SyntheticAggregator syntheticAggregator;
        IDerivativeLogic derivativeLogic;
        IERC20 marginToken;
        TokenSpender tokenSpender;
        TokenMinter tokenMinter;
    }

    
    
    
    
    
    
    function _create(Derivative memory _derivative, uint256 _quantity, address[2] memory _addresses) private {
        
        CreateLocalVars memory vars;

        
        
        
        
        
        vars.syntheticAggregator = SyntheticAggregator(registry.getSyntheticAggregator());
        vars.derivativeLogic = IDerivativeLogic(_derivative.syntheticId);
        vars.marginToken = IERC20(_derivative.token);
        vars.tokenSpender = TokenSpender(registry.getTokenSpender());
        vars.tokenMinter = TokenMinter(registry.getMinter());

        
        bytes32 derivativeHash = getDerivativeHash(_derivative);

        
        require(!vars.syntheticAggregator.isPool(derivativeHash, _derivative), ERROR_CORE_CANT_BE_POOL);

        
        require(!cancelled[derivativeHash], ERROR_CORE_TICKER_WAS_CANCELLED);

        
        require(vars.derivativeLogic.validateInput(_derivative), ERROR_CORE_SYNTHETIC_VALIDATION_ERROR);

        uint256[2] memory margins;
        
        
        
        (margins[0], margins[1]) = vars.syntheticAggregator.getMargin(derivativeHash, _derivative);

        
        
        require(vars.marginToken.allowance(msg.sender, address(vars.tokenSpender)) >= margins[0].add(margins[1]).mul(_quantity), ERROR_CORE_NOT_ENOUGH_TOKEN_ALLOWANCE);

    	
        vars.tokenSpender.claimTokens(vars.marginToken, msg.sender, address(this), margins[0].add(margins[1]).mul(_quantity));

        
        _increaseP2PVault(
            derivativeHash,
            margins[0].add(margins[1]).mul(_quantity)
        );

        
        vars.tokenMinter.mint(_addresses[0], _addresses[1], derivativeHash, _quantity);

        emit Created(_addresses[0], _addresses[1], derivativeHash, _quantity);
    }

    struct ExecuteAndCancelLocalVars {
        TokenMinter tokenMinter;
        OracleAggregator oracleAggregator;
        SyntheticAggregator syntheticAggregator;
    }

    
    
    
    
    
    function _execute(address _tokenOwner, uint256[] memory _tokenIds, uint256[] memory _quantities, Derivative[] memory _derivatives) private {
        require(_tokenIds.length == _quantities.length, ERROR_CORE_TOKEN_IDS_AND_QUANTITIES_LENGTH_DOES_NOT_MATCH);
        require(_tokenIds.length == _derivatives.length, ERROR_CORE_TOKEN_IDS_AND_DERIVATIVES_LENGTH_DOES_NOT_MATCH);

        
        ExecuteAndCancelLocalVars memory vars;

        
        
        
        vars.tokenMinter = TokenMinter(registry.getMinter());
        vars.oracleAggregator = OracleAggregator(registry.getOracleAggregator());
        vars.syntheticAggregator = SyntheticAggregator(registry.getSyntheticAggregator());

        for (uint256 i; i < _tokenIds.length; i++) {
            
            require(now > _derivatives[i].endTime, ERROR_CORE_EXECUTION_BEFORE_MATURITY_NOT_ALLOWED);

            
            require(
                _tokenOwner == msg.sender ||
                IDerivativeLogic(_derivatives[i].syntheticId).thirdpartyExecutionAllowed(_tokenOwner),
                ERROR_CORE_SYNTHETIC_EXECUTION_WAS_NOT_ALLOWED
            );

            
            uint256 payout = _getPayout(_derivatives[i], _tokenIds[i], _quantities[i], vars);

            
            if (payout > 0) {
                IERC20(_derivatives[i].token).safeTransfer(_tokenOwner, payout);
            }

            
            vars.tokenMinter.burn(_tokenOwner, _tokenIds[i], _quantities[i]);

            emit Executed(_tokenOwner, _tokenIds[i], _quantities[i]);
        }
    }

    
    
    
    
    function _cancel(uint256[] memory _tokenIds, uint256[] memory _quantities, Derivative[] memory _derivatives) private {
        require(_tokenIds.length == _quantities.length, ERROR_CORE_TOKEN_IDS_AND_QUANTITIES_LENGTH_DOES_NOT_MATCH);
        require(_tokenIds.length == _derivatives.length, ERROR_CORE_TOKEN_IDS_AND_DERIVATIVES_LENGTH_DOES_NOT_MATCH);

        
        ExecuteAndCancelLocalVars memory vars;

        
        
        
        vars.tokenMinter = TokenMinter(registry.getMinter());
        vars.oracleAggregator = OracleAggregator(registry.getOracleAggregator());
        vars.syntheticAggregator = SyntheticAggregator(registry.getSyntheticAggregator());

        for (uint256 i; i < _tokenIds.length; i++) {
            
            require(_derivatives[i].oracleId != address(0), ERROR_CORE_CANT_CANCEL_DUMMY_ORACLE_ID);

            
            require(
                _derivatives[i].endTime + NO_DATA_CANCELLATION_PERIOD <= now &&
                !vars.oracleAggregator.hasData(_derivatives[i].oracleId, _derivatives[i].endTime),
                ERROR_CORE_CANCELLATION_IS_NOT_ALLOWED
            );

            
            bytes32 derivativeHash = getDerivativeHash(_derivatives[i]);

            
            if (!cancelled[derivativeHash]) {
                cancelled[derivativeHash] = true;
                emit Canceled(derivativeHash);
            }

            uint256[2] memory margins;
            
            
            
            (margins[0], margins[1]) = vars.syntheticAggregator.getMargin(derivativeHash, _derivatives[i]);

            uint256 payout;
            
            if (derivativeHash.getLongTokenId() == _tokenIds[i]) {
                
                payout = margins[0].mul(_quantities[i]);

                
                if (vars.syntheticAggregator.isPool(derivativeHash, _derivatives[i])) {
                    
                    require(
                        poolVaults[_derivatives[i].syntheticId][_derivatives[i].token] >= payout
                        ,
                        ERROR_CORE_INSUFFICIENT_POOL_BALANCE
                    );

                    
                    poolVaults[_derivatives[i].syntheticId][_derivatives[i].token] = poolVaults[_derivatives[i].syntheticId][_derivatives[i].token].sub(payout);
                } else {
                    
                    _decreaseP2PVault(derivativeHash, payout);
                }
            
            } else if (derivativeHash.getShortTokenId() == _tokenIds[i]) {
                
                payout = margins[1].mul(_quantities[i]);
                
                _decreaseP2PVault(derivativeHash, payout);
            } else {
                
                revert(ERROR_CORE_UNKNOWN_POSITION_TYPE);
            }
            
            
            if (payout > 0) {
                IERC20(_derivatives[i].token).safeTransfer(msg.sender, payout);
            }

            
            vars.tokenMinter.burn(msg.sender, _tokenIds[i], _quantities[i]);
        }
    }

    
    
    
    
    
    
    function _getPayout(Derivative memory _derivative, uint256 _tokenId, uint256 _quantity, ExecuteAndCancelLocalVars memory _vars) private returns (uint256 payout) {
        
        
        uint256 data;
        if (_derivative.oracleId != address(0)) {
            data = _vars.oracleAggregator.getData(_derivative.oracleId, _derivative.endTime);
        } else {
            data = 0;
        }

        uint256[2] memory payoutRatio;
        
        
        
        (payoutRatio[0], payoutRatio[1]) = IDerivativeLogic(_derivative.syntheticId).getExecutionPayout(_derivative, data);

        
        bytes32 derivativeHash = getDerivativeHash(_derivative);

        
        require(!cancelled[derivativeHash], ERROR_CORE_TICKER_WAS_CANCELLED);

        uint256[2] memory margins;
        
        
        
        (margins[0], margins[1]) = _vars.syntheticAggregator.getMargin(derivativeHash, _derivative);

        uint256[2] memory payouts;
        
        
        
        payouts[0] = margins[0].add(margins[1]).mul(payoutRatio[0]).div(payoutRatio[0].add(payoutRatio[1]));
        payouts[1] = margins[0].add(margins[1]).mul(payoutRatio[1]).div(payoutRatio[0].add(payoutRatio[1]));

        
        
        if (derivativePayouts[derivativeHash][0] == 0 && derivativePayouts[derivativeHash][1] == 0) {
            
            derivativePayouts[derivativeHash][0] = payouts[0];
            
            derivativePayouts[derivativeHash][1] = payouts[1];
        }
        
        
        if (derivativeHash.getLongTokenId() == _tokenId) {
            
            if (_vars.syntheticAggregator.isPool(derivativeHash, _derivative)) {
                
                payout = payoutRatio[0];

                
                payout = payout.mul(_quantity);

                
                require(
                    poolVaults[_derivative.syntheticId][_derivative.token] >= payout
                    ,
                    ERROR_CORE_INSUFFICIENT_POOL_BALANCE
                );

                
                poolVaults[_derivative.syntheticId][_derivative.token] = poolVaults[_derivative.syntheticId][_derivative.token].sub(payout);
            } else {
                
                payout = derivativePayouts[derivativeHash][0];

                
                payout = payout.mul(_quantity);

                
                _decreaseP2PVault(derivativeHash, payout);
            }

            
            
            if (payout > margins[0].mul(_quantity)) {
                
                payout = payout.sub(_getFees(_vars.syntheticAggregator, derivativeHash, _derivative, payout - margins[0].mul(_quantity)));
            }

        
        } else if (derivativeHash.getShortTokenId() == _tokenId) {
            
            payout = derivativePayouts[derivativeHash][1];

            
            payout = payout.mul(_quantity);

            
            _decreaseP2PVault(derivativeHash, payout);

            
            
            if (payout > margins[1].mul(_quantity)) {
                
                payout = payout.sub(_getFees(_vars.syntheticAggregator, derivativeHash, _derivative, payout - margins[1].mul(_quantity)));
            }
        } else {
            
            revert(ERROR_CORE_UNKNOWN_POSITION_TYPE);
        }
    }

    
    
    
    
    
    
    function _getFees(SyntheticAggregator _syntheticAggregator, bytes32 _derivativeHash, Derivative memory _derivative, uint256 _profit) private returns (uint256 fee) {
        
        address authorAddress = _syntheticAggregator.getAuthorAddress(_derivativeHash, _derivative);
        
        uint256 commission = _syntheticAggregator.getAuthorCommission(_derivativeHash, _derivative);

        
        
        fee = _profit.mul(commission).div(COMMISSION_BASE);

        
        if (fee == 0) {
            return 0;
        }

        
        
        uint256 opiumFee = fee.mul(OPIUM_COMMISSION_PART).div(OPIUM_COMMISSION_BASE);

        
        
        uint256 authorFee = fee.sub(opiumFee);

        
        address opiumAddress = registry.getOpiumAddress();

        
        
        feesVaults[opiumAddress][_derivative.token] = feesVaults[opiumAddress][_derivative.token].add(opiumFee);

        
        
        feesVaults[authorAddress][_derivative.token] = feesVaults[authorAddress][_derivative.token].add(authorFee);
    }

    function _increaseP2PVault(bytes32 _derivativeHash, uint256 _amount) private {
        p2pVaults[_derivativeHash] = p2pVaults[_derivativeHash].add(_amount);
    }

    function _decreaseP2PVault(bytes32 _derivativeHash, uint256 _amount) private {
        require(
            p2pVaults[_derivativeHash] >= _amount,
            ERROR_CORE_INSUFFICIENT_P2P_BALANCE
        );
        p2pVaults[_derivativeHash] = p2pVaults[_derivativeHash].sub(_amount);
    }
}



pragma solidity 0.5.16;

contract MatchingErrors {
    string constant internal ERROR_MATCH_CANCELLATION_NOT_ALLOWED = "MATCH:CANCELLATION_NOT_ALLOWED";
    string constant internal ERROR_MATCH_ALREADY_CANCELED = "MATCH:ALREADY_CANCELED";
    string constant internal ERROR_MATCH_ORDER_WAS_CANCELED = "MATCH:ORDER_WAS_CANCELED";

    string constant internal ERROR_MATCH_TAKER_ADDRESS_WRONG = "MATCH:TAKER_ADDRESS_WRONG";
    string constant internal ERROR_MATCH_ORDER_IS_EXPIRED = "MATCH:ORDER_IS_EXPIRED";
    string constant internal ERROR_MATCH_SENDER_ADDRESS_WRONG = "MATCH:SENDER_ADDRESS_WRONG";
    string constant internal ERROR_MATCH_SIGNATURE_NOT_VERIFIED = "MATCH:SIGNATURE_NOT_VERIFIED";
    string constant internal ERROR_MATCH_NOT_ENOUGH_ALLOWED_FEES = "MATCH:NOT_ENOUGH_ALLOWED_FEES";
}



pragma solidity 0.5.16;


contract LibEIP712 {
    
    
    
    
    struct EIP712Domain {
        string  name;
        string  version;
        address verifyingContract;
    }

    
    bytes32 constant internal EIP712DOMAIN_TYPEHASH = keccak256(abi.encodePacked(
        "EIP712Domain(",
        "string name,",
        "string version,",
        "address verifyingContract",
        ")"
    ));

    
    bytes32 internal DOMAIN_SEPARATOR;

    
    constructor () public {
        DOMAIN_SEPARATOR = keccak256(abi.encode(
            EIP712DOMAIN_TYPEHASH,
            keccak256("Opium Network"),
            keccak256("1"),
            address(this)
        ));
    }

    
    
    
    function hashEIP712Message(bytes32 hashStruct) internal view returns (bytes32 result) {
        bytes32 domainSeparator = DOMAIN_SEPARATOR;

        assembly {
            
            let memPtr := mload(64)

            mstore(memPtr, 0x1901000000000000000000000000000000000000000000000000000000000000)  
            mstore(add(memPtr, 2), domainSeparator)                                            
            mstore(add(memPtr, 34), hashStruct)                                                 

            
            result := keccak256(memPtr, 66)
        }
        return result;
    }
}



pragma solidity 0.5.16;



contract LibSwaprateOrder is LibEIP712 {
    
    struct SwaprateOrder {
        address syntheticId;
        address oracleId;
        address token;

        address makerAddress;
        address takerAddress;

        address senderAddress;

        address relayerAddress;
        address affiliateAddress;

        address feeTokenAddress;

        uint256 endTime;

        uint256 quantity;
        uint256 partialFill;

        uint256 param0;
        uint256 param1;
        uint256 param2;
        uint256 param3;
        uint256 param4;
        uint256 param5;
        uint256 param6;
        uint256 param7;
        uint256 param8;
        uint256 param9;

        uint256 relayerFee;
        uint256 affiliateFee;

        uint256 nonce;

        
        bytes signature;
    }

    
    bytes32 constant internal EIP712_ORDER_TYPEHASH = keccak256(abi.encodePacked(
        "Order(",
        "address syntheticId,",
        "address oracleId,",
        "address token,",

        "address makerAddress,",
        "address takerAddress,",

        "address senderAddress,",

        "address relayerAddress,",
        "address affiliateAddress,",

        "address feeTokenAddress,",

        "uint256 endTime,",

        "uint256 quantity,",
        "uint256 partialFill,",

        "uint256 param0,",
        "uint256 param1,",
        "uint256 param2,",
        "uint256 param3,",
        "uint256 param4,",
        "uint256 param5,",
        "uint256 param6,",
        "uint256 param7,",
        "uint256 param8,",
        "uint256 param9,",

        "uint256 relayerFee,",
        "uint256 affiliateFee,",

        "uint256 nonce",
        ")"
    ));

    
    
    
    function hashOrder(SwaprateOrder memory _order) public pure returns (bytes32 hash) {
        hash = keccak256(
            abi.encodePacked(
                abi.encodePacked(
                    EIP712_ORDER_TYPEHASH,
                    uint256(_order.syntheticId),
                    uint256(_order.oracleId),
                    uint256(_order.token),

                    uint256(_order.makerAddress),
                    uint256(_order.takerAddress),

                    uint256(_order.senderAddress),

                    uint256(_order.relayerAddress),
                    uint256(_order.affiliateAddress),

                    uint256(_order.feeTokenAddress)
                ),
                abi.encodePacked(
                    _order.endTime,
                    _order.quantity,
                    _order.partialFill
                ),
                abi.encodePacked(
                    _order.param0,
                    _order.param1,
                    _order.param2,
                    _order.param3,
                    _order.param4
                ),
                abi.encodePacked(
                    _order.param5,
                    _order.param6,
                    _order.param7,
                    _order.param8,
                    _order.param9
                ),
                abi.encodePacked(
                    _order.relayerFee,
                    _order.affiliateFee,

                    _order.nonce
                )
            )
        );
    }

    
    
    
    
    
    function verifySignature(bytes32 _hash, bytes memory _signature, address _address) internal view returns (bool) {
        require(_signature.length == 65, "ORDER:INVALID_SIGNATURE_LENGTH");

        bytes32 digest = hashEIP712Message(_hash);
        address recovered = retrieveAddress(digest, _signature);
        return _address == recovered;
    }

    
    
    
    
    function retrieveAddress(bytes32 _hash, bytes memory _signature) private pure returns (address) {
        bytes32 r;
        bytes32 s;
        uint8 v;

        
        
        
        
        assembly {
            r := mload(add(_signature, 32))
            s := mload(add(_signature, 64))
            v := byte(0, mload(add(_signature, 96)))
        }

        
        if (v < 27) {
            v += 27;
        }

        
        if (v != 27 && v != 28) {
            return (address(0));
        } else {
            
            return ecrecover(_hash, v, r, s);
        }
    }
}



pragma solidity 0.5.16;













contract SwaprateMatchBase is MatchingErrors, LibSwaprateOrder, UsingRegistry, ReentrancyGuard {
    using SafeMath for uint256;
    using LibPosition for bytes32;
    using SafeERC20 for IERC20;

    
    event Canceled(bytes32 orderHash);

    
    
    
    mapping (bytes32 => bool) public canceled;

    
    
    
    mapping (bytes32 => bool) public verified;
    
    
    
    
    mapping (address => mapping (address => uint256)) public balances;

    
    mapping (bytes32 => bool) public feeTaken;

    
    
    function cancel(SwaprateOrder memory _order) public {
        require(msg.sender == _order.makerAddress, ERROR_MATCH_CANCELLATION_NOT_ALLOWED);
        bytes32 orderHash = hashOrder(_order);
        require(!canceled[orderHash], ERROR_MATCH_ALREADY_CANCELED);
        canceled[orderHash] = true;

        emit Canceled(orderHash);
    }

    
    
    function withdraw(IERC20 _token) public nonReentrant {
        uint256 balance = balances[msg.sender][address(_token)];
        balances[msg.sender][address(_token)] = 0;
        _token.safeTransfer(msg.sender, balance);
    }

    
    
    function validateNotCanceled(bytes32 _hash) internal view {
        require(!canceled[_hash], ERROR_MATCH_ORDER_WAS_CANCELED);
    }

    
    
    
    function validateTakerAddress(SwaprateOrder memory _leftOrder, SwaprateOrder memory _rightOrder) pure internal {
        require(
            _leftOrder.takerAddress == address(0) ||
            _leftOrder.takerAddress == _rightOrder.makerAddress,
            ERROR_MATCH_TAKER_ADDRESS_WRONG
        );
    }

    
    
    function validateSenderAddress(SwaprateOrder memory _order) internal view {
        require(
            _order.senderAddress == address(0) ||
            _order.senderAddress == msg.sender,
            ERROR_MATCH_SENDER_ADDRESS_WRONG
        );
    }

    
    
    
    function validateSignature(bytes32 orderHash, SwaprateOrder memory _order) internal {
        if (verified[orderHash]) {
            return;
        }

        bool result = verifySignature(orderHash, _order.signature, _order.makerAddress);

        require(result, ERROR_MATCH_SIGNATURE_NOT_VERIFIED);
        
        verified[orderHash] = true;
    }

    
    
    
    function takeFees(bytes32 _orderHash, SwaprateOrder memory _order) internal {
        
        if (feeTaken[_orderHash]) {
            return;
        }

        
        if (_order.feeTokenAddress == address(0)) {
            return;
        }

        
        uint256 fees = _order.relayerFee.add(_order.affiliateFee);

        
        if (fees == 0) {
            return;
        }

        
        IERC20 feeToken = IERC20(_order.feeTokenAddress);

        
        TokenSpender tokenSpender = TokenSpender(registry.getTokenSpender());

        
        require(feeToken.allowance(_order.makerAddress, address(tokenSpender)) >= fees, ERROR_MATCH_NOT_ENOUGH_ALLOWED_FEES);
        
        tokenSpender.claimTokens(feeToken, _order.makerAddress, address(this), fees);

        
        address opiumAddress = registry.getOpiumAddress();

        
        if (_order.relayerAddress != address(0)) {
            balances[_order.relayerAddress][_order.feeTokenAddress] = balances[_order.relayerAddress][_order.feeTokenAddress].add(_order.relayerFee);
        } else {
            balances[opiumAddress][_order.feeTokenAddress] = balances[opiumAddress][_order.feeTokenAddress].add(_order.relayerFee);
        }

        
        if (_order.affiliateAddress != address(0)) {
            balances[_order.affiliateAddress][_order.feeTokenAddress] = balances[_order.affiliateAddress][_order.feeTokenAddress].add(_order.affiliateFee);
        } else {
            balances[opiumAddress][_order.feeTokenAddress] = balances[opiumAddress][_order.feeTokenAddress].add(_order.affiliateFee);
        }

        
        feeTaken[_orderHash] = true;
    }

    
    
    
    
    function min(uint256 _a, uint256 _b) internal pure returns (uint256) {
        return _a < _b ? _a : _b;
    }
}



pragma solidity 0.5.16;






contract SwaprateMatch is SwaprateMatchBase, LibDerivative {

    
    
    
    mapping (bytes32 => uint256) public filled;

    
    
    constructor (address _registry) public UsingRegistry(_registry) {}
    
    
    
    
    
    function create(SwaprateOrder memory _leftOrder, SwaprateOrder memory _rightOrder, Derivative memory _derivative) public nonReentrant {
        
        require(
            _leftOrder.syntheticId == _rightOrder.syntheticId,
            "MATCH:NOT_CREATION"
        );

        
        validateTakerAddress(_leftOrder, _rightOrder);
        validateTakerAddress(_rightOrder, _leftOrder);

        
        validateSenderAddress(_leftOrder);
        validateSenderAddress(_rightOrder);

        
        
        
        bytes32[2] memory orderHashes;
        orderHashes[0] = hashOrder(_leftOrder);
        validateNotCanceled(orderHashes[0]);
        validateSignature(orderHashes[0], _leftOrder);

        orderHashes[1] = hashOrder(_rightOrder);
        validateNotCanceled(orderHashes[1]);
        validateSignature(orderHashes[1], _rightOrder);

        
        
        
        (uint256[2] memory margins, ) = _calculateDerivativeAndGetMargin(_derivative);

        
        uint256 fillable = _checkFillability(orderHashes[0], _leftOrder, orderHashes[1], _rightOrder);

        
        _verifyDerivative(_leftOrder, _rightOrder, _derivative);

        
        takeFees(orderHashes[0], _leftOrder);
        takeFees(orderHashes[1], _rightOrder);

        
        _distributeFunds(_leftOrder, _rightOrder, _derivative, margins, fillable);
        
        
        Core(registry.getCore()).create(_derivative, fillable, [_leftOrder.makerAddress, _rightOrder.makerAddress]);
    }

    

    
    
    
    
    function _calculateDerivativeAndGetMargin(Derivative memory _derivative) private returns (uint256[2] memory margins, bytes32 derivativeHash) {
        
        derivativeHash = getDerivativeHash(_derivative);

        
        
        
        (margins[0], margins[1]) = SyntheticAggregator(registry.getSyntheticAggregator()).getMargin(derivativeHash, _derivative);

        
        require(!SyntheticAggregator(registry.getSyntheticAggregator()).isPool(derivativeHash, _derivative), "MATCH:CANT_BE_POOL");
    }

    
    
    
    
    
    
    function _checkFillability(bytes32 _leftOrderHash, SwaprateOrder memory _leftOrder, bytes32 _rightOrderHash, SwaprateOrder memory _rightOrder) private returns (uint256 fillable) {
        
        uint256 leftAvailable = _leftOrder.quantity.sub(filled[_leftOrderHash]);
        uint256 rightAvailable = _rightOrder.quantity.sub(filled[_rightOrderHash]);

        require(leftAvailable != 0 && rightAvailable !=0, "MATCH:NO_AVAILABLE");

        
        fillable = min(leftAvailable, rightAvailable);

        
        if (_leftOrder.partialFill == 0 && _rightOrder.partialFill == 0) {
            require(_leftOrder.quantity == _rightOrder.quantity, "MATCH:FULL_FILL_NOT_POSSIBLE");
        } else if (_leftOrder.partialFill == 0 && _rightOrder.partialFill == 1) {
            require(_leftOrder.quantity <= rightAvailable, "MATCH:FULL_FILL_NOT_POSSIBLE");
        } else if (_leftOrder.partialFill == 1 && _rightOrder.partialFill == 0) {
            require(leftAvailable >= _rightOrder.quantity, "MATCH:FULL_FILL_NOT_POSSIBLE");
        }

        
        filled[_leftOrderHash] = filled[_leftOrderHash].add(fillable);
        filled[_rightOrderHash] = filled[_rightOrderHash].add(fillable);
    }

    
    
    
    
    function _verifyDerivative(SwaprateOrder memory _leftOrder, SwaprateOrder memory _rightOrder, Derivative memory _derivative) private pure {
        string memory orderError = "MATCH:DERIVATIVE_PARAM_IS_WRONG";

        
        require(
            _derivative.endTime == _leftOrder.endTime &&
            _derivative.endTime == _rightOrder.endTime,
            orderError
        );

        
        require(
            _derivative.syntheticId == _leftOrder.syntheticId &&
            _derivative.syntheticId == _rightOrder.syntheticId,
            orderError
        );

        
        require(
            _derivative.oracleId == _leftOrder.oracleId &&
            _derivative.oracleId == _rightOrder.oracleId,
            orderError
        );

        
        require(
            _derivative.token == _leftOrder.token &&
            _derivative.token == _rightOrder.token,
            orderError
        );

        
        require(_derivative.params.length >= 20, "MATCH:DERIVATIVE_PARAMS_LENGTH_IS_WRONG");

        
        require(_leftOrder.param0 == _derivative.params[0], orderError);
        require(_leftOrder.param1 == _derivative.params[1], orderError);
        require(_leftOrder.param2 == _derivative.params[2], orderError);
        require(_leftOrder.param3 == _derivative.params[3], orderError);
        require(_leftOrder.param4 == _derivative.params[4], orderError);
        require(_leftOrder.param5 == _derivative.params[5], orderError);
        require(_leftOrder.param6 == _derivative.params[6], orderError);
        require(_leftOrder.param7 == _derivative.params[7], orderError);
        require(_leftOrder.param8 == _derivative.params[8], orderError);
        require(_leftOrder.param9 == _derivative.params[9], orderError);

        
        require(_rightOrder.param0 == _derivative.params[10], orderError);
        require(_rightOrder.param1 == _derivative.params[11], orderError);
        require(_rightOrder.param2 == _derivative.params[12], orderError);
        require(_rightOrder.param3 == _derivative.params[13], orderError);
        require(_rightOrder.param4 == _derivative.params[14], orderError);
        require(_rightOrder.param5 == _derivative.params[15], orderError);
        require(_rightOrder.param6 == _derivative.params[16], orderError);
        require(_rightOrder.param7 == _derivative.params[17], orderError);
        require(_rightOrder.param8 == _derivative.params[18], orderError);
        require(_rightOrder.param9 == _derivative.params[19], orderError);
    }

    
    
    
    
    
    
    function _distributeFunds(SwaprateOrder memory _leftOrder, SwaprateOrder memory _rightOrder, Derivative memory _derivative, uint256[2] memory margins, uint256 _fillable) private {
        IERC20 marginToken = IERC20(_derivative.token);
        TokenSpender tokenSpender = TokenSpender(registry.getTokenSpender());

        
        if (margins[0] != 0) {
            
            require(marginToken.allowance(_leftOrder.makerAddress, address(tokenSpender)) >= margins[0].mul(_fillable), "MATCH:NOT_ENOUGH_ALLOWED_MARGIN");

            
            tokenSpender.claimTokens(marginToken, _leftOrder.makerAddress, address(this), margins[0].mul(_fillable));
        }
        
        
        if (margins[1] != 0) {
            
            require(marginToken.allowance(_rightOrder.makerAddress, address(tokenSpender)) >= margins[1].mul(_fillable), "MATCH:NOT_ENOUGH_ALLOWED_MARGIN");

            
            tokenSpender.claimTokens(marginToken, _rightOrder.makerAddress, address(this), margins[1].mul(_fillable));
        }

        if (margins[0].add(margins[1]) != 0) {
            
            require(marginToken.approve(address(tokenSpender), margins[0].add(margins[1]).mul(_fillable)), "MATCH:COULDNT_APPROVE_MARGIN_FOR_CORE");
        }
    }
}