pragma solidity 0.6.10;
pragma experimental ABIEncoderV2;

interface IERC20 {

    

    function totalSupply() external view returns (uint256);



    

    function balanceOf(address account) external view returns (uint256);



    

    function transfer(address recipient, uint256 amount) external returns (bool);



    

    function allowance(address owner, address spender) external view returns (uint256);



    

    function approve(address spender, uint256 amount) external returns (bool);



    

    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);



    

    event Transfer(address indexed from, address indexed to, uint256 value);



    

    event Approval(address indexed owner, address indexed spender, uint256 value);

}

contract TransferX {


event Memo(address indexed from, address indexed to, uint256 value, string memo,address tok);


IERC20 public Token;


 function transferx(


        address payable[] memory to,


        uint256[] memory tokens,


        string[] memory memo


    ) public payable returns (bool success) {


        require(to.length == tokens.length && tokens.length == memo.length);


        for (uint256 i = 0; i < to.length; i++) {


            if (address(Token) == address(0)){


to[i].transfer(tokens[i]);


emit Memo(msg.sender, to[i], tokens[i], memo[i], address(0));


}


else {


require(Token.transferFrom(msg.sender, to[i], tokens[i]));


            emit Memo(msg.sender, to[i], tokens[i], memo[i], address(Token));


}


        }


        return true;


    }


}
