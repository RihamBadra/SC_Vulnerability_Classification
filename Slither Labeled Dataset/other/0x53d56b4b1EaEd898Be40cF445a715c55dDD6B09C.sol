pragma solidity 0.6.12;

abstract contract Context {

    function _msgSender() internal view virtual returns (address payable) {

        return msg.sender;

    }



    function _msgData() internal view virtual returns (bytes memory) {

        this; 

        return msg.data;

    }

}

interface IContractRegistry {



	event ContractAddressUpdated(string contractName, address addr, bool managedContract);

	event ManagerChanged(string role, address newManager);

	event ContractRegistryUpdated(address newContractRegistry);



	



	

	

	function setContract(string calldata contractName, address addr, bool managedContract) external ;



	

	function getContract(string calldata contractName) external view returns (address);



	

	function getManagedContracts() external view returns (address[] memory);



	function setManager(string calldata role, address manager) external ;



	function getManager(string calldata role) external view returns (address);



	function lockContracts() external ;



	function unlockContracts() external ;



	function setNewContractRegistry(IContractRegistry newRegistry) external ;



	function getPreviousContractRegistry() external view returns (address);



}

interface IDelegations  {



    

	event DelegatedStakeChanged(address indexed addr, uint256 selfDelegatedStake, uint256 delegatedStake, address indexed delegator, uint256 delegatorContributedStake);



    

	event Delegated(address indexed from, address indexed to);



	



	

	function delegate(address to) external ;



	function refreshStake(address addr) external ;



	function getDelegatedStake(address addr) external view returns (uint256);



	function getDelegation(address addr) external view returns (address);



	function getDelegationInfo(address addr) external view returns (address delegation, uint256 delegatorStake);



	function getTotalDelegatedStake() external view returns (uint256) ;



	



	event DelegationsImported(address[] from, address indexed to);



	event DelegationInitialized(address indexed from, address indexed to);



	function importDelegations(address[] calldata from, address to) external ;



	function initDelegation(address from, address to) external ;

}

interface IElections {

	

	

	event StakeChanged(address indexed addr, uint256 selfStake, uint256 delegatedStake, uint256 effectiveStake);

	event GuardianStatusUpdated(address indexed guardian, bool readyToSync, bool readyForCommittee);



	

	event GuardianVotedUnready(address indexed guardian);

	event VoteUnreadyCasted(address indexed voter, address indexed subject, uint256 expiration);

	event GuardianVotedOut(address indexed guardian);

	event VoteOutCasted(address indexed voter, address indexed subject);



	



	

	function readyToSync() external;



	

	function readyForCommittee() external;



	

	function canJoinCommittee(address guardian) external view returns (bool);



	

	function getEffectiveStake(address guardian) external view returns (uint effectiveStake);



	

	

	function getCommittee() external view returns (address[] memory committee, uint256[] memory weights, address[] memory orbsAddrs, bool[] memory certification, bytes4[] memory ips);



	



	

	function voteUnready(address subject, uint expiration) external;



	function getVoteUnreadyVote(address voter, address subject) external view returns (bool valid, uint256 expiration);



	

	

	function getVoteUnreadyStatus(address subject) external view returns (

		address[] memory committee,

		uint256[] memory weights,

		bool[] memory certification,

		bool[] memory votes,

		bool subjectInCommittee,

		bool subjectInCertifiedCommittee

	);



	



	

	function voteOut(address subject) external;



	

	function getVoteOutVote(address voter) external view returns (address);



	

	

	function getVoteOutStatus(address subject) external view returns (bool votedOut, uint votedStake, uint totalDelegatedStake);



	



	

	

	

	function delegatedStakeChange(address delegate, uint256 selfStake, uint256 delegatedStake, uint256 totalDelegatedStake) external ;



	

	

	function guardianUnregistered(address guardian) external ;



	

	

	function guardianCertificationChanged(address guardian, bool isCertified) external ;





	



	event VoteUnreadyTimeoutSecondsChanged(uint32 newValue, uint32 oldValue);

	event VoteOutPercentMilleThresholdChanged(uint32 newValue, uint32 oldValue);

	event VoteUnreadyPercentMilleThresholdChanged(uint32 newValue, uint32 oldValue);

	event MinSelfStakePercentMilleChanged(uint32 newValue, uint32 oldValue);



	

	

	function setMinSelfStakePercentMille(uint32 minSelfStakePercentMille) external ;



	

	function getMinSelfStakePercentMille() external view returns (uint32);



	

	

	function setVoteOutPercentMilleThreshold(uint32 voteUnreadyPercentMilleThreshold) external ;



	

	function getVoteOutPercentMilleThreshold() external view returns (uint32);



	

	

	function setVoteUnreadyPercentMilleThreshold(uint32 voteUnreadyPercentMilleThreshold) external ;



	

	function getVoteUnreadyPercentMilleThreshold() external view returns (uint32);



	

	function getSettings() external view returns (

		uint32 minSelfStakePercentMille,

		uint32 voteUnreadyPercentMilleThreshold,

		uint32 voteOutPercentMilleThreshold

	);



	function initReadyForCommittee(address[] calldata guardians) external ;



}

interface ILockable {



    event Locked();

    event Unlocked();



    function lock() external ;

    function unlock() external ;

    function isLocked() view external returns (bool);



}

interface IStakeChangeNotifier {

    

    

    

    

    

    function stakeChange(address _stakeOwner, uint256 _amount, bool _sign, uint256 _updatedStake) external;



    

    

    

    

    

    function stakeChangeBatch(address[] calldata _stakeOwners, uint256[] calldata _amounts, bool[] calldata _signs,

        uint256[] calldata _updatedStakes) external;



    

    

    

    function stakeMigration(address _stakeOwner, uint256 _amount) external;

}

interface IStakingContractHandler {

    event StakeChangeNotificationSkipped(address indexed stakeOwner);

    event StakeChangeBatchNotificationSkipped(address[] stakeOwners);

    event StakeMigrationNotificationSkipped(address indexed stakeOwner);



    



    

    

    

    function getStakeBalanceOf(address _stakeOwner) external view returns (uint256);



    

    

    function getTotalStakedTokens() external view returns (uint256);



    



    event NotifyDelegationsChanged(bool notifyDelegations);



    function setNotifyDelegations(bool notifyDelegations) external; 



    function getNotifyDelegations() external returns (bool);

}

interface IStakingRewards {



    event DelegatorStakingRewardsAssigned(address indexed delegator, uint256 amount, uint256 totalAwarded, address guardian, uint256 delegatorRewardsPerToken);

    event GuardianStakingRewardsAssigned(address indexed guardian, uint256 amount, uint256 totalAwarded, uint256 delegatorRewardsPerToken, uint256 stakingRewardsPerWeight);

    event StakingRewardsClaimed(address indexed addr, uint256 claimedDelegatorRewards, uint256 claimedGuardianRewards, uint256 totalClaimedDelegatorRewards, uint256 totalClaimedGuardianRewards);

    event StakingRewardsAllocated(uint256 allocatedRewards, uint256 stakingRewardsPerWeight);

    event GuardianDelegatorsStakingRewardsPercentMilleUpdated(address indexed guardian, uint256 delegatorsStakingRewardsPercentMille);



    



    

    function getStakingRewardsBalance(address addr) external view returns (uint256 balance);



    

    

    function setGuardianDelegatorsStakingRewardsPercentMille(uint32 delegatorRewardsPercentMille) external;



    

    function getGuardianDelegatorsStakingRewardsPercentMille(address guardian) external view returns (uint256 delegatorRewardsRatioPercentMille);



    

    function claimStakingRewards(address addr) external;



    

    

    function getStakingRewardsWalletAllocatedTokens() external view returns (uint256 allocated);



    function getGuardianStakingRewardsData(address guardian) external view returns (

        uint256 balance,

        uint256 claimed,

        uint256 delegatorRewardsPerToken,

        uint256 lastStakingRewardsPerWeight

    );



    function getDelegatorStakingRewardsData(address delegator) external view returns (

        uint256 balance,

        uint256 claimed,

        uint256 lastDelegatorRewardsPerToken

    );



    function getStakingRewardsState() external view returns (

        uint96 stakingRewardsPerWeight,

        uint96 unclaimedStakingRewards

    );



    function getCurrentStakingRewardsRatePercentMille() external returns (uint256);



    

    

    function committeeMembershipWillChange(address guardian, uint256 weight, uint256 totalCommitteeWeight, bool inCommittee, bool inCommitteeAfter) external ;



    

    

    function delegationWillChange(address guardian, uint256 delegatedStake, address delegator, uint256 delegatorStake, address nextGuardian, uint256 nextGuardianDelegatedStake) external ;



    



    event AnnualStakingRewardsRateChanged(uint256 annualRateInPercentMille, uint256 annualCap);

    event DefaultDelegatorsStakingRewardsChanged(uint32 defaultDelegatorsStakingRewardsPercentMille);

    event MaxDelegatorsStakingRewardsChanged(uint32 maxDelegatorsStakingRewardsPercentMille);

    event RewardDistributionActivated(uint256 startTime);

    event RewardDistributionDeactivated();

    event StakingRewardsBalanceMigrated(address indexed addr, uint256 guardianStakingRewards, uint256 delegatorStakingRewards, address toRewardsContract);

    event StakingRewardsBalanceMigrationAccepted(address from, address indexed addr, uint256 guardianStakingRewards, uint256 delegatorStakingRewards);

    event EmergencyWithdrawal(address addr);



    

    

    function activateRewardDistribution(uint startTime) external ;



    

    

    function deactivateRewardDistribution() external ;



    

    function setDefaultDelegatorsStakingRewardsPercentMille(uint32 defaultDelegatorsStakingRewardsPercentMille) external ;



    function getDefaultDelegatorsStakingRewardsPercentMille() external view returns (uint32);



    

    function setMaxDelegatorsStakingRewardsPercentMille(uint32 maxDelegatorsStakingRewardsPercentMille) external ;



    function getMaxDelegatorsStakingRewardsPercentMille() external view returns (uint32);



    

    function setAnnualStakingRewardsRate(uint256 annualRateInPercentMille, uint256 annualCap) external ;



    function getAnnualStakingRewardsRatePercentMille() external view returns (uint32);



    function getAnnualStakingRewardsCap() external view returns (uint256);



    function isRewardAllocationActive() external view returns (bool);



    

    function getSettings() external view returns (

        uint annualStakingRewardsCap,

        uint32 annualStakingRewardsRatePercentMille,

        uint32 defaultDelegatorsStakingRewardsPercentMille,

        uint32 maxDelegatorsStakingRewardsPercentMille,

        bool rewardAllocationActive

    );



    

    function migrateRewardsBalance(address guardian) external;



    

    function acceptRewardsBalanceMigration(address guardian, uint256 guardianStakingRewards, uint256 delegatorStakingRewards) external;



    

    function emergencyWithdraw() external ;

}

contract Initializable {



    address private _initializationAdmin;



    event InitializationComplete();



    constructor() public{

        _initializationAdmin = msg.sender;

    }



    modifier onlyInitializationAdmin() {

        require(msg.sender == initializationAdmin(), "sender is not the initialization admin");



        _;

    }



    



    function initializationAdmin() public view returns (address) {

        return _initializationAdmin;

    }



    function initializationComplete() external onlyInitializationAdmin {

        _initializationAdmin = address(0);

        emit InitializationComplete();

    }



    function isInitializationComplete() public view returns (bool) {

        return _initializationAdmin == address(0);

    }



}

library SafeMath {

    

    function add(uint256 a, uint256 b) internal pure returns (uint256) {

        uint256 c = a + b;

        require(c >= a, "SafeMath: addition overflow");



        return c;

    }



    

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {

        return sub(a, b, "SafeMath: subtraction overflow");

    }



    

    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {

        require(b <= a, errorMessage);

        uint256 c = a - b;



        return c;

    }



    

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {

        

        

        

        if (a == 0) {

            return 0;

        }



        uint256 c = a * b;

        require(c / a == b, "SafeMath: multiplication overflow");



        return c;

    }



    

    function div(uint256 a, uint256 b) internal pure returns (uint256) {

        return div(a, b, "SafeMath: division by zero");

    }



    

    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {

        require(b > 0, errorMessage);

        uint256 c = a / b;

        



        return c;

    }



    

    function mod(uint256 a, uint256 b) internal pure returns (uint256) {

        return mod(a, b, "SafeMath: modulo by zero");

    }



    

    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {

        require(b != 0, errorMessage);

        return a % b;

    }

}

library SafeMath96 {

    

    function add(uint96 a, uint256 b) internal pure returns (uint96) {

        require(uint256(uint96(b)) == b, "SafeMath: addition overflow");

        uint96 c = a + uint96(b);

        require(c >= a, "SafeMath: addition overflow");



        return c;

    }



    

    function sub(uint96 a, uint256 b) internal pure returns (uint96) {

        require(uint256(uint96(b)) == b, "SafeMath: subtraction overflow");

        return sub(a, uint96(b), "SafeMath: subtraction overflow");

    }



    

    function sub(uint96 a, uint96 b, string memory errorMessage) internal pure returns (uint96) {

        require(b <= a, errorMessage);

        uint96 c = a - b;



        return c;

    }



}

contract WithClaimableRegistryManagement is Context {

    address private _registryAdmin;

    address private _pendingRegistryAdmin;



    event RegistryManagementTransferred(address indexed previousRegistryAdmin, address indexed newRegistryAdmin);



    

    constructor () internal {

        address msgSender = _msgSender();

        _registryAdmin = msgSender;

        emit RegistryManagementTransferred(address(0), msgSender);

    }



    

    function registryAdmin() public view returns (address) {

        return _registryAdmin;

    }



    

    modifier onlyRegistryAdmin() {

        require(isRegistryAdmin(), "WithClaimableRegistryManagement: caller is not the registryAdmin");

        _;

    }



    

    function isRegistryAdmin() public view returns (bool) {

        return _msgSender() == _registryAdmin;

    }



    

    function renounceRegistryManagement() public onlyRegistryAdmin {

        emit RegistryManagementTransferred(_registryAdmin, address(0));

        _registryAdmin = address(0);

    }



    

    function _transferRegistryManagement(address newRegistryAdmin) internal {

        require(newRegistryAdmin != address(0), "RegistryAdmin: new registryAdmin is the zero address");

        emit RegistryManagementTransferred(_registryAdmin, newRegistryAdmin);

        _registryAdmin = newRegistryAdmin;

    }



    

    modifier onlyPendingRegistryAdmin() {

        require(msg.sender == _pendingRegistryAdmin, "Caller is not the pending registryAdmin");

        _;

    }

    

    function transferRegistryManagement(address newRegistryAdmin) public onlyRegistryAdmin {

        _pendingRegistryAdmin = newRegistryAdmin;

    }



    

    function claimRegistryManagement() external onlyPendingRegistryAdmin {

        _transferRegistryManagement(_pendingRegistryAdmin);

        _pendingRegistryAdmin = address(0);

    }



    

    function pendingRegistryAdmin() public view returns (address) {

       return _pendingRegistryAdmin;  

    }

}

contract ContractRegistryAccessor is WithClaimableRegistryManagement, Initializable {



    IContractRegistry private contractRegistry;



    constructor(IContractRegistry _contractRegistry, address _registryAdmin) public {

        require(address(_contractRegistry) != address(0), "_contractRegistry cannot be 0");

        setContractRegistry(_contractRegistry);

        _transferRegistryManagement(_registryAdmin);

    }



    modifier onlyAdmin {

        require(isAdmin(), "sender is not an admin (registryManger or initializationAdmin)");



        _;

    }



    function isManager(string memory role) internal view returns (bool) {

        IContractRegistry _contractRegistry = contractRegistry;

        return isAdmin() || _contractRegistry != IContractRegistry(0) && contractRegistry.getManager(role) == msg.sender;

    }



    function isAdmin() internal view returns (bool) {

        return msg.sender == registryAdmin() || msg.sender == initializationAdmin() || msg.sender == address(contractRegistry);

    }



    function getProtocolContract() internal view returns (address) {

        return contractRegistry.getContract("protocol");

    }



    function getStakingRewardsContract() internal view returns (address) {

        return contractRegistry.getContract("stakingRewards");

    }



    function getFeesAndBootstrapRewardsContract() internal view returns (address) {

        return contractRegistry.getContract("feesAndBootstrapRewards");

    }



    function getCommitteeContract() internal view returns (address) {

        return contractRegistry.getContract("committee");

    }



    function getElectionsContract() internal view returns (address) {

        return contractRegistry.getContract("elections");

    }



    function getDelegationsContract() internal view returns (address) {

        return contractRegistry.getContract("delegations");

    }



    function getGuardiansRegistrationContract() internal view returns (address) {

        return contractRegistry.getContract("guardiansRegistration");

    }



    function getCertificationContract() internal view returns (address) {

        return contractRegistry.getContract("certification");

    }



    function getStakingContract() internal view returns (address) {

        return contractRegistry.getContract("staking");

    }



    function getSubscriptionsContract() internal view returns (address) {

        return contractRegistry.getContract("subscriptions");

    }



    function getStakingRewardsWallet() internal view returns (address) {

        return contractRegistry.getContract("stakingRewardsWallet");

    }



    function getBootstrapRewardsWallet() internal view returns (address) {

        return contractRegistry.getContract("bootstrapRewardsWallet");

    }



    function getGeneralFeesWallet() internal view returns (address) {

        return contractRegistry.getContract("generalFeesWallet");

    }



    function getCertifiedFeesWallet() internal view returns (address) {

        return contractRegistry.getContract("certifiedFeesWallet");

    }



    function getStakingContractHandler() internal view returns (address) {

        return contractRegistry.getContract("stakingContractHandler");

    }



    



    event ContractRegistryAddressUpdated(address addr);



    function setContractRegistry(IContractRegistry newContractRegistry) public onlyAdmin {

        require(newContractRegistry.getPreviousContractRegistry() == address(contractRegistry), "new contract registry must provide the previous contract registry");

        contractRegistry = newContractRegistry;

        emit ContractRegistryAddressUpdated(address(newContractRegistry));

    }



    function getContractRegistry() public view returns (IContractRegistry) {

        return contractRegistry;

    }



}

contract Lockable is ILockable, ContractRegistryAccessor {



    bool public locked;



    constructor(IContractRegistry _contractRegistry, address _registryAdmin) ContractRegistryAccessor(_contractRegistry, _registryAdmin) public {}



    modifier onlyLockOwner() {

        require(msg.sender == registryAdmin() || msg.sender == address(getContractRegistry()), "caller is not a lock owner");



        _;

    }



    function lock() external override onlyLockOwner {

        locked = true;

        emit Locked();

    }



    function unlock() external override onlyLockOwner {

        locked = false;

        emit Unlocked();

    }



    function isLocked() external override view returns (bool) {

        return locked;

    }



    modifier onlyWhenActive() {

        require(!locked, "contract is locked for this operation");



        _;

    }

}

contract ManagedContract is Lockable {



    constructor(IContractRegistry _contractRegistry, address _registryAdmin) Lockable(_contractRegistry, _registryAdmin) public {}



    modifier onlyMigrationManager {

        require(isManager("migrationManager"), "sender is not the migration manager");



        _;

    }



    modifier onlyFunctionalManager {

        require(isManager("functionalManager"), "sender is not the functional manager");



        _;

    }



    function refreshContracts() virtual external {}



}

contract Delegations is IDelegations, IStakeChangeNotifier, ManagedContract {

	using SafeMath for uint256;

	using SafeMath96 for uint96;



	address constant public VOID_ADDR = address(-1);



	struct StakeOwnerData {

		address delegation;

		uint96 stake;

	}

	mapping(address => StakeOwnerData) public stakeOwnersData;

	mapping(address => uint256) public uncappedDelegatedStake;



	uint256 totalDelegatedStake;



	struct DelegateStatus {

		address addr;

		uint256 uncappedDelegatedStake;

		bool isSelfDelegating;

		uint256 delegatedStake;

		uint96 selfDelegatedStake;

	}



	constructor(IContractRegistry _contractRegistry, address _registryAdmin) ManagedContract(_contractRegistry, _registryAdmin) public {

		address VOID_ADDRESS_DUMMY_DELEGATION = address(-2);

		assert(VOID_ADDR != VOID_ADDRESS_DUMMY_DELEGATION && VOID_ADDR != address(0) && VOID_ADDRESS_DUMMY_DELEGATION != address(0));

		stakeOwnersData[VOID_ADDR].delegation = VOID_ADDRESS_DUMMY_DELEGATION;

	}



	modifier onlyStakingContractHandler() {

		require(msg.sender == address(stakingContractHandler), "caller is not the staking contract handler");



		_;

	}



	



	function delegate(address to) external override onlyWhenActive {

		delegateFrom(msg.sender, to);

	}



	function getDelegation(address addr) external override view returns (address) {

		return getStakeOwnerData(addr).delegation;

	}



	function getDelegationInfo(address addr) external override view returns (address delegation, uint256 delegatorStake) {

		StakeOwnerData memory data = getStakeOwnerData(addr);

		return (data.delegation, data.stake);

	}



	function getDelegatedStake(address addr) external override view returns (uint256) {

		return getDelegateStatus(addr).delegatedStake;

	}



	function getTotalDelegatedStake() external override view returns (uint256) {

		return totalDelegatedStake;

	}



	function refreshStake(address addr) external override onlyWhenActive {

		_stakeChange(addr, stakingContractHandler.getStakeBalanceOf(addr));

	}



	



	function stakeChange(address _stakeOwner, uint256, bool, uint256 _updatedStake) external override onlyStakingContractHandler onlyWhenActive {

		_stakeChange(_stakeOwner, _updatedStake);

	}



	function stakeChangeBatch(address[] calldata _stakeOwners, uint256[] calldata _amounts, bool[] calldata _signs, uint256[] calldata _updatedStakes) external override onlyStakingContractHandler onlyWhenActive {

		uint batchLength = _stakeOwners.length;

		require(batchLength == _amounts.length, "_stakeOwners, _amounts - array length mismatch");

		require(batchLength == _signs.length, "_stakeOwners, _signs - array length mismatch");

		require(batchLength == _updatedStakes.length, "_stakeOwners, _updatedStakes - array length mismatch");



		for (uint i = 0; i < _stakeOwners.length; i++) {

			_stakeChange(_stakeOwners[i], _updatedStakes[i]);

		}

	}



	function stakeMigration(address _stakeOwner, uint256 _amount) external override onlyStakingContractHandler onlyWhenActive {}



	



	function importDelegations(address[] calldata from, address to) external override onlyInitializationAdmin {

		require(to != address(0), "to must be a non zero address");

		require(from.length > 0, "from array must contain at least one address");

		(uint96 stakingRewardsPerWeight, ) = stakingRewardsContract.getStakingRewardsState();

		require(stakingRewardsPerWeight == 0, "no rewards may be allocated prior to importing delegations");



		uint256 uncappedDelegatedStakeDelta = 0;

		StakeOwnerData memory data;

		uint256 newTotalDelegatedStake = totalDelegatedStake;

		DelegateStatus memory delegateStatus = getDelegateStatus(to);

		IStakingContractHandler _stakingContractHandler = stakingContractHandler;

		uint256 delegatorUncapped;

		uint256[] memory delegatorsStakes = new uint256[](from.length);

		for (uint i = 0; i < from.length; i++) {

			data = stakeOwnersData[from[i]];

			require(data.delegation == address(0), "import allowed only for uninitialized accounts. existing delegation detected");

			require(from[i] != to, "import cannot be used for self-delegation (already self delegated)");

			require(data.stake == 0 , "import allowed only for uninitialized accounts. existing stake detected");



			

			delegatorUncapped = uncappedDelegatedStake[from[i]];

			if (delegatorUncapped > 0) {

				newTotalDelegatedStake = newTotalDelegatedStake.sub(delegatorUncapped);

				emit DelegatedStakeChanged(

					from[i],

					0,

					0,

					from[i],

					0

				);

			}



			

			data.delegation = to;

			data.stake = uint96(_stakingContractHandler.getStakeBalanceOf(from[i]));

			stakeOwnersData[from[i]] = data;



			uncappedDelegatedStakeDelta = uncappedDelegatedStakeDelta.add(data.stake);



			

			delegatorsStakes[i] = data.stake;



			emit Delegated(from[i], to);



			emit DelegatedStakeChanged(

				to,

				delegateStatus.selfDelegatedStake,

				delegateStatus.isSelfDelegating ? delegateStatus.delegatedStake.add(uncappedDelegatedStakeDelta) : 0,

				from[i],

				data.stake

			);

		}



		

		uncappedDelegatedStake[to] = uncappedDelegatedStake[to].add(uncappedDelegatedStakeDelta);



		if (delegateStatus.isSelfDelegating) {

			newTotalDelegatedStake = newTotalDelegatedStake.add(uncappedDelegatedStakeDelta);

		}

		totalDelegatedStake = newTotalDelegatedStake;



		

		emit DelegationsImported(from, to);

	}



	function initDelegation(address from, address to) external override onlyInitializationAdmin {

		delegateFrom(from, to);

		emit DelegationInitialized(from, to);

	}



	



	function getDelegateStatus(address addr) private view returns (DelegateStatus memory status) {

		StakeOwnerData memory data = getStakeOwnerData(addr);



		status.addr = addr;

		status.uncappedDelegatedStake = uncappedDelegatedStake[addr];

		status.isSelfDelegating = data.delegation == addr;

		status.selfDelegatedStake = status.isSelfDelegating ? data.stake : 0;

		status.delegatedStake = status.isSelfDelegating ? status.uncappedDelegatedStake : 0;



		return status;

	}



	function getStakeOwnerData(address addr) private view returns (StakeOwnerData memory data) {

		data = stakeOwnersData[addr];

		data.delegation = (data.delegation == address(0)) ? addr : data.delegation;

		return data;

	}



	struct DelegateFromVars {

		DelegateStatus prevDelegateStatusBefore;

		DelegateStatus newDelegateStatusBefore;

		DelegateStatus prevDelegateStatusAfter;

		DelegateStatus newDelegateStatusAfter;

	}



	function delegateFrom(address from, address to) private {

		require(to != address(0), "cannot delegate to a zero address");



		DelegateFromVars memory vars;



		StakeOwnerData memory delegatorData = getStakeOwnerData(from);



		

		if (delegatorData.stake == 0 && uncappedDelegatedStake[from] == 0) {

			stakeOwnersData[from].delegation = to;

			emit Delegated(from, to);

			return;

		}



		address prevDelegate = delegatorData.delegation;



		vars.prevDelegateStatusBefore = getDelegateStatus(prevDelegate);

		vars.newDelegateStatusBefore = getDelegateStatus(to);



		stakingRewardsContract.delegationWillChange(prevDelegate, vars.prevDelegateStatusBefore.delegatedStake, from, delegatorData.stake, to, vars.newDelegateStatusBefore.delegatedStake);



		stakeOwnersData[from].delegation = to;



		uint256 delegatorStake = delegatorData.stake;



		uncappedDelegatedStake[prevDelegate] = vars.prevDelegateStatusBefore.uncappedDelegatedStake.sub(delegatorStake);

		uncappedDelegatedStake[to] = vars.newDelegateStatusBefore.uncappedDelegatedStake.add(delegatorStake);



		vars.prevDelegateStatusAfter = getDelegateStatus(prevDelegate);

		vars.newDelegateStatusAfter = getDelegateStatus(to);



		uint256 _totalDelegatedStake = totalDelegatedStake.sub(

			vars.prevDelegateStatusBefore.delegatedStake

		).add(

			vars.prevDelegateStatusAfter.delegatedStake

		).sub(

			vars.newDelegateStatusBefore.delegatedStake

		).add(

			vars.newDelegateStatusAfter.delegatedStake

		);



		totalDelegatedStake = _totalDelegatedStake;



		emit Delegated(from, to);



		IElections _electionsContract = electionsContract;



		if (vars.prevDelegateStatusBefore.delegatedStake != vars.prevDelegateStatusAfter.delegatedStake) {

			_electionsContract.delegatedStakeChange(

				prevDelegate,

				vars.prevDelegateStatusAfter.selfDelegatedStake,

				vars.prevDelegateStatusAfter.delegatedStake,

				_totalDelegatedStake

			);



			emit DelegatedStakeChanged(

				prevDelegate,

				vars.prevDelegateStatusAfter.selfDelegatedStake,

				vars.prevDelegateStatusAfter.delegatedStake,

				from,

				0

			);

		}



		if (vars.newDelegateStatusBefore.delegatedStake != vars.newDelegateStatusAfter.delegatedStake) {

			_electionsContract.delegatedStakeChange(

				to,

				vars.newDelegateStatusAfter.selfDelegatedStake,

				vars.newDelegateStatusAfter.delegatedStake,

				_totalDelegatedStake

			);



			emit DelegatedStakeChanged(

				to,

				vars.newDelegateStatusAfter.selfDelegatedStake,

				vars.newDelegateStatusAfter.delegatedStake,

				from,

				delegatorStake

			);

		}

	}



	function _stakeChange(address _stakeOwner, uint256 _updatedStake) private {

		StakeOwnerData memory stakeOwnerDataBefore = getStakeOwnerData(_stakeOwner);

		DelegateStatus memory delegateStatusBefore = getDelegateStatus(stakeOwnerDataBefore.delegation);



		uint256 prevUncappedStake = delegateStatusBefore.uncappedDelegatedStake;

		uint256 newUncappedStake = prevUncappedStake.sub(stakeOwnerDataBefore.stake).add(_updatedStake);



		stakingRewardsContract.delegationWillChange(stakeOwnerDataBefore.delegation, delegateStatusBefore.delegatedStake, _stakeOwner, stakeOwnerDataBefore.stake, stakeOwnerDataBefore.delegation, delegateStatusBefore.delegatedStake);



		uncappedDelegatedStake[stakeOwnerDataBefore.delegation] = newUncappedStake;



		require(uint256(uint96(_updatedStake)) == _updatedStake, "Delegations::updatedStakes value too big (>96 bits)");

		stakeOwnersData[_stakeOwner].stake = uint96(_updatedStake);



		uint256 _totalDelegatedStake = totalDelegatedStake;

		if (delegateStatusBefore.isSelfDelegating) {

			_totalDelegatedStake = _totalDelegatedStake.sub(stakeOwnerDataBefore.stake).add(_updatedStake);

			totalDelegatedStake = _totalDelegatedStake;

		}



		DelegateStatus memory delegateStatusAfter = getDelegateStatus(stakeOwnerDataBefore.delegation);



		electionsContract.delegatedStakeChange(

			stakeOwnerDataBefore.delegation,

			delegateStatusAfter.selfDelegatedStake,

			delegateStatusAfter.delegatedStake,

			_totalDelegatedStake

		);



		if (_updatedStake != stakeOwnerDataBefore.stake) {

			emit DelegatedStakeChanged(

				stakeOwnerDataBefore.delegation,

				delegateStatusAfter.selfDelegatedStake,

				delegateStatusAfter.delegatedStake,

				_stakeOwner,

				_updatedStake

			);

		}

	}



	



	IElections electionsContract;

	IStakingRewards stakingRewardsContract;

	IStakingContractHandler stakingContractHandler;

	function refreshContracts() external override {

		electionsContract = IElections(getElectionsContract());

		stakingContractHandler = IStakingContractHandler(getStakingContractHandler());

		stakingRewardsContract = IStakingRewards(getStakingRewardsContract());

	}



}
