





pragma solidity ^0.6.0;


abstract contract Context {
    function _msgSender() internal view virtual returns (address payable) {
        return msg.sender;
    }

    function _msgData() internal view virtual returns (bytes memory) {
        this; 
        return msg.data;
    }
}




pragma solidity ^0.6.0;


contract Ownable is Context {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    
    constructor () internal {
        address msgSender = _msgSender();
        _owner = msgSender;
        emit OwnershipTransferred(address(0), msgSender);
    }

    
    function owner() public view returns (address) {
        return _owner;
    }

    
    modifier onlyOwner() {
        require(_owner == _msgSender(), "Ownable: caller is not the owner");
        _;
    }

    
    function renounceOwnership() public virtual onlyOwner {
        emit OwnershipTransferred(_owner, address(0));
        _owner = address(0);
    }

    
    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), "Ownable: new owner is the zero address");
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }
}




pragma solidity ^0.6.0;


interface IERC20 {
    
    function totalSupply() external view returns (uint256);

    
    function balanceOf(address account) external view returns (uint256);

    
    function transfer(address recipient, uint256 amount) external returns (bool);

    
    function allowance(address owner, address spender) external view returns (uint256);

    
    function approve(address spender, uint256 amount) external returns (bool);

    
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);

    
    event Transfer(address indexed from, address indexed to, uint256 value);

    
    event Approval(address indexed owner, address indexed spender, uint256 value);
}




pragma solidity ^0.6.0;


library SafeMath {
    
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, "SafeMath: addition overflow");

        return c;
    }

    
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        return sub(a, b, "SafeMath: subtraction overflow");
    }

    
    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b <= a, errorMessage);
        uint256 c = a - b;

        return c;
    }

    
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        
        
        
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b, "SafeMath: multiplication overflow");

        return c;
    }

    
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        return div(a, b, "SafeMath: division by zero");
    }

    
    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b > 0, errorMessage);
        uint256 c = a / b;
        

        return c;
    }

    
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        return mod(a, b, "SafeMath: modulo by zero");
    }

    
    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b != 0, errorMessage);
        return a % b;
    }
}




pragma solidity ^0.6.0;


library Math {
    
    function max(uint256 a, uint256 b) internal pure returns (uint256) {
        return a >= b ? a : b;
    }

    
    function min(uint256 a, uint256 b) internal pure returns (uint256) {
        return a < b ? a : b;
    }

    
    function average(uint256 a, uint256 b) internal pure returns (uint256) {
        
        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);
    }
}



pragma solidity ^0.6.12;



contract TimeDistribution is Ownable {
    using SafeMath for uint256;
    using Math for uint256;

    IERC20 public token;
    address public distributor;

    struct DistributionInfo {
        uint256 amount;
        uint256 claimedAmount;
        uint256 beginTs;
        uint256 endTs;
        uint256 duration;
    }

    mapping(address => DistributionInfo) public infos;

    constructor(IERC20 _token, address _distributor) public {
        token = _token;
        distributor = _distributor;
    }

    function userTotalToken() public view returns (uint256) {
        return infos[msg.sender].amount;
    }

    function claimed() public view returns (uint256) {
        return infos[msg.sender].claimedAmount;
    }

    function setDistributor(address _distributor) public onlyOwner {
        distributor = _distributor;
    }

    function addInfo(
        address account,
        uint256 amount,
        uint256 beginTs,
        uint256 endTs
    ) public onlyOwner {
        require(infos[account].amount == 0, "Timedistribution::account is not a new user");
        require(amount != 0, "TimeDistribution::addInfo: amount should not 0");
        require(
            beginTs >= block.timestamp,
            "TimeDistribution::addInfo: begin too early"
        );
        require(
            endTs >= block.timestamp,
            "TimeDistribution::addInfo: end too early"
        );
        infos[account] = DistributionInfo(
            amount,
            0,
            beginTs,
            endTs,
            endTs.sub(beginTs)
        );
        emit AddInfo(account, amount, beginTs, endTs);
    }

    
    function addMultiInfo(address[] memory accounts, uint256[] memory amounts, uint256[] memory beginTsArray, uint256[] memory endTsArray) public onlyOwner {
        require(accounts.length == amounts.length, "TimeDistribution::addMultiInfo:function params length not equal");
        require(accounts.length == beginTsArray.length, "TimeDistribution::addMultiInfo:function params length not equal");
        require(accounts.length == endTsArray.length, "TimeDistribution::addMultiInfo:function params length not equal");
        for(uint256 i=0; i < accounts.length; i++) {
            addInfo(accounts[i], amounts[i], beginTsArray[i], endTsArray[i]);
        }
    }

    function pendingClaim() public view returns (uint256) {
        if(infos[msg.sender].amount == 0) {
            return 0;
        }
        DistributionInfo storage info = infos[msg.sender];
        uint256 nowtime = Math.min(block.timestamp, info.endTs);
        return
            (nowtime.sub(info.beginTs)).mul(info.amount).div(info.duration).sub(
                info.claimedAmount
            );
    }

    function claim() public {
        uint256 claimAmount = pendingClaim();
        DistributionInfo storage info = infos[msg.sender];
        info.claimedAmount = info.claimedAmount.add(claimAmount);
        token.transferFrom(distributor, msg.sender, claimAmount);
        emit ClaimToken(msg.sender, claimAmount);
    }

    
    
    
    
    
    

    function changeUserAdmin(address oldUser, address newUser) public onlyOwner {
        require(infos[newUser].amount == 0, "Timedistribution::newUser is not a new user");
        infos[newUser] = infos[oldUser];
        delete infos[oldUser];
        emit UserChanged(oldUser, newUser);
    }

    event AddInfo(
        address account,
        uint256 amount,
        uint256 beginTs,
        uint256 endTs
    );
    event ClaimToken(address account, uint256 amount);
    event UserChanged(address oldUser, address newUser);
}