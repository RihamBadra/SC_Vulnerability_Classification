pragma solidity 0.7.4;

enum MathError { NO_ERROR, DIVISION_BY_ZERO, INTEGER_OVERFLOW, INTEGER_UNDERFLOW, MODULO_BY_ZERO }

library Address {

    

    function isContract(address account) internal view returns (bool) {

        

        

        

        bytes32 codehash;

        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;

        

        assembly {

            codehash := extcodehash(account)

        }

        return (codehash != accountHash && codehash != 0x0);

    }

}

abstract contract AdminStorage {

    

    address public admin;

}

abstract contract BalanceSheetStorage {

    struct Vault {

        uint256 debt;

        uint256 freeCollateral;

        uint256 lockedCollateral;

        bool isOpen;

    }



    

    FintrollerInterface public fintroller;



    

    mapping(address => mapping(address => Vault)) internal vaults;



    

    bool public constant isBalanceSheet = true;

}

abstract contract CarefulMath {

    

    function addUInt(uint256 a, uint256 b) internal pure returns (MathError, uint256) {

        uint256 c = a + b;



        if (c >= a) {

            return (MathError.NO_ERROR, c);

        } else {

            return (MathError.INTEGER_OVERFLOW, 0);

        }

    }



    

    function addThenSubUInt(

        uint256 a,

        uint256 b,

        uint256 c

    ) internal pure returns (MathError, uint256) {

        (MathError err0, uint256 sum) = addUInt(a, b);



        if (err0 != MathError.NO_ERROR) {

            return (err0, 0);

        }



        return subUInt(sum, c);

    }



    

    function divUInt(uint256 a, uint256 b) internal pure returns (MathError, uint256) {

        if (b == 0) {

            return (MathError.DIVISION_BY_ZERO, 0);

        }



        return (MathError.NO_ERROR, a / b);

    }



    

    function modUInt(uint256 a, uint256 b) internal pure returns (MathError, uint256) {

        if (b == 0) {

            return (MathError.MODULO_BY_ZERO, 0);

        }



        return (MathError.NO_ERROR, a % b);

    }



    

    function mulUInt(uint256 a, uint256 b) internal pure returns (MathError, uint256) {

        if (a == 0) {

            return (MathError.NO_ERROR, 0);

        }



        uint256 c = a * b;



        if (c / a != b) {

            return (MathError.INTEGER_OVERFLOW, 0);

        } else {

            return (MathError.NO_ERROR, c);

        }

    }



    

    function subUInt(uint256 a, uint256 b) internal pure returns (MathError, uint256) {

        if (b <= a) {

            return (MathError.NO_ERROR, a - b);

        } else {

            return (MathError.INTEGER_UNDERFLOW, 0);

        }

    }

}

abstract contract Erc20PermitStorage {

    

    bytes32 public DOMAIN_SEPARATOR;



    

    bytes32 public constant PERMIT_TYPEHASH = 0xfc77c2b9d30fe91687fd39abb7d16fcdfe1472d065740051ab8b13e4bf4a617f;



    

    mapping(address => uint256) public nonces;



    

    string public constant version = "1";

}

abstract contract Erc20RecoverStorage {

    

    Erc20Interface[] public nonRecoverableTokens;



    

    bool public isInitialized;

}

abstract contract Erc20Storage {

    

    uint8 public decimals;



    

    string public name;



    

    string public symbol;



    

    uint256 public totalSupply;



    mapping(address => mapping(address => uint256)) internal allowances;



    mapping(address => uint256) internal balances;

}

abstract contract ExponentialStorage {

    struct Exp {

        uint256 mantissa;

    }



    

    uint256 internal constant expScale = 1e18;

    uint256 internal constant halfExpScale = expScale / 2;

    uint256 internal constant mantissaOne = expScale;

}

abstract contract FyTokenStorage {

    

    struct Vault {

        uint256 debt;

        uint256 freeCollateral;

        uint256 lockedCollateral;

        bool isOpen;

    }



    



    

    BalanceSheetInterface public balanceSheet;



    

    Erc20Interface public collateral;



    

    uint256 public collateralPrecisionScalar;



    

    uint256 public expirationTime;



    

    FintrollerInterface public fintroller;



    

    RedemptionPoolInterface public redemptionPool;



    

    Erc20Interface public underlying;



    

    uint256 public underlyingPrecisionScalar;



    

    bool public constant isFyToken = true;

}

abstract contract RedemptionPoolStorage {

    

    FintrollerInterface public fintroller;



    

    uint256 public totalUnderlyingSupply;



    

    FyTokenInterface public fyToken;



    

    bool public constant isRedemptionPool = true;

}

abstract contract ReentrancyGuard {

    bool private notEntered;



    

    constructor() {

        notEntered = true;

    }



    

    modifier nonReentrant() {

        

        require(notEntered, "ERR_REENTRANT_CALL");



        

        notEntered = false;



        _;



        

        notEntered = true;

    }

}

library SafeErc20 {

    using Address for address;



    



    function safeTransfer(

        Erc20Interface token,

        address to,

        uint256 value

    ) internal {

        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));

    }



    function safeTransferFrom(

        Erc20Interface token,

        address from,

        address to,

        uint256 value

    ) internal {

        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));

    }



    



    

    function callOptionalReturn(Erc20Interface token, bytes memory data) private {

        

        

        

        bytes memory returndata = functionCallWithValue(address(token), data, "ERR_SAFE_ERC20_LOW_LEVEL_CALL");

        if (returndata.length > 0) {

            

            require(abi.decode(returndata, (bool)), "ERR_SAFE_ERC20_ERC20_OPERATION");

        }

    }



    function functionCallWithValue(

        address target,

        bytes memory data,

        string memory errorMessage

    ) private returns (bytes memory) {

        require(target.isContract(), "ERR_SAFE_ERC20_CALL_TO_NON_CONTRACT");



        

        (bool success, bytes memory returndata) = target.call(data);

        if (success) {

            return returndata;

        } else {

            

            if (returndata.length > 0) {

                



                

                assembly {

                    let returndata_size := mload(returndata)

                    revert(add(32, returndata), returndata_size)

                }

            } else {

                revert(errorMessage);

            }

        }

    }

}

interface UniswapAnchoredViewInterface {

    

    function price(string memory symbol) external view returns (uint256);

}

abstract contract AdminInterface is AdminStorage {

    

    function _renounceAdmin() external virtual;



    function _transferAdmin(address newAdmin) external virtual;



    

    event TransferAdmin(address indexed oldAdmin, address indexed newAdmin);

}

abstract contract BalanceSheetInterface is BalanceSheetStorage {

    

    function getClutchableCollateral(FyTokenInterface fyToken, uint256 repayAmount)

        external

        view

        virtual

        returns (uint256);



    function getCurrentCollateralizationRatio(FyTokenInterface fyToken, address account)

        public

        view

        virtual

        returns (uint256);



    function getHypotheticalCollateralizationRatio(

        FyTokenInterface fyToken,

        address account,

        uint256 lockedCollateral,

        uint256 debt

    ) public view virtual returns (uint256);



    function getVault(FyTokenInterface fyToken, address account)

        external

        view

        virtual

        returns (

            uint256,

            uint256,

            uint256,

            bool

        );



    function getVaultDebt(FyTokenInterface fyToken, address account) external view virtual returns (uint256);



    function getVaultLockedCollateral(FyTokenInterface fyToken, address account)

        external

        view

        virtual

        returns (uint256);



    function isAccountUnderwater(FyTokenInterface fyToken, address account) external view virtual returns (bool);



    function isVaultOpen(FyTokenInterface fyToken, address account) external view virtual returns (bool);



    



    function clutchCollateral(

        FyTokenInterface fyToken,

        address liquidator,

        address borrower,

        uint256 clutchedCollateralAmount

    ) external virtual returns (bool);



    function depositCollateral(FyTokenInterface fyToken, uint256 collateralAmount) external virtual returns (bool);



    function freeCollateral(FyTokenInterface fyToken, uint256 collateralAmount) external virtual returns (bool);



    function lockCollateral(FyTokenInterface fyToken, uint256 collateralAmount) external virtual returns (bool);



    function openVault(FyTokenInterface fyToken) external virtual returns (bool);



    function setVaultDebt(

        FyTokenInterface fyToken,

        address account,

        uint256 newVaultDebt

    ) external virtual returns (bool);



    function withdrawCollateral(FyTokenInterface fyToken, uint256 collateralAmount) external virtual returns (bool);



    



    event ClutchCollateral(

        FyTokenInterface indexed fyToken,

        address indexed liquidator,

        address indexed borrower,

        uint256 clutchedCollateralAmount

    );



    event DepositCollateral(FyTokenInterface indexed fyToken, address indexed account, uint256 collateralAmount);



    event FreeCollateral(FyTokenInterface indexed fyToken, address indexed account, uint256 collateralAmount);



    event LockCollateral(FyTokenInterface indexed fyToken, address indexed account, uint256 collateralAmount);



    event OpenVault(FyTokenInterface indexed fyToken, address indexed account);



    event SetVaultDebt(FyTokenInterface indexed fyToken, address indexed account, uint256 oldDebt, uint256 newDebt);



    event WithdrawCollateral(FyTokenInterface indexed fyToken, address indexed account, uint256 collateralAmount);

}

abstract contract Erc20Interface is Erc20Storage {

    

    function allowance(address owner, address spender) external view virtual returns (uint256);



    function balanceOf(address account) external view virtual returns (uint256);



    

    function approve(address spender, uint256 amount) external virtual returns (bool);



    function transfer(address recipient, uint256 amount) external virtual returns (bool);



    function transferFrom(

        address sender,

        address recipient,

        uint256 amount

    ) external virtual returns (bool);



    

    event Approval(address indexed owner, address indexed spender, uint256 value);



    event Burn(address indexed account, uint256 burnAmount);



    event Mint(address indexed account, uint256 mintAmount);



    event Transfer(address indexed from, address indexed to, uint256 value);

}

abstract contract Erc20PermitInterface is Erc20PermitStorage {

    

    function permit(

        address owner,

        address spender,

        uint256 amount,

        uint256 deadline,

        uint8 v,

        bytes32 r,

        bytes32 s

    ) external virtual;

}

abstract contract Erc20RecoverInterface is Erc20RecoverStorage {

    

    function _recover(Erc20Interface token, uint256 recoverAmount) external virtual;



    function _setNonRecoverableTokens(Erc20Interface[] calldata tokens) external virtual;



    

    event Recover(address indexed admin, Erc20Interface token, uint256 recoverAmount);

    event SetNonRecoverableTokens(address indexed admin, Erc20Interface[] nonRecoverableTokens);

}

abstract contract Exponential is

    CarefulMath, 

    ExponentialStorage 

{

    

    function addExp(Exp memory a, Exp memory b) internal pure returns (MathError, Exp memory) {

        (MathError error, uint256 result) = addUInt(a.mantissa, b.mantissa);



        return (error, Exp({ mantissa: result }));

    }



    

    function divExp(Exp memory a, Exp memory b) internal pure returns (MathError, Exp memory) {

        (MathError err0, uint256 scaledNumerator) = mulUInt(a.mantissa, expScale);

        if (err0 != MathError.NO_ERROR) {

            return (err0, Exp({ mantissa: 0 }));

        }



        (MathError err1, uint256 rational) = divUInt(scaledNumerator, b.mantissa);

        if (err1 != MathError.NO_ERROR) {

            return (err1, Exp({ mantissa: 0 }));

        }



        return (MathError.NO_ERROR, Exp({ mantissa: rational }));

    }



    

    function mulExp(Exp memory a, Exp memory b) internal pure returns (MathError, Exp memory) {

        (MathError err0, uint256 doubleScaledProduct) = mulUInt(a.mantissa, b.mantissa);

        if (err0 != MathError.NO_ERROR) {

            return (err0, Exp({ mantissa: 0 }));

        }



        

        (MathError err1, uint256 doubleScaledProductWithHalfScale) = addUInt(halfExpScale, doubleScaledProduct);

        if (err1 != MathError.NO_ERROR) {

            return (err1, Exp({ mantissa: 0 }));

        }



        (MathError err2, uint256 product) = divUInt(doubleScaledProductWithHalfScale, expScale);

        

        assert(err2 == MathError.NO_ERROR);



        return (MathError.NO_ERROR, Exp({ mantissa: product }));

    }



    

    function mulExp3(

        Exp memory a,

        Exp memory b,

        Exp memory c

    ) internal pure returns (MathError, Exp memory) {

        (MathError err, Exp memory ab) = mulExp(a, b);

        if (err != MathError.NO_ERROR) {

            return (err, ab);

        }

        return mulExp(ab, c);

    }



    

    function subExp(Exp memory a, Exp memory b) internal pure returns (MathError, Exp memory) {

        (MathError error, uint256 result) = subUInt(a.mantissa, b.mantissa);



        return (error, Exp({ mantissa: result }));

    }

}

abstract contract FintrollerStorage is Exponential {

    struct Bond {

        Exp collateralizationRatio;

        uint256 debtCeiling;

        bool isBorrowAllowed;

        bool isDepositCollateralAllowed;

        bool isLiquidateBorrowAllowed;

        bool isListed;

        bool isRedeemFyTokenAllowed;

        bool isRepayBorrowAllowed;

        bool isSupplyUnderlyingAllowed;

    }



    

    mapping(FyTokenInterface => Bond) internal bonds;



    

    UniswapAnchoredViewInterface public oracle;



    

    uint256 public liquidationIncentiveMantissa;



    

    uint256 public constant oraclePricePrecisionScalar = 1.0e12;



    

    uint256 internal constant collateralizationRatioLowerBoundMantissa = 1.0e18;



    

    uint256 internal constant collateralizationRatioUpperBoundMantissa = 1.0e20;



    

    uint256 internal constant defaultCollateralizationRatioMantissa = 1.5e18;



    

    uint256 internal constant liquidationIncentiveLowerBoundMantissa = 1.0e18;



    

    uint256 internal constant liquidationIncentiveUpperBoundMantissa = 1.5e18;



    

    bool public constant isFintroller = true;

}

abstract contract FyTokenInterface is FyTokenStorage {

    

    function borrow(uint256 borrowAmount) external virtual returns (bool);



    function burn(address holder, uint256 burnAmount) external virtual returns (bool);



    function liquidateBorrow(address borrower, uint256 repayAmount) external virtual returns (bool);



    function mint(address beneficiary, uint256 borrowAmount) external virtual returns (bool);



    function repayBorrow(uint256 repayAmount) external virtual returns (bool);



    function repayBorrowBehalf(address borrower, uint256 repayAmount) external virtual returns (bool);



    function _setFintroller(FintrollerInterface newFintroller) external virtual returns (bool);



    

    event Borrow(address indexed account, uint256 repayAmount);



    event LiquidateBorrow(

        address indexed liquidator,

        address indexed borrower,

        uint256 repayAmount,

        uint256 clutchedCollateralAmount

    );



    event RepayBorrow(address indexed payer, address indexed borrower, uint256 repayAmount, uint256 newDebt);



    event SetFintroller(address indexed admin, FintrollerInterface oldFintroller, FintrollerInterface newFintroller);

}

abstract contract RedemptionPoolInterface is RedemptionPoolStorage {

    

    function redeemFyTokens(uint256 underlyingAmount) external virtual returns (bool);



    function supplyUnderlying(uint256 underlyingAmount) external virtual returns (bool);



    

    event RedeemFyTokens(address indexed account, uint256 fyTokenAmount, uint256 underlyingAmount);



    event SupplyUnderlying(address indexed account, uint256 underlyingAmount, uint256 fyTokenAmount);

}

abstract contract Admin is AdminInterface {

    

    modifier onlyAdmin() {

        require(admin == msg.sender, "ERR_NOT_ADMIN");

        _;

    }



    

    constructor() {

        address msgSender = msg.sender;

        admin = msgSender;

        emit TransferAdmin(address(0x00), msgSender);

    }



    

    function _renounceAdmin() external virtual override onlyAdmin {

        emit TransferAdmin(admin, address(0x00));

        admin = address(0x00);

    }



    

    function _transferAdmin(address newAdmin) external virtual override onlyAdmin {

        require(newAdmin != address(0x00), "ERR_SET_ADMIN_ZERO_ADDRESS");

        emit TransferAdmin(admin, newAdmin);

        admin = newAdmin;

    }

}

contract Erc20 is

    CarefulMath, 

    Erc20Interface 

{

    

    constructor(

        string memory name_,

        string memory symbol_,

        uint8 decimals_

    ) {

        name = name_;

        symbol = symbol_;

        decimals = decimals_;

    }



    



    

    function allowance(address owner, address spender) external view virtual override returns (uint256) {

        return allowances[owner][spender];

    }



    

    function balanceOf(address account) public view virtual override returns (uint256) {

        return balances[account];

    }



    



    

    function approve(address spender, uint256 amount) external virtual override returns (bool) {

        approveInternal(msg.sender, spender, amount);

        return true;

    }



    

    function decreaseAllowance(address spender, uint256 subtractedValue) external virtual returns (bool) {

        MathError mathErr;

        uint256 newAllowance;

        (mathErr, newAllowance) = subUInt(allowances[msg.sender][spender], subtractedValue);

        require(mathErr == MathError.NO_ERROR, "ERR_ERC20_DECREASE_ALLOWANCE_UNDERFLOW");

        approveInternal(msg.sender, spender, newAllowance);

        return true;

    }



    

    function increaseAllowance(address spender, uint256 addedValue) external virtual returns (bool) {

        MathError mathErr;

        uint256 newAllowance;

        (mathErr, newAllowance) = addUInt(allowances[msg.sender][spender], addedValue);

        require(mathErr == MathError.NO_ERROR, "ERR_ERC20_INCREASE_ALLOWANCE_OVERFLOW");

        approveInternal(msg.sender, spender, newAllowance);

        return true;

    }



    

    function transfer(address recipient, uint256 amount) external virtual override returns (bool) {

        transferInternal(msg.sender, recipient, amount);

        return true;

    }



    

    function transferFrom(

        address sender,

        address recipient,

        uint256 amount

    ) external virtual override returns (bool) {

        transferInternal(sender, recipient, amount);

        MathError mathErr;

        uint256 newAllowance;

        (mathErr, newAllowance) = subUInt(allowances[sender][msg.sender], amount);

        require(mathErr == MathError.NO_ERROR, "ERR_ERC20_TRANSFER_FROM_INSUFFICIENT_ALLOWANCE");

        approveInternal(sender, msg.sender, newAllowance);

        return true;

    }



    



    

    function approveInternal(

        address owner,

        address spender,

        uint256 amount

    ) internal virtual {

        require(owner != address(0x00), "ERR_ERC20_APPROVE_FROM_ZERO_ADDRESS");

        require(spender != address(0x00), "ERR_ERC20_APPROVE_TO_ZERO_ADDRESS");



        allowances[owner][spender] = amount;

        emit Approval(owner, spender, amount);

    }



    

    function burnInternal(address holder, uint256 burnAmount) internal {

        MathError mathErr;

        uint256 newHolderBalance;

        uint256 newTotalSupply;



        

        (mathErr, newHolderBalance) = subUInt(balances[holder], burnAmount);

        require(mathErr == MathError.NO_ERROR, "ERR_ERC20_BURN_BALANCE_UNDERFLOW");

        balances[holder] = newHolderBalance;



        

        (mathErr, newTotalSupply) = subUInt(totalSupply, burnAmount);

        require(mathErr == MathError.NO_ERROR, "ERR_ERC20_BURN_TOTAL_SUPPLY_UNDERFLOW");

        totalSupply = newTotalSupply;



        emit Burn(holder, burnAmount);

    }



    

    function mintInternal(address beneficiary, uint256 mintAmount) internal {

        MathError mathErr;

        uint256 newBeneficiaryBalance;

        uint256 newTotalSupply;



        

        (mathErr, newBeneficiaryBalance) = addUInt(balances[beneficiary], mintAmount);

        require(mathErr == MathError.NO_ERROR, "ERR_ERC20_MINT_BALANCE_OVERFLOW");

        balances[beneficiary] = newBeneficiaryBalance;



        

        (mathErr, newTotalSupply) = addUInt(totalSupply, mintAmount);

        require(mathErr == MathError.NO_ERROR, "ERR_ERC20_MINT_TOTAL_SUPPLY_OVERFLOW");

        totalSupply = newTotalSupply;



        emit Mint(beneficiary, mintAmount);

    }



    

    function transferInternal(

        address sender,

        address recipient,

        uint256 amount

    ) internal virtual {

        require(sender != address(0x00), "ERR_ERC20_TRANSFER_FROM_ZERO_ADDRESS");

        require(recipient != address(0x00), "ERR_ERC20_TRANSFER_TO_ZERO_ADDRESS");



        MathError mathErr;

        uint256 newSenderBalance;

        uint256 newRecipientBalance;



        (mathErr, newSenderBalance) = subUInt(balances[sender], amount);

        require(mathErr == MathError.NO_ERROR, "ERR_ERC20_TRANSFER_SENDER_BALANCE_UNDERFLOW");

        balances[sender] = newSenderBalance;



        (mathErr, newRecipientBalance) = addUInt(balances[recipient], amount);

        assert(mathErr == MathError.NO_ERROR);

        balances[recipient] = newRecipientBalance;



        emit Transfer(sender, recipient, amount);

    }

}

contract Erc20Permit is

    Erc20PermitInterface, 

    Erc20 

{

    constructor(

        string memory name_,

        string memory symbol_,

        uint8 decimals_

    ) Erc20(name_, symbol_, decimals_) {

        uint256 chainId;

        

        assembly {

            chainId := chainid()

        }

        DOMAIN_SEPARATOR = keccak256(

            abi.encode(

                keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"),

                keccak256(bytes(name)),

                keccak256(bytes(version)),

                chainId,

                address(this)

            )

        );

    }



    

    function permit(

        address owner,

        address spender,

        uint256 amount,

        uint256 deadline,

        uint8 v,

        bytes32 r,

        bytes32 s

    ) external override {

        require(owner != address(0x00), "ERR_ERC20_PERMIT_OWNER_ZERO_ADDRESS");

        require(spender != address(0x00), "ERR_ERC20_PERMIT_SPENDER_ZERO_ADDRESS");

        require(deadline >= block.timestamp, "ERR_ERC20_PERMIT_EXPIRED");



        

        bytes32 hashStruct = keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, amount, nonces[owner]++, deadline));

        bytes32 digest = keccak256(abi.encodePacked("\x19\x01", DOMAIN_SEPARATOR, hashStruct));

        address recoveredOwner = ecrecover(digest, v, r, s);



        require(recoveredOwner != address(0x00), "ERR_ERC20_PERMIT_RECOVERED_OWNER_ZERO_ADDRESS");

        require(recoveredOwner == owner, "ERR_ERC20_PERMIT_INVALID_SIGNATURE");



        approveInternal(owner, spender, amount);

    }

}

abstract contract Erc20Recover is

    Erc20RecoverInterface, 

    Admin 

{

    using SafeErc20 for Erc20Interface;



    

    function _setNonRecoverableTokens(Erc20Interface[] calldata tokens) external override onlyAdmin {

        

        require(isInitialized == false, "ERR_INITALIZED");



        

        uint256 length = tokens.length;

        for (uint256 i = 0; i < length; i += 1) {

            tokens[i].symbol();

            nonRecoverableTokens.push(tokens[i]);

        }



        

        isInitialized = true;



        emit SetNonRecoverableTokens(admin, tokens);

    }



    

    function _recover(Erc20Interface token, uint256 recoverAmount) external override onlyAdmin {

        

        require(isInitialized == true, "ERR_NOT_INITALIZED");

        require(recoverAmount > 0, "ERR_RECOVER_ZERO");



        bytes32 tokenSymbolHash = keccak256(bytes(token.symbol()));

        uint256 length = nonRecoverableTokens.length;



        

        for (uint256 i = 0; i < length; i += 1) {

            require(

                address(token) != address(nonRecoverableTokens[i]) &&

                    tokenSymbolHash != keccak256(bytes(nonRecoverableTokens[i].symbol())),

                "ERR_RECOVER_NON_RECOVERABLE_TOKEN"

            );

        }



        

        token.safeTransfer(admin, recoverAmount);



        emit Recover(admin, token, recoverAmount);

    }

}

abstract contract FintrollerInterface is FintrollerStorage {

    



    function getBond(FyTokenInterface fyToken)

        external

        view

        virtual

        returns (

            uint256 debtCeiling,

            uint256 collateralizationRatioMantissa,

            bool isBorrowAllowed,

            bool isDepositCollateralAllowed,

            bool isLiquidateBorrowAllowed,

            bool isListed,

            bool isRedeemFyTokenAllowed,

            bool isRepayBorrowAllowed,

            bool isSupplyUnderlyingAllowed

        );



    function getBorrowAllowed(FyTokenInterface fyToken) external view virtual returns (bool);



    function getBondDebtCeiling(FyTokenInterface fyToken) external view virtual returns (uint256);



    function getBondCollateralizationRatio(FyTokenInterface fyToken) external view virtual returns (uint256);



    function getDepositCollateralAllowed(FyTokenInterface fyToken) external view virtual returns (bool);



    function getLiquidateBorrowAllowed(FyTokenInterface fyToken) external view virtual returns (bool);



    function getRedeemFyTokensAllowed(FyTokenInterface fyToken) external view virtual returns (bool);



    function getRepayBorrowAllowed(FyTokenInterface fyToken) external view virtual returns (bool);



    function getSupplyUnderlyingAllowed(FyTokenInterface fyToken) external view virtual returns (bool);



    



    function listBond(FyTokenInterface fyToken) external virtual returns (bool);



    function setBorrowAllowed(FyTokenInterface fyToken, bool state) external virtual returns (bool);



    function setCollateralizationRatio(FyTokenInterface fyToken, uint256 newCollateralizationRatioMantissa)

        external

        virtual

        returns (bool);



    function setDebtCeiling(FyTokenInterface fyToken, uint256 newDebtCeiling) external virtual returns (bool);



    function setDepositCollateralAllowed(FyTokenInterface fyToken, bool state) external virtual returns (bool);



    function setLiquidateBorrowAllowed(FyTokenInterface fyToken, bool state) external virtual returns (bool);



    function setLiquidationIncentive(uint256 newLiquidationIncentiveMantissa) external virtual returns (bool);



    function setOracle(UniswapAnchoredViewInterface newOracle) external virtual returns (bool);



    function setRedeemFyTokensAllowed(FyTokenInterface fyToken, bool state) external virtual returns (bool);



    function setRepayBorrowAllowed(FyTokenInterface fyToken, bool state) external virtual returns (bool);



    function setSupplyUnderlyingAllowed(FyTokenInterface fyToken, bool state) external virtual returns (bool);



    

    event ListBond(address indexed admin, FyTokenInterface indexed fyToken);



    event SetBorrowAllowed(address indexed admin, FyTokenInterface indexed fyToken, bool state);



    event SetCollateralizationRatio(

        address indexed admin,

        FyTokenInterface indexed fyToken,

        uint256 oldCollateralizationRatio,

        uint256 newCollateralizationRatio

    );



    event SetDebtCeiling(

        address indexed admin,

        FyTokenInterface indexed fyToken,

        uint256 oldDebtCeiling,

        uint256 newDebtCeiling

    );



    event SetDepositCollateralAllowed(address indexed admin, FyTokenInterface indexed fyToken, bool state);



    event SetLiquidateBorrowAllowed(address indexed admin, FyTokenInterface indexed fyToken, bool state);



    event SetLiquidationIncentive(

        address indexed admin,

        uint256 oldLiquidationIncentive,

        uint256 newLiquidationIncentive

    );



    event SetRedeemFyTokensAllowed(address indexed admin, FyTokenInterface indexed fyToken, bool state);



    event SetRepayBorrowAllowed(address indexed admin, FyTokenInterface indexed fyToken, bool state);



    event SetOracle(address indexed admin, address oldOracle, address newOracle);



    event SetSupplyUnderlyingAllowed(address indexed admin, FyTokenInterface indexed fyToken, bool state);

}

contract FyToken is

    ReentrancyGuard, 

    FyTokenInterface, 

    Admin, 

    Exponential, 

    Erc20, 

    Erc20Permit, 

    Erc20Recover 

{

    modifier isVaultOpen(address account) {

        require(balanceSheet.isVaultOpen(this, account), "ERR_VAULT_NOT_OPEN");

        _;

    }



    

    constructor(

        string memory name_,

        string memory symbol_,

        uint256 expirationTime_,

        FintrollerInterface fintroller_,

        BalanceSheetInterface balanceSheet_,

        Erc20Interface underlying_,

        Erc20Interface collateral_

    ) Erc20Permit(name_, symbol_, 18) Admin() {

        uint8 defaultNumberOfDecimals = 18;



        

        uint256 underlyingDecimals = underlying_.decimals();

        require(underlyingDecimals > 0, "ERR_FYTOKEN_CONSTRUCTOR_UNDERLYING_DECIMALS_ZERO");

        require(underlyingDecimals <= defaultNumberOfDecimals, "ERR_FYTOKEN_CONSTRUCTOR_UNDERLYING_DECIMALS_OVERFLOW");

        underlyingPrecisionScalar = 10**(defaultNumberOfDecimals - underlyingDecimals);

        underlying = underlying_;



        

        uint256 collateralDecimals = collateral_.decimals();

        require(collateralDecimals > 0, "ERR_FYTOKEN_CONSTRUCTOR_COLLATERAL_DECIMALS_ZERO");

        require(defaultNumberOfDecimals >= collateralDecimals, "ERR_FYTOKEN_CONSTRUCTOR_COLLATERAL_DECIMALS_OVERFLOW");

        collateralPrecisionScalar = 10**(defaultNumberOfDecimals - collateralDecimals);

        collateral = collateral_;



        

        require(expirationTime_ > block.timestamp, "ERR_FYTOKEN_CONSTRUCTOR_EXPIRATION_TIME_NOT_VALID");

        expirationTime = expirationTime_;



        

        fintroller = fintroller_;

        fintroller.isFintroller();



        

        balanceSheet = balanceSheet_;

        balanceSheet.isBalanceSheet();



        

        redemptionPool = new RedemptionPool(fintroller_, this);

        AdminInterface(address(redemptionPool))._transferAdmin(msg.sender);

    }



    



    struct BorrowLocalVars {

        MathError mathErr;

        uint256 debt;

        uint256 debtCeiling;

        uint256 lockedCollateral;

        uint256 hypotheticalCollateralizationRatioMantissa;

        uint256 hypotheticalTotalSupply;

        uint256 newDebt;

        uint256 thresholdCollateralizationRatioMantissa;

    }



    

    function borrow(uint256 borrowAmount) public override isVaultOpen(msg.sender) nonReentrant returns (bool) {

        BorrowLocalVars memory vars;



        

        require(isMatured() == false, "ERR_BOND_MATURED");



        

        require(borrowAmount > 0, "ERR_BORROW_ZERO");



        

        require(fintroller.getBorrowAllowed(this), "ERR_BORROW_NOT_ALLOWED");



        

        (vars.mathErr, vars.hypotheticalTotalSupply) = addUInt(totalSupply, borrowAmount);

        require(vars.mathErr == MathError.NO_ERROR, "ERR_BORROW_MATH_ERROR");

        vars.debtCeiling = fintroller.getBondDebtCeiling(this);

        require(vars.hypotheticalTotalSupply <= vars.debtCeiling, "ERR_BORROW_DEBT_CEILING_OVERFLOW");



        

        (vars.debt, , vars.lockedCollateral, ) = balanceSheet.getVault(this, msg.sender);

        require(vars.lockedCollateral > 0, "ERR_BORROW_LOCKED_COLLATERAL_ZERO");

        (vars.mathErr, vars.newDebt) = addUInt(vars.debt, borrowAmount);

        require(vars.mathErr == MathError.NO_ERROR, "ERR_BORROW_MATH_ERROR");



        

        vars.hypotheticalCollateralizationRatioMantissa = balanceSheet.getHypotheticalCollateralizationRatio(

            this,

            msg.sender,

            vars.lockedCollateral,

            vars.newDebt

        );

        vars.thresholdCollateralizationRatioMantissa = fintroller.getBondCollateralizationRatio(this);

        require(

            vars.hypotheticalCollateralizationRatioMantissa >= vars.thresholdCollateralizationRatioMantissa,

            "ERR_BELOW_COLLATERALIZATION_RATIO"

        );



        

        mintInternal(msg.sender, borrowAmount);



        

        require(balanceSheet.setVaultDebt(this, msg.sender, vars.newDebt), "ERR_BORROW_CALL_SET_VAULT_DEBT");



        

        emit Borrow(msg.sender, borrowAmount);

        emit Transfer(address(this), msg.sender, borrowAmount);



        return true;

    }



    

    function burn(address holder, uint256 burnAmount) external override nonReentrant returns (bool) {

        

        require(msg.sender == address(redemptionPool), "ERR_BURN_NOT_AUTHORIZED");



        

        require(burnAmount > 0, "ERR_BURN_ZERO");



        

        burnInternal(holder, burnAmount);



        return true;

    }



    struct LiquidateBorrowsLocalVars {

        MathError mathErr;

        uint256 collateralizationRatioMantissa;

        uint256 lockedCollateral;

        bool isAccountUnderwater;

    }



    

    function liquidateBorrow(address borrower, uint256 repayAmount)

        external

        override

        isVaultOpen(borrower)

        nonReentrant

        returns (bool)

    {

        LiquidateBorrowsLocalVars memory vars;



        

        require(msg.sender != borrower, "ERR_LIQUIDATE_BORROW_SELF");



        

        require(repayAmount > 0, "ERR_LIQUIDATE_BORROW_ZERO");



        

        require(fintroller.getLiquidateBorrowAllowed(this), "ERR_LIQUIDATE_BORROW_NOT_ALLOWED");



        

        if (isMatured() == false) {

            

            vars.isAccountUnderwater = balanceSheet.isAccountUnderwater(this, borrower);

            require(vars.isAccountUnderwater, "ERR_ACCOUNT_NOT_UNDERWATER");

        }



        

        repayBorrowInternal(msg.sender, borrower, repayAmount);



        

        uint256 clutchableCollateralAmount = balanceSheet.getClutchableCollateral(this, repayAmount);

        require(

            balanceSheet.clutchCollateral(this, msg.sender, borrower, clutchableCollateralAmount),

            "ERR_LIQUIDATE_BORROW_CALL_CLUTCH_COLLATERAL"

        );



        emit LiquidateBorrow(msg.sender, borrower, repayAmount, clutchableCollateralAmount);



        return true;

    }



    

    function mint(address beneficiary, uint256 mintAmount) external override nonReentrant returns (bool) {

        

        require(msg.sender == address(redemptionPool), "ERR_MINT_NOT_AUTHORIZED");



        

        require(mintAmount > 0, "ERR_MINT_ZERO");



        

        mintInternal(beneficiary, mintAmount);



        return true;

    }



    

    function repayBorrow(uint256 repayAmount) external override isVaultOpen(msg.sender) nonReentrant returns (bool) {

        repayBorrowInternal(msg.sender, msg.sender, repayAmount);

        return true;

    }



    

    function repayBorrowBehalf(address borrower, uint256 repayAmount)

        external

        override

        isVaultOpen(borrower)

        nonReentrant

        returns (bool)

    {

        repayBorrowInternal(msg.sender, borrower, repayAmount);

        return true;

    }



    

    function _setFintroller(FintrollerInterface newFintroller) external override onlyAdmin returns (bool) {

        

        newFintroller.isFintroller();



        

        FintrollerInterface oldFintroller = fintroller;

        fintroller = newFintroller;



        emit SetFintroller(admin, oldFintroller, newFintroller);



        return true;

    }



    



    

    function isMatured() internal view returns (bool) {

        return block.timestamp >= expirationTime;

    }



    

    function repayBorrowInternal(

        address payer,

        address borrower,

        uint256 repayAmount

    ) internal {

        

        require(repayAmount > 0, "ERR_REPAY_BORROW_ZERO");



        

        require(fintroller.getRepayBorrowAllowed(this), "ERR_REPAY_BORROW_NOT_ALLOWED");



        

        uint256 debt = balanceSheet.getVaultDebt(this, borrower);

        require(debt >= repayAmount, "ERR_REPAY_BORROW_INSUFFICIENT_DEBT");



        

        require(balanceOf(payer) >= repayAmount, "ERR_REPAY_BORROW_INSUFFICIENT_BALANCE");



        

        burnInternal(payer, repayAmount);



        

        MathError mathErr;

        uint256 newDebt;

        (mathErr, newDebt) = subUInt(debt, repayAmount);

        

        assert(mathErr == MathError.NO_ERROR);



        

        require(balanceSheet.setVaultDebt(this, borrower, newDebt), "ERR_REPAY_BORROW_CALL_SET_VAULT_DEBT");



        

        emit Transfer(payer, address(this), repayAmount);

        emit RepayBorrow(payer, borrower, repayAmount, newDebt);

    }

}

contract RedemptionPool is

    CarefulMath, 

    ReentrancyGuard, 

    RedemptionPoolInterface, 

    Admin, 

    Erc20Recover 

{

    using SafeErc20 for Erc20Interface;



    

    constructor(FintrollerInterface fintroller_, FyTokenInterface fyToken_) Admin() {

        

        fintroller = fintroller_;

        fintroller.isFintroller();



        

        fyToken = fyToken_;

    }



    struct RedeemFyTokensLocalVars {

        MathError mathErr;

        uint256 newUnderlyingTotalSupply;

        uint256 underlyingPrecisionScalar;

        uint256 underlyingAmount;

    }



    

    function redeemFyTokens(uint256 fyTokenAmount) external override nonReentrant returns (bool) {

        RedeemFyTokensLocalVars memory vars;



        

        require(block.timestamp >= fyToken.expirationTime(), "ERR_BOND_NOT_MATURED");



        

        require(fyTokenAmount > 0, "ERR_REDEEM_FYTOKENS_ZERO");



        

        require(fintroller.getRedeemFyTokensAllowed(fyToken), "ERR_REDEEM_FYTOKENS_NOT_ALLOWED");



        

        require(fyTokenAmount <= totalUnderlyingSupply, "ERR_REDEEM_FYTOKENS_INSUFFICIENT_UNDERLYING");



        

        vars.underlyingPrecisionScalar = fyToken.underlyingPrecisionScalar();

        if (vars.underlyingPrecisionScalar != 1) {

            (vars.mathErr, vars.underlyingAmount) = divUInt(fyTokenAmount, vars.underlyingPrecisionScalar);

            require(vars.mathErr == MathError.NO_ERROR, "ERR_REDEEM_FYTOKENS_MATH_ERROR");

        } else {

            vars.underlyingAmount = fyTokenAmount;

        }



        

        (vars.mathErr, vars.newUnderlyingTotalSupply) = subUInt(totalUnderlyingSupply, vars.underlyingAmount);

        assert(vars.mathErr == MathError.NO_ERROR);

        totalUnderlyingSupply = vars.newUnderlyingTotalSupply;



        

        require(fyToken.burn(msg.sender, fyTokenAmount), "ERR_SUPPLY_UNDERLYING_CALL_BURN");



        

        fyToken.underlying().safeTransfer(msg.sender, vars.underlyingAmount);



        emit RedeemFyTokens(msg.sender, fyTokenAmount, vars.underlyingAmount);



        return true;

    }



    struct SupplyUnderlyingLocalVars {

        MathError mathErr;

        uint256 newUnderlyingTotalSupply;

        uint256 underlyingPrecisionScalar;

        uint256 fyTokenAmount;

    }



    

    function supplyUnderlying(uint256 underlyingAmount) external override nonReentrant returns (bool) {

        SupplyUnderlyingLocalVars memory vars;



        

        require(block.timestamp < fyToken.expirationTime(), "ERR_BOND_MATURED");



        

        require(underlyingAmount > 0, "ERR_SUPPLY_UNDERLYING_ZERO");



        

        require(fintroller.getSupplyUnderlyingAllowed(fyToken), "ERR_SUPPLY_UNDERLYING_NOT_ALLOWED");



        

        (vars.mathErr, vars.newUnderlyingTotalSupply) = addUInt(totalUnderlyingSupply, underlyingAmount);

        require(vars.mathErr == MathError.NO_ERROR, "ERR_SUPPLY_UNDERLYING_MATH_ERROR");

        totalUnderlyingSupply = vars.newUnderlyingTotalSupply;



        

        vars.underlyingPrecisionScalar = fyToken.underlyingPrecisionScalar();

        if (vars.underlyingPrecisionScalar != 1) {

            (vars.mathErr, vars.fyTokenAmount) = mulUInt(underlyingAmount, vars.underlyingPrecisionScalar);

            require(vars.mathErr == MathError.NO_ERROR, "ERR_SUPPLY_UNDERLYING_MATH_ERROR");

        } else {

            vars.fyTokenAmount = underlyingAmount;

        }



        

        require(fyToken.mint(msg.sender, vars.fyTokenAmount), "ERR_SUPPLY_UNDERLYING_CALL_MINT");



        

        fyToken.underlying().safeTransferFrom(msg.sender, address(this), underlyingAmount);



        emit SupplyUnderlying(msg.sender, underlyingAmount, vars.fyTokenAmount);



        return true;

    }

}
