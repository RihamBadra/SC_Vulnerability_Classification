pragma solidity 0.5.15;

library Addresses {

    function isContract(address account) internal view returns (bool) {

        uint256 size;

        

        assembly {

            size := extcodesize(account)

        }

        return size > 0;

    }



    function performEthTransfer(address recipient, uint256 amount) internal {

        

        (bool success, ) = recipient.call.value(amount)(""); 

        require(success, "ETH_TRANSFER_FAILED");

    }



    

    function safeTokenContractCall(address tokenAddress, bytes memory callData) internal {

        require(isContract(tokenAddress), "BAD_TOKEN_ADDRESS");

        

        

        (bool success, bytes memory returndata) = address(tokenAddress).call(callData);

        require(success, string(returndata));



        if (returndata.length > 0) {

            require(abi.decode(returndata, (bool)), "TOKEN_OPERATION_FAILED");

        }

    }

}

library StarkExTypes {



    

    

    

    

    

    

    

    struct ApprovalChainData {

        address[] list;

        

        

        

        mapping (address => uint256) unlockedForRemovalTime;

    }



}

contract GovernanceStorage {



    struct GovernanceInfoStruct {

        mapping (address => bool) effectiveGovernors;

        address candidateGovernor;

        bool initialized;

    }



    

    mapping (string => GovernanceInfoStruct) internal governanceInfo;

}

contract IFactRegistry {

    

    function isValid(bytes32 fact)

        external view

        returns(bool);

}

contract IQueryableFactRegistry is IFactRegistry {



    

    function hasRegisteredFact()

        external view

        returns(bool);



}

contract Identity {



    

    function identify()

        external pure

        returns(string memory);

}

contract LibConstants {

    

    

    

    



    

    

    uint256 public constant DEPOSIT_CANCEL_DELAY = 1 days;



    

    

    uint256 public constant FREEZE_GRACE_PERIOD = 7 days;



    

    

    uint256 public constant UNFREEZE_DELAY = 365 days;



    

    uint256 public constant MAX_VERIFIER_COUNT = uint256(64);



    

    uint256 public constant VERIFIER_REMOVAL_DELAY = FREEZE_GRACE_PERIOD + (21 days);



    uint256 constant MAX_VAULT_ID = 2**31 - 1;

    uint256 constant MAX_QUANTUM = 2**128 - 1;



    address constant ZERO_ADDRESS = address(0x0);



    uint256 constant K_MODULUS =

    0x800000000000011000000000000000000000000000000000000000000000001;

    uint256 constant K_BETA =

    0x6f21413efbe40de150e596d72f7a8c5609ad26c15c915c1f4cdfcb99cee9e89;



    uint256 constant EXPIRATION_TIMESTAMP_BITS = 22;



    uint256 internal constant MASK_250 =

    0x03FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;

    uint256 internal constant MASK_240 =

    0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;

    uint256 internal constant MINTABLE_ASSET_ID_FLAG = 1<<250;

}

contract MAcceptModifications {



    function acceptDeposit(

        uint256 starkKey,

        uint256 vaultId,

        uint256 assetId,

        uint256 quantizedAmount

    )

        internal;



    function allowWithdrawal(

        uint256 starkKey,

        uint256 assetId,

        uint256 quantizedAmount

    )

        internal;



    function acceptWithdrawal(

        uint256 starkKey,

        uint256 assetId,

        uint256 quantizedAmount

    )

        internal;



    function clearFullWithdrawalRequest(

        uint256 starkKey,

        uint256 vaultId

    )

        internal;

}

contract MApprovalChain {

    uint256 constant ENTRY_NOT_FOUND = uint256(~0);



    

    function addEntry(

        StarkExTypes.ApprovalChainData storage chain,

        address entry, uint256 maxLength, string memory identifier)

        internal;



    

    function findEntry(address[] storage list, address entry)

        internal view returns (uint256);



    

    function safeFindEntry(address[] storage list, address entry)

        internal view returns (uint256 idx);



    

    function announceRemovalIntent(

        StarkExTypes.ApprovalChainData storage chain, address entry, uint256 removalDelay)

        internal;



    

    function removeEntry(StarkExTypes.ApprovalChainData storage chain, address entry)

        internal;

}

contract MFreezable {

    

    modifier notFrozen()

    {

        

        

        revert("UNIMPLEMENTED");

        _;

    }



    

    modifier onlyFrozen()

    {

        

        

        revert("UNIMPLEMENTED");

        _;

    }



    

    function freeze()

        internal;



    

    function isFrozen()

        external view

        returns (bool);



}

contract MGovernance {

    

    modifier onlyGovernance()

    {

        

        

        revert("UNIMPLEMENTED");

        _;

    }

}

contract MKeyGetters {

    

    function getEthKey(uint256 starkKey) public view returns (address ethKey);



    function isMsgSenderStarkKeyOwner(uint256 starkKey) internal view returns (bool);



    

    modifier isSenderStarkKey(uint256 starkKey)

    {

        

        

        revert("UNIMPLEMENTED");

        _;

    }

}

contract MOperator {



    modifier onlyOperator()

    {

        

        

        revert("UNIMPLEMENTED");

        _;

    }



    function registerOperator(address newOperator)

        external;



    function unregisterOperator(address removedOperator)

        external;



}

contract MStateRoot {

    function getVaultRoot() 

        public view

        returns (uint256 root);



    function getVaultTreeHeight() 

        public view

        returns (uint256 height);

}

contract MTokenQuantization {

    function fromQuantized(uint256 presumedAssetType, uint256 quantizedAmount)

        internal

        view

        returns (uint256 amount);



    

    function getQuantum(uint256 presumedAssetType)

        public

        view

        returns (uint256 quantum);



    function toQuantized(uint256 presumedAssetType, uint256 amount)

        internal

        view

        returns (uint256 quantizedAmount);

}

contract ProxyStorage is GovernanceStorage {



    

    

    

    mapping (address => bytes32) internal initializationHash;



    

    mapping (address => uint256) internal enabledTime;



    

    

    

    mapping (bytes32 => bool) internal initialized;

}

contract PublicInputOffsets {

    

    uint256 internal constant PUB_IN_INITIAL_VAULT_ROOT_OFFSET = 0;

    uint256 internal constant PUB_IN_FINAL_VAULT_ROOT_OFFSET = 1;

    uint256 internal constant PUB_IN_INITIAL_ORDER_ROOT_OFFSET = 2;

    uint256 internal constant PUB_IN_FINAL_ORDER_ROOT_OFFSET = 3;

    uint256 internal constant PUB_IN_GLOBAL_EXPIRATION_TIMESTAMP_OFFSET = 4;

    uint256 internal constant PUB_IN_VAULT_TREE_HEIGHT_OFFSET = 5;

    uint256 internal constant PUB_IN_ORDER_TREE_HEIGHT_OFFSET = 6;

    uint256 internal constant PUB_IN_N_MODIFICATIONS_OFFSET = 7;

    uint256 internal constant PUB_IN_N_CONDITIONAL_TRANSFERS_OFFSET = 8;

    uint256 internal constant PUB_IN_TRANSACTIONS_DATA_OFFSET = 9;



    uint256 internal constant PUB_IN_N_WORDS_PER_MODIFICATION = 3;

    uint256 internal constant PUB_IN_N_WORDS_PER_CONDITIONAL_TRANSFER = 1;



    

    uint256 internal constant APP_DATA_BATCH_ID_OFFSET = 0;

    uint256 internal constant APP_DATA_PREVIOUS_BATCH_ID_OFFSET = 1;

    uint256 internal constant APP_DATA_TRANSACTIONS_DATA_OFFSET = 2;



    uint256 internal constant APP_DATA_N_WORDS_PER_CONDITIONAL_TRANSFER = 2;

}

contract SubContractor is Identity {



    function initialize(bytes calldata data)

        external;



    function initializerSize()

        external view

        returns(uint256);



}

contract Governance is GovernanceStorage, MGovernance {

    event LogNominatedGovernor(address nominatedGovernor);

    event LogNewGovernorAccepted(address acceptedGovernor);

    event LogRemovedGovernor(address removedGovernor);

    event LogNominationCancelled();



    address internal constant ZERO_ADDRESS = address(0x0);



    

    function getGovernanceTag()

        internal

        view

        returns (string memory);



    

    function contractGovernanceInfo()

        internal

        view

        returns (GovernanceInfoStruct storage) {

        string memory tag = getGovernanceTag();

        GovernanceInfoStruct storage gub = governanceInfo[tag];

        require(gub.initialized, "NOT_INITIALIZED");

        return gub;

    }



    

    function initGovernance()

        internal

    {

        string memory tag = getGovernanceTag();

        GovernanceInfoStruct storage gub = governanceInfo[tag];

        require(!gub.initialized, "ALREADY_INITIALIZED");

        gub.initialized = true;  

        

        addGovernor(msg.sender);

    }



    modifier onlyGovernance()

    {

        require(isGovernor(msg.sender), "ONLY_GOVERNANCE");

        _;

    }



    function isGovernor(address testGovernor)

        internal view

        returns (bool addressIsGovernor){

        GovernanceInfoStruct storage gub = contractGovernanceInfo();

        addressIsGovernor = gub.effectiveGovernors[testGovernor];

    }



    

    function cancelNomination() internal onlyGovernance() {

        GovernanceInfoStruct storage gub = contractGovernanceInfo();

        gub.candidateGovernor = ZERO_ADDRESS;

        emit LogNominationCancelled();

    }



    function nominateNewGovernor(address newGovernor) internal onlyGovernance() {

        GovernanceInfoStruct storage gub = contractGovernanceInfo();

        require(!isGovernor(newGovernor), "ALREADY_GOVERNOR");

        gub.candidateGovernor = newGovernor;

        emit LogNominatedGovernor(newGovernor);

    }



    

    function addGovernor(address newGovernor) private {

        require(!isGovernor(newGovernor), "ALREADY_GOVERNOR");

        GovernanceInfoStruct storage gub = contractGovernanceInfo();

        gub.effectiveGovernors[newGovernor] = true;

    }



    function acceptGovernance()

        internal

    {

        

        GovernanceInfoStruct storage gub = contractGovernanceInfo();

        require(msg.sender == gub.candidateGovernor, "ONLY_CANDIDATE_GOVERNOR");



        

        addGovernor(gub.candidateGovernor);

        gub.candidateGovernor = ZERO_ADDRESS;



        

        emit LogNewGovernorAccepted(msg.sender);

    }



    

    function removeGovernor(address governorForRemoval) internal onlyGovernance() {

        require(msg.sender != governorForRemoval, "GOVERNOR_SELF_REMOVE");

        GovernanceInfoStruct storage gub = contractGovernanceInfo();

        require (isGovernor(governorForRemoval), "NOT_GOVERNOR");

        gub.effectiveGovernors[governorForRemoval] = false;

        emit LogRemovedGovernor(governorForRemoval);

    }

}

contract MainGovernance is Governance {



    

    string public constant MAIN_GOVERNANCE_INFO_TAG = "StarkEx.Main.2019.GovernorsInformation";



    function getGovernanceTag()

        internal

        view

        returns (string memory tag) {

        tag = MAIN_GOVERNANCE_INFO_TAG;

    }



    function mainIsGovernor(address testGovernor) external view returns (bool) {

        return isGovernor(testGovernor);

    }



    function mainNominateNewGovernor(address newGovernor) external {

        nominateNewGovernor(newGovernor);

    }



    function mainRemoveGovernor(address governorForRemoval) external {

        removeGovernor(governorForRemoval);

    }



    function mainAcceptGovernance()

        external

    {

        acceptGovernance();

    }



    function mainCancelNomination() external {

        cancelNomination();

    }



}

contract MainStorage is ProxyStorage {



    IFactRegistry escapeVerifier_;



    

    bool stateFrozen;                               



    

    uint256 unFreezeTime;                           



    

    

    mapping (uint256 => mapping (uint256 => mapping (uint256 => uint256))) pendingDeposits;



    

    

    mapping (uint256 => mapping (uint256 => mapping (uint256 => uint256))) cancellationRequests;



    

    

    mapping (uint256 => mapping (uint256 => uint256)) pendingWithdrawals;



    

    mapping (uint256 => bool) escapesUsed;



    

    uint256 escapesUsedCount;                       



    

    

    mapping (uint256 => mapping (uint256 => uint256)) fullWithdrawalRequests;



    

    uint256 sequenceNumber;                         



    

    uint256 vaultRoot;                              

    uint256 vaultTreeHeight;                        



    

    uint256 orderRoot;                              

    uint256 orderTreeHeight;                        



    

    mapping (address => bool) tokenAdmins;



    

    mapping (address => bool) userAdmins;



    

    mapping (address => bool) operators;



    

    mapping (uint256 => bytes) assetTypeToAssetInfo;    



    

    mapping (uint256 => bool) registeredAssetType;      



    

    mapping (uint256 => uint256) assetTypeToQuantum;    



    

    mapping (address => uint256) starkKeys_DEPRECATED;  



    

    mapping (uint256 => address) ethKeys;               



    

    StarkExTypes.ApprovalChainData verifiersChain;

    StarkExTypes.ApprovalChainData availabilityVerifiersChain;



    

    uint256 lastBatchId;                            



    

    mapping(uint256 => address) subContracts;       

}

contract Operator is MainStorage, MGovernance, MOperator {

    event LogOperatorAdded(address operator);

    event LogOperatorRemoved(address operator);



    function initialize()

        internal

    {

        operators[msg.sender] = true;

        emit LogOperatorAdded(msg.sender);

    }



    modifier onlyOperator()

    {

        require(operators[msg.sender], "ONLY_OPERATOR");

        _;

    }



    function registerOperator(address newOperator)

        external

        onlyGovernance

    {

        operators[newOperator] = true;

        emit LogOperatorAdded(newOperator);

    }



    function unregisterOperator(address removedOperator)

        external

        onlyGovernance

    {

        operators[removedOperator] = false;

        emit LogOperatorRemoved(removedOperator);

    }



    function isOperator(address testedOperator) external view returns (bool) {

        return operators[testedOperator];

    }

}

contract StateRoot is MainStorage, MStateRoot

{



    function initialize (

        uint256 initialSequenceNumber,

        uint256 initialVaultRoot,

        uint256 initialOrderRoot,

        uint256 initialVaultTreeHeight,

        uint256 initialOrderTreeHeight

    )

        internal

    {

        sequenceNumber = initialSequenceNumber;

        vaultRoot = initialVaultRoot;

        orderRoot = initialOrderRoot;

        vaultTreeHeight = initialVaultTreeHeight;

        orderTreeHeight = initialOrderTreeHeight;

    }



    function getVaultRoot()

        public view

        returns (uint256 root)

    {

        root = vaultRoot;

    }



    function getVaultTreeHeight()

        public view

        returns (uint256 height) {

        height = vaultTreeHeight;

    }



    function getOrderRoot()

        external view

        returns (uint256 root)

    {

        root = orderRoot;

    }



    function getOrderTreeHeight()

        external view

        returns (uint256 height) {

        height = orderTreeHeight;

    }



    function getSequenceNumber()

        external view

        returns (uint256 seq)

    {

        seq = sequenceNumber;

    }



    function getLastBatchId()

        external view

        returns (uint256 batchId)

    {

        batchId = lastBatchId;

    }

}

contract TokenQuantization is MainStorage, MTokenQuantization {



    function fromQuantized(uint256 presumedAssetType, uint256 quantizedAmount)

        internal view returns (uint256 amount) {

        uint256 quantum = getQuantum(presumedAssetType);

        amount = quantizedAmount * quantum;

        require(amount / quantum == quantizedAmount, "DEQUANTIZATION_OVERFLOW");

    }



    function getQuantum(uint256 presumedAssetType) public view returns (uint256 quantum) {

        if (!registeredAssetType[presumedAssetType]) {

            

            quantum = 1;

        } else {

            

            quantum = assetTypeToQuantum[presumedAssetType];

        }

    }



    function toQuantized(uint256 presumedAssetType, uint256 amount)

        internal view returns (uint256 quantizedAmount) {

        uint256 quantum = getQuantum(presumedAssetType);

        require(amount % quantum == 0, "INVALID_AMOUNT");

        quantizedAmount = amount / quantum;

    }

}

contract Verifiers is MainStorage, LibConstants, MApprovalChain {

    function getRegisteredVerifiers()

        external view

        returns (address[] memory _verifers)

    {

        return verifiersChain.list;

    }



    function isVerifier(address verifierAddress)

        external view

        returns (bool)

    {

        return findEntry(verifiersChain.list, verifierAddress) != ENTRY_NOT_FOUND;

    }



    function registerVerifier(address verifier, string calldata identifier)

        external

    {

        addEntry(verifiersChain, verifier, MAX_VERIFIER_COUNT, identifier);

    }



    function announceVerifierRemovalIntent(address verifier)

        external

    {

        announceRemovalIntent(verifiersChain, verifier, VERIFIER_REMOVAL_DELAY);

    }



    function removeVerifier(address verifier)

        external

    {

        removeEntry(verifiersChain, verifier);

    }

}

contract VerifyFactChain is MainStorage {



    function verifyFact(

        StarkExTypes.ApprovalChainData storage chain, bytes32 fact, string memory noVerifiersErrorMessage,

        string memory invalidFactErrorMessage)

        internal view

    {

        address[] storage list = chain.list;

        uint256 n_entries = list.length;

        require(n_entries > 0, noVerifiersErrorMessage);

        for (uint256 i = 0; i < n_entries; i++) {

            

            require(IFactRegistry(list[i]).isValid(fact), invalidFactErrorMessage);

        }

    }

}

contract AcceptModifications is

    MainStorage,

    LibConstants,

    MAcceptModifications,

    MTokenQuantization

{

    event LogWithdrawalAllowed(

        uint256 starkKey,

        uint256 assetType,

        uint256 nonQuantizedAmount,

        uint256 quantizedAmount

    );



    event LogNftWithdrawalAllowed(uint256 starkKey, uint256 assetId);



    event LogMintableWithdrawalAllowed(

        uint256 starkKey,

        uint256 assetId,

        uint256 quantizedAmount

    );



    

    function acceptDeposit(

        uint256 starkKey,

        uint256 vaultId,

        uint256 assetId,

        uint256 quantizedAmount

    ) internal {

        

        require(

            pendingDeposits[starkKey][assetId][vaultId] >= quantizedAmount,

            "DEPOSIT_INSUFFICIENT"

        );



        

        pendingDeposits[starkKey][assetId][vaultId] -= quantizedAmount;

    }



    

    function allowWithdrawal(

        uint256 starkKey,

        uint256 assetId,

        uint256 quantizedAmount

    )

        internal

    {

        

        uint256 withdrawal = pendingWithdrawals[starkKey][assetId];



        

        withdrawal += quantizedAmount;

        require(withdrawal >= quantizedAmount, "WITHDRAWAL_OVERFLOW");



        

        pendingWithdrawals[starkKey][assetId] = withdrawal;



        

        uint256 presumedAssetType = assetId;

        if (registeredAssetType[presumedAssetType]) {

            emit LogWithdrawalAllowed(

                starkKey,

                presumedAssetType,

                fromQuantized(presumedAssetType, quantizedAmount),

                quantizedAmount

            );

        } else if(assetId == ((assetId & MASK_240) | MINTABLE_ASSET_ID_FLAG)) {

            emit LogMintableWithdrawalAllowed(

                starkKey,

                assetId,

                quantizedAmount

            );

        }

        else {

            

            require(withdrawal <= 1, "INVALID_NFT_AMOUNT");

            emit LogNftWithdrawalAllowed(starkKey, assetId);

        }

    }





    

    function acceptWithdrawal(

        uint256 starkKey,

        uint256 assetId,

        uint256 quantizedAmount

    ) internal {

        allowWithdrawal(starkKey, assetId, quantizedAmount);

    }



    

    function clearFullWithdrawalRequest(

        uint256 starkKey,

        uint256 vaultId

    )

        internal

    {

        

        fullWithdrawalRequests[starkKey][vaultId] = 0;  

    }

}

contract ApprovalChain is MainStorage, MApprovalChain, MGovernance, MFreezable {



    using Addresses for address;



    function addEntry(

        StarkExTypes.ApprovalChainData storage chain,

        address entry, uint256 maxLength, string memory identifier)

        internal

        onlyGovernance()

        notFrozen()

    {

        address[] storage list = chain.list;

        require(entry.isContract(), "ADDRESS_NOT_CONTRACT");

        bytes32 hash_real = keccak256(abi.encodePacked(Identity(entry).identify()));

        bytes32 hash_identifier = keccak256(abi.encodePacked(identifier));

        require(hash_real == hash_identifier, "UNEXPECTED_CONTRACT_IDENTIFIER");

        require(list.length < maxLength, "CHAIN_AT_MAX_CAPACITY");

        require(findEntry(list, entry) == ENTRY_NOT_FOUND, "ENTRY_ALREADY_EXISTS");



        

        

        require(

            list.length == 0 || IQueryableFactRegistry(entry).hasRegisteredFact(),

            "ENTRY_NOT_ENABLED");

        chain.list.push(entry);

        chain.unlockedForRemovalTime[entry] = 0;

    }



    function findEntry(address[] storage list, address entry)

        internal view returns (uint256)

    {

        uint256 n_entries = list.length;

        for (uint256 i = 0; i < n_entries; i++) {

            if (list[i] == entry) {

                return i;

            }

        }



        return ENTRY_NOT_FOUND;

    }



    function safeFindEntry(address[] storage list, address entry)

        internal view returns (uint256 idx)

    {

        idx = findEntry(list, entry);



        require(idx != ENTRY_NOT_FOUND, "ENTRY_DOES_NOT_EXIST");

    }



    function announceRemovalIntent(

        StarkExTypes.ApprovalChainData storage chain, address entry, uint256 removalDelay)

        internal

        onlyGovernance()

        notFrozen()

    {

        safeFindEntry(chain.list, entry);

        require(now + removalDelay > now, "INVALID_REMOVAL_DELAY"); 

        

        chain.unlockedForRemovalTime[entry] = now + removalDelay;

    }



    function removeEntry(StarkExTypes.ApprovalChainData storage chain, address entry)

        internal

        onlyGovernance()

        notFrozen()

    {

        address[] storage list = chain.list;

        

        uint256 idx = safeFindEntry(list, entry);

        uint256 unlockedForRemovalTime = chain.unlockedForRemovalTime[entry];



        

        require(unlockedForRemovalTime > 0, "REMOVAL_NOT_ANNOUNCED");

        

        require(now >= unlockedForRemovalTime, "REMOVAL_NOT_ENABLED_YET"); 



        uint256 n_entries = list.length;



        

        require(n_entries > 1, "LAST_ENTRY_MAY_NOT_BE_REMOVED");



        if (idx != n_entries - 1) {

            list[idx] = list[n_entries - 1];

        }

        list.pop();

        delete chain.unlockedForRemovalTime[entry];

    }

}

contract AvailabilityVerifiers is MainStorage, LibConstants, MApprovalChain {

    function getRegisteredAvailabilityVerifiers()

        external view

        returns (address[] memory _verifers)

    {

        return availabilityVerifiersChain.list;

    }



    function isAvailabilityVerifier(address verifierAddress)

        external view

        returns (bool)

    {

        return findEntry(availabilityVerifiersChain.list, verifierAddress) != ENTRY_NOT_FOUND;

    }



    function registerAvailabilityVerifier(address verifier, string calldata identifier)

        external

    {

        addEntry(availabilityVerifiersChain, verifier, MAX_VERIFIER_COUNT, identifier);

    }



    function announceAvailabilityVerifierRemovalIntent(address verifier)

        external

    {

        announceRemovalIntent(availabilityVerifiersChain, verifier, VERIFIER_REMOVAL_DELAY);

    }



    function removeAvailabilityVerifier(address verifier)

        external

    {

        removeEntry(availabilityVerifiersChain, verifier);

    }

}

contract Escapes is MainStorage, MAcceptModifications, MFreezable, MStateRoot {

    function initialize (

        IFactRegistry escapeVerifier

    ) internal

    {

        escapeVerifier_ = escapeVerifier;

    }

    

    function escape(

        uint256 starkKey,

        uint256 vaultId,

        uint256 assetId,

        uint256 quantizedAmount

    )

        external

        onlyFrozen()

    {

        require(!escapesUsed[vaultId], "ESCAPE_ALREADY_USED");



        

        escapesUsed[vaultId] = true;

        escapesUsedCount += 1;



        bytes32 claimHash = keccak256(

            abi.encode(

        starkKey, assetId, quantizedAmount, getVaultRoot(), getVaultTreeHeight(), vaultId));

        require(escapeVerifier_.isValid(claimHash), "ESCAPE_LACKS_PROOF");



        allowWithdrawal(starkKey, assetId, quantizedAmount);

    }

}

contract Freezable is MainStorage, LibConstants, MGovernance, MFreezable {

    event LogFrozen();

    event LogUnFrozen();



    modifier notFrozen()

    {

        require(!stateFrozen, "STATE_IS_FROZEN");

        _;

    }



    modifier onlyFrozen()

    {

        require(stateFrozen, "STATE_NOT_FROZEN");

        _;

    }



    function isFrozen()

        external view

        returns (bool frozen) {

        frozen = stateFrozen;

    }



    function freeze()

        internal

        notFrozen()

    {

        

        unFreezeTime = now + UNFREEZE_DELAY;



        

        stateFrozen = true;



        

        emit LogFrozen();

    }



    function unFreeze()

        external

        onlyFrozen()

        onlyGovernance()

    {

        

        require(now >= unFreezeTime, "UNFREEZE_NOT_ALLOWED_YET");  



        

        stateFrozen = false;



        

        vaultRoot += 1;

        orderRoot += 1;



        

        emit LogUnFrozen();

    }



}

contract KeyGetters is MainStorage, MKeyGetters {

    function getEthKey(uint256 starkKey) public view returns (address ethKey) {

        

        ethKey = ethKeys[starkKey];

        require(ethKey != address(0x0), "USER_UNREGISTERED");

    }



    function isMsgSenderStarkKeyOwner(uint256 starkKey) internal view returns (bool) {

        return msg.sender == getEthKey(starkKey);

    }



    modifier isSenderStarkKey(uint256 starkKey) {

        

        require(isMsgSenderStarkKeyOwner(starkKey), "MISMATCHING_STARK_ETH_KEYS");

        _;

    }

}

contract UpdateState is

    MainStorage,

    LibConstants,

    VerifyFactChain,

    MAcceptModifications,

    MFreezable,

    MOperator,

    PublicInputOffsets

{



    event LogRootUpdate(

        uint256 sequenceNumber,

        uint256 batchId,

        uint256 vaultRoot,

        uint256 orderRoot

    );



    function updateState(

        uint256[] calldata publicInput,

        uint256[] calldata applicationData

    )

        external

        notFrozen()

        onlyOperator()

    {

        require(

            publicInput.length >= PUB_IN_TRANSACTIONS_DATA_OFFSET,

            "publicInput does not contain all required fields.");

        require(

            publicInput[PUB_IN_FINAL_VAULT_ROOT_OFFSET] < K_MODULUS,

            "New vault root >= PRIME.");

        require(

            publicInput[PUB_IN_FINAL_ORDER_ROOT_OFFSET] < K_MODULUS,

            "New order root >= PRIME.");

        require(

            lastBatchId == 0 ||

            applicationData[APP_DATA_PREVIOUS_BATCH_ID_OFFSET] == lastBatchId,

            "WRONG_PREVIOUS_BATCH_ID");



        

        require(

            publicInput[PUB_IN_GLOBAL_EXPIRATION_TIMESTAMP_OFFSET] < 2**EXPIRATION_TIMESTAMP_BITS,

            "Global expiration timestamp is out of range.");



        require( 

            

            publicInput[PUB_IN_GLOBAL_EXPIRATION_TIMESTAMP_OFFSET] > now / 3600,

            "Timestamp of the current block passed the threshold for the transaction batch.");



        bytes32 publicInputFact = keccak256(abi.encodePacked(publicInput));



        verifyFact(

            verifiersChain,

            publicInputFact,

            "NO_STATE_TRANSITION_VERIFIERS",

            "NO_STATE_TRANSITION_PROOF");



        bytes32 availabilityFact = keccak256(

            abi.encodePacked(

            publicInput[PUB_IN_FINAL_VAULT_ROOT_OFFSET],

            publicInput[PUB_IN_VAULT_TREE_HEIGHT_OFFSET],

            publicInput[PUB_IN_FINAL_ORDER_ROOT_OFFSET],

            publicInput[PUB_IN_ORDER_TREE_HEIGHT_OFFSET],

            sequenceNumber + 1));



        verifyFact(

            availabilityVerifiersChain,

            availabilityFact,

            "NO_AVAILABILITY_VERIFIERS",

            "NO_AVAILABILITY_PROOF");



        performUpdateState(publicInput, applicationData);

    }



    function performUpdateState(

        uint256[] memory publicInput,

        uint256[] memory applicationData

    )

        internal

    {

        rootUpdate(

            publicInput[PUB_IN_INITIAL_VAULT_ROOT_OFFSET],

            publicInput[PUB_IN_FINAL_VAULT_ROOT_OFFSET],

            publicInput[PUB_IN_INITIAL_ORDER_ROOT_OFFSET],

            publicInput[PUB_IN_FINAL_ORDER_ROOT_OFFSET],

            publicInput[PUB_IN_VAULT_TREE_HEIGHT_OFFSET],

            publicInput[PUB_IN_ORDER_TREE_HEIGHT_OFFSET],

            applicationData[APP_DATA_BATCH_ID_OFFSET]

        );

        sendModifications(publicInput, applicationData);

    }



    function rootUpdate(

        uint256 oldVaultRoot,

        uint256 newVaultRoot,

        uint256 oldOrderRoot,

        uint256 newOrderRoot,

        uint256 vaultTreeHeightSent,

        uint256 orderTreeHeightSent,

        uint256 batchId

    )

        internal

        notFrozen()

    {

        

        require(oldVaultRoot == vaultRoot, "VAULT_ROOT_INCORRECT");

        require(oldOrderRoot == orderRoot, "ORDER_ROOT_INCORRECT");



        

        require(vaultTreeHeight == vaultTreeHeightSent, "VAULT_HEIGHT_INCORRECT");

        require(orderTreeHeight == orderTreeHeightSent, "ORDER_HEIGHT_INCORRECT");



        

        vaultRoot = newVaultRoot;

        orderRoot = newOrderRoot;

        sequenceNumber = sequenceNumber + 1;

        lastBatchId = batchId;



        

        emit LogRootUpdate(sequenceNumber, batchId, vaultRoot, orderRoot);

    }



    function sendModifications(

        uint256[] memory publicInput,

        uint256[] memory applicationData

    ) private {

        uint256 nModifications = publicInput[PUB_IN_N_MODIFICATIONS_OFFSET];

        uint256 nCondTransfers = publicInput[PUB_IN_N_CONDITIONAL_TRANSFERS_OFFSET];



        

        require(nModifications < 2**64, "Invalid number of modifications.");

        require(nCondTransfers < 2**64, "Invalid number of conditional transfers.");

        require(

            publicInput.length == PUB_IN_TRANSACTIONS_DATA_OFFSET +

                                  PUB_IN_N_WORDS_PER_MODIFICATION * nModifications +

                                  PUB_IN_N_WORDS_PER_CONDITIONAL_TRANSFER * nCondTransfers,

            "publicInput size is inconsistent with expected transactions.");

        require(

            applicationData.length == APP_DATA_TRANSACTIONS_DATA_OFFSET +

                                      APP_DATA_N_WORDS_PER_CONDITIONAL_TRANSFER * nCondTransfers,

            "applicationData size is inconsistent with expected transactions.");



        uint256 offsetPubInput = PUB_IN_TRANSACTIONS_DATA_OFFSET;

        uint256 offsetAppData = APP_DATA_TRANSACTIONS_DATA_OFFSET;



        for (uint256 i = 0; i < nModifications; i++) {

            uint256 starkKey = publicInput[offsetPubInput];

            uint256 assetId = publicInput[offsetPubInput + 1];



            require(starkKey < K_MODULUS, "Stark key >= PRIME");

            require(assetId < K_MODULUS, "Asset id >= PRIME");



            uint256 actionParams = publicInput[offsetPubInput + 2];

            require ((actionParams >> 96) == 0, "Unsupported modification action field.");



            

            int256 balance_diff = int256((actionParams & ((1 << 64) - 1)) - (1 << 63));

            uint256 vaultId = (actionParams >> 64) & ((1 << 31) - 1);



            if (balance_diff > 0) {

                

                acceptDeposit(starkKey, vaultId, assetId, uint256(balance_diff));

            } else if (balance_diff < 0) {

                

                acceptWithdrawal(starkKey, assetId, uint256(-balance_diff));

            }



            if ((actionParams & (1 << 95)) != 0) {

                clearFullWithdrawalRequest(starkKey, vaultId);

            }



            offsetPubInput += PUB_IN_N_WORDS_PER_MODIFICATION;

        }



        

        for (uint256 i = 0; i < nCondTransfers; i++) {

            address factRegistryAddress = address(applicationData[offsetAppData]);

            bytes32 condTransferFact = bytes32(applicationData[offsetAppData + 1]);

            uint256 condition = publicInput[offsetPubInput];



            

            require(

                condition ==

                    uint256(keccak256(abi.encodePacked(factRegistryAddress, condTransferFact))) &

                    MASK_250,

                "Condition mismatch.");

            (bool success, bytes memory returndata) = 

            factRegistryAddress.staticcall(

                abi.encodeWithSignature("isValid(bytes32)",condTransferFact));

            require(success && returndata.length == 32, "BAD_FACT_REGISTRY_CONTRACT");

            require(

                abi.decode(returndata, (bool)),

                "Condition for the conditional transfer was not met.");



            offsetPubInput += PUB_IN_N_WORDS_PER_CONDITIONAL_TRANSFER;

            offsetAppData += APP_DATA_N_WORDS_PER_CONDITIONAL_TRANSFER;

        }

    }

}

contract AllVerifiers is

    SubContractor,

    MainGovernance,

    Freezable,

    ApprovalChain,

    AvailabilityVerifiers,

    Verifiers

{

    function initialize(bytes calldata )

        external {

        revert("NOT_IMPLEMENTED");

    }



    function initializerSize()

        external view

        returns(uint256){

        return 0;

    }



    function identify()

        external pure

        returns(string memory){

        return "StarkWare_AllVerifiers_2020_1";

    }

}

contract StarkExState is

    MainGovernance,

    SubContractor,

    Operator,

    Freezable,

    AcceptModifications,

    TokenQuantization,

    StateRoot,

    Escapes,

    UpdateState,

    KeyGetters

{

    uint256 constant INITIALIZER_SIZE = 192;  



    

    function initialize(bytes calldata data) external {



        

        

        require(vaultRoot == 0, "STATE_ALREADY_INITIALIZED");

        require(vaultTreeHeight == 0, "STATE_ALREADY_INITIALIZED");

        require(orderRoot == 0, "STATE_ALREADY_INITIALIZED");

        require(orderTreeHeight == 0, "STATE_ALREADY_INITIALIZED");



        require(data.length == INITIALIZER_SIZE, "INCORRECT_INIT_DATA_SIZE_192");

        IFactRegistry escapeVerifier;

        uint256 initialSequenceNumber;

        uint256 initialVaultRoot;

        uint256 initialOrderRoot;

        uint256 initialVaultTreeHeight;

        uint256 initialOrderTreeHeight;

        (

            escapeVerifier,

            initialSequenceNumber,

            initialVaultRoot,

            initialOrderRoot,

            initialVaultTreeHeight,

            initialOrderTreeHeight

        ) = abi.decode(data, (IFactRegistry, uint256, uint256, uint256, uint256, uint256));



        initGovernance();

        Operator.initialize();

        StateRoot.initialize(

            initialSequenceNumber,

            initialVaultRoot,

            initialOrderRoot,

            initialVaultTreeHeight,

            initialOrderTreeHeight

        );

        Escapes.initialize(escapeVerifier);

    }



    

    function initializerSize() external view returns (uint256) {

        return INITIALIZER_SIZE;

    }



    function identify() external pure returns (string memory) {

        return "StarkWare_StarkExState_2020_1";

    }

}
