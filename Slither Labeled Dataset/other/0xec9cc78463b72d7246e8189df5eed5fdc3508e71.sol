pragma solidity 0.6.12;

library Address {

    

    function isContract(address account) internal view returns (bool) {

        

        

        

        bytes32 codehash;

        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;

        

        assembly { codehash := extcodehash(account) }

        return (codehash != accountHash && codehash != 0x0);

    }



    

    function sendValue(address payable recipient, uint256 amount) internal {

        require(address(this).balance >= amount, "Address: insufficient balance");



        

        (bool success, ) = recipient.call{ value: amount }("");

        require(success, "Address: unable to send value, recipient may have reverted");

    }



    

    function functionCall(address target, bytes memory data) internal returns (bytes memory) {

      return functionCall(target, data, "Address: low-level call failed");

    }



    

    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {

        return _functionCallWithValue(target, data, 0, errorMessage);

    }



    

    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {

        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");

    }



    

    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {

        require(address(this).balance >= value, "Address: insufficient balance for call");

        return _functionCallWithValue(target, data, value, errorMessage);

    }



    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {

        require(isContract(target), "Address: call to non-contract");



        

        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);

        if (success) {

            return returndata;

        } else {

            

            if (returndata.length > 0) {

                



                

                assembly {

                    let returndata_size := mload(returndata)

                    revert(add(32, returndata), returndata_size)

                }

            } else {

                revert(errorMessage);

            }

        }

    }

}

abstract contract Context {

    function _msgSender() internal view virtual returns (address payable) {

        return msg.sender;

    }



    function _msgData() internal view virtual returns (bytes memory) {

        this; 

        return msg.data;

    }

}

interface IERC165 {

    

    function supportsInterface(bytes4 interfaceId) external view returns (bool);

}

interface IERC20 {

    

    function totalSupply() external view returns (uint256);



    

    function balanceOf(address account) external view returns (uint256);



    

    function transfer(address recipient, uint256 amount) external returns (bool);



    

    function allowance(address owner, address spender) external view returns (uint256);



    

    function approve(address spender, uint256 amount) external returns (bool);



    

    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);



    

    event Transfer(address indexed from, address indexed to, uint256 value);



    

    event Approval(address indexed owner, address indexed spender, uint256 value);

}

library SafeMath {

    

    function add(uint256 a, uint256 b) internal pure returns (uint256) {

        uint256 c = a + b;

        require(c >= a, "SafeMath: addition overflow");



        return c;

    }



    

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {

        return sub(a, b, "SafeMath: subtraction overflow");

    }



    

    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {

        require(b <= a, errorMessage);

        uint256 c = a - b;



        return c;

    }



    

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {

        

        

        

        if (a == 0) {

            return 0;

        }



        uint256 c = a * b;

        require(c / a == b, "SafeMath: multiplication overflow");



        return c;

    }



    

    function div(uint256 a, uint256 b) internal pure returns (uint256) {

        return div(a, b, "SafeMath: division by zero");

    }



    

    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {

        require(b > 0, errorMessage);

        uint256 c = a / b;

        



        return c;

    }



    

    function mod(uint256 a, uint256 b) internal pure returns (uint256) {

        return mod(a, b, "SafeMath: modulo by zero");

    }



    

    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {

        require(b != 0, errorMessage);

        return a % b;

    }

}

contract Wrapped1155Metadata {

    

    Wrapped1155Factory public factory;

    IERC1155 public multiToken;

    uint256 public tokenId;



    modifier onlyFactory() {

        require(msg.sender == address(factory), "Wrapped1155: only factory allowed to perform operation");

        _;

    }

}

contract ERC165 is IERC165 {

    

    bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;



    

    mapping(bytes4 => bool) private _supportedInterfaces;



    constructor () internal {

        

        

        _registerInterface(_INTERFACE_ID_ERC165);

    }



    

    function supportsInterface(bytes4 interfaceId) public view override returns (bool) {

        return _supportedInterfaces[interfaceId];

    }



    

    function _registerInterface(bytes4 interfaceId) internal virtual {

        require(interfaceId != 0xffffffff, "ERC165: invalid interface id");

        _supportedInterfaces[interfaceId] = true;

    }

}

contract ERC20 is Context, IERC20 {

    using SafeMath for uint256;

    using Address for address;



    mapping (address => uint256) private _balances;



    mapping (address => mapping (address => uint256)) private _allowances;



    uint256 private _totalSupply;



    string private _name;

    string private _symbol;

    uint8 private _decimals;



    

    constructor (string memory name, string memory symbol) public {

        _name = name;

        _symbol = symbol;

        _decimals = 18;

    }



    

    function name() public view returns (string memory) {

        return _name;

    }



    

    function symbol() public view returns (string memory) {

        return _symbol;

    }



    

    function decimals() public view returns (uint8) {

        return _decimals;

    }



    

    function totalSupply() public view override returns (uint256) {

        return _totalSupply;

    }



    

    function balanceOf(address account) public view override returns (uint256) {

        return _balances[account];

    }



    

    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {

        _transfer(_msgSender(), recipient, amount);

        return true;

    }



    

    function allowance(address owner, address spender) public view virtual override returns (uint256) {

        return _allowances[owner][spender];

    }



    

    function approve(address spender, uint256 amount) public virtual override returns (bool) {

        _approve(_msgSender(), spender, amount);

        return true;

    }



    

    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {

        _transfer(sender, recipient, amount);

        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, "ERC20: transfer amount exceeds allowance"));

        return true;

    }



    

    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {

        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));

        return true;

    }



    

    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {

        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, "ERC20: decreased allowance below zero"));

        return true;

    }



    

    function _transfer(address sender, address recipient, uint256 amount) internal virtual {

        require(sender != address(0), "ERC20: transfer from the zero address");

        require(recipient != address(0), "ERC20: transfer to the zero address");



        _beforeTokenTransfer(sender, recipient, amount);



        _balances[sender] = _balances[sender].sub(amount, "ERC20: transfer amount exceeds balance");

        _balances[recipient] = _balances[recipient].add(amount);

        emit Transfer(sender, recipient, amount);

    }



    

    function _mint(address account, uint256 amount) internal virtual {

        require(account != address(0), "ERC20: mint to the zero address");



        _beforeTokenTransfer(address(0), account, amount);



        _totalSupply = _totalSupply.add(amount);

        _balances[account] = _balances[account].add(amount);

        emit Transfer(address(0), account, amount);

    }



    

    function _burn(address account, uint256 amount) internal virtual {

        require(account != address(0), "ERC20: burn from the zero address");



        _beforeTokenTransfer(account, address(0), amount);



        _balances[account] = _balances[account].sub(amount, "ERC20: burn amount exceeds balance");

        _totalSupply = _totalSupply.sub(amount);

        emit Transfer(account, address(0), amount);

    }



    

    function _approve(address owner, address spender, uint256 amount) internal virtual {

        require(owner != address(0), "ERC20: approve from the zero address");

        require(spender != address(0), "ERC20: approve to the zero address");



        _allowances[owner][spender] = amount;

        emit Approval(owner, spender, amount);

    }



    

    function _setupDecimals(uint8 decimals_) internal {

        _decimals = decimals_;

    }



    

    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }

}

interface IERC1155 is IERC165 {

    

    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);



    

    event TransferBatch(address indexed operator, address indexed from, address indexed to, uint256[] ids, uint256[] values);



    

    event ApprovalForAll(address indexed account, address indexed operator, bool approved);



    

    event URI(string value, uint256 indexed id);



    

    function balanceOf(address account, uint256 id) external view returns (uint256);



    

    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids) external view returns (uint256[] memory);



    

    function setApprovalForAll(address operator, bool approved) external;



    

    function isApprovedForAll(address account, address operator) external view returns (bool);



    

    function safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes calldata data) external;



    

    function safeBatchTransferFrom(address from, address to, uint256[] calldata ids, uint256[] calldata amounts, bytes calldata data) external;

}

interface IERC1155Receiver is IERC165 {



    

    function onERC1155Received(

        address operator,

        address from,

        uint256 id,

        uint256 value,

        bytes calldata data

    )

        external

        returns(bytes4);



    

    function onERC1155BatchReceived(

        address operator,

        address from,

        uint256[] calldata ids,

        uint256[] calldata values,

        bytes calldata data

    )

        external

        returns(bytes4);

}

contract Wrapped1155 is Wrapped1155Metadata, ERC20 {

    constructor() public ERC20("Wrapped ERC-1155 Implementation", "WMT*") {}



    function mint(address account, uint256 amount) external onlyFactory {

        _mint(account, amount);

    }



    function burn(address account, uint256 amount) external onlyFactory {

        _burn(account, amount);

    }

}

abstract contract ERC1155Receiver is ERC165, IERC1155Receiver {

    constructor() public {

        _registerInterface(

            ERC1155Receiver(0).onERC1155Received.selector ^

            ERC1155Receiver(0).onERC1155BatchReceived.selector

        );

    }

}

contract Wrapped1155Factory is ERC1155Receiver {

    using Address for address;



    Wrapped1155 public erc20Implementation;



    constructor() public {

        erc20Implementation = new Wrapped1155();

    }



    function onERC1155Received(

        address operator,

        address ,

        uint256 id,

        uint256 value,

        bytes calldata data

    )

        external

        override

        returns (bytes4)

    {

        address recipient = data.length > 0 ?

            abi.decode(data, (address)) :

            operator;



        Wrapped1155 wrapped1155 = requireWrapped1155(IERC1155(msg.sender), id);

        wrapped1155.mint(recipient, value);



        return this.onERC1155Received.selector;

    }



    function onERC1155BatchReceived(

        address operator,

        address ,

        uint256[] calldata ids,

        uint256[] calldata values,

        bytes calldata data

    )

        external

        override

        returns (bytes4)

    {

        address recipient = data.length > 0 ?

            abi.decode(data, (address)) :

            operator;



        for (uint i = 0; i < ids.length; i++) {

            requireWrapped1155(IERC1155(msg.sender), ids[i]).mint(recipient, values[i]);

        }



        return this.onERC1155BatchReceived.selector;

    }



    function unwrap(

        IERC1155 multiToken,

        uint256 tokenId,

        uint256 amount,

        address recipient,

        bytes calldata data

    )

        external

    {

        getWrapped1155(multiToken, tokenId).burn(msg.sender, amount);

        multiToken.safeTransferFrom(address(this), recipient, tokenId, amount, data);

    }



    function batchUnwrap(

        IERC1155 multiToken,

        uint256[] calldata tokenIds,

        uint256[] calldata amounts,

        address recipient,

        bytes calldata data

    )

        external

    {

        require(tokenIds.length == amounts.length, "Wrapped1155Factory: mismatched input arrays");

        for (uint i = 0; i < tokenIds.length; i++) {

            getWrapped1155(multiToken, tokenIds[i]).burn(msg.sender, amounts[i]);

        }

        multiToken.safeBatchTransferFrom(address(this), recipient, tokenIds, amounts, data);

    }



    function getWrapped1155DeployBytecode(IERC1155 multiToken, uint256 tokenId)

        public

        view

        returns (bytes memory)

    {

        return abi.encodePacked(

            

            hex"73",

            this,

            hex"3d55",



            

            hex"73",

            multiToken,

            hex"602055",



            

            hex"7f",

            tokenId,

            hex"604055",



            

            hex"7f",

            "Wrapped ERC-1155", uint128(32),

            hex"60c055",



            

            hex"7f",

            "WMT", uint232(6),

            hex"60e055",



            

            hex"60",

            uint8(18),

            hex"61010055",



            

            hex"60", uint8(44),

            

            hex"604051",



            

            hex"81",

            

            hex"60", uint8(172),

            

            hex"82"



            

            hex"39f3",



            

            hex"3d3d3d3d363d3d37363d73",

            address(erc20Implementation),

            hex"5af43d3d93803e602a57fd5bf3"

        );

    }



    function getWrapped1155(IERC1155 multiToken, uint256 tokenId)

        public

        view

        returns (Wrapped1155)

    {

        return Wrapped1155(address(uint256(keccak256(abi.encodePacked(

            uint8(0xff),

            this,

            uint256(1155),

            keccak256(getWrapped1155DeployBytecode(multiToken, tokenId))

        )))));

    }



    function requireWrapped1155(IERC1155 multiToken, uint256 tokenId)

        public

        returns (Wrapped1155)

    {

        bytes memory deployBytecode = getWrapped1155DeployBytecode(multiToken, tokenId);



        address wrapped1155Address = address(uint256(keccak256(abi.encodePacked(

            uint8(0xff),

            this,

            uint256(1155),

            keccak256(deployBytecode)

        ))));



        if (!wrapped1155Address.isContract()) {

            address addr;

            assembly {

              addr := create2(0, add(deployBytecode, 0x20), mload(deployBytecode), 1155)

            }

            require(wrapped1155Address == addr, "Wrapped1155Factory: failed to deploy");

        }



        return Wrapped1155(wrapped1155Address);

    }

}
