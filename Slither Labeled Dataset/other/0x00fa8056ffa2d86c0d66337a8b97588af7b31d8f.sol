


pragma solidity 0.8.10;





abstract contract ERC20 {
    
interface IFlywheelBooster {
    
    function boostedTotalSupply(ERC20 strategy) external view returns (uint256);

    
    function boostedBalanceOf(ERC20 strategy, address user) external view returns (uint256);
}

contract FlywheelCore is Auth {
    using SafeTransferLib for ERC20;
    using SafeCastLib for uint256;

    
    ERC20 public immutable rewardToken;

    
    ERC20[] public allStrategies;

    
    IFlywheelRewards public flywheelRewards;

    
    IFlywheelBooster public flywheelBooster;

    constructor(
        ERC20 _rewardToken,
        IFlywheelRewards _flywheelRewards,
        IFlywheelBooster _flywheelBooster,
        address _owner,
        Authority _authority
    ) Auth(_owner, _authority) {
        rewardToken = _rewardToken;
        flywheelRewards = _flywheelRewards;
        flywheelBooster = _flywheelBooster;
    }

    
    event AccrueRewards(ERC20 indexed strategy, address indexed user, uint256 rewardsDelta, uint256 rewardsIndex);

    
    event ClaimRewards(address indexed user, uint256 amount);

    
    mapping(address => uint256) public rewardsAccrued;

    
    function accrue(ERC20 strategy, address user) public returns (uint256) {
        RewardsState memory state = strategyState[strategy];

        if (state.index == 0) return 0;

        state = accrueStrategy(strategy, state);
        return accrueUser(strategy, user, state);
    }

    
    function accrue(
        ERC20 strategy,
        address user,
        address secondUser
    ) public returns (uint256, uint256) {
        RewardsState memory state = strategyState[strategy];

        if (state.index == 0) return (0, 0);

        state = accrueStrategy(strategy, state);
        return (accrueUser(strategy, user, state), accrueUser(strategy, secondUser, state));
    }

    
    function claimRewards(address user) external {
        uint256 accrued = rewardsAccrued[user];

        if (accrued != 0) {
            rewardsAccrued[user] = 0;

            rewardToken.safeTransferFrom(address(flywheelRewards), user, accrued);

            emit ClaimRewards(user, accrued);
        }
    }

    
    event AddStrategy(address indexed newStrategy);

    
    function addStrategyForRewards(ERC20 strategy) external requiresAuth {
        _addStrategyForRewards(strategy);
    }

    function _addStrategyForRewards(ERC20 strategy) internal {
        require(strategyState[strategy].index == 0, "strategy");
        strategyState[strategy] = RewardsState({index: ONE, lastUpdatedTimestamp: block.timestamp.safeCastTo32()});

        allStrategies.push(strategy);
        emit AddStrategy(address(strategy));
    }

    function getAllStrategies() external view returns (ERC20[] memory) {
        return allStrategies;
    }

    
    event FlywheelRewardsUpdate(address indexed newFlywheelRewards);

    
    function setFlywheelRewards(IFlywheelRewards newFlywheelRewards) external requiresAuth {
        uint256 oldRewardBalance = rewardToken.balanceOf(address(flywheelRewards));
        if (oldRewardBalance > 0) {
            rewardToken.safeTransferFrom(address(flywheelRewards), address(newFlywheelRewards), oldRewardBalance);
        }

        flywheelRewards = newFlywheelRewards;

        emit FlywheelRewardsUpdate(address(newFlywheelRewards));
    }

    
    event FlywheelBoosterUpdate(address indexed newBooster);

    
    function setBooster(IFlywheelBooster newBooster) external requiresAuth {
        flywheelBooster = newBooster;

        emit FlywheelBoosterUpdate(address(newBooster));
    }

    
interface IFlywheelRewards {
    
    function getAccruedRewards(ERC20 strategy, uint32 lastUpdatedTimestamp) external returns (uint256 rewards);

    
    function flywheel() external view returns (FlywheelCore);

    
    function rewardToken() external view returns (ERC20);
}

abstract contract BaseFlywheelRewards is IFlywheelRewards {
    using SafeTransferLib for ERC20;

    
    error FlywheelError();

    
    ERC20 public immutable override rewardToken;

    
    FlywheelCore public immutable override flywheel;

    constructor(FlywheelCore _flywheel) {
        flywheel = _flywheel;
        ERC20 _rewardToken = _flywheel.rewardToken();
        rewardToken = _rewardToken;

        _rewardToken.safeApprove(address(_flywheel), type(uint256).max);
    }

    modifier onlyFlywheel() {
        if (msg.sender != address(flywheel)) revert FlywheelError();
        _;
    }
}



abstract contract FlywheelDynamicRewards is BaseFlywheelRewards {
    using SafeTransferLib for ERC20;
    using SafeCastLib for uint256;

    event NewRewardsCycle(uint32 indexed start, uint32 indexed end, uint192 reward);

    
    uint32 public immutable rewardsCycleLength;

    struct RewardsCycle {
        uint32 start;
        uint32 end;
        uint192 reward;
    }

    mapping(ERC20 => RewardsCycle) public rewardsCycle;

    constructor(FlywheelCore _flywheel, uint32 _rewardsCycleLength) BaseFlywheelRewards(_flywheel) {
        rewardsCycleLength = _rewardsCycleLength;
    }

    
    function getAccruedRewards(ERC20 strategy, uint32 lastUpdatedTimestamp)
        external
        override
        onlyFlywheel
        returns (uint256 amount)
    {
        RewardsCycle memory cycle = rewardsCycle[strategy];

        uint32 timestamp = block.timestamp.safeCastTo32();

        uint32 latest = timestamp >= cycle.end ? cycle.end : timestamp;
        uint32 earliest = lastUpdatedTimestamp <= cycle.start ? cycle.start : lastUpdatedTimestamp;
        if (cycle.end != 0) {
            amount = (cycle.reward * (latest - earliest)) / (cycle.end - cycle.start);
            assert(amount <= cycle.reward); 
        }
        
        if (timestamp >= cycle.end) {
            uint32 end = ((timestamp + rewardsCycleLength) / rewardsCycleLength) * rewardsCycleLength;
            uint192 rewards = getNextCycleRewards(strategy);

            
            rewardsCycle[strategy] = RewardsCycle({start: timestamp, end: end, reward: rewards});

            emit NewRewardsCycle(timestamp, end, rewards);
        }
    }

    function getNextCycleRewards(ERC20 strategy) internal virtual returns (uint192);
}


contract FuseFlywheelDynamicRewards is FlywheelDynamicRewards {
    using SafeTransferLib for ERC20;

    constructor(FlywheelCore _flywheel, uint32 _cycleLength)
        FlywheelDynamicRewards(_flywheel, _cycleLength)
    {}

    function getNextCycleRewards(ERC20 strategy)
        internal
        override
        returns (uint192)
    {
        uint256 rewardAmount = rewardToken.balanceOf(address(strategy));
        if (rewardAmount != 0) {
            rewardToken.safeTransferFrom(
                address(strategy),
                address(this),
                rewardAmount
            );
        }
        return uint192(rewardAmount);
    }
}