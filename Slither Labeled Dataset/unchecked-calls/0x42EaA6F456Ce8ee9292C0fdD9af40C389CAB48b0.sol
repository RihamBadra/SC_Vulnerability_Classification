pragma solidity 0.6.12;
pragma experimental ABIEncoderV2;

interface ERC20 {

    function totalSupply() external view returns (uint);

    function decimals() external view returns (uint);

    function balanceOf(address tokenOwner) external view returns (uint balance);

    function allowance(address tokenOwner, address spender) external view returns (uint remaining);

    function transfer(address to, uint tokens) external returns (bool success);

    function approve(address spender, uint tokens) external returns (bool success);

    function transferFrom(address from, address to, uint tokens) external returns (bool success);

}

library GuardianUtils {



    

    function isGuardianOrGuardianSigner(address[] memory _guardians, address _guardian) internal view returns (bool, address[] memory) {

        if (_guardians.length == 0 || _guardian == address(0)) {

            return (false, _guardians);

        }

        bool isFound = false;

        address[] memory updatedGuardians = new address[](_guardians.length - 1);

        uint256 index = 0;

        for (uint256 i = 0; i < _guardians.length; i++) {

            if (!isFound) {

                

                if (_guardian == _guardians[i]) {

                    isFound = true;

                    continue;

                }

                

                if (isContract(_guardians[i]) && isGuardianOwner(_guardians[i], _guardian)) {

                    isFound = true;

                    continue;

                }

            }

            if (index < updatedGuardians.length) {

                updatedGuardians[index] = _guardians[i];

                index++;

            }

        }

        return isFound ? (true, updatedGuardians) : (false, _guardians);

    }



   

    function isContract(address _addr) internal view returns (bool) {

        uint32 size;

        

        assembly {

            size := extcodesize(_addr)

        }

        return (size > 0);

    }



    

    function isGuardianOwner(address _guardian, address _owner) internal view returns (bool) {

        address owner = address(0);

        bytes4 sig = bytes4(keccak256("owner()"));



        

        assembly {

            let ptr := mload(0x40)

            mstore(ptr,sig)

            let result := staticcall(5000, _guardian, ptr, 0x20, ptr, 0x20)

            if eq(result, 1) {

                owner := mload(ptr)

            }

        }

        return owner == _owner;

    }

}

interface IFeature {



    enum OwnerSignature {

        Anyone,             

        Required,           

        Optional,           

        Disallowed          

    }



    

    function recoverToken(address _token) external;



    

    function init(address _wallet) external;



    

    function isFeatureAuthorisedInVersionManager(address _wallet, address _feature) external view returns (bool);



    

    function getRequiredSignatures(address _wallet, bytes calldata _data) external view returns (uint256, OwnerSignature);



    

    function getStaticCallSignatures() external view returns (bytes4[] memory);

}

interface IGuardianStorage {



    

    function addGuardian(address _wallet, address _guardian) external;



    

    function revokeGuardian(address _wallet, address _guardian) external;



    

    function isGuardian(address _wallet, address _guardian) external view returns (bool);



    function isLocked(address _wallet) external view returns (bool);



    function getLock(address _wallet) external view returns (uint256);



    function getLocker(address _wallet) external view returns (address);



    function setLock(address _wallet, uint256 _releaseAfter) external;



    function getGuardians(address _wallet) external view returns (address[] memory);



    function guardianCount(address _wallet) external view returns (uint256);

}

interface ILimitStorage {



    struct Limit {

        

        uint128 current;

        

        uint128 pending;

        

        uint64 changeAfter;

    }



    struct DailySpent {

        

        uint128 alreadySpent;

        

        uint64 periodEnd;

    }



    function setLimit(address _wallet, Limit memory _limit) external;



    function getLimit(address _wallet) external view returns (Limit memory _limit);



    function setDailySpent(address _wallet, DailySpent memory _dailySpent) external;



    function getDailySpent(address _wallet) external view returns (DailySpent memory _dailySpent);



    function setLimitAndDailySpent(address _wallet, Limit memory _limit, DailySpent memory _dailySpent) external;



    function getLimitAndDailySpent(address _wallet) external view returns (Limit memory _limit, DailySpent memory _dailySpent);

}

interface ILockStorage {

    function isLocked(address _wallet) external view returns (bool);



    function getLock(address _wallet) external view returns (uint256);



    function getLocker(address _wallet) external view returns (address);



    function setLock(address _wallet, address _locker, uint256 _releaseAfter) external;

}

interface IModuleRegistry {

    function registerModule(address _module, bytes32 _name) external;



    function deregisterModule(address _module) external;



    function registerUpgrader(address _upgrader, bytes32 _name) external;



    function deregisterUpgrader(address _upgrader) external;



    function recoverToken(address _token) external;



    function moduleInfo(address _module) external view returns (bytes32);



    function upgraderInfo(address _upgrader) external view returns (bytes32);



    function isRegisteredModule(address _module) external view returns (bool);



    function isRegisteredModule(address[] calldata _modules) external view returns (bool);



    function isRegisteredUpgrader(address _upgrader) external view returns (bool);

}

interface IVersionManager {

    

    function isFeatureAuthorised(address _wallet, address _feature) external view returns (bool);



    

    function checkAuthorisedFeatureAndInvokeWallet(

        address _wallet,

        address _to,

        uint256 _value,

        bytes calldata _data

    ) external returns (bytes memory _res);



    



    

    function setOwner(address _wallet, address _newOwner) external;



    

    function invokeStorage(address _wallet, address _storage, bytes calldata _data) external;



    

    function upgradeWallet(address _wallet, uint256 _toVersion) external;

 

}

interface IWallet {

    

    function owner() external view returns (address);



    

    function modules() external view returns (uint);



    

    function setOwner(address _newOwner) external;



    

    function authorised(address _module) external view returns (bool);



    

    function enabled(bytes4 _sig) external view returns (address);



    

    function authoriseModule(address _module, bool _value) external;



    

    function enableStaticCall(address _module, bytes4 _method) external;

}

library SafeMath {

    

    function add(uint256 a, uint256 b) internal pure returns (uint256) {

        uint256 c = a + b;

        require(c >= a, "SafeMath: addition overflow");



        return c;

    }



    

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {

        return sub(a, b, "SafeMath: subtraction overflow");

    }



    

    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {

        require(b <= a, errorMessage);

        uint256 c = a - b;



        return c;

    }



    

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {

        

        

        

        if (a == 0) {

            return 0;

        }



        uint256 c = a * b;

        require(c / a == b, "SafeMath: multiplication overflow");



        return c;

    }



    

    function div(uint256 a, uint256 b) internal pure returns (uint256) {

        return div(a, b, "SafeMath: division by zero");

    }



    

    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {

        

        require(b > 0, errorMessage);

        uint256 c = a / b;

        



        return c;

    }



    

    function mod(uint256 a, uint256 b) internal pure returns (uint256) {

        return mod(a, b, "SafeMath: modulo by zero");

    }



    

    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {

        require(b != 0, errorMessage);

        return a % b;

    }

}

contract BaseFeature is IFeature {



    

    bytes constant internal EMPTY_BYTES = "";

    

    address constant internal ETH_TOKEN = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;

    

    ILockStorage internal lockStorage;

    

    IVersionManager internal versionManager;



    event FeatureCreated(bytes32 name);



    

    modifier onlyWhenUnlocked(address _wallet) {

        require(!lockStorage.isLocked(_wallet), "BF: wallet locked");

        _;

    }



    

    modifier onlyVersionManager() {

        require(msg.sender == address(versionManager), "BF: caller must be VersionManager");

        _;

    }



    

    modifier onlyWalletOwner(address _wallet) {

        require(isOwner(_wallet, msg.sender), "BF: must be wallet owner");

        _;

    }



    

    modifier onlyWalletFeature(address _wallet) {

        require(versionManager.isFeatureAuthorised(_wallet, msg.sender), "BF: must be a wallet feature");

        _;

    }



    

    modifier onlyWalletOwnerOrFeature(address _wallet) {

        

        verifyOwnerOrAuthorisedFeature(_wallet, msg.sender);

        _;

    }



    constructor(

        ILockStorage _lockStorage,

        IVersionManager _versionManager,

        bytes32 _name

    ) public {

        lockStorage = _lockStorage;

        versionManager = _versionManager;

        emit FeatureCreated(_name);

    }



    

    function recoverToken(address _token) external virtual override {

        uint total = ERC20(_token).balanceOf(address(this));

        _token.call(abi.encodeWithSelector(ERC20(_token).transfer.selector, address(versionManager), total));

    }



    

    function init(address _wallet) external virtual override  {}



    

    function getRequiredSignatures(address, bytes calldata) external virtual view override returns (uint256, OwnerSignature) {

        revert("BF: disabled method");

    }



    

    function getStaticCallSignatures() external virtual override view returns (bytes4[] memory _sigs) {}



    

    function isFeatureAuthorisedInVersionManager(address _wallet, address _feature) public override view returns (bool) {

        return versionManager.isFeatureAuthorised(_wallet, _feature);

    }



    

    function verifyData(address _wallet, bytes calldata _data) internal pure returns (bool) {

        require(_data.length >= 36, "RM: Invalid dataWallet");

        address dataWallet = abi.decode(_data[4:], (address));

        return dataWallet == _wallet;

    }

    

     

    function isOwner(address _wallet, address _addr) internal view returns (bool) {

        return IWallet(_wallet).owner() == _addr;

    }



    

    function verifyOwnerOrAuthorisedFeature(address _wallet, address _sender) internal view {

        require(isFeatureAuthorisedInVersionManager(_wallet, _sender) || isOwner(_wallet, _sender), "BF: must be owner or feature");

    }



    

    function invokeWallet(address _wallet, address _to, uint256 _value, bytes memory _data)

        internal

        returns (bytes memory _res) 

    {

        _res = versionManager.checkAuthorisedFeatureAndInvokeWallet(_wallet, _to, _value, _data);

    }



}

contract LockManager is BaseFeature {



    bytes32 constant NAME = "LockManager";



    

    uint256 public lockPeriod;

    

    IGuardianStorage public guardianStorage;



    



    event Locked(address indexed wallet, uint64 releaseAfter);

    event Unlocked(address indexed wallet);



    



    

    modifier onlyWhenLocked(address _wallet) {

        require(lockStorage.isLocked(_wallet), "LM: wallet must be locked");

        _;

    }



    

    modifier onlyGuardianOrFeature(address _wallet) {

        bool isGuardian = guardianStorage.isGuardian(_wallet, msg.sender);

        require(isFeatureAuthorisedInVersionManager(_wallet, msg.sender) || isGuardian, "LM: must be guardian or feature");

        _;

    }



    



    constructor(

        ILockStorage _lockStorage,

        IGuardianStorage _guardianStorage,

        IVersionManager _versionManager,

        uint256 _lockPeriod

    )

        BaseFeature(_lockStorage, _versionManager, NAME) public {

        guardianStorage = _guardianStorage;

        lockPeriod = _lockPeriod;

    }



    



    

    function lock(address _wallet) external onlyGuardianOrFeature(_wallet) onlyWhenUnlocked(_wallet) {

        setLock(_wallet, block.timestamp + lockPeriod);

        emit Locked(_wallet, uint64(block.timestamp + lockPeriod));

    }



    

    function unlock(address _wallet) external onlyGuardianOrFeature(_wallet) onlyWhenLocked(_wallet) {

        address locker = lockStorage.getLocker(_wallet);

        require(locker == address(this), "LM: cannot unlock a wallet that was locked by another feature");

        setLock(_wallet, 0);

        emit Unlocked(_wallet);

    }



    

    function getLock(address _wallet) external view returns(uint64 _releaseAfter) {

        uint256 lockEnd = lockStorage.getLock(_wallet);

        if (lockEnd > block.timestamp) {

            _releaseAfter = uint64(lockEnd);

        }

    }



    

    function isLocked(address _wallet) external view returns (bool _isLocked) {

        return lockStorage.isLocked(_wallet);

    }



    

    function getRequiredSignatures(address, bytes calldata) external view override returns (uint256, OwnerSignature) {

        return (1, OwnerSignature.Disallowed);

    }



    



    function setLock(address _wallet, uint256 _releaseAfter) internal {

        versionManager.invokeStorage(

            _wallet,

            address(lockStorage),

            abi.encodeWithSelector(lockStorage.setLock.selector, _wallet, address(this), _releaseAfter)

        );

    }

}
