



pragma solidity 0.8.1;

interface IReverseResolver {
    function claim(address owner) external returns (bytes32);
}

interface IERC20 {
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
}

interface IERC721 {
    function safeTransferFrom(address from, address to, uint256 tokenId) external;
}


contract MoonCatReference {

    

    address constant public MoonCatRescue = 0x60cd862c9C687A9dE49aecdC3A99b74A4fc54aB6;

    

    address[] internal ContractAddresses;

    struct Doc {
        string name;
        string description;
        string details;
    }

    mapping (address => Doc) internal Docs;

    
    function totalContracts () public view returns (uint256) {
        return ContractAddresses.length;
    }

    
    function contractAddressByIndex (uint256 index) public view returns (address) {
        require(index < ContractAddresses.length, "Index Out of Range");
        return ContractAddresses[index];
    }

    
    function doc (address _contractAddress) public view returns (string memory name, string memory description, string memory details) {
        Doc storage data = Docs[_contractAddress];
        return (data.name, data.description, data.details);
    }

    
    function doc (uint256 index) public view returns (string memory name, string memory description, string memory details, address contractAddress) {
        require(index < ContractAddresses.length, "Index Out of Range");
        contractAddress = ContractAddresses[index];
        (name, description, details) = doc(contractAddress);
    }

    
    function doc () public view returns (string memory name, string memory description, string memory details) {
        return doc(address(this));
    }

    address payable public owner;

    modifier onlyOwner () {
        require(msg.sender == owner, "Only Owner");
        _;
    }

    
    function setDoc (address contractAddress, string memory name, string memory description, string memory details) public onlyOwner {
        require(bytes(name).length > 0, "Name cannot be blank");
        Doc storage data = Docs[contractAddress];
        if (bytes(data.name).length == 0) {
            ContractAddresses.push(contractAddress);
        }
        data.name = name;
        data.description = description;
        data.details = details;
    }

    
    function setDoc (address contractAddress, string memory name, string memory description) public {
        setDoc(contractAddress, name, description, "");
    }

    
    function updateDetails (address contractAddress, string memory details) public onlyOwner {
        Doc storage data = Docs[contractAddress];
        require(bytes(data.name).length == 0, "Doc not found");
        data.details = details;
    }

    
    function batchSetDocs (address[] calldata contractAddresses, Doc[] calldata docs) public onlyOwner {
        for ( uint256 i = 0; i < docs.length; i++) {
            Doc memory data = docs[i];
            setDoc(contractAddresses[i], data.name, data.description, data.details);
        }
    }

    
    function transferOwnership (address payable newOwner) public onlyOwner {
        owner = newOwner;
    }

    
    function withdrawForeignERC20 (address tokenContract) public onlyOwner {
        IERC20 token = IERC20(tokenContract);
        token.transfer(owner, token.balanceOf(address(this)));
    }

    
    function withdrawForeignERC721 (address tokenContract, uint256 tokenId) public onlyOwner {
        IERC721(tokenContract).safeTransferFrom(address(this), owner, tokenId);
    }


    constructor () {
        owner = payable(msg.sender);

        
        IReverseResolver(0x084b1c3C81545d370f3634392De611CaaBFf8148).claim(msg.sender);

        setDoc(0x60cd862c9C687A9dE49aecdC3A99b74A4fc54aB6, "MoonCatRescue", "Original 2017 MoonCatRescue user-discoverable blockchain collectible.", "");
    }
}