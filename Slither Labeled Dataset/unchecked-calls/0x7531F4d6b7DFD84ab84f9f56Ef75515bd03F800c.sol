pragma solidity 0.6.12;
pragma experimental ABIEncoderV2;

interface ERC20 {

    function totalSupply() external view returns (uint);

    function decimals() external view returns (uint);

    function balanceOf(address tokenOwner) external view returns (uint balance);

    function allowance(address tokenOwner, address spender) external view returns (uint remaining);

    function transfer(address to, uint tokens) external returns (bool success);

    function approve(address spender, uint tokens) external returns (bool success);

    function transferFrom(address from, address to, uint tokens) external returns (bool success);

}

interface IFeature {



    enum OwnerSignature {

        Anyone,             

        Required,           

        Optional,           

        Disallowed          

    }



    

    function recoverToken(address _token) external;



    

    function init(address _wallet) external;



    

    function isFeatureAuthorisedInVersionManager(address _wallet, address _feature) external view returns (bool);



    

    function getRequiredSignatures(address _wallet, bytes calldata _data) external view returns (uint256, OwnerSignature);



    

    function getStaticCallSignatures() external view returns (bytes4[] memory);

}

interface ILimitStorage {



    struct Limit {

        

        uint128 current;

        

        uint128 pending;

        

        uint64 changeAfter;

    }



    struct DailySpent {

        

        uint128 alreadySpent;

        

        uint64 periodEnd;

    }



    function setLimit(address _wallet, Limit memory _limit) external;



    function getLimit(address _wallet) external view returns (Limit memory _limit);



    function setDailySpent(address _wallet, DailySpent memory _dailySpent) external;



    function getDailySpent(address _wallet) external view returns (DailySpent memory _dailySpent);



    function setLimitAndDailySpent(address _wallet, Limit memory _limit, DailySpent memory _dailySpent) external;



    function getLimitAndDailySpent(address _wallet) external view returns (Limit memory _limit, DailySpent memory _dailySpent);

}

interface ILockStorage {

    function isLocked(address _wallet) external view returns (bool);



    function getLock(address _wallet) external view returns (uint256);



    function getLocker(address _wallet) external view returns (address);



    function setLock(address _wallet, address _locker, uint256 _releaseAfter) external;

}

interface IModuleRegistry {

    function registerModule(address _module, bytes32 _name) external;



    function deregisterModule(address _module) external;



    function registerUpgrader(address _upgrader, bytes32 _name) external;



    function deregisterUpgrader(address _upgrader) external;



    function recoverToken(address _token) external;



    function moduleInfo(address _module) external view returns (bytes32);



    function upgraderInfo(address _upgrader) external view returns (bytes32);



    function isRegisteredModule(address _module) external view returns (bool);



    function isRegisteredModule(address[] calldata _modules) external view returns (bool);



    function isRegisteredUpgrader(address _upgrader) external view returns (bool);

}

interface ITokenPriceRegistry {

    function getTokenPrice(address _token) external view returns (uint184 _price);

    function isTokenTradable(address _token) external view returns (bool _isTradable);

}

interface IVersionManager {

    

    function isFeatureAuthorised(address _wallet, address _feature) external view returns (bool);



    

    function checkAuthorisedFeatureAndInvokeWallet(

        address _wallet,

        address _to,

        uint256 _value,

        bytes calldata _data

    ) external returns (bytes memory _res);



    



    

    function setOwner(address _wallet, address _newOwner) external;



    

    function invokeStorage(address _wallet, address _storage, bytes calldata _data) external;



    

    function upgradeWallet(address _wallet, uint256 _toVersion) external;

 

}

interface IWallet {

    

    function owner() external view returns (address);



    

    function modules() external view returns (uint);



    

    function setOwner(address _newOwner) external;



    

    function authorised(address _module) external view returns (bool);



    

    function enabled(bytes4 _sig) external view returns (address);



    

    function authoriseModule(address _module, bool _value) external;



    

    function enableStaticCall(address _module, bytes4 _method) external;

}

library SafeMath {

    

    function add(uint256 a, uint256 b) internal pure returns (uint256) {

        uint256 c = a + b;

        require(c >= a, "SafeMath: addition overflow");



        return c;

    }



    

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {

        return sub(a, b, "SafeMath: subtraction overflow");

    }



    

    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {

        require(b <= a, errorMessage);

        uint256 c = a - b;



        return c;

    }



    

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {

        

        

        

        if (a == 0) {

            return 0;

        }



        uint256 c = a * b;

        require(c / a == b, "SafeMath: multiplication overflow");



        return c;

    }



    

    function div(uint256 a, uint256 b) internal pure returns (uint256) {

        return div(a, b, "SafeMath: division by zero");

    }



    

    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {

        

        require(b > 0, errorMessage);

        uint256 c = a / b;

        



        return c;

    }



    

    function mod(uint256 a, uint256 b) internal pure returns (uint256) {

        return mod(a, b, "SafeMath: modulo by zero");

    }



    

    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {

        require(b != 0, errorMessage);

        return a % b;

    }

}

contract BaseFeature is IFeature {



    

    bytes constant internal EMPTY_BYTES = "";

    

    address constant internal ETH_TOKEN = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;

    

    ILockStorage internal lockStorage;

    

    IVersionManager internal versionManager;



    event FeatureCreated(bytes32 name);



    

    modifier onlyWhenUnlocked(address _wallet) {

        require(!lockStorage.isLocked(_wallet), "BF: wallet locked");

        _;

    }



    

    modifier onlyVersionManager() {

        require(msg.sender == address(versionManager), "BF: caller must be VersionManager");

        _;

    }



    

    modifier onlyWalletOwner(address _wallet) {

        require(isOwner(_wallet, msg.sender), "BF: must be wallet owner");

        _;

    }



    

    modifier onlyWalletFeature(address _wallet) {

        require(versionManager.isFeatureAuthorised(_wallet, msg.sender), "BF: must be a wallet feature");

        _;

    }



    

    modifier onlyWalletOwnerOrFeature(address _wallet) {

        

        verifyOwnerOrAuthorisedFeature(_wallet, msg.sender);

        _;

    }



    constructor(

        ILockStorage _lockStorage,

        IVersionManager _versionManager,

        bytes32 _name

    ) public {

        lockStorage = _lockStorage;

        versionManager = _versionManager;

        emit FeatureCreated(_name);

    }



    

    function recoverToken(address _token) external virtual override {

        uint total = ERC20(_token).balanceOf(address(this));

        _token.call(abi.encodeWithSelector(ERC20(_token).transfer.selector, address(versionManager), total));

    }



    

    function init(address _wallet) external virtual override  {}



    

    function getRequiredSignatures(address, bytes calldata) external virtual view override returns (uint256, OwnerSignature) {

        revert("BF: disabled method");

    }



    

    function getStaticCallSignatures() external virtual override view returns (bytes4[] memory _sigs) {}



    

    function isFeatureAuthorisedInVersionManager(address _wallet, address _feature) public override view returns (bool) {

        return versionManager.isFeatureAuthorised(_wallet, _feature);

    }



    

    function verifyData(address _wallet, bytes calldata _data) internal pure returns (bool) {

        require(_data.length >= 36, "RM: Invalid dataWallet");

        address dataWallet = abi.decode(_data[4:], (address));

        return dataWallet == _wallet;

    }

    

     

    function isOwner(address _wallet, address _addr) internal view returns (bool) {

        return IWallet(_wallet).owner() == _addr;

    }



    

    function verifyOwnerOrAuthorisedFeature(address _wallet, address _sender) internal view {

        require(isFeatureAuthorisedInVersionManager(_wallet, _sender) || isOwner(_wallet, _sender), "BF: must be owner or feature");

    }



    

    function invokeWallet(address _wallet, address _to, uint256 _value, bytes memory _data)

        internal

        returns (bytes memory _res) 

    {

        _res = versionManager.checkAuthorisedFeatureAndInvokeWallet(_wallet, _to, _value, _data);

    }



}

contract NftTransfer is BaseFeature{



    bytes32 constant NAME = "NftTransfer";



    

    bytes4 private constant ERC721_RECEIVED = 0x150b7a02;



    

    address public ckAddress;

    

    ITokenPriceRegistry public tokenPriceRegistry;



    



    event NonFungibleTransfer(address indexed wallet, address indexed nftContract, uint256 indexed tokenId, address to, bytes data);



    



    constructor(

        ILockStorage _lockStorage,

        ITokenPriceRegistry _tokenPriceRegistry,

        IVersionManager _versionManager,

        address _ckAddress

    )

        BaseFeature(_lockStorage, _versionManager, NAME)

        public

    {

        ckAddress = _ckAddress;

        tokenPriceRegistry = _tokenPriceRegistry;

    }



    

    

    function getRequiredSignatures(address, bytes calldata) external view override returns (uint256, OwnerSignature) {

        return (1, OwnerSignature.Required);

    }



    

    function getStaticCallSignatures() external virtual override view returns (bytes4[] memory _sigs) {

        _sigs = new bytes4[](1);

        _sigs[0] = ERC721_RECEIVED;

    }



    

    function onERC721Received(

        address ,

        address ,

        uint256 ,

        bytes calldata 

    )

        external

        returns (bytes4)

    {

        return ERC721_RECEIVED;

    }



    

    function transferNFT(

        address _wallet,

        address _nftContract,

        address _to,

        uint256 _tokenId,

        bool _safe,

        bytes calldata _data

    )

        external

        onlyWalletOwnerOrFeature(_wallet)

        onlyWhenUnlocked(_wallet)

    {

        bytes memory methodData;

        if (_nftContract == ckAddress) {

            methodData = abi.encodeWithSignature("transfer(address,uint256)", _to, _tokenId);

        } else {

           if (_safe) {

               methodData = abi.encodeWithSignature(

                   "safeTransferFrom(address,address,uint256,bytes)", _wallet, _to, _tokenId, _data);

           } else {

               require(!coveredByDailyLimit(_nftContract), "NT: Forbidden ERC20 contract");

               methodData = abi.encodeWithSignature(

                   "transferFrom(address,address,uint256)", _wallet, _to, _tokenId);

           }

        }

        invokeWallet(_wallet, _nftContract, 0, methodData);

        emit NonFungibleTransfer(_wallet, _nftContract, _tokenId, _to, _data);

    }



    



    

    function coveredByDailyLimit(address _contract) internal view returns (bool) {

        return tokenPriceRegistry.getTokenPrice(_contract) > 0;

    }



}
