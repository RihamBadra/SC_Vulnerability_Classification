pragma solidity 0.7.4;

enum MathError { NO_ERROR, DIVISION_BY_ZERO, INTEGER_OVERFLOW, INTEGER_UNDERFLOW, MODULO_BY_ZERO }

library Address {

    

    function isContract(address account) internal view returns (bool) {

        

        

        

        bytes32 codehash;

        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;

        

        assembly {

            codehash := extcodehash(account)

        }

        return (codehash != accountHash && codehash != 0x0);

    }

}

abstract contract AdminStorage {

    

    address public admin;

}

abstract contract BalanceSheetStorage {

    struct Vault {

        uint256 debt;

        uint256 freeCollateral;

        uint256 lockedCollateral;

        bool isOpen;

    }



    

    FintrollerInterface public fintroller;



    

    mapping(address => mapping(address => Vault)) internal vaults;



    

    bool public constant isBalanceSheet = true;

}

abstract contract CarefulMath {

    

    function addUInt(uint256 a, uint256 b) internal pure returns (MathError, uint256) {

        uint256 c = a + b;



        if (c >= a) {

            return (MathError.NO_ERROR, c);

        } else {

            return (MathError.INTEGER_OVERFLOW, 0);

        }

    }



    

    function addThenSubUInt(

        uint256 a,

        uint256 b,

        uint256 c

    ) internal pure returns (MathError, uint256) {

        (MathError err0, uint256 sum) = addUInt(a, b);



        if (err0 != MathError.NO_ERROR) {

            return (err0, 0);

        }



        return subUInt(sum, c);

    }



    

    function divUInt(uint256 a, uint256 b) internal pure returns (MathError, uint256) {

        if (b == 0) {

            return (MathError.DIVISION_BY_ZERO, 0);

        }



        return (MathError.NO_ERROR, a / b);

    }



    

    function modUInt(uint256 a, uint256 b) internal pure returns (MathError, uint256) {

        if (b == 0) {

            return (MathError.MODULO_BY_ZERO, 0);

        }



        return (MathError.NO_ERROR, a % b);

    }



    

    function mulUInt(uint256 a, uint256 b) internal pure returns (MathError, uint256) {

        if (a == 0) {

            return (MathError.NO_ERROR, 0);

        }



        uint256 c = a * b;



        if (c / a != b) {

            return (MathError.INTEGER_OVERFLOW, 0);

        } else {

            return (MathError.NO_ERROR, c);

        }

    }



    

    function subUInt(uint256 a, uint256 b) internal pure returns (MathError, uint256) {

        if (b <= a) {

            return (MathError.NO_ERROR, a - b);

        } else {

            return (MathError.INTEGER_UNDERFLOW, 0);

        }

    }

}

abstract contract Erc20RecoverStorage {

    

    Erc20Interface[] public nonRecoverableTokens;



    

    bool public isInitialized;

}

abstract contract Erc20Storage {

    

    uint8 public decimals;



    

    string public name;



    

    string public symbol;



    

    uint256 public totalSupply;



    mapping(address => mapping(address => uint256)) internal allowances;



    mapping(address => uint256) internal balances;

}

abstract contract ExponentialStorage {

    struct Exp {

        uint256 mantissa;

    }



    

    uint256 internal constant expScale = 1e18;

    uint256 internal constant halfExpScale = expScale / 2;

    uint256 internal constant mantissaOne = expScale;

}

abstract contract FyTokenStorage {

    

    struct Vault {

        uint256 debt;

        uint256 freeCollateral;

        uint256 lockedCollateral;

        bool isOpen;

    }



    



    

    BalanceSheetInterface public balanceSheet;



    

    Erc20Interface public collateral;



    

    uint256 public collateralPrecisionScalar;



    

    uint256 public expirationTime;



    

    FintrollerInterface public fintroller;



    

    RedemptionPoolInterface public redemptionPool;



    

    Erc20Interface public underlying;



    

    uint256 public underlyingPrecisionScalar;



    

    bool public constant isFyToken = true;

}

abstract contract RedemptionPoolStorage {

    

    FintrollerInterface public fintroller;



    

    uint256 public totalUnderlyingSupply;



    

    FyTokenInterface public fyToken;



    

    bool public constant isRedemptionPool = true;

}

abstract contract ReentrancyGuard {

    bool private notEntered;



    

    constructor() {

        notEntered = true;

    }



    

    modifier nonReentrant() {

        

        require(notEntered, "ERR_REENTRANT_CALL");



        

        notEntered = false;



        _;



        

        notEntered = true;

    }

}

library SafeErc20 {

    using Address for address;



    



    function safeTransfer(

        Erc20Interface token,

        address to,

        uint256 value

    ) internal {

        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));

    }



    function safeTransferFrom(

        Erc20Interface token,

        address from,

        address to,

        uint256 value

    ) internal {

        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));

    }



    



    

    function callOptionalReturn(Erc20Interface token, bytes memory data) private {

        

        

        

        bytes memory returndata = functionCallWithValue(address(token), data, "ERR_SAFE_ERC20_LOW_LEVEL_CALL");

        if (returndata.length > 0) {

            

            require(abi.decode(returndata, (bool)), "ERR_SAFE_ERC20_ERC20_OPERATION");

        }

    }



    function functionCallWithValue(

        address target,

        bytes memory data,

        string memory errorMessage

    ) private returns (bytes memory) {

        require(target.isContract(), "ERR_SAFE_ERC20_CALL_TO_NON_CONTRACT");



        

        (bool success, bytes memory returndata) = target.call(data);

        if (success) {

            return returndata;

        } else {

            

            if (returndata.length > 0) {

                



                

                assembly {

                    let returndata_size := mload(returndata)

                    revert(add(32, returndata), returndata_size)

                }

            } else {

                revert(errorMessage);

            }

        }

    }

}

interface UniswapAnchoredViewInterface {

    

    function price(string memory symbol) external view returns (uint256);

}

abstract contract AdminInterface is AdminStorage {

    

    function _renounceAdmin() external virtual;



    function _transferAdmin(address newAdmin) external virtual;



    

    event TransferAdmin(address indexed oldAdmin, address indexed newAdmin);

}

abstract contract BalanceSheetInterface is BalanceSheetStorage {

    

    function getClutchableCollateral(FyTokenInterface fyToken, uint256 repayAmount)

        external

        view

        virtual

        returns (uint256);



    function getCurrentCollateralizationRatio(FyTokenInterface fyToken, address account)

        public

        view

        virtual

        returns (uint256);



    function getHypotheticalCollateralizationRatio(

        FyTokenInterface fyToken,

        address account,

        uint256 lockedCollateral,

        uint256 debt

    ) public view virtual returns (uint256);



    function getVault(FyTokenInterface fyToken, address account)

        external

        view

        virtual

        returns (

            uint256,

            uint256,

            uint256,

            bool

        );



    function getVaultDebt(FyTokenInterface fyToken, address account) external view virtual returns (uint256);



    function getVaultLockedCollateral(FyTokenInterface fyToken, address account)

        external

        view

        virtual

        returns (uint256);



    function isAccountUnderwater(FyTokenInterface fyToken, address account) external view virtual returns (bool);



    function isVaultOpen(FyTokenInterface fyToken, address account) external view virtual returns (bool);



    



    function clutchCollateral(

        FyTokenInterface fyToken,

        address liquidator,

        address borrower,

        uint256 clutchedCollateralAmount

    ) external virtual returns (bool);



    function depositCollateral(FyTokenInterface fyToken, uint256 collateralAmount) external virtual returns (bool);



    function freeCollateral(FyTokenInterface fyToken, uint256 collateralAmount) external virtual returns (bool);



    function lockCollateral(FyTokenInterface fyToken, uint256 collateralAmount) external virtual returns (bool);



    function openVault(FyTokenInterface fyToken) external virtual returns (bool);



    function setVaultDebt(

        FyTokenInterface fyToken,

        address account,

        uint256 newVaultDebt

    ) external virtual returns (bool);



    function withdrawCollateral(FyTokenInterface fyToken, uint256 collateralAmount) external virtual returns (bool);



    



    event ClutchCollateral(

        FyTokenInterface indexed fyToken,

        address indexed liquidator,

        address indexed borrower,

        uint256 clutchedCollateralAmount

    );



    event DepositCollateral(FyTokenInterface indexed fyToken, address indexed account, uint256 collateralAmount);



    event FreeCollateral(FyTokenInterface indexed fyToken, address indexed account, uint256 collateralAmount);



    event LockCollateral(FyTokenInterface indexed fyToken, address indexed account, uint256 collateralAmount);



    event OpenVault(FyTokenInterface indexed fyToken, address indexed account);



    event SetVaultDebt(FyTokenInterface indexed fyToken, address indexed account, uint256 oldDebt, uint256 newDebt);



    event WithdrawCollateral(FyTokenInterface indexed fyToken, address indexed account, uint256 collateralAmount);

}

abstract contract Erc20Interface is Erc20Storage {

    

    function allowance(address owner, address spender) external view virtual returns (uint256);



    function balanceOf(address account) external view virtual returns (uint256);



    

    function approve(address spender, uint256 amount) external virtual returns (bool);



    function transfer(address recipient, uint256 amount) external virtual returns (bool);



    function transferFrom(

        address sender,

        address recipient,

        uint256 amount

    ) external virtual returns (bool);



    

    event Approval(address indexed owner, address indexed spender, uint256 value);



    event Burn(address indexed account, uint256 burnAmount);



    event Mint(address indexed account, uint256 mintAmount);



    event Transfer(address indexed from, address indexed to, uint256 value);

}

abstract contract Erc20RecoverInterface is Erc20RecoverStorage {

    

    function _recover(Erc20Interface token, uint256 recoverAmount) external virtual;



    function _setNonRecoverableTokens(Erc20Interface[] calldata tokens) external virtual;



    

    event Recover(address indexed admin, Erc20Interface token, uint256 recoverAmount);

    event SetNonRecoverableTokens(address indexed admin, Erc20Interface[] nonRecoverableTokens);

}

abstract contract Exponential is

    CarefulMath, 

    ExponentialStorage 

{

    

    function addExp(Exp memory a, Exp memory b) internal pure returns (MathError, Exp memory) {

        (MathError error, uint256 result) = addUInt(a.mantissa, b.mantissa);



        return (error, Exp({ mantissa: result }));

    }



    

    function divExp(Exp memory a, Exp memory b) internal pure returns (MathError, Exp memory) {

        (MathError err0, uint256 scaledNumerator) = mulUInt(a.mantissa, expScale);

        if (err0 != MathError.NO_ERROR) {

            return (err0, Exp({ mantissa: 0 }));

        }



        (MathError err1, uint256 rational) = divUInt(scaledNumerator, b.mantissa);

        if (err1 != MathError.NO_ERROR) {

            return (err1, Exp({ mantissa: 0 }));

        }



        return (MathError.NO_ERROR, Exp({ mantissa: rational }));

    }



    

    function mulExp(Exp memory a, Exp memory b) internal pure returns (MathError, Exp memory) {

        (MathError err0, uint256 doubleScaledProduct) = mulUInt(a.mantissa, b.mantissa);

        if (err0 != MathError.NO_ERROR) {

            return (err0, Exp({ mantissa: 0 }));

        }



        

        (MathError err1, uint256 doubleScaledProductWithHalfScale) = addUInt(halfExpScale, doubleScaledProduct);

        if (err1 != MathError.NO_ERROR) {

            return (err1, Exp({ mantissa: 0 }));

        }



        (MathError err2, uint256 product) = divUInt(doubleScaledProductWithHalfScale, expScale);

        

        assert(err2 == MathError.NO_ERROR);



        return (MathError.NO_ERROR, Exp({ mantissa: product }));

    }



    

    function mulExp3(

        Exp memory a,

        Exp memory b,

        Exp memory c

    ) internal pure returns (MathError, Exp memory) {

        (MathError err, Exp memory ab) = mulExp(a, b);

        if (err != MathError.NO_ERROR) {

            return (err, ab);

        }

        return mulExp(ab, c);

    }



    

    function subExp(Exp memory a, Exp memory b) internal pure returns (MathError, Exp memory) {

        (MathError error, uint256 result) = subUInt(a.mantissa, b.mantissa);



        return (error, Exp({ mantissa: result }));

    }

}

abstract contract FintrollerStorage is Exponential {

    struct Bond {

        Exp collateralizationRatio;

        uint256 debtCeiling;

        bool isBorrowAllowed;

        bool isDepositCollateralAllowed;

        bool isLiquidateBorrowAllowed;

        bool isListed;

        bool isRedeemFyTokenAllowed;

        bool isRepayBorrowAllowed;

        bool isSupplyUnderlyingAllowed;

    }



    

    mapping(FyTokenInterface => Bond) internal bonds;



    

    UniswapAnchoredViewInterface public oracle;



    

    uint256 public liquidationIncentiveMantissa;



    

    uint256 public constant oraclePricePrecisionScalar = 1.0e12;



    

    uint256 internal constant collateralizationRatioLowerBoundMantissa = 1.0e18;



    

    uint256 internal constant collateralizationRatioUpperBoundMantissa = 1.0e20;



    

    uint256 internal constant defaultCollateralizationRatioMantissa = 1.5e18;



    

    uint256 internal constant liquidationIncentiveLowerBoundMantissa = 1.0e18;



    

    uint256 internal constant liquidationIncentiveUpperBoundMantissa = 1.5e18;



    

    bool public constant isFintroller = true;

}

abstract contract FyTokenInterface is FyTokenStorage {

    

    function borrow(uint256 borrowAmount) external virtual returns (bool);



    function burn(address holder, uint256 burnAmount) external virtual returns (bool);



    function liquidateBorrow(address borrower, uint256 repayAmount) external virtual returns (bool);



    function mint(address beneficiary, uint256 borrowAmount) external virtual returns (bool);



    function repayBorrow(uint256 repayAmount) external virtual returns (bool);



    function repayBorrowBehalf(address borrower, uint256 repayAmount) external virtual returns (bool);



    function _setFintroller(FintrollerInterface newFintroller) external virtual returns (bool);



    

    event Borrow(address indexed account, uint256 repayAmount);



    event LiquidateBorrow(

        address indexed liquidator,

        address indexed borrower,

        uint256 repayAmount,

        uint256 clutchedCollateralAmount

    );



    event RepayBorrow(address indexed payer, address indexed borrower, uint256 repayAmount, uint256 newDebt);



    event SetFintroller(address indexed admin, FintrollerInterface oldFintroller, FintrollerInterface newFintroller);

}

abstract contract RedemptionPoolInterface is RedemptionPoolStorage {

    

    function redeemFyTokens(uint256 underlyingAmount) external virtual returns (bool);



    function supplyUnderlying(uint256 underlyingAmount) external virtual returns (bool);



    

    event RedeemFyTokens(address indexed account, uint256 fyTokenAmount, uint256 underlyingAmount);



    event SupplyUnderlying(address indexed account, uint256 underlyingAmount, uint256 fyTokenAmount);

}

abstract contract Admin is AdminInterface {

    

    modifier onlyAdmin() {

        require(admin == msg.sender, "ERR_NOT_ADMIN");

        _;

    }



    

    constructor() {

        address msgSender = msg.sender;

        admin = msgSender;

        emit TransferAdmin(address(0x00), msgSender);

    }



    

    function _renounceAdmin() external virtual override onlyAdmin {

        emit TransferAdmin(admin, address(0x00));

        admin = address(0x00);

    }



    

    function _transferAdmin(address newAdmin) external virtual override onlyAdmin {

        require(newAdmin != address(0x00), "ERR_SET_ADMIN_ZERO_ADDRESS");

        emit TransferAdmin(admin, newAdmin);

        admin = newAdmin;

    }

}

abstract contract Erc20Recover is

    Erc20RecoverInterface, 

    Admin 

{

    using SafeErc20 for Erc20Interface;



    

    function _setNonRecoverableTokens(Erc20Interface[] calldata tokens) external override onlyAdmin {

        

        require(isInitialized == false, "ERR_INITALIZED");



        

        uint256 length = tokens.length;

        for (uint256 i = 0; i < length; i += 1) {

            tokens[i].symbol();

            nonRecoverableTokens.push(tokens[i]);

        }



        

        isInitialized = true;



        emit SetNonRecoverableTokens(admin, tokens);

    }



    

    function _recover(Erc20Interface token, uint256 recoverAmount) external override onlyAdmin {

        

        require(isInitialized == true, "ERR_NOT_INITALIZED");

        require(recoverAmount > 0, "ERR_RECOVER_ZERO");



        bytes32 tokenSymbolHash = keccak256(bytes(token.symbol()));

        uint256 length = nonRecoverableTokens.length;



        

        for (uint256 i = 0; i < length; i += 1) {

            require(

                address(token) != address(nonRecoverableTokens[i]) &&

                    tokenSymbolHash != keccak256(bytes(nonRecoverableTokens[i].symbol())),

                "ERR_RECOVER_NON_RECOVERABLE_TOKEN"

            );

        }



        

        token.safeTransfer(admin, recoverAmount);



        emit Recover(admin, token, recoverAmount);

    }

}

abstract contract FintrollerInterface is FintrollerStorage {

    



    function getBond(FyTokenInterface fyToken)

        external

        view

        virtual

        returns (

            uint256 debtCeiling,

            uint256 collateralizationRatioMantissa,

            bool isBorrowAllowed,

            bool isDepositCollateralAllowed,

            bool isLiquidateBorrowAllowed,

            bool isListed,

            bool isRedeemFyTokenAllowed,

            bool isRepayBorrowAllowed,

            bool isSupplyUnderlyingAllowed

        );



    function getBorrowAllowed(FyTokenInterface fyToken) external view virtual returns (bool);



    function getBondDebtCeiling(FyTokenInterface fyToken) external view virtual returns (uint256);



    function getBondCollateralizationRatio(FyTokenInterface fyToken) external view virtual returns (uint256);



    function getDepositCollateralAllowed(FyTokenInterface fyToken) external view virtual returns (bool);



    function getLiquidateBorrowAllowed(FyTokenInterface fyToken) external view virtual returns (bool);



    function getRedeemFyTokensAllowed(FyTokenInterface fyToken) external view virtual returns (bool);



    function getRepayBorrowAllowed(FyTokenInterface fyToken) external view virtual returns (bool);



    function getSupplyUnderlyingAllowed(FyTokenInterface fyToken) external view virtual returns (bool);



    



    function listBond(FyTokenInterface fyToken) external virtual returns (bool);



    function setBorrowAllowed(FyTokenInterface fyToken, bool state) external virtual returns (bool);



    function setCollateralizationRatio(FyTokenInterface fyToken, uint256 newCollateralizationRatioMantissa)

        external

        virtual

        returns (bool);



    function setDebtCeiling(FyTokenInterface fyToken, uint256 newDebtCeiling) external virtual returns (bool);



    function setDepositCollateralAllowed(FyTokenInterface fyToken, bool state) external virtual returns (bool);



    function setLiquidateBorrowAllowed(FyTokenInterface fyToken, bool state) external virtual returns (bool);



    function setLiquidationIncentive(uint256 newLiquidationIncentiveMantissa) external virtual returns (bool);



    function setOracle(UniswapAnchoredViewInterface newOracle) external virtual returns (bool);



    function setRedeemFyTokensAllowed(FyTokenInterface fyToken, bool state) external virtual returns (bool);



    function setRepayBorrowAllowed(FyTokenInterface fyToken, bool state) external virtual returns (bool);



    function setSupplyUnderlyingAllowed(FyTokenInterface fyToken, bool state) external virtual returns (bool);



    

    event ListBond(address indexed admin, FyTokenInterface indexed fyToken);



    event SetBorrowAllowed(address indexed admin, FyTokenInterface indexed fyToken, bool state);



    event SetCollateralizationRatio(

        address indexed admin,

        FyTokenInterface indexed fyToken,

        uint256 oldCollateralizationRatio,

        uint256 newCollateralizationRatio

    );



    event SetDebtCeiling(

        address indexed admin,

        FyTokenInterface indexed fyToken,

        uint256 oldDebtCeiling,

        uint256 newDebtCeiling

    );



    event SetDepositCollateralAllowed(address indexed admin, FyTokenInterface indexed fyToken, bool state);



    event SetLiquidateBorrowAllowed(address indexed admin, FyTokenInterface indexed fyToken, bool state);



    event SetLiquidationIncentive(

        address indexed admin,

        uint256 oldLiquidationIncentive,

        uint256 newLiquidationIncentive

    );



    event SetRedeemFyTokensAllowed(address indexed admin, FyTokenInterface indexed fyToken, bool state);



    event SetRepayBorrowAllowed(address indexed admin, FyTokenInterface indexed fyToken, bool state);



    event SetOracle(address indexed admin, address oldOracle, address newOracle);



    event SetSupplyUnderlyingAllowed(address indexed admin, FyTokenInterface indexed fyToken, bool state);

}

contract RedemptionPool is

    CarefulMath, 

    ReentrancyGuard, 

    RedemptionPoolInterface, 

    Admin, 

    Erc20Recover 

{

    using SafeErc20 for Erc20Interface;



    

    constructor(FintrollerInterface fintroller_, FyTokenInterface fyToken_) Admin() {

        

        fintroller = fintroller_;

        fintroller.isFintroller();



        

        fyToken = fyToken_;

    }



    struct RedeemFyTokensLocalVars {

        MathError mathErr;

        uint256 newUnderlyingTotalSupply;

        uint256 underlyingPrecisionScalar;

        uint256 underlyingAmount;

    }



    

    function redeemFyTokens(uint256 fyTokenAmount) external override nonReentrant returns (bool) {

        RedeemFyTokensLocalVars memory vars;



        

        require(block.timestamp >= fyToken.expirationTime(), "ERR_BOND_NOT_MATURED");



        

        require(fyTokenAmount > 0, "ERR_REDEEM_FYTOKENS_ZERO");



        

        require(fintroller.getRedeemFyTokensAllowed(fyToken), "ERR_REDEEM_FYTOKENS_NOT_ALLOWED");



        

        require(fyTokenAmount <= totalUnderlyingSupply, "ERR_REDEEM_FYTOKENS_INSUFFICIENT_UNDERLYING");



        

        vars.underlyingPrecisionScalar = fyToken.underlyingPrecisionScalar();

        if (vars.underlyingPrecisionScalar != 1) {

            (vars.mathErr, vars.underlyingAmount) = divUInt(fyTokenAmount, vars.underlyingPrecisionScalar);

            require(vars.mathErr == MathError.NO_ERROR, "ERR_REDEEM_FYTOKENS_MATH_ERROR");

        } else {

            vars.underlyingAmount = fyTokenAmount;

        }



        

        (vars.mathErr, vars.newUnderlyingTotalSupply) = subUInt(totalUnderlyingSupply, vars.underlyingAmount);

        assert(vars.mathErr == MathError.NO_ERROR);

        totalUnderlyingSupply = vars.newUnderlyingTotalSupply;



        

        require(fyToken.burn(msg.sender, fyTokenAmount), "ERR_SUPPLY_UNDERLYING_CALL_BURN");



        

        fyToken.underlying().safeTransfer(msg.sender, vars.underlyingAmount);



        emit RedeemFyTokens(msg.sender, fyTokenAmount, vars.underlyingAmount);



        return true;

    }



    struct SupplyUnderlyingLocalVars {

        MathError mathErr;

        uint256 newUnderlyingTotalSupply;

        uint256 underlyingPrecisionScalar;

        uint256 fyTokenAmount;

    }



    

    function supplyUnderlying(uint256 underlyingAmount) external override nonReentrant returns (bool) {

        SupplyUnderlyingLocalVars memory vars;



        

        require(block.timestamp < fyToken.expirationTime(), "ERR_BOND_MATURED");



        

        require(underlyingAmount > 0, "ERR_SUPPLY_UNDERLYING_ZERO");



        

        require(fintroller.getSupplyUnderlyingAllowed(fyToken), "ERR_SUPPLY_UNDERLYING_NOT_ALLOWED");



        

        (vars.mathErr, vars.newUnderlyingTotalSupply) = addUInt(totalUnderlyingSupply, underlyingAmount);

        require(vars.mathErr == MathError.NO_ERROR, "ERR_SUPPLY_UNDERLYING_MATH_ERROR");

        totalUnderlyingSupply = vars.newUnderlyingTotalSupply;



        

        vars.underlyingPrecisionScalar = fyToken.underlyingPrecisionScalar();

        if (vars.underlyingPrecisionScalar != 1) {

            (vars.mathErr, vars.fyTokenAmount) = mulUInt(underlyingAmount, vars.underlyingPrecisionScalar);

            require(vars.mathErr == MathError.NO_ERROR, "ERR_SUPPLY_UNDERLYING_MATH_ERROR");

        } else {

            vars.fyTokenAmount = underlyingAmount;

        }



        

        require(fyToken.mint(msg.sender, vars.fyTokenAmount), "ERR_SUPPLY_UNDERLYING_CALL_MINT");



        

        fyToken.underlying().safeTransferFrom(msg.sender, address(this), underlyingAmount);



        emit SupplyUnderlying(msg.sender, underlyingAmount, vars.fyTokenAmount);



        return true;

    }

}
