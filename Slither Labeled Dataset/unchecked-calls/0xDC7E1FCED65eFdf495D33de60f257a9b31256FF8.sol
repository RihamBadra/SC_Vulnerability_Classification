pragma solidity 0.7.4;

enum MathError { NO_ERROR, DIVISION_BY_ZERO, INTEGER_OVERFLOW, INTEGER_UNDERFLOW, MODULO_BY_ZERO }

library Address {

    

    function isContract(address account) internal view returns (bool) {

        

        

        

        bytes32 codehash;

        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;

        

        assembly {

            codehash := extcodehash(account)

        }

        return (codehash != accountHash && codehash != 0x0);

    }

}

abstract contract AdminStorage {

    

    address public admin;

}

abstract contract BalanceSheetStorage {

    struct Vault {

        uint256 debt;

        uint256 freeCollateral;

        uint256 lockedCollateral;

        bool isOpen;

    }



    

    FintrollerInterface public fintroller;



    

    mapping(address => mapping(address => Vault)) internal vaults;



    

    bool public constant isBalanceSheet = true;

}

abstract contract CarefulMath {

    

    function addUInt(uint256 a, uint256 b) internal pure returns (MathError, uint256) {

        uint256 c = a + b;



        if (c >= a) {

            return (MathError.NO_ERROR, c);

        } else {

            return (MathError.INTEGER_OVERFLOW, 0);

        }

    }



    

    function addThenSubUInt(

        uint256 a,

        uint256 b,

        uint256 c

    ) internal pure returns (MathError, uint256) {

        (MathError err0, uint256 sum) = addUInt(a, b);



        if (err0 != MathError.NO_ERROR) {

            return (err0, 0);

        }



        return subUInt(sum, c);

    }



    

    function divUInt(uint256 a, uint256 b) internal pure returns (MathError, uint256) {

        if (b == 0) {

            return (MathError.DIVISION_BY_ZERO, 0);

        }



        return (MathError.NO_ERROR, a / b);

    }



    

    function modUInt(uint256 a, uint256 b) internal pure returns (MathError, uint256) {

        if (b == 0) {

            return (MathError.MODULO_BY_ZERO, 0);

        }



        return (MathError.NO_ERROR, a % b);

    }



    

    function mulUInt(uint256 a, uint256 b) internal pure returns (MathError, uint256) {

        if (a == 0) {

            return (MathError.NO_ERROR, 0);

        }



        uint256 c = a * b;



        if (c / a != b) {

            return (MathError.INTEGER_OVERFLOW, 0);

        } else {

            return (MathError.NO_ERROR, c);

        }

    }



    

    function subUInt(uint256 a, uint256 b) internal pure returns (MathError, uint256) {

        if (b <= a) {

            return (MathError.NO_ERROR, a - b);

        } else {

            return (MathError.INTEGER_UNDERFLOW, 0);

        }

    }

}

abstract contract Erc20Storage {

    

    uint8 public decimals;



    

    string public name;



    

    string public symbol;



    

    uint256 public totalSupply;



    mapping(address => mapping(address => uint256)) internal allowances;



    mapping(address => uint256) internal balances;

}

abstract contract ExponentialStorage {

    struct Exp {

        uint256 mantissa;

    }



    

    uint256 internal constant expScale = 1e18;

    uint256 internal constant halfExpScale = expScale / 2;

    uint256 internal constant mantissaOne = expScale;

}

abstract contract FyTokenStorage {

    

    struct Vault {

        uint256 debt;

        uint256 freeCollateral;

        uint256 lockedCollateral;

        bool isOpen;

    }



    



    

    BalanceSheetInterface public balanceSheet;



    

    Erc20Interface public collateral;



    

    uint256 public collateralPrecisionScalar;



    

    uint256 public expirationTime;



    

    FintrollerInterface public fintroller;



    

    RedemptionPoolInterface public redemptionPool;



    

    Erc20Interface public underlying;



    

    uint256 public underlyingPrecisionScalar;



    

    bool public constant isFyToken = true;

}

library OraclePriceUtils {

    

    function getAdjustedPrice(

        UniswapAnchoredViewInterface oracle,

        string memory symbol,

        uint256 precisionScalar

    ) internal view returns (MathError, uint256) {

        string memory actualSymbol = getActualSymbol(symbol);

        uint256 price = oracle.price(actualSymbol);

        require(price > 0, "ERR_PRICE_ZERO");



        

        uint256 adjustedPrice = price * precisionScalar;

        if (adjustedPrice / price != precisionScalar) {

            return (MathError.INTEGER_OVERFLOW, 0);

        } else {

            return (MathError.NO_ERROR, adjustedPrice);

        }

    }



    

    function areStringsEqual(string memory a, string memory b) internal pure returns (bool) {

        if (bytes(a).length != bytes(b).length) {

            return false;

        } else {

            return keccak256(abi.encodePacked(a)) == keccak256(abi.encodePacked(b));

        }

    }



    

    function getActualSymbol(string memory symbol) internal pure returns (string memory) {

        if (areStringsEqual(symbol, "WETH")) {

            return "ETH";

        } else {

            return symbol;

        }

    }

}

abstract contract RedemptionPoolStorage {

    

    FintrollerInterface public fintroller;



    

    uint256 public totalUnderlyingSupply;



    

    FyTokenInterface public fyToken;



    

    bool public constant isRedemptionPool = true;

}

abstract contract ReentrancyGuard {

    bool private notEntered;



    

    constructor() {

        notEntered = true;

    }



    

    modifier nonReentrant() {

        

        require(notEntered, "ERR_REENTRANT_CALL");



        

        notEntered = false;



        _;



        

        notEntered = true;

    }

}

library SafeErc20 {

    using Address for address;



    



    function safeTransfer(

        Erc20Interface token,

        address to,

        uint256 value

    ) internal {

        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));

    }



    function safeTransferFrom(

        Erc20Interface token,

        address from,

        address to,

        uint256 value

    ) internal {

        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));

    }



    



    

    function callOptionalReturn(Erc20Interface token, bytes memory data) private {

        

        

        

        bytes memory returndata = functionCallWithValue(address(token), data, "ERR_SAFE_ERC20_LOW_LEVEL_CALL");

        if (returndata.length > 0) {

            

            require(abi.decode(returndata, (bool)), "ERR_SAFE_ERC20_ERC20_OPERATION");

        }

    }



    function functionCallWithValue(

        address target,

        bytes memory data,

        string memory errorMessage

    ) private returns (bytes memory) {

        require(target.isContract(), "ERR_SAFE_ERC20_CALL_TO_NON_CONTRACT");



        

        (bool success, bytes memory returndata) = target.call(data);

        if (success) {

            return returndata;

        } else {

            

            if (returndata.length > 0) {

                



                

                assembly {

                    let returndata_size := mload(returndata)

                    revert(add(32, returndata), returndata_size)

                }

            } else {

                revert(errorMessage);

            }

        }

    }

}

interface UniswapAnchoredViewInterface {

    

    function price(string memory symbol) external view returns (uint256);

}

abstract contract AdminInterface is AdminStorage {

    

    function _renounceAdmin() external virtual;



    function _transferAdmin(address newAdmin) external virtual;



    

    event TransferAdmin(address indexed oldAdmin, address indexed newAdmin);

}

abstract contract BalanceSheetInterface is BalanceSheetStorage {

    

    function getClutchableCollateral(FyTokenInterface fyToken, uint256 repayAmount)

        external

        view

        virtual

        returns (uint256);



    function getCurrentCollateralizationRatio(FyTokenInterface fyToken, address account)

        public

        view

        virtual

        returns (uint256);



    function getHypotheticalCollateralizationRatio(

        FyTokenInterface fyToken,

        address account,

        uint256 lockedCollateral,

        uint256 debt

    ) public view virtual returns (uint256);



    function getVault(FyTokenInterface fyToken, address account)

        external

        view

        virtual

        returns (

            uint256,

            uint256,

            uint256,

            bool

        );



    function getVaultDebt(FyTokenInterface fyToken, address account) external view virtual returns (uint256);



    function getVaultLockedCollateral(FyTokenInterface fyToken, address account)

        external

        view

        virtual

        returns (uint256);



    function isAccountUnderwater(FyTokenInterface fyToken, address account) external view virtual returns (bool);



    function isVaultOpen(FyTokenInterface fyToken, address account) external view virtual returns (bool);



    



    function clutchCollateral(

        FyTokenInterface fyToken,

        address liquidator,

        address borrower,

        uint256 clutchedCollateralAmount

    ) external virtual returns (bool);



    function depositCollateral(FyTokenInterface fyToken, uint256 collateralAmount) external virtual returns (bool);



    function freeCollateral(FyTokenInterface fyToken, uint256 collateralAmount) external virtual returns (bool);



    function lockCollateral(FyTokenInterface fyToken, uint256 collateralAmount) external virtual returns (bool);



    function openVault(FyTokenInterface fyToken) external virtual returns (bool);



    function setVaultDebt(

        FyTokenInterface fyToken,

        address account,

        uint256 newVaultDebt

    ) external virtual returns (bool);



    function withdrawCollateral(FyTokenInterface fyToken, uint256 collateralAmount) external virtual returns (bool);



    



    event ClutchCollateral(

        FyTokenInterface indexed fyToken,

        address indexed liquidator,

        address indexed borrower,

        uint256 clutchedCollateralAmount

    );



    event DepositCollateral(FyTokenInterface indexed fyToken, address indexed account, uint256 collateralAmount);



    event FreeCollateral(FyTokenInterface indexed fyToken, address indexed account, uint256 collateralAmount);



    event LockCollateral(FyTokenInterface indexed fyToken, address indexed account, uint256 collateralAmount);



    event OpenVault(FyTokenInterface indexed fyToken, address indexed account);



    event SetVaultDebt(FyTokenInterface indexed fyToken, address indexed account, uint256 oldDebt, uint256 newDebt);



    event WithdrawCollateral(FyTokenInterface indexed fyToken, address indexed account, uint256 collateralAmount);

}

abstract contract Erc20Interface is Erc20Storage {

    

    function allowance(address owner, address spender) external view virtual returns (uint256);



    function balanceOf(address account) external view virtual returns (uint256);



    

    function approve(address spender, uint256 amount) external virtual returns (bool);



    function transfer(address recipient, uint256 amount) external virtual returns (bool);



    function transferFrom(

        address sender,

        address recipient,

        uint256 amount

    ) external virtual returns (bool);



    

    event Approval(address indexed owner, address indexed spender, uint256 value);



    event Burn(address indexed account, uint256 burnAmount);



    event Mint(address indexed account, uint256 mintAmount);



    event Transfer(address indexed from, address indexed to, uint256 value);

}

abstract contract Exponential is

    CarefulMath, 

    ExponentialStorage 

{

    

    function addExp(Exp memory a, Exp memory b) internal pure returns (MathError, Exp memory) {

        (MathError error, uint256 result) = addUInt(a.mantissa, b.mantissa);



        return (error, Exp({ mantissa: result }));

    }



    

    function divExp(Exp memory a, Exp memory b) internal pure returns (MathError, Exp memory) {

        (MathError err0, uint256 scaledNumerator) = mulUInt(a.mantissa, expScale);

        if (err0 != MathError.NO_ERROR) {

            return (err0, Exp({ mantissa: 0 }));

        }



        (MathError err1, uint256 rational) = divUInt(scaledNumerator, b.mantissa);

        if (err1 != MathError.NO_ERROR) {

            return (err1, Exp({ mantissa: 0 }));

        }



        return (MathError.NO_ERROR, Exp({ mantissa: rational }));

    }



    

    function mulExp(Exp memory a, Exp memory b) internal pure returns (MathError, Exp memory) {

        (MathError err0, uint256 doubleScaledProduct) = mulUInt(a.mantissa, b.mantissa);

        if (err0 != MathError.NO_ERROR) {

            return (err0, Exp({ mantissa: 0 }));

        }



        

        (MathError err1, uint256 doubleScaledProductWithHalfScale) = addUInt(halfExpScale, doubleScaledProduct);

        if (err1 != MathError.NO_ERROR) {

            return (err1, Exp({ mantissa: 0 }));

        }



        (MathError err2, uint256 product) = divUInt(doubleScaledProductWithHalfScale, expScale);

        

        assert(err2 == MathError.NO_ERROR);



        return (MathError.NO_ERROR, Exp({ mantissa: product }));

    }



    

    function mulExp3(

        Exp memory a,

        Exp memory b,

        Exp memory c

    ) internal pure returns (MathError, Exp memory) {

        (MathError err, Exp memory ab) = mulExp(a, b);

        if (err != MathError.NO_ERROR) {

            return (err, ab);

        }

        return mulExp(ab, c);

    }



    

    function subExp(Exp memory a, Exp memory b) internal pure returns (MathError, Exp memory) {

        (MathError error, uint256 result) = subUInt(a.mantissa, b.mantissa);



        return (error, Exp({ mantissa: result }));

    }

}

abstract contract FintrollerStorage is Exponential {

    struct Bond {

        Exp collateralizationRatio;

        uint256 debtCeiling;

        bool isBorrowAllowed;

        bool isDepositCollateralAllowed;

        bool isLiquidateBorrowAllowed;

        bool isListed;

        bool isRedeemFyTokenAllowed;

        bool isRepayBorrowAllowed;

        bool isSupplyUnderlyingAllowed;

    }



    

    mapping(FyTokenInterface => Bond) internal bonds;



    

    UniswapAnchoredViewInterface public oracle;



    

    uint256 public liquidationIncentiveMantissa;



    

    uint256 public constant oraclePricePrecisionScalar = 1.0e12;



    

    uint256 internal constant collateralizationRatioLowerBoundMantissa = 1.0e18;



    

    uint256 internal constant collateralizationRatioUpperBoundMantissa = 1.0e20;



    

    uint256 internal constant defaultCollateralizationRatioMantissa = 1.5e18;



    

    uint256 internal constant liquidationIncentiveLowerBoundMantissa = 1.0e18;



    

    uint256 internal constant liquidationIncentiveUpperBoundMantissa = 1.5e18;



    

    bool public constant isFintroller = true;

}

abstract contract FyTokenInterface is FyTokenStorage {

    

    function borrow(uint256 borrowAmount) external virtual returns (bool);



    function burn(address holder, uint256 burnAmount) external virtual returns (bool);



    function liquidateBorrow(address borrower, uint256 repayAmount) external virtual returns (bool);



    function mint(address beneficiary, uint256 borrowAmount) external virtual returns (bool);



    function repayBorrow(uint256 repayAmount) external virtual returns (bool);



    function repayBorrowBehalf(address borrower, uint256 repayAmount) external virtual returns (bool);



    function _setFintroller(FintrollerInterface newFintroller) external virtual returns (bool);



    

    event Borrow(address indexed account, uint256 repayAmount);



    event LiquidateBorrow(

        address indexed liquidator,

        address indexed borrower,

        uint256 repayAmount,

        uint256 clutchedCollateralAmount

    );



    event RepayBorrow(address indexed payer, address indexed borrower, uint256 repayAmount, uint256 newDebt);



    event SetFintroller(address indexed admin, FintrollerInterface oldFintroller, FintrollerInterface newFintroller);

}

abstract contract RedemptionPoolInterface is RedemptionPoolStorage {

    

    function redeemFyTokens(uint256 underlyingAmount) external virtual returns (bool);



    function supplyUnderlying(uint256 underlyingAmount) external virtual returns (bool);



    

    event RedeemFyTokens(address indexed account, uint256 fyTokenAmount, uint256 underlyingAmount);



    event SupplyUnderlying(address indexed account, uint256 underlyingAmount, uint256 fyTokenAmount);

}

abstract contract Admin is AdminInterface {

    

    modifier onlyAdmin() {

        require(admin == msg.sender, "ERR_NOT_ADMIN");

        _;

    }



    

    constructor() {

        address msgSender = msg.sender;

        admin = msgSender;

        emit TransferAdmin(address(0x00), msgSender);

    }



    

    function _renounceAdmin() external virtual override onlyAdmin {

        emit TransferAdmin(admin, address(0x00));

        admin = address(0x00);

    }



    

    function _transferAdmin(address newAdmin) external virtual override onlyAdmin {

        require(newAdmin != address(0x00), "ERR_SET_ADMIN_ZERO_ADDRESS");

        emit TransferAdmin(admin, newAdmin);

        admin = newAdmin;

    }

}

contract BalanceSheet is

    ReentrancyGuard, 

    BalanceSheetInterface, 

    Admin, 

    Exponential 

{

    using OraclePriceUtils for UniswapAnchoredViewInterface;

    using SafeErc20 for Erc20Interface;



    modifier isVaultOpenForMsgSender(FyTokenInterface fyToken) {

        require(vaults[address(fyToken)][msg.sender].isOpen, "ERR_VAULT_NOT_OPEN");

        _;

    }



    

    constructor(FintrollerInterface fintroller_) Admin() {

        

        fintroller = fintroller_;

        fintroller.isFintroller();

    }



    



    struct CalculateClutchableCollateralLocalVars {

        MathError mathErr;

        Exp clutchableCollateralAmountUpscaled;

        uint256 clutchableCollateralAmount;

        uint256 collateralPrecisionScalar;

        uint256 collateralPriceUpscaled;

        uint256 liquidationIncentiveMantissa;

        Exp numerator;

        uint256 oraclePricePrecisionScalar;

        uint256 underlyingPriceUpscaled;

    }



    

    function getClutchableCollateral(FyTokenInterface fyToken, uint256 repayAmount)

        external

        view

        override

        returns (uint256)

    {

        CalculateClutchableCollateralLocalVars memory vars;



        

        require(repayAmount > 0, "ERR_GET_CLUTCHABLE_COLLATERAL_ZERO");



        

        vars.liquidationIncentiveMantissa = fintroller.liquidationIncentiveMantissa();

        if (vars.liquidationIncentiveMantissa == 0) {

            return 0;

        }



        

        UniswapAnchoredViewInterface oracle = fintroller.oracle();

        vars.oraclePricePrecisionScalar = fintroller.oraclePricePrecisionScalar();

        (vars.mathErr, vars.underlyingPriceUpscaled) = oracle.getAdjustedPrice(

            fyToken.underlying().symbol(),

            vars.oraclePricePrecisionScalar

        );

        require(vars.mathErr == MathError.NO_ERROR, "ERR_GET_CLUTCHABLE_COLLATERAL_MATH_ERROR");



        

        (vars.mathErr, vars.collateralPriceUpscaled) = oracle.getAdjustedPrice(

            fyToken.collateral().symbol(),

            vars.oraclePricePrecisionScalar

        );

        require(vars.mathErr == MathError.NO_ERROR, "ERR_GET_CLUTCHABLE_COLLATERAL_MATH_ERROR");



        

        (vars.mathErr, vars.numerator) = mulExp3(

            Exp({ mantissa: repayAmount }),

            Exp({ mantissa: vars.liquidationIncentiveMantissa }),

            Exp({ mantissa: vars.underlyingPriceUpscaled })

        );

        require(vars.mathErr == MathError.NO_ERROR, "ERR_GET_CLUTCHABLE_COLLATERAL_MATH_ERROR");



        

        (vars.mathErr, vars.clutchableCollateralAmountUpscaled) = divExp(

            vars.numerator,

            Exp({ mantissa: vars.collateralPriceUpscaled })

        );

        require(vars.mathErr == MathError.NO_ERROR, "ERR_GET_CLUTCHABLE_COLLATERAL_MATH_ERROR");



        

        vars.collateralPrecisionScalar = fyToken.collateralPrecisionScalar();

        if (vars.collateralPrecisionScalar != 1) {

            (vars.mathErr, vars.clutchableCollateralAmount) = divUInt(

                vars.clutchableCollateralAmountUpscaled.mantissa,

                vars.collateralPrecisionScalar

            );

            require(vars.mathErr == MathError.NO_ERROR, "ERR_GET_CLUTCHABLE_COLLATERAL_MATH_ERROR");

        } else {

            vars.clutchableCollateralAmount = vars.clutchableCollateralAmountUpscaled.mantissa;

        }



        return vars.clutchableCollateralAmount;

    }



    

    function getCurrentCollateralizationRatio(FyTokenInterface fyToken, address account)

        public

        view

        override

        returns (uint256)

    {

        Vault memory vault = vaults[address(fyToken)][account];

        return getHypotheticalCollateralizationRatio(fyToken, account, vault.lockedCollateral, vault.debt);

    }



    struct GetHypotheticalAccountLiquidityLocalVars {

        MathError mathErr;

        uint256 collateralPriceUpscaled;

        uint256 collateralPrecisionScalar;

        uint256 collateralizationRatioMantissa;

        Exp debtValueUsd;

        Exp hypotheticalCollateralizationRatio;

        Exp lockedCollateralValueUsd;

        uint256 lockedCollateralUpscaled;

        uint256 oraclePricePrecisionScalar;

        uint256 underlyingPriceUpscaled;

        uint256 underlyingPrecisionScalar;

    }



    

    function getHypotheticalCollateralizationRatio(

        FyTokenInterface fyToken,

        address account,

        uint256 lockedCollateral,

        uint256 debt

    ) public view override returns (uint256) {

        GetHypotheticalAccountLiquidityLocalVars memory vars;



        

        require(vaults[address(fyToken)][account].isOpen, "ERR_VAULT_NOT_OPEN");



        

        if (lockedCollateral == 0) {

            return 0;

        }

        require(debt > 0, "ERR_GET_HYPOTHETICAL_COLLATERALIZATION_RATIO_DEBT_ZERO");



        

        UniswapAnchoredViewInterface oracle = fintroller.oracle();

        vars.oraclePricePrecisionScalar = fintroller.oraclePricePrecisionScalar();

        (vars.mathErr, vars.collateralPriceUpscaled) = oracle.getAdjustedPrice(

            fyToken.collateral().symbol(),

            vars.oraclePricePrecisionScalar

        );

        require(vars.mathErr == MathError.NO_ERROR, "ERR_GET_HYPOTHETICAL_COLLATERALIZATION_RATIO_MATH_ERROR");



        

        (vars.mathErr, vars.underlyingPriceUpscaled) = oracle.getAdjustedPrice(

            fyToken.underlying().symbol(),

            vars.oraclePricePrecisionScalar

        );

        require(vars.mathErr == MathError.NO_ERROR, "ERR_GET_HYPOTHETICAL_COLLATERALIZATION_RATIO_MATH_ERROR");



        

        vars.collateralPrecisionScalar = fyToken.collateralPrecisionScalar();

        if (vars.collateralPrecisionScalar != 1) {

            (vars.mathErr, vars.lockedCollateralUpscaled) = mulUInt(lockedCollateral, vars.collateralPrecisionScalar);

            require(vars.mathErr == MathError.NO_ERROR, "ERR_GET_HYPOTHETICAL_COLLATERALIZATION_RATIO_MATH_ERROR");

        } else {

            vars.lockedCollateralUpscaled = lockedCollateral;

        }



        

        (vars.mathErr, vars.lockedCollateralValueUsd) = mulExp(

            Exp({ mantissa: vars.lockedCollateralUpscaled }),

            Exp({ mantissa: vars.collateralPriceUpscaled })

        );

        require(vars.mathErr == MathError.NO_ERROR, "ERR_GET_HYPOTHETICAL_COLLATERALIZATION_RATIO_MATH_ERROR");



        

        (vars.mathErr, vars.debtValueUsd) = mulExp(

            Exp({ mantissa: debt }),

            Exp({ mantissa: vars.underlyingPriceUpscaled })

        );

        require(vars.mathErr == MathError.NO_ERROR, "ERR_GET_HYPOTHETICAL_COLLATERALIZATION_RATIO_MATH_ERROR");



        

        (vars.mathErr, vars.hypotheticalCollateralizationRatio) = divExp(

            vars.lockedCollateralValueUsd,

            vars.debtValueUsd

        );

        require(vars.mathErr == MathError.NO_ERROR, "ERR_GET_HYPOTHETICAL_COLLATERALIZATION_RATIO_MATH_ERROR");



        return vars.hypotheticalCollateralizationRatio.mantissa;

    }



    

    function getVault(FyTokenInterface fyToken, address account)

        external

        view

        override

        returns (

            uint256,

            uint256,

            uint256,

            bool

        )

    {

        return (

            vaults[address(fyToken)][account].debt,

            vaults[address(fyToken)][account].freeCollateral,

            vaults[address(fyToken)][account].lockedCollateral,

            vaults[address(fyToken)][account].isOpen

        );

    }



    

    function getVaultDebt(FyTokenInterface fyToken, address account) external view override returns (uint256) {

        return vaults[address(fyToken)][account].debt;

    }



    

    function getVaultLockedCollateral(FyTokenInterface fyToken, address account)

        external

        view

        override

        returns (uint256)

    {

        return vaults[address(fyToken)][account].lockedCollateral;

    }



    

    function isAccountUnderwater(FyTokenInterface fyToken, address account) external view override returns (bool) {

        Vault memory vault = vaults[address(fyToken)][account];

        if (!vault.isOpen || vault.debt == 0) {

            return false;

        }

        uint256 currentCollateralizationRatioMantissa = getCurrentCollateralizationRatio(fyToken, account);

        uint256 thresholdCollateralizationRatioMantissa = fintroller.getBondCollateralizationRatio(fyToken);

        return currentCollateralizationRatioMantissa < thresholdCollateralizationRatioMantissa;

    }



    

    function isVaultOpen(FyTokenInterface fyToken, address account) external view override returns (bool) {

        return vaults[address(fyToken)][account].isOpen;

    }



    



    

    function clutchCollateral(

        FyTokenInterface fyToken,

        address liquidator,

        address borrower,

        uint256 collateralAmount

    ) external override nonReentrant returns (bool) {

        

        require(msg.sender == address(fyToken), "ERR_CLUTCH_COLLATERAL_NOT_AUTHORIZED");



        

        uint256 lockedCollateral = vaults[address(fyToken)][borrower].lockedCollateral;

        require(lockedCollateral >= collateralAmount, "ERR_INSUFFICIENT_LOCKED_COLLATERAL");



        

        MathError mathErr;

        uint256 newLockedCollateral;

        (mathErr, newLockedCollateral) = subUInt(lockedCollateral, collateralAmount);

        assert(mathErr == MathError.NO_ERROR);



        

        vaults[address(fyToken)][borrower].lockedCollateral = newLockedCollateral;



        

        fyToken.collateral().safeTransfer(liquidator, collateralAmount);



        emit ClutchCollateral(fyToken, liquidator, borrower, collateralAmount);



        return true;

    }



    

    function depositCollateral(FyTokenInterface fyToken, uint256 collateralAmount)

        external

        override

        isVaultOpenForMsgSender(fyToken)

        nonReentrant

        returns (bool)

    {

        

        require(collateralAmount > 0, "ERR_DEPOSIT_COLLATERAL_ZERO");



        

        require(fintroller.getDepositCollateralAllowed(fyToken), "ERR_DEPOSIT_COLLATERAL_NOT_ALLOWED");



        

        MathError mathErr;

        uint256 hypotheticalFreeCollateral;

        (mathErr, hypotheticalFreeCollateral) = addUInt(

            vaults[address(fyToken)][msg.sender].freeCollateral,

            collateralAmount

        );

        require(mathErr == MathError.NO_ERROR, "ERR_DEPOSIT_COLLATERAL_MATH_ERROR");

        vaults[address(fyToken)][msg.sender].freeCollateral = hypotheticalFreeCollateral;



        

        fyToken.collateral().safeTransferFrom(msg.sender, address(this), collateralAmount);



        emit DepositCollateral(fyToken, msg.sender, collateralAmount);



        return true;

    }



    struct FreeCollateralLocalVars {

        MathError mathErr;

        uint256 collateralizationRatioMantissa;

        uint256 hypotheticalCollateralizationRatioMantissa;

        uint256 newFreeCollateral;

        uint256 newLockedCollateral;

    }



    

    function freeCollateral(FyTokenInterface fyToken, uint256 collateralAmount)

        external

        override

        isVaultOpenForMsgSender(fyToken)

        returns (bool)

    {

        FreeCollateralLocalVars memory vars;



        

        require(collateralAmount > 0, "ERR_FREE_COLLATERAL_ZERO");



        

        Vault memory vault = vaults[address(fyToken)][msg.sender];

        require(vault.lockedCollateral >= collateralAmount, "ERR_INSUFFICIENT_LOCKED_COLLATERAL");



        

        (vars.mathErr, vars.newLockedCollateral) = subUInt(vault.lockedCollateral, collateralAmount);

        assert(vars.mathErr == MathError.NO_ERROR);



        

        if (vault.debt > 0) {

            vars.hypotheticalCollateralizationRatioMantissa = getHypotheticalCollateralizationRatio(

                fyToken,

                msg.sender,

                vars.newLockedCollateral,

                vault.debt

            );

            vars.collateralizationRatioMantissa = fintroller.getBondCollateralizationRatio(fyToken);

            require(

                vars.hypotheticalCollateralizationRatioMantissa >= vars.collateralizationRatioMantissa,

                "ERR_BELOW_COLLATERALIZATION_RATIO"

            );

        }



        

        vaults[address(fyToken)][msg.sender].lockedCollateral = vars.newLockedCollateral;

        (vars.mathErr, vars.newFreeCollateral) = addUInt(vault.freeCollateral, collateralAmount);

        require(vars.mathErr == MathError.NO_ERROR, "ERR_FREE_COLLATERAL_MATH_ERROR");

        vaults[address(fyToken)][msg.sender].freeCollateral = vars.newFreeCollateral;



        emit FreeCollateral(fyToken, msg.sender, collateralAmount);



        return true;

    }



    

    function lockCollateral(FyTokenInterface fyToken, uint256 collateralAmount)

        external

        override

        isVaultOpenForMsgSender(fyToken)

        returns (bool)

    {

        

        require(collateralAmount > 0, "ERR_LOCK_COLLATERAL_ZERO");



        Vault memory vault = vaults[address(fyToken)][msg.sender];

        require(vault.freeCollateral >= collateralAmount, "ERR_INSUFFICIENT_FREE_COLLATERAL");



        MathError mathErr;

        uint256 newLockedCollateral;

        (mathErr, newLockedCollateral) = addUInt(vault.lockedCollateral, collateralAmount);

        require(mathErr == MathError.NO_ERROR, "ERR_LOCK_COLLATERAL_MATH_ERROR");

        vaults[address(fyToken)][msg.sender].lockedCollateral = newLockedCollateral;



        

        uint256 hypotheticalFreeCollateral;

        (mathErr, hypotheticalFreeCollateral) = subUInt(vault.freeCollateral, collateralAmount);

        assert(mathErr == MathError.NO_ERROR);

        vaults[address(fyToken)][msg.sender].freeCollateral = hypotheticalFreeCollateral;



        emit LockCollateral(fyToken, msg.sender, collateralAmount);



        return true;

    }



    

    function openVault(FyTokenInterface fyToken) external override returns (bool) {

        fyToken.isFyToken();

        require(vaults[address(fyToken)][msg.sender].isOpen == false, "ERR_VAULT_OPEN");

        vaults[address(fyToken)][msg.sender].isOpen = true;

        emit OpenVault(fyToken, msg.sender);

        return true;

    }



    

    function setVaultDebt(

        FyTokenInterface fyToken,

        address account,

        uint256 newVaultDebt

    ) external override returns (bool) {

        

        require(msg.sender == address(fyToken), "ERR_SET_VAULT_DEBT_NOT_AUTHORIZED");



        

        uint256 oldVaultDebt = vaults[address(fyToken)][account].debt;

        vaults[address(fyToken)][account].debt = newVaultDebt;



        emit SetVaultDebt(fyToken, account, oldVaultDebt, newVaultDebt);



        return true;

    }



    

    function withdrawCollateral(FyTokenInterface fyToken, uint256 collateralAmount)

        external

        override

        isVaultOpenForMsgSender(fyToken)

        nonReentrant

        returns (bool)

    {

        

        require(collateralAmount > 0, "ERR_WITHDRAW_COLLATERAL_ZERO");



        

        require(

            vaults[address(fyToken)][msg.sender].freeCollateral >= collateralAmount,

            "ERR_INSUFFICIENT_FREE_COLLATERAL"

        );



        

        MathError mathErr;

        uint256 newFreeCollateral;

        (mathErr, newFreeCollateral) = subUInt(vaults[address(fyToken)][msg.sender].freeCollateral, collateralAmount);

        

        assert(mathErr == MathError.NO_ERROR);

        vaults[address(fyToken)][msg.sender].freeCollateral = newFreeCollateral;



        

        fyToken.collateral().safeTransfer(msg.sender, collateralAmount);



        emit WithdrawCollateral(fyToken, msg.sender, collateralAmount);



        return true;

    }

}

abstract contract FintrollerInterface is FintrollerStorage {

    



    function getBond(FyTokenInterface fyToken)

        external

        view

        virtual

        returns (

            uint256 debtCeiling,

            uint256 collateralizationRatioMantissa,

            bool isBorrowAllowed,

            bool isDepositCollateralAllowed,

            bool isLiquidateBorrowAllowed,

            bool isListed,

            bool isRedeemFyTokenAllowed,

            bool isRepayBorrowAllowed,

            bool isSupplyUnderlyingAllowed

        );



    function getBorrowAllowed(FyTokenInterface fyToken) external view virtual returns (bool);



    function getBondDebtCeiling(FyTokenInterface fyToken) external view virtual returns (uint256);



    function getBondCollateralizationRatio(FyTokenInterface fyToken) external view virtual returns (uint256);



    function getDepositCollateralAllowed(FyTokenInterface fyToken) external view virtual returns (bool);



    function getLiquidateBorrowAllowed(FyTokenInterface fyToken) external view virtual returns (bool);



    function getRedeemFyTokensAllowed(FyTokenInterface fyToken) external view virtual returns (bool);



    function getRepayBorrowAllowed(FyTokenInterface fyToken) external view virtual returns (bool);



    function getSupplyUnderlyingAllowed(FyTokenInterface fyToken) external view virtual returns (bool);



    



    function listBond(FyTokenInterface fyToken) external virtual returns (bool);



    function setBorrowAllowed(FyTokenInterface fyToken, bool state) external virtual returns (bool);



    function setCollateralizationRatio(FyTokenInterface fyToken, uint256 newCollateralizationRatioMantissa)

        external

        virtual

        returns (bool);



    function setDebtCeiling(FyTokenInterface fyToken, uint256 newDebtCeiling) external virtual returns (bool);



    function setDepositCollateralAllowed(FyTokenInterface fyToken, bool state) external virtual returns (bool);



    function setLiquidateBorrowAllowed(FyTokenInterface fyToken, bool state) external virtual returns (bool);



    function setLiquidationIncentive(uint256 newLiquidationIncentiveMantissa) external virtual returns (bool);



    function setOracle(UniswapAnchoredViewInterface newOracle) external virtual returns (bool);



    function setRedeemFyTokensAllowed(FyTokenInterface fyToken, bool state) external virtual returns (bool);



    function setRepayBorrowAllowed(FyTokenInterface fyToken, bool state) external virtual returns (bool);



    function setSupplyUnderlyingAllowed(FyTokenInterface fyToken, bool state) external virtual returns (bool);



    

    event ListBond(address indexed admin, FyTokenInterface indexed fyToken);



    event SetBorrowAllowed(address indexed admin, FyTokenInterface indexed fyToken, bool state);



    event SetCollateralizationRatio(

        address indexed admin,

        FyTokenInterface indexed fyToken,

        uint256 oldCollateralizationRatio,

        uint256 newCollateralizationRatio

    );



    event SetDebtCeiling(

        address indexed admin,

        FyTokenInterface indexed fyToken,

        uint256 oldDebtCeiling,

        uint256 newDebtCeiling

    );



    event SetDepositCollateralAllowed(address indexed admin, FyTokenInterface indexed fyToken, bool state);



    event SetLiquidateBorrowAllowed(address indexed admin, FyTokenInterface indexed fyToken, bool state);



    event SetLiquidationIncentive(

        address indexed admin,

        uint256 oldLiquidationIncentive,

        uint256 newLiquidationIncentive

    );



    event SetRedeemFyTokensAllowed(address indexed admin, FyTokenInterface indexed fyToken, bool state);



    event SetRepayBorrowAllowed(address indexed admin, FyTokenInterface indexed fyToken, bool state);



    event SetOracle(address indexed admin, address oldOracle, address newOracle);



    event SetSupplyUnderlyingAllowed(address indexed admin, FyTokenInterface indexed fyToken, bool state);

}
