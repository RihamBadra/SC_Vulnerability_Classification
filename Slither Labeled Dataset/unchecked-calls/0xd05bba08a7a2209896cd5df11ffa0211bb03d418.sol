pragma solidity 0.7.4;

library Address {


    


    function isContract(address account) internal view returns (bool) {


        


        


        


        bytes32 codehash;


        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;


        


        assembly { codehash := extcodehash(account) }


        return (codehash != accountHash && codehash != 0x0);


    }





    function functionCallWithValue(address target, bytes memory data, uint256 weiValue) internal returns (bytes memory) {


        


        require(data.length == 0 || isContract(target));


        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);


        if (success) {


            return returndata;


        } else {


            revert(string(returndata));


        }


    }


}

contract MultiSigFactory {





  event ContractCreated(address contractAddress, string typeName);





  function create(address owner) public returns (address) {


    address instance = address(new MultiSig(owner));


    emit ContractCreated(instance, "MultiSig");


    return instance;


  }





  function predict(address owner, bytes32 salt) public view returns (address) {


    return address(uint(keccak256(abi.encodePacked(byte(0xff), address(this), salt,


            keccak256(abi.encodePacked(type(MultiSig).creationCode, owner))


        ))));


  }





  function create(address owner, bytes32 salt) public returns (address) {


    address instance = address(new MultiSig{salt: salt}(owner));


    emit ContractCreated(instance, "MultiSig");


    return instance;


  }


}

contract Nonce {





    uint256 public constant MAX_INCREASE = 100;


    


    uint256 private compound;


    


    constructor(){


        setBoth(128, 0);


    }


    


    


    function nextNonce() public view returns (uint256){


        return getMax() + 1;


    }





     


    function isFree(uint128 nonce) public view returns (bool){


        uint128 max = getMax();


        return isValidHighNonce(max, nonce) || isValidLowNonce(max, getRegister(), nonce);


    }





    


    function flagUsed(uint128 nonce) public {


        uint256 comp = compound;


        uint128 max = uint128(comp);


        uint128 reg = uint128(comp >> 128);


        if (isValidHighNonce(max, nonce)){


            setBoth(nonce, ((reg << 1) | 0x1) << (nonce - max - 1));


        } else if (isValidLowNonce(max, reg, nonce)){


            setBoth(max, uint128(reg | 0x1 << (max - nonce - 1)));


        } else {


            require(false);


        }


    }


    


    function getMax() private view returns (uint128) {


        return uint128(compound);


    }


    


    function getRegister() private view returns (uint128) {


        return uint128(compound >> 128);


    }


    


    function setBoth(uint128 max, uint128 reg) private {


        compound = uint256(reg) << 128 | max;


    }





    function isValidHighNonce(uint128 max, uint128 nonce) private pure returns (bool){


        return nonce > max && nonce <= max + MAX_INCREASE;


    }





    function isValidLowNonce(uint128 max, uint128 reg, uint256 nonce) private pure returns (bool){


        uint256 diff = max - nonce;


        return diff > 0 && diff <= 128 && ((0x1 << (diff - 1)) & reg == 0);


    }


    


}

library RLPEncode {


    uint8 constant STRING_SHORT_PREFIX = 0x80;


    uint8 constant STRING_LONG_PREFIX = 0xb7;


    uint8 constant LIST_SHORT_PREFIX = 0xc0;


    uint8 constant LIST_LONG_PREFIX = 0xf7;





    


    


    


    function encodeBytes(bytes memory self) internal pure returns (bytes memory) {


        if(self.length == 1 && self[0] < 0x80) {


            return self;


        } else {


            return encode(self, STRING_SHORT_PREFIX, STRING_LONG_PREFIX);


        }


    }


    


    


    


    


    function encodeList(bytes[] memory self) internal pure returns (bytes memory) {


        bytes memory list = flatten(self);


        return encode(list, LIST_SHORT_PREFIX, LIST_LONG_PREFIX);


    }





    function encode(bytes memory self, uint8 prefix1, uint8 prefix2) private pure returns (bytes memory) {


        uint selfPtr;


        assembly { selfPtr := add(self, 0x20) }





        uint len = self.length;


        if(len <= 55) {


            bytes memory encoded = new bytes(len+1);


            uint8 lenshort = uint8(len);


            


            encoded[0] = byte(prefix1+lenshort);





            


            uint encodedPtr;


            assembly { encodedPtr := add(encoded, 0x21) }


            memcpy(encodedPtr, selfPtr, len);


            return encoded;


        } else {


            uint8 lenLen;


            uint i = 0x1;


            while(len/i != 0) {


                lenLen++;


                i *= 0x100;


            }





            


           bytes memory encoded = new bytes(1+lenLen+len);





            


            encoded[0] = byte(prefix2+lenLen);





            


            for(i=1; i<=lenLen; i++) {


                encoded[i] = byte(uint8((len/(0x100**(lenLen-i)))%0x100));


            }





            


            uint encodedPtr;


            assembly { encodedPtr := add(add(encoded, 0x21), lenLen) }


            memcpy(encodedPtr, selfPtr, len);


            return encoded;


        }


    }


    


    function flatten(bytes[] memory self) private pure returns (bytes memory) {


        if(self.length == 0) {


            return new bytes(0);


        }





        uint len;


        for(uint i=0; i<self.length; i++) {


            len += self[i].length;


        }





        bytes memory flattened = new bytes(len);


        uint flattenedPtr;


        assembly { flattenedPtr := add(flattened, 0x20) }





        for(uint i=0; i<self.length; i++) {


            bytes memory item = self[i];


            


            uint selfPtr;


            assembly { selfPtr := add(item, 0x20)}





            memcpy(flattenedPtr, selfPtr, item.length);


            flattenedPtr += self[i].length;


        }





        return flattened;


    }





    


    function memcpy(uint dest, uint src, uint len) private pure {


        


        for(; len >= 32; len -= 32) {


            assembly {


                mstore(dest, mload(src))


            }


            dest += 32;


            src += 32;


        }





        


        uint mask = 256 ** (32 - len) - 1;


        assembly {


            let srcpart := and(mload(src), not(mask))


            let destpart := and(mload(dest), mask)


            mstore(dest, or(destpart, srcpart))


        }


    }


}

contract MultiSig is Nonce {





  mapping (address => uint8) public signers; 





  uint16 public signerCount;


  bytes public contractId; 





  event SignerChange(


    address indexed signer,


    uint8 cosignaturesNeeded


  );





  event Transacted(


    address indexed toAddress,  


    bytes4 selector, 


    address[] signers 


  );





  constructor (address owner) {


    


    


    


    


    


    contractId = toBytes(uint32(address(this)));


    _setSigner(owner, 1); 


  }





  


  receive() external payable {


  }





  


  function checkSignatures(uint128 nonce, address to, uint value, bytes calldata data,


    uint8[] calldata v, bytes32[] calldata r, bytes32[] calldata s) public view returns (address[] memory) {


    bytes32 transactionHash = calculateTransactionHash(nonce, contractId, to, value, data);


    return verifySignatures(transactionHash, v, r, s);


  }





  


  function checkExecution(address to, uint value, bytes calldata data) public {


    Address.functionCallWithValue(to, data, value);


    require(false, "Test passed. Reverting.");


  }





  function execute(uint128 nonce, address to, uint value, bytes calldata data, uint8[] calldata v, bytes32[] calldata r, bytes32[] calldata s) public returns (bytes memory) {


    bytes32 transactionHash = calculateTransactionHash(nonce, contractId, to, value, data);


    address[] memory found = verifySignatures(transactionHash, v, r, s);


    bytes memory returndata = Address.functionCallWithValue(to, data, value);


    flagUsed(nonce);


    emit Transacted(to, extractSelector(data), found);


    return returndata;


  }





  function extractSelector(bytes calldata data) private pure returns (bytes4){


    if (data.length < 4){


      return bytes4(0);


    } else {


      return bytes4(data[0]) | (bytes4(data[1]) >> 8) | (bytes4(data[2]) >> 16) | (bytes4(data[3]) >> 24);


    }


  }





  function toBytes(uint number) internal pure returns (bytes memory){


    uint len = 0;


    uint temp = 1;


    while (number >= temp){


      temp = temp << 8;


      len++;


    }


    temp = number;


    bytes memory data = new bytes(len);


    for (uint i = len; i>0; i--) {


      data[i-1] = bytes1(uint8(temp));


      temp = temp >> 8;


    }


    return data;


  }





  


  function calculateTransactionHash(uint128 sequence, bytes storage id, address to, uint value, bytes calldata data)


    private pure returns (bytes32){


    bytes[] memory all = new bytes[](9);


    all[0] = toBytes(sequence); 


    all[1] = id; 


    all[2] = toBytes(21000); 


    all[3] = abi.encodePacked(to);


    all[4] = toBytes(value);


    all[5] = data;


    all[6] = toBytes(1);


    all[7] = toBytes(0);


    for (uint i = 0; i<8; i++){


      all[i] = RLPEncode.encodeBytes(all[i]);


    }


    all[8] = all[7];


    return keccak256(RLPEncode.encodeList(all));


  }





  function verifySignatures(bytes32 transactionHash, uint8[] calldata v, bytes32[] calldata r, bytes32[] calldata s)


    private view returns (address[] memory) {


    address[] memory found = new address[](r.length);


    for (uint i = 0; i < r.length; i++) {


      address signer = ecrecover(transactionHash, v[i], r[i], s[i]);


      uint8 cosignaturesNeeded = signers[signer];


      require(cosignaturesNeeded > 0 && cosignaturesNeeded <= r.length, "cosigner error");


      found[i] = signer;


    }


    requireNoDuplicates(found);


    return found;


  }





  function requireNoDuplicates(address[] memory found) private pure {


    for (uint i = 0; i < found.length; i++) {


      for (uint j = i+1; j < found.length; j++) {


        require(found[i] != found[j], "duplicate signature");


      }


    }


  }





  


  function setSigner(address signer, uint8 cosignaturesNeeded) public authorized {


    _setSigner(signer, cosignaturesNeeded);


    require(signerCount > 0);


  }





  function migrate(address destination) public {


    _migrate(msg.sender, destination);


  }





  function migrate(address source, address destination) public authorized {


    _migrate(source, destination);


  }





  function _migrate(address source, address destination) private {


    require(signers[destination] == 0); 


    _setSigner(destination, signers[source]);


    _setSigner(source, 0);


  }





  function _setSigner(address signer, uint8 cosignaturesNeeded) private {


    require(!Address.isContract(signer), "signer cannot be a contract");


    uint8 prevValue = signers[signer];


    signers[signer] = cosignaturesNeeded;


    if (prevValue > 0 && cosignaturesNeeded == 0){


      signerCount--;


    } else if (prevValue == 0 && cosignaturesNeeded > 0){


      signerCount++;


    }


    emit SignerChange(signer, cosignaturesNeeded);


  }





  modifier authorized() {


    require(address(this) == msg.sender || signers[msg.sender] == 1, "not authorized");


    _;


  }





}
