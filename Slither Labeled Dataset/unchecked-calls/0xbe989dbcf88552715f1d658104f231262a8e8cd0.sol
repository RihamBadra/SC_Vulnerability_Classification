pragma solidity 0.7.1;

abstract contract Context {


    


    


    constructor () { }





    function _msgSender() internal view virtual returns (address payable) {


        return msg.sender;


    }





    function _msgData() internal view virtual returns (bytes memory) {


        this; 


        return msg.data;


    }


}

contract Ownable is Context {


    address private _owner;





    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);





    


    constructor () {


        address msgSender = _msgSender();


        _owner = msgSender;


        emit OwnershipTransferred(address(0), msgSender);


    }





    


    function owner() public view returns (address) {


        return _owner;


    }





    


    modifier onlyOwner() {


        require(_owner == _msgSender(), "Ownable: caller is not the owner");


        _;


    }





    


    function renounceOwnership() public virtual onlyOwner {


        emit OwnershipTransferred(_owner, address(0));


        _owner = address(0);


    }





    


    function transferOwnership(address newOwner) public virtual onlyOwner {


        require(newOwner != address(0), "Ownable: new owner is the zero address");


        emit OwnershipTransferred(_owner, newOwner);


        _owner = newOwner;


    }


}

interface PRDX_token {                                     


    function balanceOf(address owner) external returns (uint256);


    function transfer(address to, uint256 amount) external returns (bool);


    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);


}

contract PRDXDistr is Ownable{


    uint256 public PRDXPrice ;


    


    address public token_addr ; 


    PRDX_token token_contract = PRDX_token(token_addr) ;


    


    event sold(address seller, uint256 amount) ;


    event bought(address buyer, uint256 amount) ;


    event priceAdjusted(uint256 oldPrice, uint256 newPrice) ; 





    constructor(uint256 PRDXperETH) {


        PRDXPrice = PRDXperETH ; 


    }





    


    function safeMultiply(uint256 a, uint256 b) internal pure returns (uint256) {


        if (a == 0) {


            return 0 ;


        } else {


            uint256 c = a * b ;


            assert(c / a == b) ;


            return c ;


        }


    }


    


    


    function safeDivide(uint256 a, uint256 b) internal pure returns (uint256) {


        require(b > 0); 


        uint256 c = a / b;





        return c;


    }


    


    


    function set_token_contract(address addr) public onlyOwner {


        token_addr = addr ;


        token_contract = PRDX_token(token_addr) ;


    }


    


    


    function sell_PRDX(address payable seller, uint256 amount) public returns (bool success) {


        require(token_contract.transferFrom(seller, address(this), amount), "Error transacting tokens to contract") ;


        


        uint256 a = safeDivide(amount, PRDXPrice) ; 


        


        seller.transfer(a) ; 


        


        emit sold(seller, a) ; 


        


        return true ; 


    }





    


    function buy_PRDX() public payable returns (bool success) {


        require(msg.value > 0) ; 


        uint256 scaledAmount = safeMultiply(msg.value, PRDXPrice) ;


        require(token_contract.balanceOf(address(this)) >= scaledAmount) ;





        token_contract.transfer(msg.sender, scaledAmount) ;


        


        emit bought(msg.sender, scaledAmount) ; 


    


        return true ; 


    }


    


    


    receive() external payable {


        buy_PRDX() ; 


    }





    


    function adjustPrice(uint PRDXperETH) public onlyOwner {


        emit priceAdjusted(PRDXPrice, PRDXperETH) ; 


        


        PRDXPrice = PRDXperETH ; 


        


    }





    


    function endPRDXDistr() public onlyOwner {             


        require(token_contract.transfer(owner(), token_contract.balanceOf(address(this)))) ;





        msg.sender.transfer(address(this).balance) ;


    }


}
