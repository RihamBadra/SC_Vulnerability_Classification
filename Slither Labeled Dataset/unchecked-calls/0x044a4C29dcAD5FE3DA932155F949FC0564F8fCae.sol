

pragma solidity >=0.4.24 <0.7.0;



contract Initializable {

  
  bool private initialized;

  
  bool private initializing;

  
  modifier initializer() {
    require(initializing || isConstructor() || !initialized, "Contract instance has already been initialized");

    bool isTopLevelCall = !initializing;
    if (isTopLevelCall) {
      initializing = true;
      initialized = true;
    }

    _;

    if (isTopLevelCall) {
      initializing = false;
    }
  }

  
  function isConstructor() private view returns (bool) {
    
    
    
    
    
    address self = address(this);
    uint256 cs;
    assembly { cs := extcodesize(self) }
    return cs == 0;
  }

  
  uint256[50] private ______gap;
}



pragma solidity ^0.5.2;



library OpenZeppelinUpgradesECDSA {
    
    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {
        
        if (signature.length != 65) {
            return (address(0));
        }

        
        bytes32 r;
        bytes32 s;
        uint8 v;

        
        
        
        assembly {
            r := mload(add(signature, 0x20))
            s := mload(add(signature, 0x40))
            v := byte(0, mload(add(signature, 0x60)))
        }

        
        
        
        
        
        
        
        
        
        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {
            return address(0);
        }

        if (v != 27 && v != 28) {
            return address(0);
        }

        
        return ecrecover(hash, v, r, s);
    }

    
    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {
        
        
        return keccak256(abi.encodePacked("\x19Ethereum Signed Message:\n32", hash));
    }
}



pragma solidity ^0.5.0;



contract Context is Initializable {
    
    
    constructor () internal { }
    

    function _msgSender() internal view returns (address payable) {
        return msg.sender;
    }

    function _msgData() internal view returns (bytes memory) {
        this; 
        return msg.data;
    }
}



pragma solidity ^0.5.0;


library Roles {
    struct Role {
        mapping (address => bool) bearer;
    }

    
    function add(Role storage role, address account) internal {
        require(!has(role, account), "Roles: account already has role");
        role.bearer[account] = true;
    }

    
    function remove(Role storage role, address account) internal {
        require(has(role, account), "Roles: account does not have role");
        role.bearer[account] = false;
    }

    
    function has(Role storage role, address account) internal view returns (bool) {
        require(account != address(0), "Roles: account is the zero address");
        return role.bearer[account];
    }
}



pragma solidity ^0.5.0;





contract WhitelistAdminRole is Initializable, Context {
    using Roles for Roles.Role;

    event WhitelistAdminAdded(address indexed account);
    event WhitelistAdminRemoved(address indexed account);

    Roles.Role private _whitelistAdmins;

    function initialize(address sender) public initializer {
        if (!isWhitelistAdmin(sender)) {
            _addWhitelistAdmin(sender);
        }
    }

    modifier onlyWhitelistAdmin() {
        require(isWhitelistAdmin(_msgSender()), "WhitelistAdminRole: caller does not have the WhitelistAdmin role");
        _;
    }

    function isWhitelistAdmin(address account) public view returns (bool) {
        return _whitelistAdmins.has(account);
    }

    function addWhitelistAdmin(address account) public onlyWhitelistAdmin {
        _addWhitelistAdmin(account);
    }

    function renounceWhitelistAdmin() public {
        _removeWhitelistAdmin(_msgSender());
    }

    function _addWhitelistAdmin(address account) internal {
        _whitelistAdmins.add(account);
        emit WhitelistAdminAdded(account);
    }

    function _removeWhitelistAdmin(address account) internal {
        _whitelistAdmins.remove(account);
        emit WhitelistAdminRemoved(account);
    }

    uint256[50] private ______gap;
}



pragma solidity ^0.5.0;






contract WhitelistedRole is Initializable, Context, WhitelistAdminRole {
    using Roles for Roles.Role;

    event WhitelistedAdded(address indexed account);
    event WhitelistedRemoved(address indexed account);

    Roles.Role private _whitelisteds;

    modifier onlyWhitelisted() {
        require(isWhitelisted(_msgSender()), "WhitelistedRole: caller does not have the Whitelisted role");
        _;
    }

    function initialize(address sender) public initializer {
        WhitelistAdminRole.initialize(sender);
    }

    function isWhitelisted(address account) public view returns (bool) {
        return _whitelisteds.has(account);
    }

    function addWhitelisted(address account) public onlyWhitelistAdmin {
        _addWhitelisted(account);
    }

    function removeWhitelisted(address account) public onlyWhitelistAdmin {
        _removeWhitelisted(account);
    }

    function renounceWhitelisted() public {
        _removeWhitelisted(_msgSender());
    }

    function _addWhitelisted(address account) internal {
        _whitelisteds.add(account);
        emit WhitelistedAdded(account);
    }

    function _removeWhitelisted(address account) internal {
        _whitelisteds.remove(account);
        emit WhitelistedRemoved(account);
    }

    uint256[50] private ______gap;
}



pragma solidity ^0.5.0;





contract WhitelistedRoleMeta is WhitelistedRole {

    function initialize(address sender) public initializer {
        WhitelistAdminRole.initialize(sender);
    }

    function addSignedWhitelisted(address account, bytes memory signature) public {
        address signer = getWhitelistedRoleActionSigner('addSignedWhitelisted', account, signature);
        require(signer != address(0), "Invalid signature");
        require(isWhitelistAdmin(signer), "signer is not an admin");
        _addWhitelisted(account);
    }

    function addSignedWhitelistAdmin(address account, bytes memory signature) public {
        address signer = getWhitelistedRoleActionSigner('addSignedWhitelistAdmin', account, signature);
        require(signer != address(0), "Invalid signature");
        require(isWhitelistAdmin(signer), "signer is not an admin");
        _addWhitelistAdmin(account);
    }

    function getWhitelistedRoleActionSigner(string memory action, address account, bytes memory _signature) private view returns (address) {
      bytes32 msgHash = OpenZeppelinUpgradesECDSA.toEthSignedMessageHash(
      keccak256(
          abi.encodePacked(
            action,
            account,
            address(this)
          )
        )
      );
      return OpenZeppelinUpgradesECDSA.recover(msgHash, _signature);
    }
}



pragma solidity ^0.5.0;



contract ReentrancyGuardEmber is Initializable {
    
    uint256 private _guardCounter;

    function initialize() public initializer {
        
        
        _guardCounter = 1;
    }

    
    modifier nonReentrant() {
        _guardCounter += 1;
        uint256 localCounter = _guardCounter;
        _;
        require(localCounter == _guardCounter, "ReentrancyGuard: reentrant call");
    }

    uint256[50] private ______gap;
}



pragma solidity ^0.5.0;


library SafeMath {
    
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, "SafeMath: addition overflow");

        return c;
    }

    
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        return sub(a, b, "SafeMath: subtraction overflow");
    }

    
    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b <= a, errorMessage);
        uint256 c = a - b;

        return c;
    }

    
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        
        
        
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b, "SafeMath: multiplication overflow");

        return c;
    }

    
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        return div(a, b, "SafeMath: division by zero");
    }

    
    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        
        require(b > 0, errorMessage);
        uint256 c = a / b;
        

        return c;
    }

    
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        return mod(a, b, "SafeMath: modulo by zero");
    }

    
    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b != 0, errorMessage);
        return a % b;
    }
}





pragma solidity 0.5.7;



library CommonMath {
    using SafeMath for uint256;

    uint256 public constant SCALE_FACTOR = 10 ** 18;
    uint256 public constant MAX_UINT_256 = 2 ** 256 - 1;

    
    function scaleFactor()
        internal
        pure
        returns (uint256)
    {
        return SCALE_FACTOR;
    }

    
    function maxUInt256()
        internal
        pure
        returns (uint256)
    {
        return MAX_UINT_256;
    }

    
    function scale(
        uint256 a
    )
        internal
        pure
        returns (uint256)
    {
        return a.mul(SCALE_FACTOR);
    }

    
    function deScale(
        uint256 a
    )
        internal
        pure
        returns (uint256)
    {
        return a.div(SCALE_FACTOR);
    }

    
    function safePower(
        uint256 a,
        uint256 pow
    )
        internal
        pure
        returns (uint256)
    {
        require(a > 0);

        uint256 result = 1;
        for (uint256 i = 0; i < pow; i++){
            uint256 previousResult = result;

            
            result = previousResult.mul(a);
        }

        return result;
    }

    
    function divCeil(uint256 a, uint256 b)
        internal
        pure
        returns(uint256)
    {
        return a.mod(b) > 0 ? a.div(b).add(1) : a.div(b);
    }

    
    function getPartialAmount(
        uint256 _principal,
        uint256 _numerator,
        uint256 _denominator
    )
        internal
        pure
        returns (uint256)
    {
        
        uint256 remainder = mulmod(_principal, _numerator, _denominator);

        
        if (remainder == 0) {
            return _principal.mul(_numerator).div(_denominator);
        }

        
        uint256 errPercentageTimes1000000 = remainder.mul(1000000).div(_numerator.mul(_principal));

        
        require(
            errPercentageTimes1000000 < 1000,
            "CommonMath.getPartialAmount: Rounding error exceeds bounds"
        );

        return _principal.mul(_numerator).div(_denominator);
    }
    
    
    function ceilLog10(
        uint256 _value
    )
        internal
        pure 
        returns (uint256)
    {
        
        require (
            _value > 0,
            "CommonMath.ceilLog10: Value must be greater than zero."
        );

        
        if (_value == 1) return 0;

        
        uint256 x = _value - 1;

        uint256 result = 0;

        if (x >= 10 ** 64) {
            x /= 10 ** 64;
            result += 64;
        }
        if (x >= 10 ** 32) {
            x /= 10 ** 32;
            result += 32;
        }
        if (x >= 10 ** 16) {
            x /= 10 ** 16;
            result += 16;
        }
        if (x >= 10 ** 8) {
            x /= 10 ** 8;
            result += 8;
        }
        if (x >= 10 ** 4) {
            x /= 10 ** 4;
            result += 4;
        }
        if (x >= 100) {
            x /= 100;
            result += 2;
        }
        if (x >= 10) {
            result += 1;
        }

        return result + 1;
    }
}





pragma solidity 0.5.7;



interface IERC20 {
    function balanceOf(
        address _owner
    )
        external
        view
        returns (uint256);

    function allowance(
        address _owner,
        address _spender
    )
        external
        view
        returns (uint256);

    function transfer(
        address _to,
        uint256 _quantity
    )
        external;

    function transferFrom(
        address _from,
        address _to,
        uint256 _quantity
    )
        external;

    function approve(
        address _spender,
        uint256 _quantity
    )
        external
        returns (bool);

    function totalSupply()
        external
        returns (uint256);
}





pragma solidity 0.5.7;





library ERC20Wrapper {

    

    
    function balanceOf(
        address _token,
        address _owner
    )
        external
        view
        returns (uint256)
    {
        return IERC20(_token).balanceOf(_owner);
    }

    
    function allowance(
        address _token,
        address _owner,
        address _spender
    )
        internal
        view
        returns (uint256)
    {
        return IERC20(_token).allowance(_owner, _spender);
    }

    
    function transfer(
        address _token,
        address _to,
        uint256 _quantity
    )
        external
    {
        IERC20(_token).transfer(_to, _quantity);

        
        require(
            checkSuccess(),
            "ERC20Wrapper.transfer: Bad return value"
        );
    }

    
    function transferFrom(
        address _token,
        address _from,
        address _to,
        uint256 _quantity
    )
        external
    {
        IERC20(_token).transferFrom(_from, _to, _quantity);

        
        require(
            checkSuccess(),
            "ERC20Wrapper.transferFrom: Bad return value"
        );
    }

    
    function approve(
        address _token,
        address _spender,
        uint256 _quantity
    )
        internal
    {
        IERC20(_token).approve(_spender, _quantity);

        
        require(
            checkSuccess(),
            "ERC20Wrapper.approve: Bad return value"
        );
    }

    
    function ensureAllowance(
        address _token,
        address _owner,
        address _spender,
        uint256 _quantity
    )
        internal
    {
        uint256 currentAllowance = allowance(_token, _owner, _spender);
        if (currentAllowance < _quantity) {
            approve(
                _token,
                _spender,
                CommonMath.maxUInt256()
            );
        }
    }

    

    
    function checkSuccess(
    )
        private
        pure
        returns (bool)
    {
        
        uint256 returnValue = 0;

        assembly {
            
            switch returndatasize

            
            case 0x0 {
                returnValue := 1
            }

            
            case 0x20 {
                
                returndatacopy(0x0, 0x0, 0x20)

                
                returnValue := mload(0x0)
            }

            
            default { }
        }

        
        return returnValue == 1;
    }
}





pragma solidity 0.5.7;



interface IWETH {
    function deposit()
        external
        payable;

    function withdraw(
        uint256 wad
    )
        external;
}



pragma solidity 0.5.7;



interface IVault {

    function deposit(uint amount)
        external;

    function withdraw(uint shares)
        external;
}



pragma solidity ^0.5.7;
pragma experimental ABIEncoderV2;

interface ChiGasSaver {
    function freeFromUpTo(address from, uint256 value) external returns (uint256 freed);
    function approve(address spender, uint256 amount) external returns (bool);
    function allowance(address _owner, address _spender) view external returns (uint256 remaining);
}





pragma solidity ^0.5.0;











contract SmartWalletVault is Initializable, ReentrancyGuardEmber, WhitelistedRoleMeta {
    using SafeMath for uint256;

    
    mapping(uint256 => bool) private nonces;

    uint16 public constant version = 3;

    
    ChiGasSaver public constant chiGasSaver = ChiGasSaver(0x0000000000004946c0e9F43F4Dee607b0eF1fA1c);

    modifier discountChiGasSaver {
      uint256 gasStart = gasleft();
      _;
      uint256 gasSpent = 21000 + gasStart - gasleft() + 16 *
                         msg.data.length;
      uint256 allowance = chiGasSaver.allowance(msg.sender, address(this));
      uint256 chiTokensToSpend = (gasSpent + 14154) / 41947;
      if (allowance < chiTokensToSpend) {
        chiGasSaver.approve(address(this), chiTokensToSpend);
      }
      chiGasSaver.freeFromUpTo(msg.sender, chiTokensToSpend);
    }

    mapping(address => address) public depositTokenAddressToYVault;
    mapping(address => address) public yVaultToDepositTokenAddress;

    
    function initialize(address _owner) public initializer {
      WhitelistedRoleMeta.initialize(_owner);
      ReentrancyGuardEmber.initialize();

      
      
      
      depositTokenAddressToYVault[0xdAC17F958D2ee523a2206206994597C13D831ec7] = 0x2f08119C6f07c006695E079AAFc638b8789FAf18;
      yVaultToDepositTokenAddress[0x2f08119C6f07c006695E079AAFc638b8789FAf18] = 0xdAC17F958D2ee523a2206206994597C13D831ec7;
    }

    function() external payable { }

    
    
    
    
    

    function getTransfersProxy() public view returns (address) {
      return 0x882d80D3a191859d64477eb78Cca46599307ec1C;
    }

    function getRebalancingSetExchangeIssuanceModule() public view returns (address payable) {
      return 0xde697AC56b1bD9C0987c08911020f2341e274813;
    }

    function getRebalancingSetIssuanceModule() public view returns (address payable) {
      return 0xDA6786379FF88729264d31d472FA917f5E561443;
    }

    function getCTokenaddressToAddressWhiteList() public view returns (address payable) {
      return 0x5BA020a8835ed40936941562bdF42D66F65fc00f;
    }

    function getWrappedEthInstance() public view returns (IWETH) {
      return IWETH(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);
    }

    
    function withdrawAllAdmin(address [] calldata _tokenAddresses)
      external
      nonReentrant
      onlyWhitelistAdmin
    {
      for (uint i=0; i<_tokenAddresses.length; i++) {
          uint256 tokenBalance = ERC20Wrapper.balanceOf(_tokenAddresses[i], address(this));
          ERC20Wrapper.transfer(
              _tokenAddresses[i],
              msg.sender,
              tokenBalance
          );
      }
    }

    
    function withdrawERC20(address _tokenAddress, address _to, uint256 _withdrawalAmount)
      external
      nonReentrant
      onlyWhitelisted
    {
      uint256 tokenBalance = ERC20Wrapper.balanceOf(_tokenAddress, address(this));
      require(tokenBalance >= _withdrawalAmount, "Withdrawal amount is too high");
      require(this.isWhitelistAdmin(_to), "You can only withdraw to an owner address");
      ERC20Wrapper.transfer(
          _tokenAddress,
          _to,
          _withdrawalAmount
      );
    }

    
    function withdrawETH(address payable _to, uint256 _withdrawalAmount)
      external
      nonReentrant
      onlyWhitelisted
    {
      uint256 ethBalance = address(this).balance;
      require(ethBalance >= _withdrawalAmount, "Withdrawal amount is too high");
      require(this.isWhitelistAdmin(_to), "You can only withdraw to an owner address");
      _to.transfer(_withdrawalAmount);
    }

    function _checkReplayAttack(
       uint256 _nonce
    )
      private
      nonReentrant
    {
      require(!nonces[_nonce], "Replay attack detected.");
      nonces[_nonce] = true;
    }

    
    function getVaultDepositSigner(address _vaultAddress, address _tokenDepositAddress, uint256 _nonce, bytes memory _signature) private view returns (address) {
      bytes32 msgHash = OpenZeppelinUpgradesECDSA.toEthSignedMessageHash(
      keccak256(
          abi.encodePacked(
            _vaultAddress,
            _tokenDepositAddress,
            _nonce,
            address(this)
          )
        )
      );
      return OpenZeppelinUpgradesECDSA.recover(msgHash, _signature);
    }

    function vaultDeposit(
      address _vaultAddress,
      address _tokenDepositAddress,
      uint256 _amount,
      uint256 _nonce,
      bytes memory _signature
    )
        public
        nonReentrant
        discountChiGasSaver
    {

      _checkReplayAttack(_nonce);
      require(depositTokenAddressToYVault[_tokenDepositAddress] == _vaultAddress, "Deposit token and vault not supported");
      address signer = getVaultDepositSigner(_vaultAddress, _tokenDepositAddress, _nonce, _signature);
      require(signer != address(0), "Invalid signature");
      require(isWhitelistAdmin(signer), "signer is not an admin");

      uint256 tokenDepositBalance = ERC20Wrapper.balanceOf(_tokenDepositAddress, address(this));
      require(tokenDepositBalance >= _amount, "Token deposit balance is too low");

      
      
      ERC20Wrapper.approve(_tokenDepositAddress, _vaultAddress, 0);
      ERC20Wrapper.approve(_tokenDepositAddress, _vaultAddress, _amount);

      
      IVault(_vaultAddress).deposit(_amount);
    }


    
    function getVaultWithdrawalSigner(address _vaultAddress, address payable _to, uint256 _nonce, bytes memory _signature) private view returns (address) {
      bytes32 msgHash = OpenZeppelinUpgradesECDSA.toEthSignedMessageHash(
      keccak256(
          abi.encodePacked(
            _vaultAddress,
            _to,
            _nonce,
            address(this)
          )
        )
      );
      return OpenZeppelinUpgradesECDSA.recover(msgHash, _signature);
    }

    function vaultWithdraw(
      address _vaultAddress,
      uint shares,
      address payable _to,
      uint256 _nonce,
      bytes memory _signature
    )
        public
        nonReentrant
        discountChiGasSaver
    {

      _checkReplayAttack(_nonce);
      address depositTokenAddress = yVaultToDepositTokenAddress[_vaultAddress];
      require(depositTokenAddress != address(0), "Vault not supported");

      address signer = getVaultWithdrawalSigner(_vaultAddress, _to, _nonce, _signature);
      require(signer != address(0), "Invalid signature");
      require(isWhitelistAdmin(signer), "signer is not an admin");

      
      uint256 depositTokenBalanceBeforeWithdrawal = ERC20Wrapper.balanceOf(depositTokenAddress, address(this));
      
      IVault(_vaultAddress).withdraw(shares);

      
      uint256 depositTokenWithdrawn = ERC20Wrapper.balanceOf(depositTokenAddress, address(this)).sub(depositTokenBalanceBeforeWithdrawal);
      require(depositTokenWithdrawn > 0, "No token withdrawn");

      
      ERC20Wrapper.transfer(
          depositTokenAddress,
          _to,
          depositTokenWithdrawn
      );

    }

}