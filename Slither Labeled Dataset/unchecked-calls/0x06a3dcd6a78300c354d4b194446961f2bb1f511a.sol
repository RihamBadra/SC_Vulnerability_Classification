





pragma solidity ^0.8.0;


abstract contract Context {
    function _msgSender() internal view virtual returns (address) {
        return msg.sender;
    }

    function _msgData() internal view virtual returns (bytes calldata) {
        return msg.data;
    }
}





pragma solidity ^0.8.0;



abstract contract Ownable is Context {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    
    constructor() {
        _setOwner(_msgSender());
    }

    
    function owner() public view virtual returns (address) {
        return _owner;
    }

    
    modifier onlyOwner() {
        require(owner() == _msgSender(), "Ownable: caller is not the owner");
        _;
    }

    
    function renounceOwnership() public virtual onlyOwner {
        _setOwner(address(0));
    }

    
    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), "Ownable: new owner is the zero address");
        _setOwner(newOwner);
    }

    function _setOwner(address newOwner) private {
        address oldOwner = _owner;
        _owner = newOwner;
        emit OwnershipTransferred(oldOwner, newOwner);
    }
}





pragma solidity ^0.8.0;


abstract contract ReentrancyGuard {
    
    
    
    
    

    
    
    
    
    
    uint256 private constant _NOT_ENTERED = 1;
    uint256 private constant _ENTERED = 2;

    uint256 private _status;

    constructor() {
        _status = _NOT_ENTERED;
    }

    
    modifier nonReentrant() {
        
        require(_status != _ENTERED, "ReentrancyGuard: reentrant call");

        
        _status = _ENTERED;

        _;

        
        
        _status = _NOT_ENTERED;
    }
}





pragma solidity ^0.8.0;






library SafeMath {
    
    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        unchecked {
            uint256 c = a + b;
            if (c < a) return (false, 0);
            return (true, c);
        }
    }

    
    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        unchecked {
            if (b > a) return (false, 0);
            return (true, a - b);
        }
    }

    
    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        unchecked {
            
            
            
            if (a == 0) return (true, 0);
            uint256 c = a * b;
            if (c / a != b) return (false, 0);
            return (true, c);
        }
    }

    
    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        unchecked {
            if (b == 0) return (false, 0);
            return (true, a / b);
        }
    }

    
    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        unchecked {
            if (b == 0) return (false, 0);
            return (true, a % b);
        }
    }

    
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        return a + b;
    }

    
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        return a - b;
    }

    
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        return a * b;
    }

    
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        return a / b;
    }

    
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        return a % b;
    }

    
    function sub(
        uint256 a,
        uint256 b,
        string memory errorMessage
    ) internal pure returns (uint256) {
        unchecked {
            require(b <= a, errorMessage);
            return a - b;
        }
    }

    
    function div(
        uint256 a,
        uint256 b,
        string memory errorMessage
    ) internal pure returns (uint256) {
        unchecked {
            require(b > 0, errorMessage);
            return a / b;
        }
    }

    
    function mod(
        uint256 a,
        uint256 b,
        string memory errorMessage
    ) internal pure returns (uint256) {
        unchecked {
            require(b > 0, errorMessage);
            return a % b;
        }
    }
}





pragma solidity ^0.8.0;


interface IERC20 {
    
    function totalSupply() external view returns (uint256);

    
    function balanceOf(address account) external view returns (uint256);

    
    function transfer(address recipient, uint256 amount) external returns (bool);

    
    function allowance(address owner, address spender) external view returns (uint256);

    
    function approve(address spender, uint256 amount) external returns (bool);

    
    function transferFrom(
        address sender,
        address recipient,
        uint256 amount
    ) external returns (bool);

    
    event Transfer(address indexed from, address indexed to, uint256 value);

    
    event Approval(address indexed owner, address indexed spender, uint256 value);
}





pragma solidity ^0.8.0;


interface IERC165 {
    
    function supportsInterface(bytes4 interfaceId) external view returns (bool);
}





pragma solidity ^0.8.0;



interface IERC1155 is IERC165 {
    
    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);

    
    event TransferBatch(
        address indexed operator,
        address indexed from,
        address indexed to,
        uint256[] ids,
        uint256[] values
    );

    
    event ApprovalForAll(address indexed account, address indexed operator, bool approved);

    
    event URI(string value, uint256 indexed id);

    
    function balanceOf(address account, uint256 id) external view returns (uint256);

    
    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)
        external
        view
        returns (uint256[] memory);

    
    function setApprovalForAll(address operator, bool approved) external;

    
    function isApprovedForAll(address account, address operator) external view returns (bool);

    
    function safeTransferFrom(
        address from,
        address to,
        uint256 id,
        uint256 amount,
        bytes calldata data
    ) external;

    
    function safeBatchTransferFrom(
        address from,
        address to,
        uint256[] calldata ids,
        uint256[] calldata amounts,
        bytes calldata data
    ) external;
}





pragma solidity ^0.8.0;



interface IERC721 is IERC165 {
    
    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);

    
    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);

    
    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);

    
    function balanceOf(address owner) external view returns (uint256 balance);

    
    function ownerOf(uint256 tokenId) external view returns (address owner);

    
    function safeTransferFrom(
        address from,
        address to,
        uint256 tokenId
    ) external;

    
    function transferFrom(
        address from,
        address to,
        uint256 tokenId
    ) external;

    
    function approve(address to, uint256 tokenId) external;

    
    function getApproved(uint256 tokenId) external view returns (address operator);

    
    function setApprovalForAll(address operator, bool _approved) external;

    
    function isApprovedForAll(address owner, address operator) external view returns (bool);

    
    function safeTransferFrom(
        address from,
        address to,
        uint256 tokenId,
        bytes calldata data
    ) external;
}





pragma solidity ^0.8.0;



interface IERC721Enumerable is IERC721 {
    
    function totalSupply() external view returns (uint256);

    
    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256 tokenId);

    
    function tokenByIndex(uint256 index) external view returns (uint256);
}





pragma solidity ^0.8.0;



abstract contract ERC165 is IERC165 {
    
    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {
        return interfaceId == type(IERC165).interfaceId;
    }
}





pragma solidity ^0.8.0;



interface IERC1155Receiver is IERC165 {
    
    function onERC1155Received(
        address operator,
        address from,
        uint256 id,
        uint256 value,
        bytes calldata data
    ) external returns (bytes4);

    
    function onERC1155BatchReceived(
        address operator,
        address from,
        uint256[] calldata ids,
        uint256[] calldata values,
        bytes calldata data
    ) external returns (bytes4);
}





pragma solidity ^0.8.0;




abstract contract ERC1155Receiver is ERC165, IERC1155Receiver {
    
    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {
        return interfaceId == type(IERC1155Receiver).interfaceId || super.supportsInterface(interfaceId);
    }
}





pragma solidity ^0.8.0;



contract ERC1155Holder is ERC1155Receiver {
    function onERC1155Received(
        address,
        address,
        uint256,
        uint256,
        bytes memory
    ) public virtual override returns (bytes4) {
        return this.onERC1155Received.selector;
    }

    function onERC1155BatchReceived(
        address,
        address,
        uint256[] memory,
        uint256[] memory,
        bytes memory
    ) public virtual override returns (bytes4) {
        return this.onERC1155BatchReceived.selector;
    }
}




pragma solidity ^0.8.7;




contract CointoolMultisender is ERC1155Holder, ReentrancyGuard, Ownable {

  using SafeMath for uint256;

  address payable public feeReceiver;
  uint256 public ethFee;
  uint256 public array_limit;


  bytes emptyData = bytes("");


  constructor()  {
    ethFee = 0.05 ether;
    feeReceiver =payable(msg.sender);
    array_limit = 200;
  }


    function arrayLimit() public view returns(uint256) {
        return array_limit;
    }

    function currentFee(address _customer) public view returns(uint256) {
        if(_customer == address(0x0)){
            return 0;
        }
        return  ethFee;
    }


  
  
  function _send721Or20(address tokenAddress, address from, address to, uint256 amountOrId) internal {
    IERC721(tokenAddress).transferFrom(from, to, amountOrId);
  }



  

  
  function multisendToken(
    address tokenAddress,
    address[] calldata userAddresses,
    uint256[] calldata amountsOrIds
   ) external payable nonReentrant {
    require((userAddresses.length == amountsOrIds.length), "diff lengths");
    for (uint256 i = 0; i < userAddresses.length; i++) {
      _send721Or20(tokenAddress, msg.sender, userAddresses[i], amountsOrIds[i]);
    }
  }


  function send721Or20To721Ids(
    address[] calldata erc721Addresses,
    uint256[] calldata receiverIds,
    uint256[] calldata amountsOrIds,
    address tokenAddress) external payable nonReentrant {
    require((erc721Addresses.length == receiverIds.length), "diff lengths");
    require((erc721Addresses.length == amountsOrIds.length), "diff lengths");
    for (uint256 i = 0; i < receiverIds.length; i++) {
      IERC721Enumerable erc721 = IERC721Enumerable(erc721Addresses[i]);
      _send721Or20(tokenAddress, msg.sender, erc721.ownerOf(receiverIds[i]), amountsOrIds[i]);
    }
  }

  
  function send1155ToAddresses(
    address[] calldata userAddresses,
    uint256[] calldata tokenIds,
    uint256[] calldata amounts,
    address tokenAddress) external payable nonReentrant {
    require((userAddresses.length == amounts.length), "diff lengths");
    require((userAddresses.length == tokenIds.length), "diff lengths");
    for (uint256 i = 0; i < userAddresses.length; i++) {
      IERC1155(tokenAddress).safeTransferFrom(msg.sender, userAddresses[i], tokenIds[i], amounts[i], emptyData);
    }
  }

  
  function send1155To721Ids(
    address[] calldata erc721Addresses,
    uint256[] calldata erc721Ids,
    uint256[] calldata tokenIds,
    uint256[] calldata amounts,
    address tokenAddress) external payable nonReentrant {
    require((erc721Addresses.length == erc721Ids.length), "diff lengths");
    require((erc721Addresses.length == amounts.length), "diff lengths");
    require((erc721Addresses.length == tokenIds.length), "diff lengths");
    for (uint256 i = 0; i < erc721Addresses.length; i++) {
      IERC1155(tokenAddress).safeTransferFrom(msg.sender, IERC721(erc721Addresses[i]).ownerOf(erc721Ids[i]), tokenIds[i], amounts[i], emptyData);
    }
  }





  

  function setFeeReceiver(address payable a) public onlyOwner {
    feeReceiver = a;
  }

  function setEthFee(uint256 f) public onlyOwner {
    ethFee = f;
  }
  
    function claimTokens(address _token) public onlyOwner {
        if (_token == address(0x0)) {
             feeReceiver.transfer(address(this).balance);
            return;
        }
        IERC20 erc20token = IERC20(_token);
        uint256 balance = erc20token.balanceOf(address(this));
        erc20token.transfer(feeReceiver, balance);
    }
   
  
  

}