






pragma solidity ^0.8.1;


library Address {
    
    function isContract(address account) internal view returns (bool) {
        
        
        

        return account.code.length > 0;
    }

    
    function sendValue(address payable recipient, uint256 amount) internal {
        require(address(this).balance >= amount, "Address: insufficient balance");

        (bool success, ) = recipient.call{value: amount}("");
        require(success, "Address: unable to send value, recipient may have reverted");
    }

    
    function functionCall(address target, bytes memory data) internal returns (bytes memory) {
        return functionCall(target, data, "Address: low-level call failed");
    }

    
    function functionCall(
        address target,
        bytes memory data,
        string memory errorMessage
    ) internal returns (bytes memory) {
        return functionCallWithValue(target, data, 0, errorMessage);
    }

    
    function functionCallWithValue(
        address target,
        bytes memory data,
        uint256 value
    ) internal returns (bytes memory) {
        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");
    }

    
    function functionCallWithValue(
        address target,
        bytes memory data,
        uint256 value,
        string memory errorMessage
    ) internal returns (bytes memory) {
        require(address(this).balance >= value, "Address: insufficient balance for call");
        require(isContract(target), "Address: call to non-contract");

        (bool success, bytes memory returndata) = target.call{value: value}(data);
        return verifyCallResult(success, returndata, errorMessage);
    }

    
    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {
        return functionStaticCall(target, data, "Address: low-level static call failed");
    }

    
    function functionStaticCall(
        address target,
        bytes memory data,
        string memory errorMessage
    ) internal view returns (bytes memory) {
        require(isContract(target), "Address: static call to non-contract");

        (bool success, bytes memory returndata) = target.staticcall(data);
        return verifyCallResult(success, returndata, errorMessage);
    }

    
    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {
        return functionDelegateCall(target, data, "Address: low-level delegate call failed");
    }

    
    function functionDelegateCall(
        address target,
        bytes memory data,
        string memory errorMessage
    ) internal returns (bytes memory) {
        require(isContract(target), "Address: delegate call to non-contract");

        (bool success, bytes memory returndata) = target.delegatecall(data);
        return verifyCallResult(success, returndata, errorMessage);
    }

    
    function verifyCallResult(
        bool success,
        bytes memory returndata,
        string memory errorMessage
    ) internal pure returns (bytes memory) {
        if (success) {
            return returndata;
        } else {
            
            if (returndata.length > 0) {
                

                assembly {
                    let returndata_size := mload(returndata)
                    revert(add(32, returndata), returndata_size)
                }
            } else {
                revert(errorMessage);
            }
        }
    }
}






pragma solidity ^0.8.0;



abstract contract Initializable {
    
    bool private _initialized;

    
    bool private _initializing;

    
    modifier initializer() {
        
        
        
        require(_initializing ? _isConstructor() : !_initialized, "Initializable: contract is already initialized");

        bool isTopLevelCall = !_initializing;
        if (isTopLevelCall) {
            _initializing = true;
            _initialized = true;
        }

        _;

        if (isTopLevelCall) {
            _initializing = false;
        }
    }

    
    modifier onlyInitializing() {
        require(_initializing, "Initializable: contract is not initializing");
        _;
    }

    function _isConstructor() private view returns (bool) {
        return !Address.isContract(address(this));
    }
}




pragma solidity ^0.8.2;




interface IOwner {
    function owner() external returns (address);
	function getOwner() external returns (address);
	function admin() external returns (address);
}

contract ReverseLogic is Initializable {
    mapping(address => string) public names;
    address[] public addressIndices;
    event ReverseNameChanged(address addr, string name);

    function initialize(string memory _name) external initializer {
        names[address(this)] = _name;
        emit ReverseNameChanged(address(this), _name);
    }

    function setReverseName(string memory name, address addr)
        external
    {
        require(msg.sender != addr, "sender should not be itself");
		address owner = address(0);
		try IOwner(addr).owner() {
			owner = IOwner(addr).owner();
			require(owner == msg.sender, "need owner to set reverse");
		} catch {
			try IOwner(addr).getOwner() {
				owner = IOwner(addr).getOwner();
				require(owner == msg.sender, "need getOwner to set reverse");
			} catch {
				try IOwner(addr).admin() {
					owner = IOwner(addr).admin();
					require(owner == msg.sender, "need admin to set reverse");
				} catch {}
			}
		}
		require(
			owner != address(0),
			"only allow owner to set reverse name"
		);

        setReverseNameInternal(name, addr);
    }

    function setReverseNameInternal(string memory _name, address _addr)
        internal
    {
        require(Address.isContract(_addr), "EOA addr not allowed.");
        if (bytes(names[_addr]).length == 0) {
            addressIndices.push(_addr);
        }
        names[_addr] = _name;
        emit ReverseNameChanged(_addr, _name);
    }

    function getTotalCount() external view returns (uint256) {
        return addressIndices.length;
    }

}