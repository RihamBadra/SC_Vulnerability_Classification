



pragma solidity 0.8.12;
pragma experimental ABIEncoderV2;






abstract contract Context {
    function _msgSender() internal view virtual returns (address) {
        return msg.sender;
    }

    function _msgData() internal view virtual returns (bytes calldata) {
        return msg.data;
    }
}



interface I3Pool {
    function add_liquidity(uint256[3] memory amounts, uint256 min_mint_amount)
        external;

        function get_virtual_price() external view returns(uint256);
}




interface IERC20 {
    
    function totalSupply() external view returns (uint256);

    
    function balanceOf(address account) external view returns (uint256);

    
    function transfer(address recipient, uint256 amount) external returns (bool);

    
    function allowance(address owner, address spender) external view returns (uint256);

    
    function approve(address spender, uint256 amount) external returns (bool);

    
    function transferFrom(
        address sender,
        address recipient,
        uint256 amount
    ) external returns (bool);

    
    event Transfer(address indexed from, address indexed to, uint256 value);

    
    event Approval(address indexed owner, address indexed spender, uint256 value);
}



interface IStaking {

    struct ProposalState {
        uint256 proposalTime;
        uint256 iBZRXWeight;
        uint256 lpBZRXBalance;
        uint256 lpTotalSupply;
    }

    struct AltRewardsUserInfo {
        uint256 rewardsPerShare;
        uint256 pendingRewards;
    }

    function getCurrentFeeTokens()
        external
        view
        returns (address[] memory);

    function maxUniswapDisagreement()
        external
        view
        returns (uint256);


    function isPaused()
        external
        view
        returns (bool);

    function fundsWallet()
        external
        view
        returns (address);


    function callerRewardDivisor()
        external
        view
        returns (uint256);


    function maxCurveDisagreement()
        external
        view
        returns (uint256);

    function rewardPercent()
        external
        view
        returns (uint256);

    function addRewards(uint256 newBZRX, uint256 newStableCoin)
        external;

    function stake(
        address[] calldata tokens,
        uint256[] calldata values
    )
        external;

    function unstake(
        address[] calldata tokens,
        uint256[] calldata values
    )
        external;


    function earned(address account)
        external
        view
        returns (
            uint256 bzrxRewardsEarned,
            uint256 stableCoinRewardsEarned,
            uint256 bzrxRewardsVesting,
            uint256 stableCoinRewardsVesting,
            uint256 sushiRewardsEarned
        );

    function pendingCrvRewards(address account)
    external
    view
    returns (
        uint256 bzrxRewardsEarned,
        uint256 stableCoinRewardsEarned,
        uint256 bzrxRewardsVesting,
        uint256 stableCoinRewardsVesting,
        uint256 sushiRewardsEarned
    );

    function getVariableWeights()
        external
        view
        returns (uint256 vBZRXWeight, uint256 iBZRXWeight, uint256 LPTokenWeight);

    function balanceOfByAsset(
        address token,
        address account)
        external
        view
        returns (uint256 balance);

    function balanceOfByAssets(
        address account)
        external
        view
        returns (
            uint256 bzrxBalance,
            uint256 iBZRXBalance,
            uint256 vBZRXBalance,
            uint256 LPTokenBalance,
            uint256 LPTokenBalanceOld
        );

    function balanceOfStored(
        address account)
        external
        view
        returns (uint256 vestedBalance, uint256 vestingBalance);

    function totalSupplyStored()
        external
        view
        returns (uint256 supply);

    function vestedBalanceForAmount(
        uint256 tokenBalance,
        uint256 lastUpdate,
        uint256 vestingEndTime)
        external
        view
        returns (uint256 vested);

    function votingBalanceOf(
        address account,
        uint256 proposalId)
        external
        view
        returns (uint256 totalVotes);

    function votingBalanceOfNow(
        address account)
        external
        view
        returns (uint256 totalVotes);

    function votingFromStakedBalanceOf(
        address account)
        external
        view
        returns (uint256 totalVotes);

    function _setProposalVals(
        address account,
        uint256 proposalId)
        external
        returns (uint256);

    function exit()
        external;

    function addAltRewards(address token, uint256 amount)
        external;

    function governor()
        external
        view
        returns(address);

}




abstract contract Ownable is Context {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    
    constructor() {
        _transferOwnership(_msgSender());
    }

    
    function owner() public view virtual returns (address) {
        return _owner;
    }

    
    modifier onlyOwner() {
        require(owner() == _msgSender(), "Ownable: caller is not the owner");
        _;
    }

    
    function renounceOwnership() public virtual onlyOwner {
        _transferOwnership(address(0));
    }

    
    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), "Ownable: new owner is the zero address");
        _transferOwnership(newOwner);
    }

    
    function _transferOwnership(address newOwner) internal virtual {
        address oldOwner = _owner;
        _owner = newOwner;
        emit OwnershipTransferred(oldOwner, newOwner);
    }
}



contract PausableGuardian_0_8 is Ownable {
    
    bytes32 internal constant Pausable_FunctionPause = 0xa7143c84d793a15503da6f19bf9119a2dac94448ca45d77c8bf08f57b2e91047;

    
    bytes32 internal constant Pausable_GuardianAddress = 0x80e6706973d0c59541550537fd6a33b971efad732635e6c3b99fb01006803cdf;

    modifier pausable() {
        require(!_isPaused(msg.sig) || msg.sender == getGuardian(), "paused");
        _;
    }

    function _isPaused(bytes4 sig) public view returns (bool isPaused) {
        bytes32 slot = keccak256(abi.encodePacked(sig, Pausable_FunctionPause));
        assembly {
            isPaused := sload(slot)
        }
    }

    function toggleFunctionPause(bytes4 sig) public {
        require(msg.sender == getGuardian() || msg.sender == owner(), "unauthorized");
        bytes32 slot = keccak256(abi.encodePacked(sig, Pausable_FunctionPause));
        assembly {
            sstore(slot, 1)
        }
    }

    function toggleFunctionUnPause(bytes4 sig) public {
        
        require(msg.sender == getGuardian() || msg.sender == owner(), "unauthorized");
        bytes32 slot = keccak256(abi.encodePacked(sig, Pausable_FunctionPause));
        assembly {
            sstore(slot, 0)
        }
    }

    function changeGuardian(address newGuardian) public {
        require(msg.sender == getGuardian() || msg.sender == owner(), "unauthorized");
        assembly {
            sstore(Pausable_GuardianAddress, newGuardian)
        }
    }

    function getGuardian() public view returns (address guardian) {
        assembly {
            guardian := sload(Pausable_GuardianAddress)
        }
    }
}



contract ConvertAndAdminister is PausableGuardian_0_8 {
    address public implementation;
    address public constant crv3 = 0x6c3F90f043a72FA612cbac8115EE7e52BDe6E490;
    address public constant pool3 = 0xbEbc44782C7dB0a1A60Cb6fe97d0b483032FF1C7;
    IERC20 public constant USDC =
        IERC20(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48);
    address public constant STAKING = 0x16f179f5C344cc29672A58Ea327A26F64B941a63; 
        address public constant TREASURY = 0xfedC4dD5247B93feb41e899A09C44cFaBec29Cbc;
    event Distributed(address indexed sender, uint256 treasury, uint256 stakers);

    function distributeFees() external pausable {
        _convertTo3Crv();
                uint256 total = IERC20(crv3).balanceOf(address(this));
                uint256 toTreasury = total*1000/3500;
                IERC20(crv3).transfer(TREASURY,toTreasury); 
                uint256 toStakers = IERC20(crv3).balanceOf(address(this));
        _addRewards(toStakers);
        emit Distributed(msg.sender, toTreasury, toStakers);
    }

    

    function _convertTo3Crv() internal returns(uint256 amountUsed) {
                amountUsed = USDC.balanceOf(address(this));
                uint256 min_amount = (amountUsed*1e12*1e18/I3Pool(pool3).get_virtual_price())*995/1000; 
        I3Pool(pool3).add_liquidity([0, amountUsed, 0], min_amount);
    }

    function _addRewards(uint256 amount) internal {
        IStaking(STAKING).addRewards(0, amount);
    }

    

    function setApprovals(
        address token,
        address spender,
        uint256 amount
    ) external onlyOwner {
        IERC20(token).approve(spender, 0);
        IERC20(token).approve(spender, amount);
    }
}