pragma solidity 0.5.16;

contract AufStaking2 {

    string public name = "Auf Staking phase 2";

    address public owner;

    AufToken public aufToken;



    address[] public stakers;

    mapping(address => uint) public stakingBalance;

    mapping(address => bool) public hasStaked;

    mapping(address => bool) public isStaking;



    constructor(AufToken _aufToken) public {

        aufToken = _aufToken;

        

        owner = msg.sender;

    }



    function stakeTokens(uint _amount) public {

        

        require(_amount > 0, "amount cannot be 0");



        

        aufToken.transferFrom(msg.sender, address(this), _amount);



        

        stakingBalance[msg.sender] = stakingBalance[msg.sender] + _amount;



        

        if(!hasStaked[msg.sender]) {

            stakers.push(msg.sender);

        }



        

        isStaking[msg.sender] = true;

        hasStaked[msg.sender] = true;

    }



    

    function unstakeTokens() public {

        

        uint balance = stakingBalance[msg.sender];



        

        require(balance > 0, "staking balance cannot be 0");



        

        aufToken.transfer(msg.sender, balance);



        

        stakingBalance[msg.sender] = 0;



        

        isStaking[msg.sender] = false;

    }



    

    function issueTokens() public {

        

        require(msg.sender == owner, "caller must be the owner");



        

        for (uint i=0; i<stakers.length; i++) {

            address recipient = stakers[i];

            uint balance = stakingBalance[recipient];

            if(balance > 0) {

                aufToken.transfer(recipient, balance * 10 / 100);

            }

        }

    }

}

contract AufToken {

    string  public name = "AmongUs.Finance";

    string  public symbol = "AUF";

    uint256 public totalSupply = 10000000000000000000000; 

    uint8   public decimals = 18;



    event Transfer(

        address indexed _from,

        address indexed _to,

        uint256 _value

    );



    event Approval(

        address indexed _owner,

        address indexed _spender,

        uint256 _value

    );



    mapping(address => uint256) public balanceOf;

    mapping(address => mapping(address => uint256)) public allowance;



    constructor() public {

        balanceOf[msg.sender] = totalSupply;

    }



    function transfer(address _to, uint256 _value) public returns (bool success) {

        require(balanceOf[msg.sender] >= _value);

        balanceOf[msg.sender] -= _value;

        balanceOf[_to] += _value;

        emit Transfer(msg.sender, _to, _value);

        return true;

    }



    function approve(address _spender, uint256 _value) public returns (bool success) {

        allowance[msg.sender][_spender] = _value;

        emit Approval(msg.sender, _spender, _value);

        return true;

    }



    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {

        require(_value <= balanceOf[_from]);

        require(_value <= allowance[_from][msg.sender]);

        balanceOf[_from] -= _value;

        balanceOf[_to] += _value;

        allowance[_from][msg.sender] -= _value;

        emit Transfer(_from, _to, _value);

        return true;

    }

}
