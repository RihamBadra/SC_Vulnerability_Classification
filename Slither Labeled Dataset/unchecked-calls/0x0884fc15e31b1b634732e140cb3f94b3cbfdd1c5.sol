





pragma solidity ^0.8.0;




interface IERC20 {
    
    function totalSupply() external view returns (uint256);

    
    function balanceOf(address account) external view returns (uint256);

    
    function transfer(address recipient, uint256 amount) external returns (bool);

    
    function allowance(address owner, address spender) external view returns (uint256);

    
    function approve(address spender, uint256 amount) external returns (bool);

    
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);

    
    event Transfer(address indexed from, address indexed to, uint256 value);

    
    event Approval(address indexed owner, address indexed spender, uint256 value);
}




interface IERC165 {
    
    function supportsInterface(bytes4 interfaceId) external view returns (bool);
}




interface IERC721 is IERC165 {
    
    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);

    
    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);

    
    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);

    
    function balanceOf(address owner) external view returns (uint256 balance);

    
    function ownerOf(uint256 tokenId) external view returns (address owner);

    
    function safeTransferFrom(address from, address to, uint256 tokenId) external;

    
    function transferFrom(address from, address to, uint256 tokenId) external;

    
    function approve(address to, uint256 tokenId) external;

    
    function getApproved(uint256 tokenId) external view returns (address operator);

    
    function setApprovalForAll(address operator, bool _approved) external;

    
    function isApprovedForAll(address owner, address operator) external view returns (bool);

    
    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;
}





interface ENSRegistryOwnerI {
    function owner(bytes32 node) external view returns (address);
}

interface ENSReverseRegistrarI {
    event NameChanged(bytes32 indexed node, string name);
    
    function setName(string calldata name) external returns (bytes32);
}





interface BridgeDataI {

    event AddressChanged(string name, address previousAddress, address newAddress);
    event ConnectedChainChanged(string previousConnectedChainName, string newConnectedChainName);
    event TokenURIBaseChanged(string previousTokenURIBase, string newTokenURIBase);
    event TokenSunsetAnnounced(uint256 indexed timestamp);

    
    function connectedChainName() external view returns (string memory);

    
    function ownChainName() external view returns (string memory);

    
    function tokenURIBase() external view returns (string memory);

    
    function tokenSunsetTimestamp() external view returns (uint256);

    
    function setTokenSunsetTimestamp(uint256 _timestamp) external;

    
    function setAddress(string memory name, address newAddress) external;

    
    function getAddress(string memory name) external view returns (address);
}









contract BridgeData is BridgeDataI {
    
    string public override connectedChainName;
    string public override ownChainName;
    
    string public override tokenURIBase;

    
    uint256 public override tokenSunsetTimestamp;
    uint256 public immutable sunsetDelay;

    
    mapping (bytes32 => address) private addresses;

    constructor(string memory _connectedChainName, string memory _ownChainName, string memory _tokenURIBase, uint256 _sunsetDelay, address _tokenAssignmentControl)
    {
        
        
        _setAddress("bridgeControl", msg.sender);
        _setAddress("tokenAssignmentControl", _tokenAssignmentControl);
        sunsetDelay = _sunsetDelay;
        connectedChainName = _connectedChainName;
        ownChainName = _ownChainName;
        tokenURIBase = _tokenURIBase;
    }

    modifier onlyBridgeControl()
    {
        require(msg.sender == getAddress("bridgeControl"), "bridgeControl key required for this function.");
        _;
    }

    modifier onlyBridge()
    {
        require(msg.sender == getAddress("bridgeControl") || msg.sender == getAddress("bridgeHead"), "bridgeControl key or bridge head required for this function.");
        _;
    }

    modifier onlyTokenAssignmentControl() {
        require(msg.sender == getAddress("tokenAssignmentControl"), "tokenAssignmentControl key required for this function.");
        _;
    }

    

    function setConnectedChain(string memory _newConnectedChainName)
    external
    onlyBridgeControl
    {
        require(bytes(_newConnectedChainName).length > 0, "You need to provide an actual chain name string.");
        emit ConnectedChainChanged(connectedChainName, _newConnectedChainName);
        connectedChainName = _newConnectedChainName;
    }

    function setTokenURIBase(string memory _newTokenURIBase)
    external
    onlyBridgeControl
    {
        require(bytes(_newTokenURIBase).length > 0, "You need to provide an actual token URI base string.");
        emit TokenURIBaseChanged(tokenURIBase, _newTokenURIBase);
        tokenURIBase = _newTokenURIBase;
    }

    
    
    
    
    function setTokenSunsetTimestamp(uint256 _timestamp)
    public override
    onlyBridge
    {
        require(_timestamp == 0 || _timestamp >= block.timestamp + sunsetDelay ||
                (tokenSunsetTimestamp > 0 && _timestamp >= tokenSunsetTimestamp && _timestamp >= block.timestamp),
                "Sunset needs to be 0 or (enough) in the future.");
        tokenSunsetTimestamp = _timestamp;
        emit TokenSunsetAnnounced(_timestamp);
    }

    function setAddress(string memory _name, address _newAddress)
    public override
    onlyBridge
    {
        _setAddress(_name, _newAddress);
    }

    function _setAddress(string memory _name, address _newAddress)
    internal
    {
        bytes32 nameHash = _getNameHash(_name);
        require(_newAddress != address(0) || nameHash != _getNameHash("bridgeControl"), "bridgeControl cannot be the zero address.");
        emit AddressChanged(_name, addresses[nameHash], _newAddress);
        addresses[nameHash] = _newAddress;
    }

    function getAddress(string memory _name)
    public view override
    returns (address)
    {
        return addresses[_getNameHash(_name)];
    }

    function _getNameHash(string memory _name)
    internal pure
    returns (bytes32 _hash)
    {
        return keccak256(abi.encodePacked(_name));
    }

    

    
    
    
    function registerReverseENS(address _reverseRegistrarAddress, string calldata _name)
    external
    onlyTokenAssignmentControl
    {
        require(_reverseRegistrarAddress != address(0), "need a valid reverse registrar");
        ENSReverseRegistrarI(_reverseRegistrarAddress).setName(_name);
    }

    

    
    function rescueToken(address _foreignToken, address _to)
    external
    onlyTokenAssignmentControl
    {
        IERC20 erc20Token = IERC20(_foreignToken);
        erc20Token.transfer(_to, erc20Token.balanceOf(address(this)));
    }

    
    function approveNFTrescue(IERC721 _foreignNFT, address _to)
    external
    onlyTokenAssignmentControl
    {
        _foreignNFT.setApprovalForAll(_to, true);
    }

}