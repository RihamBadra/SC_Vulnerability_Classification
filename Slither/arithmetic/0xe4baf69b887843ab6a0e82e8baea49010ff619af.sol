pragma solidity 0.6.2;

library Address {


    


    function isContract(address account) internal view returns (bool) {


        


        


        





        uint256 size;


        


        assembly { size := extcodesize(account) }


        return size > 0;


    }





    


    function sendValue(address payable recipient, uint256 amount) internal {


        require(address(this).balance >= amount, "Address: insufficient balance");





        


        (bool success, ) = recipient.call{ value: amount }("");


        require(success, "Address: unable to send value, recipient may have reverted");


    }





    


    function functionCall(address target, bytes memory data) internal returns (bytes memory) {


      return functionCall(target, data, "Address: low-level call failed");


    }





    


    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {


        return _functionCallWithValue(target, data, 0, errorMessage);


    }





    


    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {


        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");


    }





    


    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {


        require(address(this).balance >= value, "Address: insufficient balance for call");


        return _functionCallWithValue(target, data, value, errorMessage);


    }





    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {


        require(isContract(target), "Address: call to non-contract");





        


        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);


        if (success) {


            return returndata;


        } else {


            


            if (returndata.length > 0) {


                





                


                assembly {


                    let returndata_size := mload(returndata)


                    revert(add(32, returndata), returndata_size)


                }


            } else {


                revert(errorMessage);


            }


        }


    }


}

abstract contract Context {


    function _msgSender() internal view virtual returns (address payable) {


        return msg.sender;


    }





    function _msgData() internal view virtual returns (bytes memory) {


        this; 


        return msg.data;


    }


}

interface IERC20 {


    


    function totalSupply() external view returns (uint256);





    


    function balanceOf(address account) external view returns (uint256);





    


    function transfer(address recipient, uint256 amount) external returns (bool);





    


    function allowance(address owner, address spender) external view returns (uint256);





    


    function approve(address spender, uint256 amount) external returns (bool);





    


    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);





    


    event Transfer(address indexed from, address indexed to, uint256 value);





    


    event Approval(address indexed owner, address indexed spender, uint256 value);


}

contract MXXERC20 is Context, IERC20 {


    using SafeMath for uint256;


    using Address for address;





    mapping (address => uint256) private _balances;





    mapping (address => mapping (address => uint256)) private _allowances;





    uint256 private _totalSupply;





    string private _name;


    string private _symbol;


    uint8 private _decimals;





    


    constructor (string memory name, string memory symbol) public {


        _name = name;


        _symbol = symbol;


        _decimals = 18;


    }





    


    function name() public view returns (string memory) {


        return _name;


    }





    


    function symbol() public view returns (string memory) {


        return _symbol;


    }





    


    function decimals() public view returns (uint8) {


        return _decimals;


    }





    


    function totalSupply() public view override returns (uint256) {


        return _totalSupply;


    }





    


    function balanceOf(address account) public view override returns (uint256) {


        return _balances[account];


    }





    


    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {


        _transfer(_msgSender(), recipient, amount);


        return true;


    }





    


    function allowance(address owner, address spender) public view virtual override returns (uint256) {


        return _allowances[owner][spender];


    }





    


    function approve(address spender, uint256 amount) public virtual override returns (bool) {


        _approve(_msgSender(), spender, amount);


        return true;


    }





    


    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {


        _transfer(sender, recipient, amount);


        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, "ERC20: transfer amount exceeds allowance"));


        return true;


    }





    


    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {


        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));


        return true;


    }





    


    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {


        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, "ERC20: decreased allowance below zero"));


        return true;


    }





    


    function _transfer(address sender, address recipient, uint256 amount) internal virtual {


        


        





        _beforeTokenTransfer(sender, recipient, amount);





        _balances[sender] = _balances[sender].sub(amount, "ERC20: transfer amount exceeds balance");


        _balances[recipient] = _balances[recipient].add(amount);


        emit Transfer(sender, recipient, amount);


    }





    


    function _mint(address account, uint256 amount) internal virtual {


        require(account != address(0), "ERC20: mint to the zero address");





        _beforeTokenTransfer(address(0), account, amount);





        _totalSupply = _totalSupply.add(amount);


        _balances[account] = _balances[account].add(amount);


        emit Transfer(address(0), account, amount);


    }





    


    function _burn(address account, uint256 amount) internal virtual {


        require(account != address(0), "ERC20: burn from the zero address");





        _beforeTokenTransfer(account, address(0), amount);





        _balances[account] = _balances[account].sub(amount, "ERC20: burn amount exceeds balance");


        _totalSupply = _totalSupply.sub(amount);


        emit Transfer(account, address(0), amount);


    }





    


    function _approve(address owner, address spender, uint256 amount) internal virtual {


        require(owner != address(0), "ERC20: approve from the zero address");


        require(spender != address(0), "ERC20: approve to the zero address");





        _allowances[owner][spender] = amount;


        emit Approval(owner, spender, amount);


    }





    


    function _setupDecimals(uint8 decimals_) internal {


        _decimals = decimals_;


    }





    


    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }


}

contract Ownable is Context {


    address private _owner;





    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);





    


    constructor () internal {


        address msgSender = _msgSender();


        _owner = msgSender;


        emit OwnershipTransferred(address(0), msgSender);


    }





    


    function owner() public view returns (address) {


        return _owner;


    }





    


    modifier onlyOwner() {


        require(_owner == _msgSender(), "Ownable: caller is not the owner");


        _;


    }





    


    function renounceOwnership() public virtual onlyOwner {


        emit OwnershipTransferred(_owner, address(0));


        _owner = address(0);


    }





    


    function transferOwnership(address newOwner) public virtual onlyOwner {


        require(newOwner != address(0), "Ownable: new owner is the zero address");


        emit OwnershipTransferred(_owner, newOwner);


        _owner = newOwner;


    }


}

contract ReentrancyGuard {


    


    


    


    


    





    


    


    


    


    


    uint256 private constant _NOT_ENTERED = 1;


    uint256 private constant _ENTERED = 2;





    uint256 private _status;





    constructor () internal {


        _status = _NOT_ENTERED;


    }





    


    modifier nonReentrant() {


        


        require(_status != _ENTERED, "ReentrancyGuard: reentrant call");





        


        _status = _ENTERED;





        _;





        


        


        _status = _NOT_ENTERED;


    }


}

library SafeERC20 {

    using SafeMath for uint256;

    using Address for address;



    function safeTransfer(IERC20 token, address to, uint256 value) internal {

        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));

    }



    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {

        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));

    }



    

    function safeApprove(IERC20 token, address spender, uint256 value) internal {

        

        

        

        

        require((value == 0) || (token.allowance(address(this), spender) == 0),

            "SafeERC20: approve from non-zero to non-zero allowance"

        );

        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));

    }



    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {

        uint256 newAllowance = token.allowance(address(this), spender).add(value);

        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));

    }



    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {

        uint256 newAllowance = token.allowance(address(this), spender).sub(value, "SafeERC20: decreased allowance below zero");

        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));

    }



    

    function _callOptionalReturn(IERC20 token, bytes memory data) private {

        

        

        



        bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");

        if (returndata.length > 0) { 

            

            require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");

        }

    }

}

library SafeMath {


    


    function add(uint256 a, uint256 b) internal pure returns (uint256) {


        uint256 c = a + b;


        require(c >= a, "SafeMath: addition overflow");





        return c;


    }





    


    function sub(uint256 a, uint256 b) internal pure returns (uint256) {


        return sub(a, b, "SafeMath: subtraction overflow");


    }





    


    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {


        require(b <= a, errorMessage);


        uint256 c = a - b;





        return c;


    }





    


    function mul(uint256 a, uint256 b) internal pure returns (uint256) {


        


        


        


        if (a == 0) {


            return 0;


        }





        uint256 c = a * b;


        require(c / a == b, "SafeMath: multiplication overflow");





        return c;


    }





    


    function div(uint256 a, uint256 b) internal pure returns (uint256) {


        return div(a, b, "SafeMath: division by zero");


    }





    


    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {


        require(b > 0, errorMessage);


        uint256 c = a / b;


        





        return c;


    }





    


    function mod(uint256 a, uint256 b) internal pure returns (uint256) {


        return mod(a, b, "SafeMath: modulo by zero");


    }





    


    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {


        require(b != 0, errorMessage);


        return a % b;


    }


}

contract YieldContract is Ownable, ReentrancyGuard {

    

    using SafeERC20 for ERC20;



    

    using SafeMath for uint256;



    

    using Address for address;



    



    

    address[] public erc20List;



    

    struct Erc20Details {

        string symbol;

        bool isValid;

        uint64 noContracts;

        uint256 mFactor;

    }



    

    mapping(address => Erc20Details) public erc20Map;



    

    bytes32[] public allContracts;



    

    enum Status {

        Inactive, 

        Active, 

        OpenMarket, 

        Claimed, 

        Destroyed

    }



    

    enum ParamType {

        ContractFee,

        MinEarlyRedeemFee,

        MaxEarlyRedeemFee,

        TotalAllocatedMxx

    }



    

    struct ContractDetails {

        address contractOwner;

        uint48 startTime;

        uint48 endTime;

        address tokenAddress;

        uint16 tenure;

        uint64 interest;

        Status contractStatus;

        uint256 collateral;

        uint256 mxxToBeMinted;

    }



    

    mapping(bytes32 => ContractDetails) public contractMap;



    

    mapping(uint256 => uint64) public tenureApyMap;



    

    uint64 public contractFee;



    

    address public constant MXX_ADDRESS = 0x8a6f3BF52A26a21531514E23016eEAe8Ba7e7018;



    

    address public constant BURN_ADDRESS = 0x19B292c1a84379Aab41564283e7f75bF20e45f91;



    

    address internal constant ZERO_ADDRESS = address(0);



    

    uint64 internal constant POW6 = 1000000;



    

    uint256 public totalAllocatedMxx;



    

    uint256 public mxxMintedFromContract;



    

    uint64 public minEarlyRedeemFee;

    uint64 public maxEarlyRedeemFee;



    



    constructor(uint256 _mxxmFactor) public Ownable() {

        

        tenureApyMap[90] = 2 * POW6;

        tenureApyMap[180] = 4 * POW6;

        tenureApyMap[270] = 10 * POW6;

        contractFee = (8 * POW6) / 100;

        totalAllocatedMxx = 1000000000 * (10**8); 

        minEarlyRedeemFee = (5 * POW6) / 100;

        maxEarlyRedeemFee = (5 * POW6) / 10;



        addErc20(MXX_ADDRESS, _mxxmFactor);

    }



    



    



    modifier onlyErc20OrEth(address _erc20Address) {

        require(

            _erc20Address == ZERO_ADDRESS || Address.isContract(_erc20Address),

            "Not contract address"

        );

        _;

    }



    



    modifier inErc20List(address _erc20Address) {

        require(

            erc20Map[_erc20Address].mFactor != 0 ||

                bytes(erc20Map[_erc20Address].symbol).length != 0,

            "Not in ERC20 list"

        );

        _;

    }



    



    



    function getIndex(address _inputAddress, address[] memory _inputAddressList)

        internal

        pure

        returns (uint256 index, bool isFound)

    {

        

        for (uint256 i = 0; i < _inputAddressList.length; i++) {

            

            if (_inputAddress == _inputAddressList[i]) {

                return (i, true);

            }

        }



        

        return (0, false);

    }



    



    



    function setInterest(uint256 _tenure, uint64 _interestRate)

        public

        onlyOwner()

        returns (bool)

    {

        tenureApyMap[_tenure] = _interestRate;

        return true;

    }



    



    function setParamType(ParamType _parameter, uint256 _value)

        public

        onlyOwner()

        returns (bool)

    {

        if (_parameter == ParamType.ContractFee) {

            contractFee = uint64(_value);

        } else if (_parameter == ParamType.MinEarlyRedeemFee) {

            require(

                uint64(_value) <= maxEarlyRedeemFee,

                "Greater than max redeem fee"

            );

            minEarlyRedeemFee = uint64(_value);

        } else if (_parameter == ParamType.MaxEarlyRedeemFee) {

            require(

                uint64(_value) >= minEarlyRedeemFee,

                "Less than min redeem fee"

            );

            maxEarlyRedeemFee = uint64(_value);

        } else if (_parameter == ParamType.TotalAllocatedMxx) {

            require(

                _value >= mxxMintedFromContract,

                "Less than total mxx minted"

            );

            totalAllocatedMxx = _value;

        }

    }



    



    

    function addErc20(address _erc20Address, uint256 _mFactor)

        public

        onlyOwner()

        onlyErc20OrEth(_erc20Address)

        returns (bool)

    {

        

        require(

            erc20Map[_erc20Address].noContracts == 0,

            "Token has existing contracts"

        );

        require(!erc20Map[_erc20Address].isValid, "Token already available");



        

        

        erc20Map[_erc20Address] = Erc20Details(

            (_erc20Address == ZERO_ADDRESS)

                ? "ETH"

                : ERC20(_erc20Address).symbol(),

            true,

            0,

            _mFactor

        );



        erc20List.push(_erc20Address);

        return true;

    }



    

    function addErc20List(

        address[] memory _erc20AddressList,

        uint256[] memory _mFactorList

    ) public onlyOwner() returns (bool) {

        

        require(

            _erc20AddressList.length == _mFactorList.length,

            "Inconsistent Inputs"

        );



        

        for (uint256 i = 0; i < _erc20AddressList.length; i++) {

            addErc20(_erc20AddressList[i], _mFactorList[i]);

        }

        return true;

    }



    

    function removeErc20(address _erc20Address)

        public

        onlyOwner()

        returns (bool)

    {

        

        require(_erc20Address != MXX_ADDRESS, "Cannot remove MXX");



        

        require(

            erc20Map[_erc20Address].noContracts == 0,

            "Token has existing contracts"

        );



        

        uint256 index;

        bool isFound;

        (index, isFound) = getIndex(_erc20Address, erc20List);



        

        require(isFound, "Address not found");



        

        address lastErc20Address = erc20List[erc20List.length - 1];



        

        erc20List[index] = lastErc20Address;



        

        erc20List.pop();



        

        delete erc20Map[_erc20Address];

        return true;

    }



    

    function setErc20Validity(address _erc20Address, bool _isValid)

        public

        onlyOwner()

        inErc20List(_erc20Address)

        returns (bool)

    {

        

        erc20Map[_erc20Address].isValid = _isValid;

        return true;

    }



    

    function updateMFactor(address _erc20Address, uint256 _mFactor)

        public

        onlyOwner()

        inErc20List(_erc20Address)

        onlyErc20OrEth(_erc20Address)

        returns (bool)

    {

        

        erc20Map[_erc20Address].mFactor = _mFactor;

        return true;

    }



    

    function updateMFactorList(

        address[] memory _erc20AddressList,

        uint256[] memory _mFactorList

    ) public onlyOwner() returns (bool) {

        

        require(

            _erc20AddressList.length == _mFactorList.length,

            "Inconsistent Inputs"

        );



        

        for (uint256 i = 0; i < _erc20AddressList.length; i++) {

            updateMFactor(_erc20AddressList[i], _mFactorList[i]);

        }

        return true;

    }



    

    function getNoOfErc20s() public view returns (uint256) {

        return (erc20List.length);

    }



    

    function getSubsetErc20List(uint256 _start, uint256 _end)

        public

        view

        returns (address[] memory)

    {

        

        if (_end >= erc20List.length) {

            _end = erc20List.length - 1;

        }



        

        require(_start <= _end, "Invalid limits");



        

        uint256 noOfElements = _end - _start + 1;

        address[] memory subsetErc20List = new address[](noOfElements);



        

        for (uint256 i = _start; i <= _end; i++) {

            subsetErc20List[i - _start] = erc20List[i];

        }

        return subsetErc20List;

    }



    



    



    function createYieldContract(

        address _erc20Address,

        uint256 _collateral,

        uint16 _tenure

    ) external payable nonReentrant() {

        

        require(erc20Map[_erc20Address].isValid, "Token/Coin not approved");



        

        bytes32 contractId = keccak256(

            abi.encode(msg.sender, _erc20Address, now, allContracts.length)

        );

        require(

            contractMap[contractId].contractStatus == Status.Inactive,

            "Contract already exists"

        );



        

        require(tenureApyMap[_tenure] != 0, "No interest rate is set");



        

        uint256 collateralDecimals;



        

        require(_collateral != 0, "Collateral is 0");



        if (_erc20Address == ZERO_ADDRESS) {

            

            require(msg.value == _collateral, "Incorrect funds");



            

            collateralDecimals = 10**18;

        } else {

            

            require(msg.value == 0, "Incorrect funds");



            collateralDecimals = 10**uint256(ERC20(_erc20Address).decimals());



            

            ERC20(_erc20Address).safeTransferFrom(

                msg.sender,

                address(this),

                _collateral

            );

        }



        

        uint256 numerator = _collateral

            .mul(erc20Map[_erc20Address].mFactor)

            .mul(tenureApyMap[_tenure])

            .mul(10**uint256(ERC20(MXX_ADDRESS).decimals()))

            .mul(_tenure);

        uint256 denominator = collateralDecimals

            .mul(erc20Map[MXX_ADDRESS].mFactor)

            .mul(365 * POW6);

        uint256 valueToBeMinted = numerator.div(denominator);



        

        mxxMintedFromContract = mxxMintedFromContract.add(valueToBeMinted);



        

        require(

            totalAllocatedMxx >= mxxMintedFromContract,

            "Total allocated MXX exceeded"

        );



        

        numerator = valueToBeMinted.mul(contractFee);

        denominator = POW6;

        uint256 valueToBeBurnt = numerator.div(denominator);



        

        ERC20(MXX_ADDRESS).safeTransferFrom(

            msg.sender,

            BURN_ADDRESS,

            valueToBeBurnt

        );



        

        contractMap[contractId] = ContractDetails(

            msg.sender,

            uint48(now),

            uint48(now.add(uint256(_tenure).mul(1 days))),

            _erc20Address,

            _tenure,

            tenureApyMap[_tenure],

            Status.Active,

            _collateral,

            valueToBeMinted

        );



        

        allContracts.push(contractId);



        

        erc20Map[_erc20Address].noContracts += 1;

    }



    



    function earlyRedeemContract(bytes32 _contractId) external nonReentrant() {

        

        require(

            contractMap[_contractId].contractStatus == Status.Active,

            "Contract is not active"

        );



        

        require(

            contractMap[_contractId].contractOwner == msg.sender,

            "Redeemer is not owner"

        );



        

        require(

            now < contractMap[_contractId].endTime,

            "Contract is beyond its end time"

        );



        

        uint256 numerator = now.sub(contractMap[_contractId].startTime).mul(

            contractMap[_contractId].mxxToBeMinted

        );

        uint256 denominator = uint256(contractMap[_contractId].endTime).sub(

            contractMap[_contractId].startTime

        );

        uint256 mxxMintedTillDate = numerator.div(denominator);



        

        numerator = uint256(maxEarlyRedeemFee).sub(minEarlyRedeemFee).mul(

            now.sub(contractMap[_contractId].startTime)

        );

        uint256 penaltyPercent = uint256(maxEarlyRedeemFee).sub(

            numerator.div(denominator)

        );



        

        numerator = penaltyPercent.mul(mxxMintedTillDate);

        uint256 penaltyMXXToBurn = numerator.div(POW6);



        

        require(penaltyMXXToBurn != 0, "No penalty MXX");



        

        uint256 mxxToBeSent = mxxMintedTillDate.sub(penaltyMXXToBurn);



        

        if (contractMap[_contractId].tokenAddress == ZERO_ADDRESS) {

            

            (bool success, ) = contractMap[_contractId].contractOwner.call{

                value: contractMap[_contractId].collateral

            }("");

            require(success, "Transfer failed");

        } else {

            

            ERC20(contractMap[_contractId].tokenAddress).safeTransfer(

                contractMap[_contractId].contractOwner,

                contractMap[_contractId].collateral

            );

        }



        

        ERC20(MXX_ADDRESS).safeTransfer(

            contractMap[_contractId].contractOwner,

            mxxToBeSent

        );



        

        ERC20(MXX_ADDRESS).safeTransfer(BURN_ADDRESS, penaltyMXXToBurn);



        

        contractMap[_contractId].startTime = uint48(now);

        contractMap[_contractId].mxxToBeMinted = contractMap[_contractId]

            .mxxToBeMinted

            .sub(mxxMintedTillDate);

        contractMap[_contractId].contractOwner = ZERO_ADDRESS;

        contractMap[_contractId].contractStatus = Status.OpenMarket;

    }



    



    function acquireYieldContract(bytes32 _contractId)

        external

        payable

        nonReentrant()

    {

        

        require(

            contractMap[_contractId].contractStatus == Status.OpenMarket,

            "Contract not in open market"

        );



        

        if (contractMap[_contractId].tokenAddress != ZERO_ADDRESS) {

            

            require(msg.value == 0, "ETH should not be sent");

            ERC20(contractMap[_contractId].tokenAddress).safeTransferFrom(

                msg.sender,

                address(this),

                contractMap[_contractId].collateral

            );

        } else {

            

            require(

                msg.value == contractMap[_contractId].collateral,

                "Incorrect funds"

            );

        }



        

        contractMap[_contractId].contractOwner = msg.sender;

        contractMap[_contractId].contractStatus = Status.Active;

    }



    



    function destroyOMContract(bytes32 _contractId)

        external

        onlyOwner()

        nonReentrant()

    {

        

        require(

            contractMap[_contractId].contractStatus == Status.OpenMarket,

            "Contract not in open market"

        );



        

        mxxMintedFromContract -= contractMap[_contractId].mxxToBeMinted;

        contractMap[_contractId].contractStatus = Status.Destroyed;

    }



    



    function claimYieldContract(bytes32 _contractId) external nonReentrant() {

        

        require(

            contractMap[_contractId].contractStatus == Status.Active,

            "Contract is not active"

        );



        

        require(

            contractMap[_contractId].contractOwner == msg.sender,

            "Contract owned by someone else"

        );



        

        require(now >= contractMap[_contractId].endTime, "Too early to claim");



        

        if (contractMap[_contractId].tokenAddress == ZERO_ADDRESS) {

            

            (bool success, ) = contractMap[_contractId].contractOwner.call{

                value: contractMap[_contractId].collateral

            }("");

            require(success, "Transfer failed");

        } else {

            

            ERC20(contractMap[_contractId].tokenAddress).safeTransfer(

                contractMap[_contractId].contractOwner,

                contractMap[_contractId].collateral

            );

        }



        

        ERC20(MXX_ADDRESS).safeTransfer(

            contractMap[_contractId].contractOwner,

            contractMap[_contractId].mxxToBeMinted

        );



        

        contractMap[_contractId].contractStatus = Status.Claimed;



        

        erc20Map[contractMap[_contractId].tokenAddress].noContracts -= 1;

    }



    



    function getSubsetYieldContracts(uint256 _start, uint256 _end)

        public

        view

        returns (bytes32[] memory)

    {

        

        if (_end >= allContracts.length) {

            _end = allContracts.length.sub(1);

        }



        

        require(_start <= _end, "Invalid limits");



        

        uint256 noOfElements = _end.sub(_start).add(1);

        bytes32[] memory subsetYieldContracts = new bytes32[](noOfElements);



        

        for (uint256 i = _start; i <= _end; i++) {

            subsetYieldContracts[i - _start] = allContracts[i];

        }



        return subsetYieldContracts;

    }



    



    function withdrawMXX(uint256 _amount)

        public

        onlyOwner()

        nonReentrant()

        returns (bool)

    {

        ERC20(MXX_ADDRESS).safeTransfer(msg.sender, _amount);

        return true;

    }

}

contract ERC20 is Context, IERC20 {


    using SafeMath for uint256;


    using Address for address;





    mapping (address => uint256) private _balances;





    mapping (address => mapping (address => uint256)) private _allowances;





    uint256 private _totalSupply;





    string private _name;


    string private _symbol;


    uint8 private _decimals;





    


    constructor (string memory name, string memory symbol) public {


        _name = name;


        _symbol = symbol;


        _decimals = 18;


    }





    


    function name() public view returns (string memory) {


        return _name;


    }





    


    function symbol() public view returns (string memory) {


        return _symbol;


    }





    


    function decimals() public view returns (uint8) {


        return _decimals;


    }





    


    function totalSupply() public view override returns (uint256) {


        return _totalSupply;


    }





    


    function balanceOf(address account) public view override returns (uint256) {


        return _balances[account];


    }





    


    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {


        _transfer(_msgSender(), recipient, amount);


        return true;


    }





    


    function allowance(address owner, address spender) public view virtual override returns (uint256) {


        return _allowances[owner][spender];


    }





    


    function approve(address spender, uint256 amount) public virtual override returns (bool) {


        _approve(_msgSender(), spender, amount);


        return true;


    }





    


    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {


        _transfer(sender, recipient, amount);


        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, "ERC20: transfer amount exceeds allowance"));


        return true;


    }





    


    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {


        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));


        return true;


    }





    


    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {


        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, "ERC20: decreased allowance below zero"));


        return true;


    }





    


    function _transfer(address sender, address recipient, uint256 amount) internal virtual {


        require(sender != address(0), "ERC20: transfer from the zero address");


        require(recipient != address(0), "ERC20: transfer to the zero address");





        _beforeTokenTransfer(sender, recipient, amount);





        _balances[sender] = _balances[sender].sub(amount, "ERC20: transfer amount exceeds balance");


        _balances[recipient] = _balances[recipient].add(amount);


        emit Transfer(sender, recipient, amount);


    }





    


    function _mint(address account, uint256 amount) internal virtual {


        require(account != address(0), "ERC20: mint to the zero address");





        _beforeTokenTransfer(address(0), account, amount);





        _totalSupply = _totalSupply.add(amount);


        _balances[account] = _balances[account].add(amount);


        emit Transfer(address(0), account, amount);


    }





    


    function _burn(address account, uint256 amount) internal virtual {


        require(account != address(0), "ERC20: burn from the zero address");





        _beforeTokenTransfer(account, address(0), amount);





        _balances[account] = _balances[account].sub(amount, "ERC20: burn amount exceeds balance");


        _totalSupply = _totalSupply.sub(amount);


        emit Transfer(account, address(0), amount);


    }





    


    function _approve(address owner, address spender, uint256 amount) internal virtual {


        require(owner != address(0), "ERC20: approve from the zero address");


        require(spender != address(0), "ERC20: approve to the zero address");





        _allowances[owner][spender] = amount;


        emit Approval(owner, spender, amount);


    }





    


    function _setupDecimals(uint8 decimals_) internal {


        _decimals = decimals_;


    }





    


    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }


}
