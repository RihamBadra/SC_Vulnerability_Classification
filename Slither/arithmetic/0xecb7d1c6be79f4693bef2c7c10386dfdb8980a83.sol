pragma solidity 0.5.17;

interface GAMER {

    function gamersScalingFactor() external view returns (uint256);

    function balanceOfUnderlying(address amount) external returns(uint256);

    function mint(address to, uint256 amount) external;

}

library Math {

    

    function max(uint256 a, uint256 b) internal pure returns (uint256) {

        return a >= b ? a : b;

    }



    

    function min(uint256 a, uint256 b) internal pure returns (uint256) {

        return a < b ? a : b;

    }



    

    function average(uint256 a, uint256 b) internal pure returns (uint256) {

        

        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);

    }

}

library SafeMath {

    

    function add(uint256 a, uint256 b) internal pure returns (uint256) {

        uint256 c = a + b;

        require(c >= a, "SafeMath: addition overflow");



        return c;

    }



    

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {

        return sub(a, b, "SafeMath: subtraction overflow");

    }



    

    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {

        require(b <= a, errorMessage);

        uint256 c = a - b;



        return c;

    }



    

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {

        

        

        

        if (a == 0) {

            return 0;

        }



        uint256 c = a * b;

        require(c / a == b, "SafeMath: multiplication overflow");



        return c;

    }



    

    function div(uint256 a, uint256 b) internal pure returns (uint256) {

        return div(a, b, "SafeMath: division by zero");

    }



    

    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {

        

        require(b > 0, errorMessage);

        uint256 c = a / b;

        



        return c;

    }



    

    function mod(uint256 a, uint256 b) internal pure returns (uint256) {

        return mod(a, b, "SafeMath: modulo by zero");

    }



    

    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {

        require(b != 0, errorMessage);

        return a % b;

    }

}

contract Context {

    

    

    constructor () internal { }

    



    function _msgSender() internal view returns (address payable) {

        return msg.sender;

    }



    function _msgData() internal view returns (bytes memory) {

        this; 

        return msg.data;

    }

}

contract Ownable is Context {

    address private _owner;



    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);



    

    constructor () internal {

        _owner = _msgSender();

        emit OwnershipTransferred(address(0), _owner);

    }



    

    function owner() public view returns (address) {

        return _owner;

    }



    

    modifier onlyOwner() {

        require(isOwner(), "Ownable: caller is not the owner");

        _;

    }



    

    function isOwner() public view returns (bool) {

        return _msgSender() == _owner;

    }



    

    function renounceOwnership() public onlyOwner {

        emit OwnershipTransferred(_owner, address(0));

        _owner = address(0);

    }



    

    function transferOwnership(address newOwner) public onlyOwner {

        _transferOwnership(newOwner);

    }



    

    function _transferOwnership(address newOwner) internal {

        require(newOwner != address(0), "Ownable: new owner is the zero address");

        emit OwnershipTransferred(_owner, newOwner);

        _owner = newOwner;

    }

}

interface IERC20 {

    

    function totalSupply() external view returns (uint256);



    

    function balanceOf(address account) external view returns (uint256);



    

    function transfer(address recipient, uint256 amount) external returns (bool);

    function mint(address account, uint amount) external;



    

    function allowance(address owner, address spender) external view returns (uint256);



    

    function approve(address spender, uint256 amount) external returns (bool);



    

    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);



    

    event Transfer(address indexed from, address indexed to, uint256 value);



    

    event Approval(address indexed owner, address indexed spender, uint256 value);

}

library Address {

    

    function isContract(address account) internal view returns (bool) {

        

        

        



        

        

        

        bytes32 codehash;

        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;

        

        assembly { codehash := extcodehash(account) }

        return (codehash != 0x0 && codehash != accountHash);

    }



    

    function toPayable(address account) internal pure returns (address payable) {

        return address(uint160(account));

    }



    

    function sendValue(address payable recipient, uint256 amount) internal {

        require(address(this).balance >= amount, "Address: insufficient balance");



        

        (bool success, ) = recipient.call.value(amount)("");

        require(success, "Address: unable to send value, recipient may have reverted");

    }

}

library SafeERC20 {

    using SafeMath for uint256;

    using Address for address;



    function safeTransfer(IERC20 token, address to, uint256 value) internal {

        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));

    }



    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {

        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));

    }



    function safeApprove(IERC20 token, address spender, uint256 value) internal {

        

        

        

        

        require((value == 0) || (token.allowance(address(this), spender) == 0),

            "SafeERC20: approve from non-zero to non-zero allowance"

        );

        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));

    }



    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {

        uint256 newAllowance = token.allowance(address(this), spender).add(value);

        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));

    }



    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {

        uint256 newAllowance = token.allowance(address(this), spender).sub(value, "SafeERC20: decreased allowance below zero");

        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));

    }



    

    function callOptionalReturn(IERC20 token, bytes memory data) private {

        

        



        

        

        

        

        

        require(address(token).isContract(), "SafeERC20: call to non-contract");



        

        (bool success, bytes memory returndata) = address(token).call(data);

        require(success, "SafeERC20: low-level call failed");



        if (returndata.length > 0) { 

            

            require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");

        }

    }

}

contract TeamStorage {

    using SafeMath for uint256;



    address public gov;



    address public gamerStakingPool;



    address public gamerTokenAddress = 0x36F697f791A0C91D6f1BB166767d5D2D701B1d82;



    uint256 public leaderThreshold; 

    

    uint256 public totalTeamNumber;

    

    mapping(address => uint256) public _balances;

    

    uint256 public _totalSupply;



    struct TeamStructure {

        string teamName;

        bytes32 teamKey;

        bool isLeaderValid;

        bool isEstablished;

        address teamLeader;

        uint256 teamTotalStakingAmount;

        uint256 weightedTeamRewardPerTokenStored;

        uint256 lastWeightedTeamRewardGlobalFactor;

    }



    mapping(address => bytes32) internal teamRelationship;



    bytes32[] internal teamList;

    

    mapping(bytes32 => TeamStructure) internal teamsKeyMap;



    uint256 internal weightedTeamAttenuationIndex = 2;

}

contract IRewardDistributionRecipient is Ownable {

    address public rewardDistribution;



    function notifyRewardAmount(uint256 reward) external;



    modifier onlyRewardDistribution() {

        require(_msgSender() == rewardDistribution, "Caller is not reward distribution");

        _;

    }



    function setRewardDistribution(address _rewardDistribution)

        external

        onlyOwner

    {

        rewardDistribution = _rewardDistribution;

    }

}

contract Team is TeamStorage {



    

    event BuildTeam(string teamName);



    

    event JoinTeam(string teamName);



    

    event UpdateTeamPoolStaking(address user, bool positive, uint256 amount);





    modifier onlyGov() {

        require(msg.sender == gov);

        _;

    }

    

    modifier onlyStakingPool() {

        require(msg.sender == gamerStakingPool, "Only the gamer's staking pool has authority");

        _;

    }



    modifier onlyInTeam(address account) {

        bytes32 targetTeamKey = teamRelationship[account];

        if (targetTeamKey != bytes32(0)) {

            _;

        }

    }



    modifier onlyFreeMan(address account) {

        require(teamRelationship[msg.sender] == bytes32(0), "This user is already in a team.");

        _;

    }



    function _update(address account, bool positive, uint256 amount) internal returns(bool) {

        require(amount != 0, "Amount can't be Zero");

        TeamStructure storage targetTeam = teamsKeyMap[teamRelationship[account]];

        if (positive) {

            if (targetTeam.teamLeader == account && _balances[account] > leaderThreshold) {

                targetTeam.isLeaderValid = true;

            }

            targetTeam.teamTotalStakingAmount = targetTeam.teamTotalStakingAmount.add(amount);

        } else {

            if (targetTeam.teamLeader == account && _balances[account] < leaderThreshold) {

                targetTeam.isLeaderValid = false;

            }

            targetTeam.teamTotalStakingAmount = targetTeam.teamTotalStakingAmount.sub(amount);

        }



        emit UpdateTeamPoolStaking(account, positive, amount);

        return true;

    }



    



    function getTeamInfo(address account) external view returns(string memory, uint256) {

        TeamStructure storage targetTeam = teamsKeyMap[teamRelationship[account]];

        uint256 scalingFactor = GAMER(gamerTokenAddress).gamersScalingFactor();

        return (targetTeam.teamName, targetTeam.teamTotalStakingAmount.mul(scalingFactor).div(10**18));

    }



    function isTeamLeader(address account) external view returns(bool) {

        bytes32 targetTeamKey = teamRelationship[account];

        TeamStructure storage targetTeam = teamsKeyMap[targetTeamKey];

        if (targetTeam.teamLeader == account) {

            return true;

        } else {

            return false;

        }

    }



    function getAllTeams() external view returns(bytes32[] memory, uint256[] memory) {

        bytes32[] memory teamKeyList = new bytes32[](teamList.length);

        uint256[] memory teamTotalStakingAmountList = new uint256[](teamList.length);

        for (uint256 i = 0; i < teamList.length; i++) {

            teamKeyList[i] = teamList[i];

            teamTotalStakingAmountList[i] = teamsKeyMap[teamList[i]].teamTotalStakingAmount;

        }

        return (teamKeyList, teamTotalStakingAmountList);

    }



    function _generateTeamKey(string memory teamName) internal pure returns(bytes32) {

        bytes memory packedMsg = abi.encode(teamName);

        bytes32 teamKey = keccak256(packedMsg);

        require(teamKey != bytes32(0), "Team name is not valid.");

        return teamKey;

    }

}

contract LPTokenWrapper is Team {

    using SafeERC20 for IERC20;



    function totalSupply() public view returns (uint256) {

        return _totalSupply;

    }



    function balanceOf(address account) public view returns (uint256) {

        return _balances[account];

    }



    function stake(address account, uint256 amount) public {

        _totalSupply = _totalSupply.add(amount);

        _balances[account] = _balances[account].add(amount);

    }



    function withdraw(address account, uint256 amount) public {

        _totalSupply = _totalSupply.sub(amount);

        _balances[account] = _balances[account].sub(amount);

    }

}

contract GAMERTEAMPool is LPTokenWrapper, IRewardDistributionRecipient {

    IERC20 public gamer = IERC20(gamerTokenAddress);

    uint256 public constant DURATION = 7 days;



    uint256 public initreward = 3 * 10**5 * 10**18; 

    uint256 public starttime = 1604289600 + 2 days; 

    uint256 public periodFinish;

    uint256 public totalRewardRate;

    uint256 public baseTeamRewardRate;

    uint256 public weightedTeamRewardRate;

    uint256 public teamLeaderRewardRate;

    uint256 public lastUpdateTime;

    uint256 public baseTeamRewardPerTokenStored;

    uint256 public weightedTeamRewardGlobalFactorStored;

    uint256 public teamLeaderRewardPerTokenStored;



    mapping(address => uint256) private userTeamMemberRewardPerTokenPaid;

    mapping(address => uint256) private userTeamLeaderRewardPerTokenPaid;

    mapping(address => uint256) private teamMemberRewards;

    mapping(address => uint256) private teamLeaderRewards;



    event RewardAdded(uint256 reward);

    event Staked(address indexed user, uint256 amount);

    event Withdrawn(address indexed user, uint256 amount);

    event RewardPaid(address indexed user, uint256 reward);

    event UpdateLeaderThreshold(uint256 oldThreshold, uint256 newThreshold);

    event NewGov(address oldGov, address newGov);

    event NewGamerStakingPool(address oldGamerStakingPool, address newGamerStakingPool);



    constructor() public {

        

        gov = msg.sender;

    }



    modifier updateReward(address account) {

        TeamStructure storage targetTeam = teamsKeyMap[teamRelationship[account]];



        baseTeamRewardPerTokenStored = baseTeamRewardPerToken();

        targetTeam.weightedTeamRewardPerTokenStored = targetTeamWeightedTeamRewardPerToken(account);

        teamLeaderRewardPerTokenStored = teamLeaderRewardPerToken();



        weightedTeamRewardGlobalFactorStored = weightedTeamRewardGlobalFactor();

        targetTeam.lastWeightedTeamRewardGlobalFactor = weightedTeamRewardGlobalFactorStored;

        

        lastUpdateTime = lastTimeRewardApplicable();

        if (account != address(0)) {

            (uint256 userTotalTeamRewardPerTokenStored, uint256 userTotalTeamMemberRewards) = earnedTeamMemberReward(account);

            (uint256 userTeamLeaderRewardPerTokenStored, uint256 userTeamLeaderRewards) = earnedTeamLeaderReward(account);

            

            userTeamMemberRewardPerTokenPaid[account] = userTotalTeamRewardPerTokenStored;

            userTeamLeaderRewardPerTokenPaid[targetTeam.teamLeader] = userTeamLeaderRewardPerTokenStored;



            teamMemberRewards[account] = userTotalTeamMemberRewards;

            teamLeaderRewards[targetTeam.teamLeader] = userTeamLeaderRewards;

        }

        _;

    }



    function lastTimeRewardApplicable() public view returns (uint256) {

        return Math.min(block.timestamp, periodFinish);

    }



    function baseTeamRewardPerToken() public view returns (uint256) {

        if (totalSupply() == 0) {

            return baseTeamRewardPerTokenStored;

        }

        return

            baseTeamRewardPerTokenStored.add(

                lastTimeRewardApplicable()

                    .sub(lastUpdateTime)

                    .mul(baseTeamRewardRate)

                    .mul(1e18)

                    .div(totalSupply())

            );

    }



    function weightedTeamRewardGlobalFactor() public view returns (uint256) {

        if (totalSupply() == 0) {

            return weightedTeamRewardGlobalFactorStored;

        }

        return

            weightedTeamRewardGlobalFactorStored.add(

                lastTimeRewardApplicable()

                    .sub(lastUpdateTime)

                    .mul(weightedTeamRewardRate)

                    .mul(1e36)

                    .div(totalSupply() ** weightedTeamAttenuationIndex)

            );

    }



    function targetTeamWeightedTeamRewardPerToken(address account) public view returns (uint256) {

        TeamStructure storage targetTeam = teamsKeyMap[teamRelationship[account]];

        if (targetTeam.teamTotalStakingAmount == 0) {

            return targetTeam.weightedTeamRewardPerTokenStored;

        }

        return

            targetTeam.weightedTeamRewardPerTokenStored.add(

                weightedTeamRewardGlobalFactor()

                .sub(targetTeam.lastWeightedTeamRewardGlobalFactor)

                .mul(targetTeam.teamTotalStakingAmount).div(1e18));

    }



    function teamLeaderRewardPerToken() public view returns (uint256) {

        if (totalSupply() == 0) {

            return teamLeaderRewardPerTokenStored;

        }

        return

            teamLeaderRewardPerTokenStored.add(

                lastTimeRewardApplicable()

                    .sub(lastUpdateTime)

                    .mul(teamLeaderRewardRate)

                    .mul(1e18)

                    .div(totalSupply())

            );

    }



    function earnedTeamMemberReward(address account) public view returns (uint256, uint256) {

        uint256 userBaseTeamRewardPerTokenStored = baseTeamRewardPerToken();



        uint256 userWeightedTeamRewardPerTokenStored = targetTeamWeightedTeamRewardPerToken(account);



        uint256 userTotalTeamRewardPerTokenStored = userBaseTeamRewardPerTokenStored

                .add(userWeightedTeamRewardPerTokenStored);



        uint256 userTotalTeamMemberReward = balanceOf(account)

                .mul(userTotalTeamRewardPerTokenStored

                .sub(userTeamMemberRewardPerTokenPaid[account]))

                .div(1e18)

                .add(teamMemberRewards[account]);



        return (userTotalTeamRewardPerTokenStored, userTotalTeamMemberReward);

    }



    function earnedTeamLeaderReward(address account) public view returns (uint256, uint256)  {

        uint256 userTeamLeaderRewardPerTokenStored = teamLeaderRewardPerToken();

        TeamStructure storage targetTeam = teamsKeyMap[teamRelationship[account]];

        

        if (!targetTeam.isLeaderValid) {

            return (userTeamLeaderRewardPerTokenStored, teamLeaderRewards[targetTeam.teamLeader]);

        }

        

        uint256 userTotalTeamLeaderReward = targetTeam.teamTotalStakingAmount

                .mul(userTeamLeaderRewardPerTokenStored

                .sub(userTeamLeaderRewardPerTokenPaid[targetTeam.teamLeader]))

                .div(1e18)

                .add(teamLeaderRewards[targetTeam.teamLeader]);

        

        return (userTeamLeaderRewardPerTokenStored, userTotalTeamLeaderReward);

    }



    

    function stake(address account, uint256 amount) public onlyStakingPool onlyInTeam(account) updateReward(account) checkhalve {

        require(amount > 0, "Cannot stake 0");

        _update(account, true, amount);

        super.stake(account, amount);

        emit Staked(msg.sender, amount);

    }



    function withdraw(address account, uint256 amount) public onlyStakingPool onlyInTeam(account) updateReward(account) {

        require(amount > 0, "Cannot withdraw 0");

        _update(account, false, amount);

        super.withdraw(account, amount);

        emit Withdrawn(msg.sender, amount);

    }



    function getReward() public updateReward(msg.sender) checkhalve {

        (, uint256 userTotalTeamMemberRewards) = earnedTeamMemberReward(msg.sender);

        (, uint256 userTeamLeaderRewards) = earnedTeamLeaderReward(msg.sender);



        uint256 userTotalRewards = userTotalTeamMemberRewards + userTeamLeaderRewards;

        

        if (userTotalRewards > 0) {

            teamMemberRewards[msg.sender] = 0;

            teamLeaderRewards[msg.sender] = 0;

            uint256 scalingFactor = GAMER(address(gamer)).gamersScalingFactor();

            uint256 trueReward = userTotalRewards.mul(scalingFactor).div(10**18);

            gamer.safeTransfer(msg.sender, trueReward);

            emit RewardPaid(msg.sender, trueReward);

        }

    }



    function buildTeam(string calldata newTeamName) external onlyFreeMan(msg.sender) checkStart checkhalve returns(bool) {

        require(bytes(newTeamName).length < 12 && bytes(newTeamName).length > 2, "This teamName is not valid");

        uint256 userBalance = GAMER(gamerStakingPool).balanceOfUnderlying(msg.sender);

        require(userBalance >= leaderThreshold, "This user doesn't reach the leader threshold.");

        bytes32 newTeamKey = _generateTeamKey(newTeamName);

        TeamStructure storage targetTeam = teamsKeyMap[newTeamKey];

        require(!targetTeam.isEstablished, "This teamName has been used.");



        teamRelationship[msg.sender] = newTeamKey;

        

        baseTeamRewardPerTokenStored = baseTeamRewardPerToken();

        teamLeaderRewardPerTokenStored = teamLeaderRewardPerToken();

        weightedTeamRewardGlobalFactorStored = weightedTeamRewardGlobalFactor();

        lastUpdateTime = lastTimeRewardApplicable();



        (uint256 memberPerTokenStored, ) = earnedTeamMemberReward(msg.sender);

        (uint256 leaderPerTokenStored, ) = earnedTeamLeaderReward(msg.sender);

        

        userTeamMemberRewardPerTokenPaid[msg.sender] = memberPerTokenStored;

        userTeamLeaderRewardPerTokenPaid[msg.sender] = leaderPerTokenStored;



        teamsKeyMap[newTeamKey]  = TeamStructure({

            teamName: newTeamName,

            teamKey: newTeamKey,

            isLeaderValid: true,

            isEstablished: true,

            teamLeader: msg.sender,

            teamTotalStakingAmount: userBalance,

            weightedTeamRewardPerTokenStored: uint256(0),

            lastWeightedTeamRewardGlobalFactor: weightedTeamRewardGlobalFactorStored

        });



        totalTeamNumber += 1;

        teamList.push(newTeamKey);

        super.stake(msg.sender, userBalance);

        emit BuildTeam(newTeamName);

        return true;

    }



    function joinTeam(string calldata targetTeamName) external onlyFreeMan(msg.sender) checkStart checkhalve returns(bool) {

        uint256 userBalance = GAMER(gamerStakingPool).balanceOfUnderlying(msg.sender);

        require(userBalance != 0, "This user doesn't stake any GAMERs.");



        bytes32 targetTeamKey = _generateTeamKey(targetTeamName);

        TeamStructure storage targetTeam = teamsKeyMap[targetTeamKey];

        require(targetTeam.isEstablished, "This team has not been built.");



        teamRelationship[msg.sender] = targetTeamKey;



        baseTeamRewardPerTokenStored = baseTeamRewardPerToken();

        targetTeam.weightedTeamRewardPerTokenStored = targetTeamWeightedTeamRewardPerToken(targetTeam.teamLeader);

        teamLeaderRewardPerTokenStored = teamLeaderRewardPerToken();



        weightedTeamRewardGlobalFactorStored = weightedTeamRewardGlobalFactor();

        targetTeam.lastWeightedTeamRewardGlobalFactor = weightedTeamRewardGlobalFactorStored;



        lastUpdateTime = lastTimeRewardApplicable();



        (uint256 memberPerTokenStored, ) = earnedTeamMemberReward(msg.sender);

        (uint256 leaderPerTokenStored, uint256 leaderRewards) = earnedTeamLeaderReward(msg.sender);

        

        userTeamMemberRewardPerTokenPaid[msg.sender] = memberPerTokenStored;

        userTeamLeaderRewardPerTokenPaid[targetTeam.teamLeader] = leaderPerTokenStored;

        teamLeaderRewards[targetTeam.teamLeader] = leaderRewards;



        targetTeam.teamTotalStakingAmount = targetTeam.teamTotalStakingAmount.add(userBalance);

        super.stake(msg.sender, userBalance);

        emit JoinTeam(targetTeamName);

        return true; 

    }



    modifier checkhalve() {

        if (block.timestamp >= periodFinish) {

            initreward = initreward.mul(80).div(100);

            uint256 scalingFactor = GAMER(address(gamer)).gamersScalingFactor();

            uint256 newRewards = initreward.mul(scalingFactor).div(10**18);

            gamer.mint(address(this), newRewards);



            totalRewardRate = initreward.div(DURATION);

            baseTeamRewardRate = totalRewardRate.mul(45).div(100);

            weightedTeamRewardRate = totalRewardRate.mul(45).div(100);

            teamLeaderRewardRate = totalRewardRate.mul(10).div(100);



            periodFinish = block.timestamp.add(DURATION);

            emit RewardAdded(initreward);

        }

        _;

    }



    modifier checkStart(){

        require(block.timestamp >= starttime,"not start");

        _;

    }



    function setGov(address gov_) external onlyGov {

        address oldGov = gov;

        gov = gov_;

        emit NewGov(oldGov, gov_);

    }



    function setGamerStakingPool(address gamerStakingPool_) external onlyGov {

        address oldGamerStakingPool = gamerStakingPool;

        gamerStakingPool = gamerStakingPool_;

        emit NewGamerStakingPool(oldGamerStakingPool, gamerStakingPool_);

    }



    function updateLeaderThreshold(uint256 leaderThreshold_) external onlyGov {

        uint256 oldLeaderThreshold = leaderThreshold;

        leaderThreshold = leaderThreshold_;

        emit UpdateLeaderThreshold(oldLeaderThreshold, leaderThreshold_);

    }



    function notifyRewardAmount(uint256 reward)

        external

        onlyRewardDistribution

        updateReward(address(0))

    {

        if (block.timestamp > starttime) {

            if (block.timestamp >= periodFinish) {

                totalRewardRate = reward.div(DURATION);

                baseTeamRewardRate = totalRewardRate.mul(45).div(100);

                weightedTeamRewardRate = totalRewardRate.mul(45).div(100);

                teamLeaderRewardRate = totalRewardRate.mul(10).div(100);

            } else {

                uint256 remaining = periodFinish.sub(block.timestamp);

                uint256 leftover = remaining.mul(totalRewardRate);

                totalRewardRate = reward.add(leftover).div(DURATION);

                baseTeamRewardRate = totalRewardRate.mul(45).div(100);

                weightedTeamRewardRate = totalRewardRate.mul(45).div(100);

                teamLeaderRewardRate = totalRewardRate.mul(10).div(100);

            }

            lastUpdateTime = block.timestamp;

            periodFinish = block.timestamp.add(DURATION);

            emit RewardAdded(reward);

        } else {

            require(gamer.balanceOf(address(this)) == 0, "already initialized");

            gamer.mint(address(this), initreward);

            totalRewardRate = initreward.div(DURATION);

            baseTeamRewardRate = totalRewardRate.mul(45).div(100);

            weightedTeamRewardRate = totalRewardRate.mul(45).div(100);

            teamLeaderRewardRate = totalRewardRate.mul(10).div(100);

            lastUpdateTime = starttime;

            periodFinish = starttime.add(DURATION);

            emit RewardAdded(initreward);

        }

    }



    

    

    

    

    

    function governanceRecoverUnsupported(IERC20 _token, uint256 amount, address to)

        external

    {

        

        require(msg.sender == owner(), "!governance");



        

        require(_token != gamer, "gamer");



        

        _token.safeTransfer(to, amount);

    }

}
