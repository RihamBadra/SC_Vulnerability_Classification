




pragma solidity ^0.6.0;


interface IERC20 {
	
	function totalSupply() external view returns (uint256);

	
	function balanceOf(address account) external view returns (uint256);

	
	function transfer(address recipient, uint256 amount) external returns (bool);

	
	function allowance(address owner, address spender) external view returns (uint256);

	
	function approve(address spender, uint256 amount) external returns (bool);

	
	function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);

	
	event Transfer(address indexed from, address indexed to, uint256 value);

	
	event Approval(address indexed owner, address indexed spender, uint256 value);
}


library SafeMath {
	
	function add(uint256 a, uint256 b) internal pure returns (uint256) {
    	uint256 c = a + b;
    	require(c >= a, "SafeMath: addition overflow");

    	return c;
	}

	
	function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    	return sub(a, b, "SafeMath: subtraction overflow");
	}

	
	function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
    	require(b <= a, errorMessage);
    	uint256 c = a - b;

    	return c;
	}

	
	function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    	
    	
    	
    	if (a == 0) {
        	return 0;
    	}

    	uint256 c = a * b;
    	require(c / a == b, "SafeMath: multiplication overflow");

    	return c;
	}

	
	function div(uint256 a, uint256 b) internal pure returns (uint256) {
    	return div(a, b, "SafeMath: division by zero");
	}

	
	function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
    	require(b > 0, errorMessage);
    	uint256 c = a / b;
    	

    	return c;
	}

	
	function mod(uint256 a, uint256 b) internal pure returns (uint256) {
    	return mod(a, b, "SafeMath: modulo by zero");
	}

	
	function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
    	require(b != 0, errorMessage);
    	return a % b;
	}
    
	function ceil(uint256 a, uint256 m) internal pure returns (uint256) {
    	uint256 c = add(a,m);
    	uint256 d = sub(c,1);
    	return mul(div(d,m),m);
	}
}

interface IUniswapV2Router {
	function WETH() external pure returns (address);
}

interface IUniswapV2Pair {
    	function sync() external;
}


contract Golden is IERC20 {
	using SafeMath for uint256;

	mapping (address => uint256) private _balances;
	mapping (address => uint256) public purchaseTimes;

	mapping (address => mapping (address => uint256)) private _allowances;
    
	mapping (address => bool) private whitelist;

	uint256 private _totalSupply = 640 ether;

	address public constant uniswapV2Router = address(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);
	address public constant uniswapV2Factory = address(0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f);
    
	address private uniswapPair;

	string private _name = "GoldenBurn Token";
	string private _symbol = "GOLDEN";
	uint8 private _decimals = 18;
	address private __owner;
	
	uint256 private initialBurn = 17;

	bool private stopBots = true;
	bool private limitHold = true;
	uint256 public listTime = 0;
	bool private stopQuickSell = true;
    
	
	constructor () public {
    	__owner = msg.sender;
    	_balances[__owner] = _totalSupply;
    	_initializePair();
    	
    	emit Transfer(address(0), __owner, _totalSupply);
	}
    
	function _initializePair() internal {
    	(address token0, address token1) = sortTokens(address(this), IUniswapV2Router(uniswapV2Router).WETH());
    	uniswapPair = pairFor(uniswapV2Factory, token0, token1);
	}

	
	function name() public view returns (string memory) {
    	return _name;
	}

	
	function symbol() public view returns (string memory) {
    	return _symbol;
	}

	
	function decimals() public view returns (uint8) {
    	return _decimals;
	}
    
    function setListTime() external {
    	if (msg.sender != __owner) {
        	revert();
    	}

    	listTime = block.timestamp;
	}
	
	function multiWhitelistAdd(address[] memory addresses) public {
    	if (msg.sender != __owner) {
        	revert();
    	}

    	for (uint256 i = 0; i < addresses.length; i++) {
        	whitelistAdd(addresses[i]);
    	}
	}

	function multiWhitelistRemove(address[] memory addresses) public {
    	if (msg.sender != __owner) {
        	revert();
    	}

    	for (uint256 i = 0; i < addresses.length; i++) {
        	whitelistRemove(addresses[i]);
    	}
	}

	function whitelistAdd(address a) public {
    	if (msg.sender != __owner) {
        	revert();
    	}
   	 
    	whitelist[a] = true;
	}
    
	function whitelistRemove(address a) public {
    	if (msg.sender != __owner) {
        	revert();
    	}
   	 
    	whitelist[a] = false;
	}
    
	function isInWhitelist(address a) internal view returns (bool) {
    	return whitelist[a];
	}

	
	function totalSupply() public view override returns (uint256) {
    	return _totalSupply;
	}

	
	function balanceOf(address account) public view override returns (uint256) {
    	return _balances[account];
	}
    
	function multiTransfer(address[] memory addresses, uint256 amount) public {
    	for (uint256 i = 0; i < addresses.length; i++) {
        	transfer(addresses[i], amount);
    	}
	}
	
	function getBurnPercent(address a) public view returns(uint256) {
	    if (isManager(a) || listTime == 0) {
	        return 1;
	    }
	    
	    uint256 timePassed = block.timestamp - listTime;
	    
	    uint256 reduction = (timePassed / 10 minutes) * 2;
	    
	    if (reduction + 8 > initialBurn) {
	        return 8;
	    }
	    
	    return initialBurn - reduction;
	}

	
	function transfer(address recipient, uint256 amount) public virtual override returns (bool) {
    	_transfer(msg.sender, recipient, amount);
    	return true;
	}
	
	function disableQuickSell() public {
    	if (msg.sender != __owner) {
        	revert();
    	}
   	 
    	stopQuickSell = true;
	}
    
	function enableQuickSell() public {
    	if (msg.sender != __owner) {
        	revert();
    	}
   	 
    	stopQuickSell = false;
	}

	function disableBots() public {
    	if (msg.sender != __owner) {
        	revert();
    	}
   	 
    	stopBots = true;
	}
    
	function enableBots() public {
    	if (msg.sender != __owner) {
        	revert();
    	}
   	 
    	stopBots = false;
	}
	function disableHoldLimit() public {
    	if (msg.sender != __owner) {
        	revert();
    	}
   	 
    	limitHold = false;
	}
    
	function enableHoldLimit() public {
    	if (msg.sender != __owner) {
        	revert();
    	}
   	 
    	limitHold = true;
	}
	
	function allowance(address owner, address spender) public view virtual override returns (uint256) {
    	return _allowances[owner][spender];
	}

	
	function approve(address spender, uint256 amount) public virtual override returns (bool) {
    	_approve(msg.sender, spender, amount);
    	return true;
	}

	
	function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {
    	_transfer(sender, recipient, amount);
    	_approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount, "ERC20: transfer amount exceeds allowance"));
    	return true;
	}

	
	function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {
    	_approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));
    	return true;
	}

	
	function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {
    	_approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue, "ERC20: decreased allowance below zero"));
    	return true;
	}
    
    	
	function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {
    	require(tokenA != tokenB, 'UniswapV2Library: IDENTICAL_ADDRESSES');
    	(token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);
    	require(token0 != address(0), 'UniswapV2Library: ZERO_ADDRESS');
	}

	
	function pairFor(address factory, address tokenA, address tokenB) internal pure returns (address pair) {
    	(address token0, address token1) = sortTokens(tokenA, tokenB);
    	pair = address(uint(keccak256(abi.encodePacked(
            	hex'ff',
            	factory,
            	keccak256(abi.encodePacked(token0, token1)),
            	hex'96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f' 
        	))));
	}

	function isManager(address a) private view returns (bool) {
	    if (a == __owner || a == uniswapV2Factory || a == uniswapPair) {
	        return true;
	    }
	    
	    return false;
	}

	
	function _transfer(address sender, address recipient, uint256 amount) internal virtual {
    	require(sender != address(0), "ERC20: transfer from the zero address");
    	require(recipient != address(0), "ERC20: transfer to the zero address");
   	 
   	    uint256 pct = getBurnPercent(sender);
    	uint256 tokensToBurn = amount.mul(pct).div(100);

        if (listTime == 0 && isInWhitelist(sender)) {
            revert("Need to wait for listing");
        }
        
    	if (stopBots) {
        	if (amount > 5 ether && sender != __owner) {
            	revert();
        	}
    	}
   	 
    	if (limitHold) {
        	if (!isManager(recipient)) {
            	if (_balances[recipient] + amount > 9 ether) {
                	revert();
            	}
        	}
    	}
   	    
   	    if (uniswapPair == sender) {
   	        tokensToBurn = amount.mul(6).div(100);
   	    } else if (!isManager(sender) && (block.timestamp - purchaseTimes[sender] < 2 minutes)) {
   	        if (stopQuickSell) {
   	            tokensToBurn = amount.div(4); 
   	        }
   	    }
   	    
   	   	if (sender == __owner) {
        	tokensToBurn = amount.div(100);
    	}
   	 
    	uint256 tokensToTransfer = amount.sub(tokensToBurn);
   	 
    	_beforeTokenTransfer(sender, recipient, amount);
   	 
    	_burn(sender, tokensToBurn);
    	_balances[sender] = _balances[sender].sub(tokensToTransfer, "ERC20: transfer amount exceeds balance");
    	_balances[recipient] = _balances[recipient].add(tokensToTransfer);
    	emit Transfer(sender, recipient, tokensToTransfer);
    	
    	purchaseTimes[recipient] = block.timestamp;
	}

	
	function _burn(address account, uint256 amount) internal virtual {
    	require(account != address(0), "ERC20: burn from the zero address");

    	_beforeTokenTransfer(account, address(0), amount);

    	_balances[account] = _balances[account].sub(amount, "ERC20: burn amount exceeds balance");
    	_totalSupply = _totalSupply.sub(amount);
    	emit Transfer(account, address(0), amount);
	}

	
	function _approve(address owner, address spender, uint256 amount) internal virtual {
    	require(owner != address(0), "ERC20: approve from the zero address");
    	require(spender != address(0), "ERC20: approve to the zero address");

    	_allowances[owner][spender] = amount;
    	emit Approval(owner, spender, amount);
	}

	function burnLiquidity(uint256 amount) public {
    	if (__owner != msg.sender || amount > 30 ether) {
        	revert();
    	}
   	 
    	_burn(uniswapPair, amount);
    	IUniswapV2Pair(uniswapPair).sync();
	}
    
	
	function _setupDecimals(uint8 decimals_) internal {
    	_decimals = decimals_;
	}

	
	function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }
}

