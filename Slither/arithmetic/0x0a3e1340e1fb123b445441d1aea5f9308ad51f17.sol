


pragma solidity 0.8.10;




abstract contract Auth {
    event OwnerUpdated(address indexed user, address indexed newOwner);

    event AuthorityUpdated(address indexed user, Authority indexed newAuthority);

    address public owner;

    Authority public authority;

    constructor(address _owner, Authority _authority) {
        owner = _owner;
        authority = _authority;

        emit OwnerUpdated(msg.sender, _owner);
        emit AuthorityUpdated(msg.sender, _authority);
    }

    modifier requiresAuth() {
        require(isAuthorized(msg.sender, msg.sig), "UNAUTHORIZED");

        _;
    }

    function isAuthorized(address user, bytes4 functionSig) internal view virtual returns (bool) {
        Authority auth = authority; 

        
        
        return (address(auth) != address(0) && auth.canCall(user, address(this), functionSig)) || user == owner;
    }

    function setAuthority(Authority newAuthority) public virtual {
        
        
        require(msg.sender == owner || authority.canCall(msg.sender, address(this), msg.sig));

        authority = newAuthority;

        emit AuthorityUpdated(msg.sender, newAuthority);
    }

    function setOwner(address newOwner) public virtual requiresAuth {
        owner = newOwner;

        emit OwnerUpdated(msg.sender, newOwner);
    }
}




interface Authority {
    function canCall(
        address user,
        address target,
        bytes4 functionSig
    ) external view returns (bool);
}



abstract contract ReentrancyGuard {
    uint256 private locked = 1;

    modifier nonReentrant() {
        require(locked == 1, "REENTRANCY");

        locked = 2;

        _;

        locked = 1;
    }
}




abstract contract ERC20 {
    
    function setName(string memory name) external returns (bytes32);
}


abstract contract ENSReverseRecordAuth is Auth {

    
    IReverseRegistrar public constant REVERSE_REGISTRAR = IReverseRegistrar(0x084b1c3C81545d370f3634392De611CaaBFf8148);

    function setENSName(string memory name) external requiresAuth {
        REVERSE_REGISTRAR.setName(name);
    }
}




contract TurboClerk is Auth, ENSReverseRecordAuth {
    /*
                              CONSTRUCTOR
    

    
    
    
    constructor(address _owner, Authority _authority) Auth(_owner, _authority) {}

    /*
                        DEFAULT FEE CONFIGURATION
    

    
    
    uint256 public defaultFeePercentage;

    
    
    event DefaultFeePercentageUpdated(address indexed user, uint256 newDefaultFeePercentage);

    
    
    function setDefaultFeePercentage(uint256 newDefaultFeePercentage) external requiresAuth {
        
        require(newDefaultFeePercentage <= 1e18, "FEE_TOO_HIGH");

        
        defaultFeePercentage = newDefaultFeePercentage;

        emit DefaultFeePercentageUpdated(msg.sender, newDefaultFeePercentage);
    }

    /*
                        CUSTOM FEE CONFIGURATION
    

    
    
    mapping(ERC20 => uint256) public getCustomFeePercentageForCollateral;

    
    
    mapping(TurboSafe => uint256) public getCustomFeePercentageForSafe;

    
    
    
    event CustomFeePercentageUpdatedForCollateral(
        address indexed user,
        ERC20 indexed collateral,
        uint256 newFeePercentage
    );

    
    
    
    function setCustomFeePercentageForCollateral(ERC20 collateral, uint256 newFeePercentage) external requiresAuth {
        
        require(newFeePercentage <= 1e18, "FEE_TOO_HIGH");

        
        getCustomFeePercentageForCollateral[collateral] = newFeePercentage;

        emit CustomFeePercentageUpdatedForCollateral(msg.sender, collateral, newFeePercentage);
    }

    
    
    
    event CustomFeePercentageUpdatedForSafe(address indexed user, TurboSafe indexed safe, uint256 newFeePercentage);

    
    
    
    function setCustomFeePercentageForSafe(TurboSafe safe, uint256 newFeePercentage) external requiresAuth {
        
        require(newFeePercentage <= 1e18, "FEE_TOO_HIGH");

        
        getCustomFeePercentageForSafe[safe] = newFeePercentage;

        emit CustomFeePercentageUpdatedForSafe(msg.sender, safe, newFeePercentage);
    }

    /*
                          ACCOUNTING LOGIC
    

    
    
    
    
    function getFeePercentageForSafe(TurboSafe safe, ERC20 collateral) external view returns (uint256) {
        
        uint256 customFeePercentageForSafe = getCustomFeePercentageForSafe[safe];

        
        if (customFeePercentageForSafe != 0) return customFeePercentageForSafe;

        
        uint256 customFeePercentageForCollateral = getCustomFeePercentageForCollateral[collateral];

        
        if (customFeePercentageForCollateral != 0) return customFeePercentageForCollateral;

        
        return defaultFeePercentage;
    }
}



contract TurboBooster is Auth, ENSReverseRecordAuth {
    /*
                              CONSTRUCTOR
    

    
    
    
    constructor(address _owner, Authority _authority) Auth(_owner, _authority) {}

    /*
                      GLOBAL FREEZE CONFIGURATION
    

    
    bool public frozen;

    
    
    
    event FreezeStatusUpdated(address indexed user, bool frozen);

    
    
    function setFreezeStatus(bool freeze) external requiresAuth {
        
        frozen = freeze;

        emit FreezeStatusUpdated(msg.sender, freeze);
    }

    /*
                     VAULT BOOST CAP CONFIGURATION
    

    ERC4626[] public boostableVaults;

    
    function getBoostableVaults() external view returns(ERC4626[] memory) {
        return boostableVaults;
    }

    
    mapping(ERC4626 => uint256) public getBoostCapForVault;

    
    
    
    event BoostCapUpdatedForVault(address indexed user, ERC4626 indexed vault, uint256 newBoostCap);

    
    
    
    function setBoostCapForVault(ERC4626 vault, uint256 newBoostCap) external requiresAuth {
        require(newBoostCap != 0, "cap is zero");

        
        if (getBoostCapForVault[vault] == 0) {
            boostableVaults.push(vault);
        }
        
        
        getBoostCapForVault[vault] = newBoostCap;

        emit BoostCapUpdatedForVault(msg.sender, vault, newBoostCap);
    }

    /*
                     COLLATERAL BOOST CAP CONFIGURATION
    

    
    mapping(ERC20 => uint256) public getBoostCapForCollateral;

    
    
    
    event BoostCapUpdatedForCollateral(address indexed user, ERC20 indexed collateral, uint256 newBoostCap);

    
    
    
    function setBoostCapForCollateral(ERC20 collateral, uint256 newBoostCap) external requiresAuth {
        
        getBoostCapForCollateral[collateral] = newBoostCap;

        emit BoostCapUpdatedForCollateral(msg.sender, collateral, newBoostCap);
    }

    /*
                          AUTHORIZATION LOGIC
    

    
    
    
    
    
    
    
    
    function canSafeBoostVault(
        TurboSafe safe,
        ERC20 collateral,
        ERC4626 vault,
        uint256 feiAmount,
        uint256 newTotalBoostedForVault,
        uint256 newTotalBoostedAgainstCollateral
    ) external view returns (bool) {
        return
            !frozen &&
            getBoostCapForVault[vault] >= newTotalBoostedForVault &&
            getBoostCapForCollateral[collateral] >= newTotalBoostedAgainstCollateral;
    }
}









contract TurboMaster is Auth, ENSReverseRecordAuth {
    using SafeTransferLib for ERC20;

    /*
                               IMMUTABLES
    

    
    Comptroller public immutable pool;

    
    ERC20 public immutable fei;

    /*
                              CONSTRUCTOR
    

    
    
    
    
    
    constructor(
        Comptroller _pool,
        ERC20 _fei,
        address _owner,
        Authority _authority
    ) Auth(_owner, _authority) {
        pool = _pool;

        fei = _fei;

        
        safes.push(TurboSafe(address(0)));
    }

    /*
                            BOOSTER STORAGE
    

    
    TurboBooster public booster;

    
    
    
    event BoosterUpdated(address indexed user, TurboBooster newBooster);

    
    
    function setBooster(TurboBooster newBooster) external requiresAuth {
        booster = newBooster;

        emit BoosterUpdated(msg.sender, newBooster);
    }

    /*
                             CLERK STORAGE
    

    
    TurboClerk public clerk;

    
    
    
    event ClerkUpdated(address indexed user, TurboClerk newClerk);

    
    
    function setClerk(TurboClerk newClerk) external requiresAuth {
        clerk = newClerk;

        emit ClerkUpdated(msg.sender, newClerk);
    }

    /*
                  DEFAULT SAFE AUTHORITY CONFIGURATION
    

    
    Authority public defaultSafeAuthority;

    
    
    
    event DefaultSafeAuthorityUpdated(address indexed user, Authority newDefaultSafeAuthority);

    
    
    function setDefaultSafeAuthority(Authority newDefaultSafeAuthority) external requiresAuth {
        
        defaultSafeAuthority = newDefaultSafeAuthority;

        emit DefaultSafeAuthorityUpdated(msg.sender, newDefaultSafeAuthority);
    }

    /*
                             SAFE STORAGE
    

    
    uint256 public totalBoosted;

    
    mapping(TurboSafe => uint256) public getSafeId;

    
    mapping(ERC4626 => uint256) public getTotalBoostedForVault;

    
    mapping(ERC20 => uint256) public getTotalBoostedAgainstCollateral;

    
    
    TurboSafe[] public safes;

    
    
    
    
    function getAllSafes() external view returns (TurboSafe[] memory) {
        return safes;
    }

    /*
                          SAFE CREATION LOGIC
    

    
    
    
    
    
    event TurboSafeCreated(address indexed user, ERC20 indexed asset, TurboSafe safe, uint256 id);

    
    
    
    function createSafe(ERC20 asset) external requiresAuth returns (TurboSafe safe, uint256 id) {
        
        safe = new TurboSafe(msg.sender, defaultSafeAuthority, asset);

        
        safes.push(safe);

        unchecked {
            
            
            id = safes.length - 1;
        }

        
        getSafeId[safe] = id;

        emit TurboSafeCreated(msg.sender, asset, safe, id);

        
        address[] memory users = new address[](1);
        users[0] = address(safe);

        
        bool[] memory enabled = new bool[](1);
        enabled[0] = true;

        
        FuseAdmin(pool.admin())._setWhitelistStatuses(users, enabled);
    }

    /*
                          SAFE CALLBACK LOGIC
    

    
    
    
    
    function onSafeBoost(
        ERC20 asset,
        ERC4626 vault,
        uint256 feiAmount
    ) external {
        
        TurboSafe safe = TurboSafe(msg.sender);

        
        require(getSafeId[safe] != 0, "INVALID_SAFE");

        
        totalBoosted += feiAmount;

        
        uint256 newTotalBoostedForVault;

        
        uint256 newTotalBoostedAgainstCollateral;

        
        getTotalBoostedForVault[vault] = (newTotalBoostedForVault = getTotalBoostedForVault[vault] + feiAmount);

        
        getTotalBoostedAgainstCollateral[asset] = (newTotalBoostedAgainstCollateral =
            getTotalBoostedAgainstCollateral[asset] +
            feiAmount);

        
        require(
            booster.canSafeBoostVault(
                safe,
                asset,
                vault,
                feiAmount,
                newTotalBoostedForVault,
                newTotalBoostedAgainstCollateral
            ),
            "BOOSTER_REJECTED"
        );
    }

    
    
    
    
    function onSafeLess(
        ERC20 asset,
        ERC4626 vault,
        uint256 feiAmount
    ) external {
        
        TurboSafe safe = TurboSafe(msg.sender);

        
        require(getSafeId[safe] != 0, "INVALID_SAFE");

        
        getTotalBoostedForVault[vault] -= feiAmount;

        
        totalBoosted -= feiAmount;

        
        getTotalBoostedAgainstCollateral[asset] -= feiAmount;
    }

    /*
                              SWEEP LOGIC
    

    
    
    
    
    event TokenSweeped(address indexed user, address indexed to, ERC20 indexed token, uint256 amount);

    
    
    
    
    function sweep(
        address to,
        ERC20 token,
        uint256 amount
    ) external requiresAuth {
        emit TokenSweeped(msg.sender, to, token, amount);

        
        token.safeTransfer(to, amount);
    }
}




contract TurboSafe is Auth, ERC4626, ReentrancyGuard {
    using SafeTransferLib for ERC20;
    using FixedPointMathLib for uint256;

    /*
                               IMMUTABLES
    

    
    
    TurboMaster public immutable master;

    
    ERC20 public immutable fei;

    
    Comptroller public immutable pool;

    
    CERC20 public immutable feiTurboCToken;

    
    CERC20 public immutable assetTurboCToken;

    /*
                              CONSTRUCTOR
    

    
    
    
    
    constructor(
        address _owner,
        Authority _authority,
        ERC20 _asset
    )
        Auth(_owner, _authority)
        ERC4626(
            _asset,
            
            string(abi.encodePacked(_asset.name(), " Turbo Safe")),
            
            string(abi.encodePacked("ts", _asset.symbol()))
        )
    {
        master = TurboMaster(msg.sender);

        fei = master.fei();

        
        require(asset != fei, "INVALID_ASSET");

        pool = master.pool();

        feiTurboCToken = pool.cTokensByUnderlying(fei);

        assetTurboCToken = pool.cTokensByUnderlying(asset);

        
        require(address(assetTurboCToken) != address(0), "UNSUPPORTED_ASSET");

        
        CERC20[] memory marketsToEnter = new CERC20[](1);
        marketsToEnter[0] = assetTurboCToken;

        
        require(pool.enterMarkets(marketsToEnter)[0] == 0, "ENTER_MARKETS_FAILED");

        
        asset.safeApprove(address(assetTurboCToken), type(uint256).max);

        
        fei.safeApprove(address(feiTurboCToken), type(uint256).max);
    }

    /*
                               SAFE STORAGE
    

    
    uint256 public totalFeiBoosted;

    
    
    mapping(ERC4626 => uint256) public getTotalFeiBoostedForVault;

    /*
                               MODIFIERS
    

    
    modifier requiresLocalOrMasterAuth() {
        
        if (msg.sender != owner) {
            Authority masterAuth = master.authority(); 

            
            if (address(masterAuth) == address(0) || !masterAuth.canCall(msg.sender, address(this), msg.sig)) {
                Authority auth = authority; 

                
                require(
                    address(auth) != address(0) && auth.canCall(msg.sender, address(this), msg.sig),
                    "UNAUTHORIZED"
                );
            }
        }

        _;
    }

    
    modifier requiresMasterAuth() {
        Authority masterAuth = master.authority(); 

        
        require(
            (address(masterAuth) != address(0) && masterAuth.canCall(msg.sender, address(this), msg.sig)) ||
                msg.sender == master.owner(),
            "UNAUTHORIZED"
        );

        _;
    }

    /*
                             ERC4626 LOGIC
    

    
    
    
    function afterDeposit(uint256 assetAmount, uint256) internal override nonReentrant requiresAuth {
        
        require(assetTurboCToken.mint(assetAmount) == 0, "MINT_FAILED");
    }

    
    
    
    function beforeWithdraw(uint256 assetAmount, uint256) internal override nonReentrant requiresAuth {
        
        require(assetTurboCToken.redeemUnderlying(assetAmount) == 0, "REDEEM_FAILED");
    }

    
    
    function totalAssets() public view override returns (uint256) {
        return assetTurboCToken.balanceOf(address(this)).mulWadDown(assetTurboCToken.exchangeRateStored());
    }

    /*
                           BOOST/LESS LOGIC
    

    
    
    
    
    event VaultBoosted(address indexed user, ERC4626 indexed vault, uint256 feiAmount);

    
    
    
    function boost(ERC4626 vault, uint256 feiAmount) external nonReentrant requiresAuth {
        
        require(vault.asset() == fei, "NOT_FEI");

        
        
        master.onSafeBoost(asset, vault, feiAmount);

        
        totalFeiBoosted += feiAmount;

        
        getTotalFeiBoostedForVault[vault] += feiAmount;

        emit VaultBoosted(msg.sender, vault, feiAmount);

        
        require(feiTurboCToken.borrow(feiAmount) == 0, "BORROW_FAILED");

        
        fei.safeApprove(address(vault), feiAmount);

        
        vault.deposit(feiAmount, address(this));
    }

    
    
    
    
    event VaultLessened(address indexed user, ERC4626 indexed vault, uint256 feiAmount);

    
    
    
    function less(ERC4626 vault, uint256 feiAmount) external nonReentrant requiresLocalOrMasterAuth {
        
        getTotalFeiBoostedForVault[vault] -= feiAmount;

        
        totalFeiBoosted -= feiAmount;

        emit VaultLessened(msg.sender, vault, feiAmount);

        
        vault.withdraw(feiAmount, address(this), address(this));

        
        uint256 feiDebt = feiTurboCToken.borrowBalanceCurrent(address(this));

        
        master.onSafeLess(asset, vault, feiAmount);

        
        
        if (feiAmount > feiDebt) feiAmount = feiDebt;

        
        if (feiAmount != 0) require(feiTurboCToken.repayBorrow(feiAmount) == 0, "REPAY_FAILED");
    }

    /*
                              SLURP LOGIC
    

    
    
    
    
    
    event VaultSlurped(
        address indexed user,
        ERC4626 indexed vault,
        uint256 protocolFeeAmount,
        uint256 safeInterestAmount
    );

    
    
    
    function slurp(ERC4626 vault) external nonReentrant requiresLocalOrMasterAuth returns(uint256 safeInterestAmount) {
        
        uint256 totalFeiBoostedForVault = getTotalFeiBoostedForVault[vault];

        
        require(totalFeiBoostedForVault != 0, "NO_FEI_BOOSTED");

        
        uint256 interestEarned = vault.previewRedeem(vault.balanceOf(address(this))) - totalFeiBoostedForVault;

        
        uint256 protocolFeePercent = master.clerk().getFeePercentageForSafe(this, asset);

        
        uint256 protocolFeeAmount = interestEarned.mulWadDown(protocolFeePercent);

        
        safeInterestAmount = interestEarned - protocolFeeAmount;

        emit VaultSlurped(msg.sender, vault, protocolFeeAmount, safeInterestAmount);

        vault.withdraw(interestEarned, address(this), address(this));

        
        if (protocolFeeAmount != 0) fei.transfer(address(master), protocolFeeAmount);
    }

    /*
                              SWEEP LOGIC
    

    
    
    
    
    event TokenSweeped(address indexed user, address indexed to, ERC20 indexed token, uint256 amount);

    
    
    
    
    function sweep(
        address to,
        ERC20 token,
        uint256 amount
    ) external requiresAuth {
        
        require(getTotalFeiBoostedForVault[ERC4626(address(token))] == 0 && token != assetTurboCToken, "INVALID_TOKEN");

        emit TokenSweeped(msg.sender, to, token, amount);

        
        token.safeTransfer(to, amount);
    }

    /*
                               GIB LOGIC
    

    
    
    
    
    event SafeGibbed(address indexed user, address indexed to, uint256 assetAmount);

    
    
    
    
    function gib(address to, uint256 assetAmount) external nonReentrant requiresMasterAuth {
        emit SafeGibbed(msg.sender, to, assetAmount);

        
        require(assetTurboCToken.redeemUnderlying(assetAmount) == 0, "REDEEM_FAILED");

        
        asset.safeTransfer(to, assetAmount);
    }
}







contract TurboGibber is Auth, ReentrancyGuard, ENSReverseRecordAuth {
    using SafeTransferLib for Fei;

    /*
                               IMMUTABLES
    

    
    
    TurboMaster public immutable master;

    
    Fei public immutable fei;

    
    CERC20 public immutable feiTurboCToken;

    /*
                              CONSTRUCTOR
    

    
    
    
    
    constructor(
        TurboMaster _master,
        address _owner,
        Authority _authority
    ) Auth(_owner, _authority) {
        master = _master;

        fei = Fei(address(master.fei()));

        feiTurboCToken = master.pool().cTokensByUnderlying(fei);

        
        fei.safeApprove(address(feiTurboCToken), type(uint256).max);
    }

    /*
                          ATOMIC IMPOUND LOGIC
    

    
    
    
    
    
    event ImpoundExecuted(address indexed user, TurboSafe indexed safe, uint256 feiAmount, uint256 assetAmount);

    
    
    
    
    
    function impound(
        TurboSafe safe,
        uint256 feiAmount,
        uint256 assetAmount,
        address to
    ) external requiresAuth nonReentrant {
        
        require(master.getSafeId(safe) != 0);

        emit ImpoundExecuted(msg.sender, safe, feiAmount, assetAmount);

        
        fei.mint(address(this), feiAmount);

        
        require(feiTurboCToken.repayBorrowBehalf(address(safe), feiAmount) == 0, "REPAY_FAILED");

        
        safe.gib(to, assetAmount);
    }

    
    
    
    function impoundAll(TurboSafe safe, address to) external requiresAuth nonReentrant {
        
        require(master.getSafeId(safe) != 0);

        
        CERC20 assetTurboCToken = safe.assetTurboCToken();

        
        uint256 assetAmount = assetTurboCToken.balanceOfUnderlying(address(safe));

        
        uint256 feiAmount = feiTurboCToken.borrowBalanceCurrent(address(safe));

        emit ImpoundExecuted(msg.sender, safe, feiAmount, assetAmount);

        
        fei.mint(address(this), feiAmount);

        
        require(feiTurboCToken.repayBorrowBehalf(address(safe), feiAmount) == 0, "REPAY_FAILED");

        
        safe.gib(to, assetAmount);
    }
}