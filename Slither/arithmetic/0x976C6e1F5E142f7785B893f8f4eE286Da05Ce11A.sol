pragma solidity 0.7.1;

contract LYNCToken {





    


    using SafeMath for uint256;





    


    string constant public name = "LYNC Network";


    string constant public symbol = "LYNC";


    uint8 constant public decimals = 18;





    


    address public owner;


    address public rewardPoolAddress;





    


    uint256 public maxTokenSupply = 1e24;   


    uint256 public feePercent = 1;          


    uint256 public feePercentMax = 10;      





    


    event Transfer(address indexed _from, address indexed _to, uint256 _tokens);


    event Approval(address indexed _owner,address indexed _spender, uint256 _tokens);


    event TranserFee(uint256 _tokens);


    event UpdateFee(uint256 _fee);


    event RewardPoolUpdated(address indexed _rewardPoolAddress, address indexed _newRewardPoolAddress);


    event OwnershipTransferred(address indexed _previousOwner, address indexed _newOwner);


    event OwnershipRenounced(address indexed _previousOwner, address indexed _newOwner);





    


    mapping(address => uint256) public balanceOf;


    mapping(address => mapping(address => uint256)) private allowances;





    


    constructor () {


        owner = msg.sender;


        rewardPoolAddress = address(this);


        balanceOf[msg.sender] = maxTokenSupply;


        emit Transfer(address(0), msg.sender, maxTokenSupply);


    }





    


    function totalSupply() public view returns (uint256) {


        return maxTokenSupply;


    }





    


    function transfer(address _to, uint256 _tokens) public returns (bool) {


        transferWithFee(msg.sender, _to, _tokens);


        return true;


    }





    


    function transferFrom(address _from, address _to, uint256 _tokens) public returns (bool) {


        require(_tokens <= balanceOf[_from], "Not enough tokens in the approved address balance");


        require(_tokens <= allowances[_from][msg.sender], "token amount is larger than the current allowance");


        transferWithFee(_from, _to, _tokens);


        allowances[_from][msg.sender] = allowances[_from][msg.sender].sub(_tokens);


        return true;


    }





    


    function approve(address _spender, uint256 _tokens) public returns (bool) {


        allowances[msg.sender][_spender] = _tokens;


        emit Approval(msg.sender, _spender, _tokens);


        return true;


    }





    


    function allowance(address _owner, address _spender) public view returns (uint256) {


        return allowances[_owner][_spender];


    }





    


    function transferWithFee(address _from, address _to, uint256 _tokens) internal returns (bool) {


        require(balanceOf[_from] >= _tokens, "Not enough tokens in the senders balance");


        uint256 _feeAmount = (_tokens.mul(feePercent)).div(100);


        balanceOf[_from] = balanceOf[_from].sub(_tokens);


        balanceOf[_to] = balanceOf[_to].add(_tokens.sub(_feeAmount));


        balanceOf[rewardPoolAddress] = balanceOf[rewardPoolAddress].add(_feeAmount);


        emit Transfer(_from, _to, _tokens.sub(_feeAmount));


        emit Transfer(_from, rewardPoolAddress, _feeAmount);


        emit TranserFee(_tokens);


        return true;


    }





    


    function updateFee(uint256 _updateFee) public onlyOwner {


        require(_updateFee <= feePercentMax, "Transaction fee cannot be greater than 10%");


        feePercent = _updateFee;


        emit UpdateFee(_updateFee);


    }





    


    function updateRewardPool(address _newRewardPoolAddress) public onlyOwner {


        require(_newRewardPoolAddress != address(0), "New reward pool address cannot be a zero address");


        rewardPoolAddress = _newRewardPoolAddress;


        emit RewardPoolUpdated(rewardPoolAddress, _newRewardPoolAddress);


    }





    


    function rewardPoolBalanceTransfer() public onlyOwner returns (bool) {


        uint256 _currentBalance = balanceOf[address(this)];


        transferWithFee(address(this), rewardPoolAddress, _currentBalance);


        return true;


    }





    


    function transferOwnership(address _newOwner) public onlyOwner {


        require(_newOwner != address(0), "New owner cannot be a zero address");


        emit OwnershipTransferred(owner, _newOwner);


        owner = _newOwner;


    }





    


    function renounceOwnership() public onlyOwner {


        emit OwnershipRenounced(owner, address(0));


        owner = address(0);


    }





    


    modifier onlyOwner() {


        require(owner == msg.sender, "Only current owner can call this function");


        _;


    }


}

contract LYNCTokenSale {





   


    using SafeMath for uint256;





    address payable owner;


    address public contractAddress;


    uint256 public tokensSold;


    uint256 public priceETH;


    uint256 public SCALAR = 1e18;           


    uint256 public maxBuyETH = 10;          


    uint256 public tokenOverFlow = 5e20;    


    uint256 public tokenPrice = 70;         


    uint256 public batchSize = 1;           





    bool public saleEnabled = false;





    LYNCToken public tokenContract;





    


    event Sell(address _buyer, uint256 _amount);








    


    mapping(address => uint256) public purchaseData;





    


    address[] userIndex;





    


    constructor(LYNCToken _tokenContract, uint256 _priceETH) {


        owner = msg.sender;


        tokenContract = _tokenContract;


        contractAddress = address(this);


        priceETH = _priceETH;


    }





    


    function buyTokens(uint256 _ethSent) public payable {





        require(saleEnabled == true, "The LYNC Initial Token Offering will commence on the 28th of September @ 5PM UTC");


        require(_ethSent <= maxBuyETH.mul(SCALAR), "Exceeded maximum purchase per transaction");


        require(_ethSent >= 1e17, "Minimum purchase per transaction is 0.1 ETH");





        uint256 _priceETH = priceETH.mul(SCALAR);





        


        if (tokensSold < (100000 * SCALAR)) {





            


            uint256 _tokenPrice = tokenPrice.mul(SCALAR);





            


            uint256 _tokensPerETH = _priceETH.div(_tokenPrice);


            uint256 _numberOfTokens = _ethSent.mul(_tokensPerETH);





            


            uint256 _tokensRemaining = (100000 * SCALAR).sub(tokensSold);





            


            require(_numberOfTokens < _tokensRemaining.add(tokenOverFlow), "Not enough tokens remain in Round 1");





            


            if(purchaseData[msg.sender] == 0) {


                userIndex.push(msg.sender);


            }





            purchaseData[msg.sender] = purchaseData[msg.sender].add(_numberOfTokens);


            tokensSold = tokensSold.add(_numberOfTokens);


            emit Sell(msg.sender, _numberOfTokens);





            


            if(tokensSold > 100000 * SCALAR) {


              


              tokenPrice = 80; 


            }





        } else if (tokensSold > (100000 * SCALAR) && tokensSold < (250000 * SCALAR)) {





            


            uint256 _tokenPrice = tokenPrice.mul(SCALAR);





            


            uint256 _tokensPerETH = _priceETH.div(_tokenPrice);


            uint256 _numberOfTokens = _ethSent.mul(_tokensPerETH);





            


            uint256 _tokensRemaining = (250000 * SCALAR).sub(tokensSold);





            


            require(_numberOfTokens < _tokensRemaining.add(tokenOverFlow), "Not enough tokens remain in Round 2");





            


            if(purchaseData[msg.sender] == 0) {


                userIndex.push(msg.sender);


            }


            purchaseData[msg.sender] = purchaseData[msg.sender].add(_numberOfTokens);


            tokensSold = tokensSold.add(_numberOfTokens);


            emit Sell(msg.sender, _numberOfTokens);





            


            if(tokensSold > 250000 * SCALAR) {


              


              tokenPrice = 90; 


            }





        } else {





            


            uint256 _tokenPrice = tokenPrice.mul(SCALAR);





            


            uint256 _tokensPerETH = _priceETH.div(_tokenPrice);


            uint256 _numberOfTokens = _ethSent.mul(_tokensPerETH);





            


            require(_numberOfTokens <= tokenContract.balanceOf(address(this)), "Not enough tokens remain in Round 3");





            


            if(purchaseData[msg.sender] == 0) {


                userIndex.push(msg.sender);


            }


            purchaseData[msg.sender] = purchaseData[msg.sender].add(_numberOfTokens);


            tokensSold = tokensSold.add(_numberOfTokens);


            emit Sell(msg.sender, _numberOfTokens);


        }


    }





    


    function totalBuyers() view public returns (uint256) {


        return userIndex.length;


    }





    


    function enableSale(bool _saleStatus) public onlyOwner {


        saleEnabled = _saleStatus;


    }





    


    function updatePriceETH(uint256 _updateETH) public onlyOwner {


        priceETH = _updateETH;


    }





    


    function updateMaxBuyETH(uint256 _maxBuyETH) public onlyOwner {


        maxBuyETH = _maxBuyETH;


    }





    


    function updateBatchSize(uint256 _batchSize) public onlyOwner {


        batchSize = _batchSize;


    }





    


    function distributeTokens() public onlyOwner {





        for (uint256 i = 0; i < batchSize; i++) {


            address _userAddress = userIndex[i];


            uint256 _tokensOwed = purchaseData[_userAddress];


            if(_tokensOwed > 0) {


                require(tokenContract.transfer(_userAddress, _tokensOwed));


                purchaseData[_userAddress] = 0;


            }


        }


    }





    


    function withdraw() external onlyOwner {


        msg.sender.transfer(address(this).balance);


    }





    


    function endSale() public onlyOwner {


        require(tokenContract.transfer(owner, tokenContract.balanceOf(address(this))));


        msg.sender.transfer(address(this).balance);


        saleEnabled = false;


    }





    


    modifier onlyOwner() {


        require(owner == msg.sender, "Only current owner can call this function");


        _;


    }


}

library SafeMath {


    


    function add(uint256 a, uint256 b) internal pure returns (uint256) {


        uint256 c = a + b;


        require(c >= a, "SafeMath: addition overflow");





        return c;


    }





    


    function sub(uint256 a, uint256 b) internal pure returns (uint256) {


        return sub(a, b, "SafeMath: subtraction overflow");


    }





    


    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {


        require(b <= a, errorMessage);


        uint256 c = a - b;





        return c;


    }





    


    function mul(uint256 a, uint256 b) internal pure returns (uint256) {


        


        


        


        if (a == 0) {


            return 0;


        }





        uint256 c = a * b;


        require(c / a == b, "SafeMath: multiplication overflow");





        return c;


    }





    


    function div(uint256 a, uint256 b) internal pure returns (uint256) {


        return div(a, b, "SafeMath: division by zero");


    }





    


    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {


        


        require(b > 0, errorMessage);


        uint256 c = a / b;


        





        return c;


    }





    


    function mod(uint256 a, uint256 b) internal pure returns (uint256) {


        return mod(a, b, "SafeMath: modulo by zero");


    }





    


    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {


        require(b != 0, errorMessage);


        return a % b;


    }


}
