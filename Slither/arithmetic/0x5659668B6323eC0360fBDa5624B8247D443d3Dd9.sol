pragma solidity 0.7.2;

contract LYNCStakingV1 {





  


  using SafeMath for uint256;





    address public owner;


    address public contractAddress;


    uint256 public totalRewards = 0;


    uint256 public totalRewardsClaimed = 0;


    uint256 public totalStakedV1 = 0;


    uint256 public oneDay = 86400;          


    uint256 public SCALAR = 1e18;           


    uint256 public minimumTokenStake = 98;  


    uint256 public endOfStakeFee = 4;       





    LYNCToken public tokenContract;





    


	event Stake(address _from, uint256 tokens);


	event Unstake(address _to, uint256 tokens);


	event UnstakeFee(address _to, uint256 tokens);


	event CollectRewards(address _to, uint256 tokens);





	


	struct Staker {


		uint256 staked;


		uint256 poolAtLastClaim;


		uint256 userTimeStamp;


	}





    


    mapping(address => Staker) stakers;





    


    constructor(LYNCToken _tokenContract) {


        owner = msg.sender;


        tokenContract = _tokenContract;


        contractAddress = address(this);


    }





    


    function mulDiv(uint x, uint y, uint z) public pure returns (uint) {


          (uint l, uint h) = fullMul (x, y);


          assert (h < z);


          uint mm = mulmod(x, y, z);


          if (mm > l) h -= 1;


          l -= mm;


          uint pow2 = z & -z;


          z /= pow2;


          l /= pow2;


          l += h * ((-pow2) / pow2 + 1);


          uint r = 1;


          r *= 2 - z * r;


          r *= 2 - z * r;


          r *= 2 - z * r;


          r *= 2 - z * r;


          r *= 2 - z * r;


          r *= 2 - z * r;


          r *= 2 - z * r;


          r *= 2 - z * r;


          return l * r;


    }





    


    function fullMul(uint x, uint y) private pure returns (uint l, uint h) {


          uint mm = mulmod(x, y, uint (-1));


          l = x * y;


          h = mm - l;


          if (mm < l) h -= 1;


    }





    


    function rewardPoolBalance() public view returns(uint256) {


        return tokenContract.balanceOf(address(this)).sub(totalStakedV1);


    }





    


    function stakerInformation(address _stakerAddress) public view returns(uint256, uint256, uint256) {


        return (stakers[_stakerAddress].staked, stakers[_stakerAddress].poolAtLastClaim, stakers[_stakerAddress].userTimeStamp);


    }





    


    function stakeTokens(uint256 _numberOfTokens) external returns (bool) {





        


        if(stakers[msg.sender].staked == 0) {





            


            require(_numberOfTokens > (minimumTokenStake * SCALAR), "Not enough tokens to start staking");





            


            require(tokenContract.transferFrom(msg.sender, address(this), _numberOfTokens));


            stakers[msg.sender].poolAtLastClaim = totalRewards;


            stakers[msg.sender].userTimeStamp = block.timestamp;


        } else {





            


            require(tokenContract.transferFrom(msg.sender, address(this), _numberOfTokens));


        }





        


        uint256 _feeAmount = (_numberOfTokens.mul(tokenContract.feePercent())).div(100);


        uint256 _stakedAfterFee = _numberOfTokens.sub(_feeAmount);





        


        stakers[msg.sender].staked = (stakers[msg.sender].staked).add(_stakedAfterFee);


        totalStakedV1 = totalStakedV1.add(_stakedAfterFee);


        totalRewards = rewardPoolBalance().add(totalRewardsClaimed);





        emit Stake(msg.sender, _numberOfTokens);


        return true;


    }





    


    function unstakeTokens() external returns (bool) {





        


        uint256 _stakedTokens = stakers[msg.sender].staked;


        uint256 _feeAmount = (_stakedTokens.mul(endOfStakeFee)).div(100);


        uint256 _unstakeTokens = (stakers[msg.sender].staked).sub(_feeAmount);





        


        require(tokenContract.transfer(msg.sender, _unstakeTokens));


        totalStakedV1 = totalStakedV1.sub(_stakedTokens);





        


        stakers[msg.sender].staked = 0;


        stakers[msg.sender].poolAtLastClaim = 0;


        stakers[msg.sender].userTimeStamp = 0;


        totalRewards = rewardPoolBalance().add(totalRewardsClaimed);





        emit Unstake(msg.sender, _unstakeTokens);


        emit UnstakeFee(msg.sender, _feeAmount);


        return true;


    }





    


    function claimRewards() external returns (bool) {





        totalRewards = rewardPoolBalance().add(totalRewardsClaimed);


        require(stakers[msg.sender].staked > 0, "You do not have any tokens staked");


        require(block.timestamp > (stakers[msg.sender].userTimeStamp + oneDay), "You can only claim 24 hours after staking and once every 24 hours");





        


        uint256 _poolSinceLastClaim = totalRewards.sub(stakers[msg.sender].poolAtLastClaim);


        uint256 _rewardPercent = mulDiv(stakers[msg.sender].staked, 10000, totalStakedV1);


        uint256 _rewardToClaim = mulDiv(_poolSinceLastClaim, _rewardPercent, 10000);





        


        require(tokenContract.transfer(msg.sender, _rewardToClaim));





        


        stakers[msg.sender].poolAtLastClaim = totalRewards;


        stakers[msg.sender].userTimeStamp = block.timestamp;


        totalRewardsClaimed = totalRewardsClaimed.add(_rewardToClaim);


        totalRewards = rewardPoolBalance().add(totalRewardsClaimed);





        emit CollectRewards(msg.sender, _rewardToClaim);


        return true;


    }





    


    function updateStakeMinimum(uint256 _minimumTokenStake) public onlyOwner {


        minimumTokenStake = _minimumTokenStake;


    }





    


    modifier onlyOwner() {


        require(owner == msg.sender, "Only current owner can call this function");


        _;


    }


}

contract LYNCToken {





    


    using SafeMath for uint256;





    


    string constant public name = "LYNC Network";


    string constant public symbol = "LYNC";


    uint8 constant public decimals = 18;





    


    address public owner;


    address public rewardPoolAddress;





    


    uint256 public maxTokenSupply = 1e24;   


    uint256 public feePercent = 1;          


    uint256 public feePercentMax = 10;      





    


    event Transfer(address indexed _from, address indexed _to, uint256 _tokens);


    event Approval(address indexed _owner,address indexed _spender, uint256 _tokens);


    event TranserFee(uint256 _tokens);


    event UpdateFee(uint256 _fee);


    event RewardPoolUpdated(address indexed _rewardPoolAddress, address indexed _newRewardPoolAddress);


    event OwnershipTransferred(address indexed _previousOwner, address indexed _newOwner);


    event OwnershipRenounced(address indexed _previousOwner, address indexed _newOwner);





    


    mapping(address => uint256) public balanceOf;


    mapping(address => mapping(address => uint256)) private allowances;





    


    constructor () {


        owner = msg.sender;


        rewardPoolAddress = address(this);


        balanceOf[msg.sender] = maxTokenSupply;


        emit Transfer(address(0), msg.sender, maxTokenSupply);


    }





    


    function totalSupply() public view returns (uint256) {


        return maxTokenSupply;


    }





    


    function transfer(address _to, uint256 _tokens) public returns (bool) {


        transferWithFee(msg.sender, _to, _tokens);


        return true;


    }





    


    function transferFrom(address _from, address _to, uint256 _tokens) public returns (bool) {


        require(_tokens <= balanceOf[_from], "Not enough tokens in the approved address balance");


        require(_tokens <= allowances[_from][msg.sender], "token amount is larger than the current allowance");


        transferWithFee(_from, _to, _tokens);


        allowances[_from][msg.sender] = allowances[_from][msg.sender].sub(_tokens);


        return true;


    }





    


    function approve(address _spender, uint256 _tokens) public returns (bool) {


        allowances[msg.sender][_spender] = _tokens;


        emit Approval(msg.sender, _spender, _tokens);


        return true;


    }





    


    function allowance(address _owner, address _spender) public view returns (uint256) {


        return allowances[_owner][_spender];


    }





    


    function transferWithFee(address _from, address _to, uint256 _tokens) internal returns (bool) {


        require(balanceOf[_from] >= _tokens, "Not enough tokens in the senders balance");


        uint256 _feeAmount = (_tokens.mul(feePercent)).div(100);


        balanceOf[_from] = balanceOf[_from].sub(_tokens);


        balanceOf[_to] = balanceOf[_to].add(_tokens.sub(_feeAmount));


        balanceOf[rewardPoolAddress] = balanceOf[rewardPoolAddress].add(_feeAmount);


        emit Transfer(_from, _to, _tokens.sub(_feeAmount));


        emit Transfer(_from, rewardPoolAddress, _feeAmount);


        emit TranserFee(_tokens);


        return true;


    }





    


    function updateFee(uint256 _updateFee) public onlyOwner {


        require(_updateFee <= feePercentMax, "Transaction fee cannot be greater than 10%");


        feePercent = _updateFee;


        emit UpdateFee(_updateFee);


    }





    


    function updateRewardPool(address _newRewardPoolAddress) public onlyOwner {


        require(_newRewardPoolAddress != address(0), "New reward pool address cannot be a zero address");


        rewardPoolAddress = _newRewardPoolAddress;


        emit RewardPoolUpdated(rewardPoolAddress, _newRewardPoolAddress);


    }





    


    function rewardPoolBalanceTransfer() public onlyOwner returns (bool) {


        uint256 _currentBalance = balanceOf[address(this)];


        transferWithFee(address(this), rewardPoolAddress, _currentBalance);


        return true;


    }





    


    function transferOwnership(address _newOwner) public onlyOwner {


        require(_newOwner != address(0), "New owner cannot be a zero address");


        emit OwnershipTransferred(owner, _newOwner);


        owner = _newOwner;


    }





    


    function renounceOwnership() public onlyOwner {


        emit OwnershipRenounced(owner, address(0));


        owner = address(0);


    }





    


    modifier onlyOwner() {


        require(owner == msg.sender, "Only current owner can call this function");


        _;


    }


}

library SafeMath {


    


    function add(uint256 a, uint256 b) internal pure returns (uint256) {


        uint256 c = a + b;


        require(c >= a, "SafeMath: addition overflow");





        return c;


    }





    


    function sub(uint256 a, uint256 b) internal pure returns (uint256) {


        return sub(a, b, "SafeMath: subtraction overflow");


    }





    


    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {


        require(b <= a, errorMessage);


        uint256 c = a - b;





        return c;


    }





    


    function mul(uint256 a, uint256 b) internal pure returns (uint256) {


        


        


        


        if (a == 0) {


            return 0;


        }





        uint256 c = a * b;


        require(c / a == b, "SafeMath: multiplication overflow");





        return c;


    }





    


    function div(uint256 a, uint256 b) internal pure returns (uint256) {


        return div(a, b, "SafeMath: division by zero");


    }





    


    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {


        


        require(b > 0, errorMessage);


        uint256 c = a / b;


        





        return c;


    }





    


    function mod(uint256 a, uint256 b) internal pure returns (uint256) {


        return mod(a, b, "SafeMath: modulo by zero");


    }





    


    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {


        require(b != 0, errorMessage);


        return a % b;


    }


}
