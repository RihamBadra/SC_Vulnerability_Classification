




pragma solidity 0.6.5;

interface YearnRewardsI {
    function starttime() external returns (uint256);
    function totalRewards() external returns (uint256);
    function y() external returns (address);
    function yfi() external returns (address);
    function balanceOf(address _) external returns(uint256);
    function earned(address _) external returns(uint256);
}

interface UniV2PairI {
    function sync() external;
}

interface ERC20MigratorI {
    function totalMigrated() external returns (uint256);
}





pragma solidity 0.6.5;


library SafeMathInt {
    int256 private constant MIN_INT256 = int256(1) << 255;
    int256 private constant MAX_INT256 = ~(int256(1) << 255);

    
    function mul(int256 a, int256 b) internal pure returns (int256) {
        int256 c = a * b;

        
        require(c != MIN_INT256 || (a & MIN_INT256) != (b & MIN_INT256));
        require((b == 0) || (c / b == a));
        return c;
    }

    
    function div(int256 a, int256 b) internal pure returns (int256) {
        
        require(b != -1 || a != MIN_INT256);

        
        return a / b;
    }

    
    function sub(int256 a, int256 b) internal pure returns (int256) {
        int256 c = a - b;
        require((b >= 0 && c <= a) || (b < 0 && c > a));
        return c;
    }

    
    function add(int256 a, int256 b) internal pure returns (int256) {
        int256 c = a + b;
        require((b >= 0 && c >= a) || (b < 0 && c < a));
        return c;
    }

    
    function abs(int256 a) internal pure returns (int256) {
        require(a != MIN_INT256);
        return a < 0 ? -a : a;
    }
}





pragma solidity >=0.6.0 <0.8.0;


abstract contract Context {
    function _msgSender() internal view virtual returns (address payable) {
        return msg.sender;
    }

    function _msgData() internal view virtual returns (bytes memory) {
        this; 
        return msg.data;
    }
}





pragma solidity >=0.6.0 <0.8.0;


interface IERC20 {
    
    function totalSupply() external view returns (uint256);

    
    function balanceOf(address account) external view returns (uint256);

    
    function transfer(address recipient, uint256 amount) external returns (bool);

    
    function allowance(address owner, address spender) external view returns (uint256);

    
    function approve(address spender, uint256 amount) external returns (bool);

    
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);

    
    event Transfer(address indexed from, address indexed to, uint256 value);

    
    event Approval(address indexed owner, address indexed spender, uint256 value);
}





pragma solidity >=0.6.0 <0.8.0;


library SafeMath {
    
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, "SafeMath: addition overflow");

        return c;
    }

    
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        return sub(a, b, "SafeMath: subtraction overflow");
    }

    
    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b <= a, errorMessage);
        uint256 c = a - b;

        return c;
    }

    
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        
        
        
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b, "SafeMath: multiplication overflow");

        return c;
    }

    
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        return div(a, b, "SafeMath: division by zero");
    }

    
    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b > 0, errorMessage);
        uint256 c = a / b;
        

        return c;
    }

    
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        return mod(a, b, "SafeMath: modulo by zero");
    }

    
    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b != 0, errorMessage);
        return a % b;
    }
}





pragma solidity 0.6.5;





contract ERC20 is Context, IERC20 {
    using SafeMath for uint256;

    mapping (address => uint256) private _balances;

    mapping (address => mapping (address => uint256)) private _allowances;

    uint256 private _totalSupply;

    string private _name;
    string private _symbol;
    uint8 private _decimals;

    
    constructor (string memory name_, string memory symbol_) public {
        _name = name_;
        _symbol = symbol_;
        _decimals = 18;
    }

    
    function name() public view returns (string memory) {
        return _name;
    }

    
    function symbol() public view returns (string memory) {
        return _symbol;
    }

    
    function decimals() public view returns (uint8) {
        return _decimals;
    }

    
    function totalSupply() public view override virtual returns (uint256) {
        return _totalSupply;
    }

    
    function balanceOf(address account) public view override virtual returns (uint256) {
        return _balances[account];
    }

    
    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {
        _transfer(_msgSender(), recipient, amount);
        return true;
    }

    
    function allowance(address owner, address spender) public view virtual override returns (uint256) {
        return _allowances[owner][spender];
    }

    
    function approve(address spender, uint256 amount) public virtual override returns (bool) {
        _approve(_msgSender(), spender, amount);
        return true;
    }

    
    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {
        _transfer(sender, recipient, amount);
        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, "ERC20: transfer amount exceeds allowance"));
        return true;
    }

    
    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {
        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));
        return true;
    }

    
    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {
        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, "ERC20: decreased allowance below zero"));
        return true;
    }

    
    function _transfer(address sender, address recipient, uint256 amount) internal virtual {
        require(sender != address(0), "ERC20: transfer from the zero address");
        require(recipient != address(0), "ERC20: transfer to the zero address");

        _beforeTokenTransfer(sender, recipient, amount);

        _balances[sender] = _balances[sender].sub(amount, "ERC20: transfer amount exceeds balance");
        _balances[recipient] = _balances[recipient].add(amount);
        emit Transfer(sender, recipient, amount);
    }

    
    function _mint(address account, uint256 amount) internal virtual {
        require(account != address(0), "ERC20: mint to the zero address");

        _beforeTokenTransfer(address(0), account, amount);

        _totalSupply = _totalSupply.add(amount);
        _balances[account] = _balances[account].add(amount);
        emit Transfer(address(0), account, amount);
    }

    
    function _burn(address account, uint256 amount) internal virtual {
        require(account != address(0), "ERC20: burn from the zero address");

        _beforeTokenTransfer(account, address(0), amount);

        _balances[account] = _balances[account].sub(amount, "ERC20: burn amount exceeds balance");
        _totalSupply = _totalSupply.sub(amount);
        emit Transfer(account, address(0), amount);
    }

    
    function _approve(address owner, address spender, uint256 amount) internal virtual {
        require(owner != address(0), "ERC20: approve from the zero address");
        require(spender != address(0), "ERC20: approve to the zero address");

        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }

    
    function _setupDecimals(uint8 decimals_) internal {
        _decimals = decimals_;
    }

    
    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }
}





pragma solidity >=0.6.0 <0.8.0;


abstract contract Ownable is Context {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    
    constructor () internal {
        address msgSender = _msgSender();
        _owner = msgSender;
        emit OwnershipTransferred(address(0), msgSender);
    }

    
    function owner() public view returns (address) {
        return _owner;
    }

    
    modifier onlyOwner() {
        require(_owner == _msgSender(), "Ownable: caller is not the owner");
        _;
    }

    
    function renounceOwnership() public virtual onlyOwner {
        emit OwnershipTransferred(_owner, address(0));
        _owner = address(0);
    }

    
    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), "Ownable: new owner is the zero address");
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }
}




pragma solidity 0.6.5;






contract BasixToken is ERC20, Ownable {
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    using SafeMath for uint256;
    using SafeMathInt for int256;

    event LogRebase(uint256 indexed epoch, uint256 totalSupply);
    event LogMonetaryPolicyUpdated(address monetaryPolicy);

    
    address public monetaryPolicy;

    modifier onlyMonetaryPolicy() {
        require(msg.sender == monetaryPolicy, "Required Monetarypolicy");
        _;
    }

    bool private rebasePausedDeprecated;
    bool private tokenPausedDeprecated;

    modifier validRecipient(address to) {
        require(to != address(0x0), "No valid address");
        require(to != address(this), "No valid address");
        _;
    }

    uint256 private constant DECIMALS = 18;
    uint256 private constant MAX_UINT256 = ~uint256(0);
    uint256 private constant INITIAL_FRAGMENTS_SUPPLY = 2000000 * uint(10)**DECIMALS;
    uint256 private constant TRANSFER_FEE = 100; 

    
    
    uint256 private constant TOTAL_GRAINS = MAX_UINT256 - (MAX_UINT256 % INITIAL_FRAGMENTS_SUPPLY);

    
    uint256 private constant MAX_SUPPLY = ~uint128(0);  

    uint256 private _totalSupply;
    uint256 private _grainsPerFragment;
    mapping(address => uint256) private _grainBalances;
    mapping(address => bool) _feeWhiteList;

    
    
    mapping (address => mapping (address => uint256)) private _allowedFragments;

    constructor (
        string memory name_,
        string memory symbol_,
        address owner_,
        address pool_
    ) 
      ERC20(name_, symbol_) public {

        rebasePausedDeprecated = false;
        tokenPausedDeprecated = false;

        _totalSupply = INITIAL_FRAGMENTS_SUPPLY;
        _grainsPerFragment = TOTAL_GRAINS.div(_totalSupply);

        uint256 poolVal = 200000 * (10 ** DECIMALS);
        uint256 poolGrains = poolVal.mul(_grainsPerFragment);

        _grainBalances[owner_] = TOTAL_GRAINS.sub(poolGrains);
        _grainBalances[pool_] = poolGrains;

        addToWhitelist(owner_);
        addToWhitelist(pool_);

        emit Transfer(address(0x0), owner_, _totalSupply.sub(poolVal));
        emit Transfer(address(0x0), pool_, poolVal);
    }
    
    function totalSupply() public view override returns (uint256) {
        return _totalSupply;
    }

    function addToWhitelist(address wallet) onlyOwner() public {
        _feeWhiteList[wallet] = true;
    }

    function removeFromWhitelist(address wallet) onlyOwner() public {
        _feeWhiteList[wallet] = false;
    }

    
    function setMonetaryPolicy(address monetaryPolicy_)
        public
        onlyOwner
    {
        monetaryPolicy = monetaryPolicy_;
        emit LogMonetaryPolicyUpdated(monetaryPolicy_);
    }

    
    function rebase(uint256 epoch, int256 supplyDelta)
        public
        onlyMonetaryPolicy
        returns (uint256)
    {
        if (supplyDelta == 0) {
            emit LogRebase(epoch, _totalSupply);
            return _totalSupply;
        }

        if (supplyDelta < 0) {
            _totalSupply = _totalSupply.sub(uint256(supplyDelta.abs()));
        } else {
            _totalSupply = _totalSupply.add(uint256(supplyDelta));
        }

        if (_totalSupply > MAX_SUPPLY) {
            _totalSupply = MAX_SUPPLY;
        }

        _grainsPerFragment = TOTAL_GRAINS.div(_totalSupply);

        
        
        
        
        
        
        
        
        
        

        emit LogRebase(epoch, _totalSupply);
        return _totalSupply;
    }

    
    function balanceOf(address who) public view override returns (uint256) {
        return _grainBalances[who].div(_grainsPerFragment);
    }

    
    function transfer(address to, uint256 value)
        public
        override
        validRecipient(to)
        returns (bool)
    {
        if (_feeWhiteList[to]) {
            uint256 grainValue = value.mul(_grainsPerFragment);

            _grainBalances[msg.sender] = _grainBalances[msg.sender].sub(grainValue);
            _grainBalances[to] = _grainBalances[to].add(grainValue);
            emit Transfer(msg.sender, to, value);
            return true;
        } else {
            uint256 grainValue = value.mul(_grainsPerFragment);
            uint256 grainFee = grainValue.div(10000).mul(TRANSFER_FEE);
            uint256 newGrainsValue = grainValue - grainFee;
            uint256 newValue = newGrainsValue.div(_grainsPerFragment);

            _burn(msg.sender, grainFee);

            _grainBalances[msg.sender] = _grainBalances[msg.sender].sub(newGrainsValue);
            _grainBalances[to] = _grainBalances[to].add(newGrainsValue);
            emit Transfer(msg.sender, to, newValue);
            return true;
        }
    }

    
    function allowance(address owner_, address spender)
        public
        view
        override
        returns (uint256)
    {
        return _allowedFragments[owner_][spender];
    }

    
    function transferFrom(address from, address to, uint256 value)
        public
        override
        validRecipient(to)
        returns (bool)
    {
        _allowedFragments[from][msg.sender] = _allowedFragments[from][msg.sender].sub(value);

        if (_feeWhiteList[from] || _feeWhiteList[to]) {
            uint256 grainValue = value.mul(_grainsPerFragment);

            _grainBalances[from] = _grainBalances[from].sub(grainValue);
            _grainBalances[to] = _grainBalances[to].add(grainValue);
            emit Transfer(from, to, value);

            return true;
        } else {
            uint256 grainValue = value.mul(_grainsPerFragment);
            uint256 grainFee = grainValue.div(10000).mul(TRANSFER_FEE);
            uint256 newGrainsValue = grainValue - grainFee;
            uint256 newValue = newGrainsValue.div(_grainsPerFragment);

            _burn(from, grainFee);

            _grainBalances[from] = _grainBalances[from].sub(newGrainsValue);
            _grainBalances[to] = _grainBalances[to].add(newGrainsValue);
            emit Transfer(from, to, newValue);

            return true;
        }
    }

    function _burn(address account, uint256 grainsAmount) internal override {
        require(account != address(0), "ERC20: burn from the zero address");

        _grainBalances[account] = _grainBalances[account].sub(grainsAmount, "ERC20: burn amount exceeds balance");
        
        uint256 amount = grainsAmount.div(_grainsPerFragment);
        
        _totalSupply = _totalSupply.sub(amount);
        emit Transfer(account, address(0), amount);
    }

    
    function approve(address spender, uint256 value)
        public
        override
        returns (bool)
    {
        _allowedFragments[msg.sender][spender] = value;
        emit Approval(msg.sender, spender, value);
        return true;
    }

    
    function increaseAllowance(address spender, uint256 addedValue)
        public
        override
        returns (bool)
    {
        _allowedFragments[msg.sender][spender] =
            _allowedFragments[msg.sender][spender].add(addedValue);
        emit Approval(msg.sender, spender, _allowedFragments[msg.sender][spender]);
        return true;
    }

    
    function decreaseAllowance(address spender, uint256 subtractedValue)
        public
        override
        returns (bool)
    {
        uint256 oldValue = _allowedFragments[msg.sender][spender];
        if (subtractedValue >= oldValue) {
            _allowedFragments[msg.sender][spender] = 0;
        } else {
            _allowedFragments[msg.sender][spender] = oldValue.sub(subtractedValue);
        }
        emit Approval(msg.sender, spender, _allowedFragments[msg.sender][spender]);
        return true;
    }
}



pragma solidity 0.6.5;

interface IOracle {
    function getData() external returns (uint256, bool);
}



pragma solidity 0.6.5;


library UInt256Lib {
    uint256 private constant MAX_INT256 = ~(uint256(1) << 255);

    
    function toInt256Safe(uint256 a) internal pure returns (int256) {
        require(a <= MAX_INT256);
        return int256(a);
    }
}




pragma solidity 0.6.5;








contract BasixProtocol is Ownable {
    using SafeMath for uint256;
    using SafeMathInt for int256;
    using UInt256Lib for uint256;

    event LogRebase(
        uint256 indexed epoch,
        uint256 exchangeRate,
        int256 requestedSupplyAdjustment,
        uint256 timestampSec
    );

    BasixToken public fragments;

    
    
    IOracle public marketOracle;

    
    uint256 private baseCpi;

    
    
    
    
    uint256 public deviationThreshold;

    
    
    
    uint256 public rebaseLag;

    
    uint256 public minRebaseTimeIntervalSec;

    
    uint256 public lastRebaseTimestampSec;

    
    
    uint256 public rebaseWindowOffsetSec;

    
    uint256 public rebaseWindowLengthSec;

    
    uint256 public epoch;

    uint256 private constant DECIMALS = 18;

    
    
    uint256 private constant MAX_RATE = 10**6 * 10**DECIMALS;
    
    uint256 private constant MAX_SUPPLY = ~(uint256(1) << 255) / MAX_RATE;

    
    address public orchestrator;

    modifier onlyOrchestrator() {
        require(msg.sender == orchestrator, "Only Orchestrator");
        _;
    }

    constructor (BasixToken fragments_) public {
        
        deviationThreshold = 5 * 10 ** (DECIMALS-2);

        rebaseLag = 10;
        minRebaseTimeIntervalSec = 1 days;
        rebaseWindowOffsetSec = 32400;  
        rebaseWindowLengthSec = 60 minutes;
        lastRebaseTimestampSec = 0;
        epoch = 0;

        fragments = fragments_;
    }

    
    function rebase() external onlyOrchestrator {
        require(inRebaseWindow(), "Not in rebase window");

        
        require(lastRebaseTimestampSec.add(minRebaseTimeIntervalSec) < now, "No reentrancy");

        
        lastRebaseTimestampSec = now.sub(
            now.mod(minRebaseTimeIntervalSec)
        ).add(rebaseWindowOffsetSec);

        epoch = epoch.add(1);

        uint256 targetRate = 10 ** DECIMALS;

        uint256 exchangeRate;
        bool rateValid;
        (exchangeRate, rateValid) = marketOracle.getData();
        require(rateValid, "Not valid rate");

        if (exchangeRate > MAX_RATE) {
            exchangeRate = MAX_RATE;
        }

        int256 supplyDelta = computeSupplyDelta(exchangeRate, targetRate);

        
        supplyDelta = supplyDelta.div(rebaseLag.toInt256Safe());

        if (supplyDelta > 0 && fragments.totalSupply().add(uint256(supplyDelta)) > MAX_SUPPLY) {
            supplyDelta = (MAX_SUPPLY.sub(fragments.totalSupply())).toInt256Safe();
        }

        uint256 supplyAfterRebase = fragments.rebase(epoch, supplyDelta);
        assert(supplyAfterRebase <= MAX_SUPPLY);
        emit LogRebase(epoch, exchangeRate, supplyDelta, now);
    }

    
    function setMarketOracle(IOracle marketOracle_)
        external
        onlyOwner
    {
        
        require(address(marketOracle) == address(0), "Not valid oracle address");
        marketOracle = marketOracle_;
    }

    
    function setOrchestrator(address orchestrator_)
        external
        onlyOwner
    {
        orchestrator = orchestrator_;
    }

    
    function setDeviationThreshold(uint256 deviationThreshold_)
        external
        onlyOwner
    {
        deviationThreshold = deviationThreshold_;
    }

    
    function setRebaseLag(uint256 rebaseLag_)
        external
        onlyOwner
    {
        require(rebaseLag_ > 0, "Not valid rebase lag");
        rebaseLag = rebaseLag_;
    }

    
    function setRebaseTimingParameters(
        uint256 minRebaseTimeIntervalSec_,
        uint256 rebaseWindowOffsetSec_,
        uint256 rebaseWindowLengthSec_)
        external
        onlyOwner
    {
        require(minRebaseTimeIntervalSec_ > 0, "Not valid min rebase time interval seconds");
        require(rebaseWindowOffsetSec_ < minRebaseTimeIntervalSec_, "Not valid min rebase time interval seconds");

        minRebaseTimeIntervalSec = minRebaseTimeIntervalSec_;
        rebaseWindowOffsetSec = rebaseWindowOffsetSec_;
        rebaseWindowLengthSec = rebaseWindowLengthSec_;
    }

    
    function inRebaseWindow() public view returns (bool) {
        return (
            now.mod(minRebaseTimeIntervalSec) >= rebaseWindowOffsetSec &&
            now.mod(minRebaseTimeIntervalSec) < (rebaseWindowOffsetSec.add(rebaseWindowLengthSec))
        );
    }

    
    function computeSupplyDelta(uint256 rate, uint256 targetRate)
        private
        view
        returns (int256)
    {
        if (withinDeviationThreshold(rate, targetRate)) {
            return 0;
        }

        
        int256 targetRateSigned = targetRate.toInt256Safe();
        return fragments.totalSupply().toInt256Safe()
            .mul(rate.toInt256Safe().sub(targetRateSigned))
            .div(targetRateSigned);
    }
    
    
    function withinDeviationThreshold(uint256 rate, uint256 targetRate)
        private
        view
        returns (bool)
    {
        uint256 absoluteDeviationThreshold = targetRate.mul(deviationThreshold)
            .div(10 ** DECIMALS);

        return (rate >= targetRate && rate.sub(targetRate) < absoluteDeviationThreshold)
            || (rate < targetRate && targetRate.sub(rate) < absoluteDeviationThreshold);
    }
}




pragma solidity 0.6.5;






contract Orchestrator is Ownable {
    using SafeMath for uint256;

    struct Transaction {
        bool enabled;
        address destination;
        bytes data;
    }

    event TransactionFailed(address indexed destination, uint index, bytes data);

    
    Transaction[] public transactions;

    ERC20 public basix;
    address public deployer;
    YearnRewardsI public pool;
    UniV2PairI public uniSyncs;
    BasixProtocol public policy;
    uint256 public rebaseRequiredSupply;

    address constant uniFactory = 0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f;

    
    function genUniAddr(address left, address right) internal pure returns (UniV2PairI) {
        address first = left < right ? left : right;
        address second = left < right ? right : left;
        address pair = address(uint(keccak256(abi.encodePacked(
          hex'ff',
          uniFactory,
          keccak256(abi.encodePacked(first, second)),
          hex'96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f'
        ))));
        return UniV2PairI(pair);
    }

    constructor (
        address policy_,
        address pool_,
        address basix_,
        address sUSD_,
        uint256 rebaseRequiredSupply_
    ) public {
        policy      = BasixProtocol(policy_);
        pool        = YearnRewardsI(pool_);
        basix       = ERC20(basix_);
        uniSyncs    = genUniAddr(basix_, sUSD_);

        rebaseRequiredSupply = rebaseRequiredSupply_;
    }

    
    function rebase()
        external
    {
        
        
        uint256 rewardsDistributed = pool.totalRewards();
        require(rewardsDistributed >= rebaseRequiredSupply || block.timestamp >= pool.starttime() + 1 days, "Rebase not ready");

        policy.rebase();

        uniSyncs.sync();
    }
}