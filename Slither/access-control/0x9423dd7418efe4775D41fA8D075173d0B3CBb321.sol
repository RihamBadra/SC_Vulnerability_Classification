pragma solidity 0.5.17;

contract BondedSortitionPoolFactory {

  

  

  function createSortitionPool(

    IStaking stakingContract,

    IBonding bondingContract,

    uint256 minimumStake,

    uint256 initialMinimumBond,

    uint256 poolWeightDivisor

  ) public returns (address) {

    return

      address(

        new BondedSortitionPool(

          stakingContract,

          bondingContract,

          minimumStake,

          initialMinimumBond,

          poolWeightDivisor,

          msg.sender

        )

      );

  }

}

library Branch {

  

  



  

  

  uint256 constant SLOT_BITS = 3;

  



  

  

  uint256 constant SLOT_COUNT = 2**SLOT_BITS;

  uint256 constant SLOT_WIDTH = 256 / SLOT_COUNT;

  uint256 constant LAST_SLOT = SLOT_COUNT - 1;

  uint256 constant SLOT_MAX = (2**SLOT_WIDTH) - 1;



  



  

  

  

  

  

  

  

  

  function slotShift(uint256 position) internal pure returns (uint256) {

    return position * SLOT_WIDTH;

  }



  

  

  function getSlot(uint256 node, uint256 position)

    internal

    pure

    returns (uint256)

  {

    uint256 shiftBits = position * SLOT_WIDTH;

    

    

    

    

    return (node >> shiftBits) & SLOT_MAX;

  }



  

  function clearSlot(uint256 node, uint256 position)

    internal

    pure

    returns (uint256)

  {

    uint256 shiftBits = position * SLOT_WIDTH;

    

    

    

    

    

    

    

    

    

    

    

    return node & ~(SLOT_MAX << shiftBits);

  }



  

  

  

  

  

  function setSlot(

    uint256 node,

    uint256 position,

    uint256 weight

  ) internal pure returns (uint256) {

    uint256 shiftBits = position * SLOT_WIDTH;

    

    uint256 clearedNode = node & ~(SLOT_MAX << shiftBits);

    

    

    

    

    

    

    

    uint256 shiftedWeight = (weight & SLOT_MAX) << shiftBits;

    

    

    

    return clearedNode | shiftedWeight;

  }



  

  function sumWeight(uint256 node) internal pure returns (uint256 sum) {

    sum = node & SLOT_MAX;

    

    

    

    uint256 newNode = node >> SLOT_WIDTH;

    while (newNode > 0) {

      sum += (newNode & SLOT_MAX);

      newNode = newNode >> SLOT_WIDTH;

    }

    return sum;

  }



  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  function pickWeightedSlot(uint256 node, uint256 index)

    internal

    pure

    returns (uint256 slot, uint256 newIndex)

  {

    newIndex = index;

    uint256 newNode = node;

    uint256 currentSlotWeight = newNode & SLOT_MAX;

    while (newIndex >= currentSlotWeight) {

      newIndex -= currentSlotWeight;

      slot++;

      newNode = newNode >> SLOT_WIDTH;

      currentSlotWeight = newNode & SLOT_MAX;

    }

    return (slot, newIndex);

  }

}

library DynamicArray {

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  struct UintArray {

    

    

    

    

    

    

    

    

    uint256 allocatedMemory;

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    uint256[] array;

  }



  struct AddressArray {

    uint256 allocatedMemory;

    address[] array;

  }



  

  

  

  

  

  

  function uintArray(uint256 length) internal pure returns (UintArray memory) {

    uint256[] memory array = _allocateUints(length);

    return UintArray(length, array);

  }



  function addressArray(uint256 length)

    internal

    pure

    returns (AddressArray memory)

  {

    address[] memory array = _allocateAddresses(length);

    return AddressArray(length, array);

  }



  

  

  

  

  

  

  function convert(uint256[] memory array)

    internal

    pure

    returns (UintArray memory)

  {

    return UintArray(array.length, array);

  }



  function convert(address[] memory array)

    internal

    pure

    returns (AddressArray memory)

  {

    return AddressArray(array.length, array);

  }



  

  

  

  

  

  

  

  

  

  

  

  

  function arrayPush(UintArray memory self, uint256 item) internal pure {

    uint256 length = self.array.length;

    uint256 allocLength = self.allocatedMemory;

    

    

    

    

    if (length >= allocLength) {

      

      require(length == allocLength, "Array length exceeds allocation");

      

      

      uint256 newMemory = length * 2;

      uint256[] memory newArray = _allocateUints(newMemory);

      _copy(newArray, self.array);

      self.array = newArray;

      self.allocatedMemory = newMemory;

    }

    

    _push(self.array, item);

  }



  function arrayPush(AddressArray memory self, address item) internal pure {

    uint256 length = self.array.length;

    uint256 allocLength = self.allocatedMemory;

    if (length >= allocLength) {

      require(length == allocLength, "Array length exceeds allocation");

      uint256 newMemory = length * 2;

      address[] memory newArray = _allocateAddresses(newMemory);

      _copy(newArray, self.array);

      self.array = newArray;

      self.allocatedMemory = newMemory;

    }

    _push(self.array, item);

  }



  

  

  

  

  

  

  

  function arrayPop(UintArray memory self)

    internal

    pure

    returns (uint256 item)

  {

    uint256[] memory array = self.array;

    uint256 length = array.length;

    require(length > 0, "Can't pop from empty array");

    return _pop(array);

  }



  function arrayPop(AddressArray memory self)

    internal

    pure

    returns (address item)

  {

    address[] memory array = self.array;

    uint256 length = array.length;

    require(length > 0, "Can't pop from empty array");

    return _pop(array);

  }



  

  

  

  

  

  

  

  

  function _allocateUints(uint256 length)

    private

    pure

    returns (uint256[] memory array)

  {

    

    

    

    

    

    

    uint256 inMemorySize = (length + 1) * 0x20;

    

    assembly {

      

      array := mload(0x40)

      

      

      

      

      

      mstore(array, 0)

      

      

      mstore(0x40, add(array, inMemorySize))

    }

    return array;

  }



  function _allocateAddresses(uint256 length)

    private

    pure

    returns (address[] memory array)

  {

    uint256 inMemorySize = (length + 1) * 0x20;

    

    assembly {

      array := mload(0x40)

      mstore(array, 0)

      mstore(0x40, add(array, inMemorySize))

    }

    return array;

  }



  

  

  

  function _copy(uint256[] memory dest, uint256[] memory src) private pure {

    

    assembly {

      let length := mload(src)

      let byteLength := mul(length, 0x20)

      

      mstore(dest, length)

      

      

      

      

      let writePtr := add(dest, 0x20)

      

      

      

      

      

      

      let end := add(writePtr, byteLength)



      for {

        

        

        let readPtr := add(src, 0x20)

      } lt(writePtr, end) {

        

        writePtr := add(writePtr, 0x20)

        readPtr := add(readPtr, 0x20)

      } {

        

        

        mstore(writePtr, mload(readPtr))

      }

    }

  }



  function _copy(address[] memory dest, address[] memory src) private pure {

    

    assembly {

      let length := mload(src)

      let byteLength := mul(length, 0x20)

      mstore(dest, length)

      let writePtr := add(dest, 0x20)

      let end := add(writePtr, byteLength)



      for {

        let readPtr := add(src, 0x20)

      } lt(writePtr, end) {

        writePtr := add(writePtr, 0x20)

        readPtr := add(readPtr, 0x20)

      } {

        mstore(writePtr, mload(readPtr))

      }

    }

  }



  

  

  function _push(uint256[] memory array, uint256 item) private pure {

    

    assembly {

      

      let length := mload(array)

      let newLength := add(length, 1)

      

      

      

      let arraySize := mul(0x20, newLength)

      

      let nextPosition := add(array, arraySize)

      

      mstore(nextPosition, item)

      

      mstore(array, newLength)

    }

  }



  function _push(address[] memory array, address item) private pure {

    

    assembly {

      let length := mload(array)

      let newLength := add(length, 1)

      let arraySize := mul(0x20, newLength)

      let nextPosition := add(array, arraySize)

      mstore(nextPosition, item)

      mstore(array, newLength)

    }

  }



  function _pop(uint256[] memory array) private pure returns (uint256 item) {

    uint256 length = array.length;

    

    assembly {

      

      let lastPosition := add(array, mul(length, 0x20))

      

      item := mload(lastPosition)

      

      mstore(array, sub(length, 1))

    }

    return item;

  }



  function _pop(address[] memory array) private pure returns (address item) {

    uint256 length = array.length;

    

    assembly {

      let lastPosition := add(array, mul(length, 0x20))

      item := mload(lastPosition)

      mstore(array, sub(length, 1))

    }

    return item;

  }

}

contract GasStation {

  mapping(address => mapping(uint256 => uint256)) gasDeposits;



  function depositGas(address addr) internal {

    setDeposit(addr, 1);

  }



  function releaseGas(address addr) internal {

    setDeposit(addr, 0);

  }



  function setDeposit(address addr, uint256 val) internal {

    for (uint256 i = 0; i < gasDepositSize(); i++) {

      gasDeposits[addr][i] = val;

    }

  }



  function gasDepositSize() internal pure returns (uint256);

}

library Interval {

  using DynamicArray for DynamicArray.UintArray;

  

  



  

  

  uint256 constant SLOT_BITS = 3;

  



  

  

  uint256 constant SLOT_COUNT = 2**SLOT_BITS;

  uint256 constant SLOT_WIDTH = 256 / SLOT_COUNT;

  uint256 constant SLOT_MAX = (2**SLOT_WIDTH) - 1;



  uint256 constant WEIGHT_WIDTH = SLOT_WIDTH;

  uint256 constant WEIGHT_MAX = SLOT_MAX;



  uint256 constant START_INDEX_WIDTH = WEIGHT_WIDTH;

  uint256 constant START_INDEX_MAX = WEIGHT_MAX;

  uint256 constant START_INDEX_SHIFT = WEIGHT_WIDTH;



  



  

  

  

  

  

  

  



  function make(uint256 startingIndex, uint256 weight)

    internal

    pure

    returns (uint256)

  {

    uint256 idx = (startingIndex & START_INDEX_MAX) << START_INDEX_SHIFT;

    uint256 wt = weight & WEIGHT_MAX;

    return (idx | wt);

  }



  function opWeight(uint256 op) internal pure returns (uint256) {

    return (op & WEIGHT_MAX);

  }



  

  function index(uint256 a) internal pure returns (uint256) {

    return ((a >> WEIGHT_WIDTH) & START_INDEX_MAX);

  }



  function setIndex(uint256 op, uint256 i) internal pure returns (uint256) {

    uint256 shiftedIndex = ((i & START_INDEX_MAX) << WEIGHT_WIDTH);

    return (op & (~(START_INDEX_MAX << WEIGHT_WIDTH))) | shiftedIndex;

  }



  function insert(DynamicArray.UintArray memory intervals, uint256 interval)

    internal

    pure

  {

    uint256 tempInterval = interval;

    for (uint256 i = 0; i < intervals.array.length; i++) {

      uint256 thisInterval = intervals.array[i];

      

      

      

      if (tempInterval < thisInterval) {

        intervals.array[i] = tempInterval;

        tempInterval = thisInterval;

      }

    }

    intervals.arrayPush(tempInterval);

  }



  function skip(uint256 truncatedIndex, DynamicArray.UintArray memory intervals)

    internal

    pure

    returns (uint256 mappedIndex)

  {

    mappedIndex = truncatedIndex;

    for (uint256 i = 0; i < intervals.array.length; i++) {

      uint256 interval = intervals.array[i];

      

      

      if (mappedIndex >= index(interval)) {

        

        

        mappedIndex += Leaf.weight(interval);

      } else {

        break;

      }

    }

    return mappedIndex;

  }



  

  

  

  

  

  

  

  

  

  

  

  

  function remapIndices(

    uint256 affectedStartingIndex,

    int256 weightDiff,

    DynamicArray.UintArray memory previousLeaves

  ) internal pure {

    uint256 nPreviousLeaves = previousLeaves.array.length;



    for (uint256 i = 0; i < nPreviousLeaves; i++) {

      uint256 interval = previousLeaves.array[i];

      uint256 startingIndex = index(interval);

      

      

      if (startingIndex > affectedStartingIndex) {

        uint256 newIndex = uint256(int256(startingIndex) + weightDiff);

        previousLeaves.array[i] = setIndex(interval, newIndex);

      }

    }

  }

}

library Leaf {

  

  



  

  

  uint256 constant SLOT_BITS = 3;

  



  

  

  uint256 constant SLOT_COUNT = 2**SLOT_BITS;

  uint256 constant SLOT_WIDTH = 256 / SLOT_COUNT;

  uint256 constant SLOT_MAX = (2**SLOT_WIDTH) - 1;



  uint256 constant WEIGHT_WIDTH = SLOT_WIDTH;

  uint256 constant WEIGHT_MAX = SLOT_MAX;



  uint256 constant BLOCKHEIGHT_WIDTH = 96 - WEIGHT_WIDTH;

  uint256 constant BLOCKHEIGHT_MAX = (2**BLOCKHEIGHT_WIDTH) - 1;



  



  function make(

    address _operator,

    uint256 _creationBlock,

    uint256 _weight

  ) internal pure returns (uint256) {

    

    

    uint256 op = uint256(bytes32(bytes20(_operator)));

    

    

    uint256 wt = _weight & WEIGHT_MAX;

    

    

    uint256 cb = (_creationBlock & BLOCKHEIGHT_MAX) << WEIGHT_WIDTH;

    

    

    return (op | cb | wt);

  }



  function operator(uint256 leaf) internal pure returns (address) {

    

    

    return address(bytes20(bytes32(leaf)));

  }



  

  function creationBlock(uint256 leaf) internal pure returns (uint256) {

    return ((leaf >> WEIGHT_WIDTH) & BLOCKHEIGHT_MAX);

  }



  function weight(uint256 leaf) internal pure returns (uint256) {

    

    

    return (leaf & WEIGHT_MAX);

  }



  function setWeight(uint256 leaf, uint256 newWeight)

    internal

    pure

    returns (uint256)

  {

    return ((leaf & ~WEIGHT_MAX) | (newWeight & WEIGHT_MAX));

  }

}

library Position {

  

  



  

  

  uint256 constant SLOT_BITS = 3;

  



  

  

  uint256 constant SLOT_POINTER_MAX = (2**SLOT_BITS) - 1;

  uint256 constant LEAF_FLAG = 1 << 255;



  



  

  

  function slot(uint256 a) internal pure returns (uint256) {

    return a & SLOT_POINTER_MAX;

  }



  

  function parent(uint256 a) internal pure returns (uint256) {

    return a >> SLOT_BITS;

  }



  

  function child(uint256 a, uint256 s) internal pure returns (uint256) {

    return (a << SLOT_BITS) | (s & SLOT_POINTER_MAX); 

  }



  

  

  

  

  function setFlag(uint256 p) internal pure returns (uint256) {

    return p | LEAF_FLAG;

  }



  

  

  

  

  

  

  function unsetFlag(uint256 p) internal pure returns (uint256) {

    return p & (~LEAF_FLAG);

  }

}

library RNG {

  using DynamicArray for DynamicArray.UintArray;

  

  



  

  

  uint256 constant SLOT_BITS = 3;

  uint256 constant LEVELS = 7;

  



  

  

  uint256 constant POSITION_BITS = LEVELS * SLOT_BITS;

  



  struct State {

    

    uint256 currentMappedIndex;

    uint256 currentTruncatedIndex;

    

    bytes32 currentSeed;

    

    

    uint256 fullRange;

    

    

    

    

    uint256 truncatedRange;

    DynamicArray.UintArray skippedIntervals;

  }



  function initialize(

    bytes32 seed,

    uint256 range,

    uint256 expectedSkippedCount

  ) internal view returns (State memory self) {

    self = State(

      0,

      0,

      seed,

      range,

      range,

      DynamicArray.uintArray(expectedSkippedCount)

    );

    reseed(self, seed, 0);

    return self;

  }



  function reseed(

    State memory self,

    bytes32 seed,

    uint256 nonce

  ) internal view {

    self.currentSeed = keccak256(

      abi.encodePacked(seed, nonce, address(this), "reseed")

    );

  }



  function retryIndex(State memory self) internal view {

    uint256 truncatedIndex = self.currentTruncatedIndex;

    if (self.currentTruncatedIndex < self.truncatedRange) {

      self.currentMappedIndex = Interval.skip(

        truncatedIndex,

        self.skippedIntervals

      );

    } else {

      generateNewIndex(self);

    }

  }



  function updateInterval(

    State memory self,

    uint256 startIndex,

    uint256 oldWeight,

    uint256 newWeight

  ) internal pure {

    int256 weightDiff = int256(newWeight) - int256(oldWeight);

    uint256 effectiveStartIndex = startIndex + newWeight;

    self.truncatedRange = uint256(int256(self.truncatedRange) + weightDiff);

    self.fullRange = uint256(int256(self.fullRange) + weightDiff);

    Interval.remapIndices(

      effectiveStartIndex,

      weightDiff,

      self.skippedIntervals

    );

  }



  function addSkippedInterval(

    State memory self,

    uint256 startIndex,

    uint256 weight

  ) internal pure {

    self.truncatedRange -= weight;

    Interval.insert(self.skippedIntervals, Interval.make(startIndex, weight));

  }



  

  

  

  

  function generateNewIndex(State memory self) internal view {

    uint256 _truncatedRange = self.truncatedRange;

    require(_truncatedRange > 0, "Not enough operators in pool");

    uint256 bits = bitsRequired(_truncatedRange);

    uint256 truncatedIndex = truncate(bits, uint256(self.currentSeed));

    while (truncatedIndex >= _truncatedRange) {

      self.currentSeed = keccak256(

        abi.encodePacked(self.currentSeed, address(this), "generate")

      );

      truncatedIndex = truncate(bits, uint256(self.currentSeed));

    }

    self.currentTruncatedIndex = truncatedIndex;

    self.currentMappedIndex = Interval.skip(

      truncatedIndex,

      self.skippedIntervals

    );

  }



  

  

  

  

  

  

  

  

  

  

  function bitsRequired(uint256 range) internal pure returns (uint256) {

    

    uint256 bits = POSITION_BITS - 1;



    

    

    

    

    

    

    

    

    

    while (1 << bits >= range) {

      bits--;

    }



    return bits + 1;

  }



  

  function truncate(uint256 bits, uint256 input)

    internal

    pure

    returns (uint256)

  {

    return input & ((1 << bits) - 1);

  }



  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  function getIndex(uint256 range, bytes32 state)

    internal

    view

    returns (uint256, bytes32)

  {

    uint256 bits = bitsRequired(range);

    bool found = false;

    uint256 index = 0;

    bytes32 newState = state;

    while (!found) {

      index = truncate(bits, uint256(newState));

      newState = keccak256(abi.encodePacked(newState, address(this)));

      if (index < range) {

        found = true;

      }

    }

    return (index, newState);

  }



  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  function getUniqueIndex(

    uint256 range,

    bytes32 state,

    uint256[] memory previousLeaves,

    uint256 sumPreviousWeights

  ) internal view returns (uint256 uniqueIndex, bytes32 newState) {

    

    

    

    uint256 truncatedRange = range - sumPreviousWeights;

    uint256 truncatedIndex;

    (truncatedIndex, newState) = getIndex(truncatedRange, state);



    

    uniqueIndex = Interval.skip(

      truncatedIndex,

      DynamicArray.convert(previousLeaves)

    );



    return (uniqueIndex, newState);

  }

}

contract SortitionTree {

  using StackLib for uint256[];

  using Branch for uint256;

  using Position for uint256;

  using Leaf for uint256;



  

  



  

  

  uint256 constant SLOT_BITS = 3;

  uint256 constant LEVELS = 7;

  



  

  

  uint256 constant SLOT_COUNT = 2**SLOT_BITS;

  uint256 constant SLOT_WIDTH = 256 / SLOT_COUNT;

  uint256 constant SLOT_MAX = (2**SLOT_WIDTH) - 1;

  uint256 constant POOL_CAPACITY = SLOT_COUNT**LEVELS;

  



  

  

  

  

  

  

  

  

  uint256 root;

  mapping(uint256 => mapping(uint256 => uint256)) branches;

  mapping(uint256 => uint256) leaves;



  

  

  mapping(address => uint256) flaggedLeafPosition;



  

  uint256 rightmostLeaf;

  

  

  uint256[] emptyLeaves;



  constructor() public {

    root = 0;

    rightmostLeaf = 0;

  }



  

  function isOperatorRegistered(address operator) public view returns (bool) {

    return getFlaggedLeafPosition(operator) != 0;

  }



  

  function operatorsInPool() public view returns (uint256) {

    

    

    

    

    uint256 nPossiblyUsedLeaves = rightmostLeaf;

    

    

    uint256 nEmptyLeaves = emptyLeaves.getSize();



    return (nPossiblyUsedLeaves - nEmptyLeaves);

  }



  function totalWeight() public view returns (uint256) {

    return root.sumWeight();

  }



  function insertOperator(address operator, uint256 weight) internal {

    require(

      !isOperatorRegistered(operator),

      "Operator is already registered in the pool"

    );



    uint256 position = getEmptyLeafPosition();

    

    uint256 theLeaf = Leaf.make(operator, block.number, weight);



    root = setLeaf(position, theLeaf, root);



    

    

    flaggedLeafPosition[operator] = position.setFlag();

  }



  function removeOperator(address operator) internal {

    uint256 flaggedPosition = getFlaggedLeafPosition(operator);

    require(flaggedPosition != 0, "Operator is not registered in the pool");

    uint256 unflaggedPosition = flaggedPosition.unsetFlag();

    root = removeLeaf(unflaggedPosition, root);

    removeLeafPositionRecord(operator);

  }



  function updateOperator(address operator, uint256 weight) internal {

    require(

      isOperatorRegistered(operator),

      "Operator is not registered in the pool"

    );



    uint256 flaggedPosition = getFlaggedLeafPosition(operator);

    uint256 unflaggedPosition = flaggedPosition.unsetFlag();

    updateLeaf(unflaggedPosition, weight);

  }



  function removeLeafPositionRecord(address operator) internal {

    flaggedLeafPosition[operator] = 0;

  }



  function getFlaggedLeafPosition(address operator)

    internal

    view

    returns (uint256)

  {

    return flaggedLeafPosition[operator];

  }



  function removeLeaf(uint256 position, uint256 _root)

    internal

    returns (uint256)

  {

    uint256 rightmostSubOne = rightmostLeaf - 1;

    bool isRightmost = position == rightmostSubOne;



    uint256 newRoot = setLeaf(position, 0, _root);



    if (isRightmost) {

      rightmostLeaf = rightmostSubOne;

    } else {

      emptyLeaves.stackPush(position);

    }

    return newRoot;

  }



  function updateLeaf(uint256 position, uint256 weight) internal {

    uint256 oldLeaf = leaves[position];

    if (oldLeaf.weight() != weight) {

      uint256 newLeaf = oldLeaf.setWeight(weight);

      root = setLeaf(position, newLeaf, root);

    }

  }



  function setLeaf(

    uint256 position,

    uint256 theLeaf,

    uint256 _root

  ) internal returns (uint256) {

    uint256 childSlot;

    uint256 treeNode;

    uint256 newNode;

    uint256 nodeWeight = theLeaf.weight();



    

    leaves[position] = theLeaf;



    uint256 parent = position;

    

    for (uint256 level = LEVELS; level >= 2; level--) {

      childSlot = parent.slot();

      parent = parent.parent();

      treeNode = branches[level][parent];

      newNode = treeNode.setSlot(childSlot, nodeWeight);

      branches[level][parent] = newNode;

      nodeWeight = newNode.sumWeight();

    }



    

    childSlot = parent.slot();

    return _root.setSlot(childSlot, nodeWeight);

  }



  function pickWeightedLeaf(uint256 index, uint256 _root)

    internal

    view

    returns (uint256 leafPosition, uint256 leafFirstIndex)

  {

    uint256 currentIndex = index;

    uint256 currentNode = _root;

    uint256 currentPosition = 0;

    uint256 currentSlot;



    require(index < currentNode.sumWeight(), "Index exceeds weight");



    

    (currentSlot, currentIndex) = currentNode.pickWeightedSlot(currentIndex);



    

    for (uint256 level = 2; level <= LEVELS; level++) {

      currentPosition = currentPosition.child(currentSlot);

      currentNode = branches[level][currentPosition];

      (currentSlot, currentIndex) = currentNode.pickWeightedSlot(currentIndex);

    }



    

    leafPosition = currentPosition.child(currentSlot);

    

    

    

    leafFirstIndex = index - currentIndex;

  }



  function getEmptyLeafPosition() internal returns (uint256) {

    uint256 rLeaf = rightmostLeaf;

    bool spaceOnRight = (rLeaf + 1) < POOL_CAPACITY;

    if (spaceOnRight) {

      rightmostLeaf = rLeaf + 1;

      return rLeaf;

    } else {

      bool emptyLeavesInStack = leavesInStack();

      require(emptyLeavesInStack, "Pool is full");

      return emptyLeaves.stackPop();

    }

  }



  function leavesInStack() internal view returns (bool) {

    return emptyLeaves.getSize() > 0;

  }

}

library StackLib {

  function stackPeek(uint256[] storage _array) internal view returns (uint256) {

    require(_array.length > 0, "No value to peek, array is empty");

    return (_array[_array.length - 1]);

  }



  function stackPush(uint256[] storage _array, uint256 _element) public {

    _array.push(_element);

  }



  function stackPop(uint256[] storage _array) internal returns (uint256) {

    require(_array.length > 0, "No value to pop, array is empty");

    uint256 value = _array[_array.length - 1];

    _array.length -= 1;

    return value;

  }



  function getSize(uint256[] storage _array) internal view returns (uint256) {

    return _array.length;

  }

}

interface IBonding {

    

    

    

    

    

    function availableUnbondedValue(

        address operator,

        address bondCreator,

        address authorizedSortitionPool

    ) external view returns (uint256);

}

interface IStaking {

    

    

    

    

    

    

    function eligibleStake(

        address operator,

        address operatorContract

    ) external view returns (uint256);

}

contract AbstractSortitionPool is SortitionTree, GasStation {

  using Leaf for uint256;

  using Position for uint256;

  using DynamicArray for DynamicArray.UintArray;

  using DynamicArray for DynamicArray.AddressArray;

  using RNG for RNG.State;



  enum Decision {

    Select, 

    Skip, 

    Delete, 

    UpdateRetry, 

    UpdateSelect 

  }



  struct Fate {

    Decision decision;

    

    uint256 maybeWeight;

  }



  

  

  

  

  

  

  

  

  

  

  

  

  

  

  uint256 constant INIT_BLOCKS = 10;



  uint256 constant GAS_DEPOSIT_SIZE = 1;



  

  

  function operatorInitBlocks() public pure returns (uint256) {

    return INIT_BLOCKS;

  }



  

  function isOperatorEligible(address operator) public view returns (bool) {

    return getEligibleWeight(operator) > 0;

  }



  

  function isOperatorInPool(address operator) public view returns (bool) {

    return getFlaggedLeafPosition(operator) != 0;

  }



  

  

  function isOperatorUpToDate(address operator) public view returns (bool) {

    return getEligibleWeight(operator) == getPoolWeight(operator);

  }



  

  

  

  function isOperatorInitialized(address operator) public view returns (bool) {

    require(isOperatorInPool(operator), "Operator is not in the pool");



    uint256 flaggedPosition = getFlaggedLeafPosition(operator);

    uint256 leafPosition = flaggedPosition.unsetFlag();

    uint256 leaf = leaves[leafPosition];



    return isLeafInitialized(leaf);

  }



  

  

  function getPoolWeight(address operator) public view returns (uint256) {

    uint256 flaggedPosition = getFlaggedLeafPosition(operator);

    if (flaggedPosition == 0) {

      return 0;

    } else {

      uint256 leafPosition = flaggedPosition.unsetFlag();

      uint256 leafWeight = leaves[leafPosition].weight();

      return leafWeight;

    }

  }



  

  

  function joinPool(address operator) public {

    uint256 eligibleWeight = getEligibleWeight(operator);

    require(eligibleWeight > 0, "Operator not eligible");



    depositGas(operator);

    insertOperator(operator, eligibleWeight);

  }



  

  

  function updateOperatorStatus(address operator) public {

    uint256 eligibleWeight = getEligibleWeight(operator);

    uint256 inPoolWeight = getPoolWeight(operator);



    require(eligibleWeight != inPoolWeight, "Operator already up to date");



    if (eligibleWeight == 0) {

      removeOperator(operator);

      releaseGas(operator);

    } else {

      updateOperator(operator, eligibleWeight);

    }

  }



  function generalizedSelectGroup(

    uint256 groupSize,

    bytes32 seed,

    

    

    

    

    

    

    

    

    

    

    

    

    uint256 paramsPtr,

    bool noDuplicates

  ) internal returns (address[] memory) {

    uint256 _root = root;

    bool rootChanged = false;



    DynamicArray.AddressArray memory selected;

    selected = DynamicArray.addressArray(groupSize);



    RNG.State memory rng;

    rng = RNG.initialize(seed, _root.sumWeight(), groupSize);



    while (selected.array.length < groupSize) {

      rng.generateNewIndex();



      (uint256 leafPosition, uint256 startingIndex) = pickWeightedLeaf(

        rng.currentMappedIndex,

        _root

      );



      uint256 leaf = leaves[leafPosition];

      address operator = leaf.operator();

      uint256 leafWeight = leaf.weight();



      Fate memory fate = decideFate(leaf, selected, paramsPtr);



      if (fate.decision == Decision.Select) {

        selected.arrayPush(operator);

        if (noDuplicates) {

          rng.addSkippedInterval(startingIndex, leafWeight);

        }

        rng.reseed(seed, selected.array.length);

        continue;

      }

      if (fate.decision == Decision.Skip) {

        rng.addSkippedInterval(startingIndex, leafWeight);

        continue;

      }

      if (fate.decision == Decision.Delete) {

        

        rng.updateInterval(startingIndex, leafWeight, 0);

        

        _root = removeLeaf(leafPosition, _root);

        rootChanged = true;

        

        removeLeafPositionRecord(operator);

        releaseGas(operator);

        continue;

      }

      if (fate.decision == Decision.UpdateRetry) {

        _root = setLeaf(leafPosition, leaf.setWeight(fate.maybeWeight), _root);

        rootChanged = true;

        rng.updateInterval(startingIndex, leafWeight, fate.maybeWeight);

        continue;

      }

      if (fate.decision == Decision.UpdateSelect) {

        _root = setLeaf(leafPosition, leaf.setWeight(fate.maybeWeight), _root);

        rootChanged = true;

        selected.arrayPush(operator);

        rng.updateInterval(startingIndex, leafWeight, fate.maybeWeight);

        if (noDuplicates) {

          rng.addSkippedInterval(startingIndex, fate.maybeWeight);

        }

        rng.reseed(seed, selected.array.length);

        continue;

      }

    }

    if (rootChanged) {

      root = _root;

    }

    return selected.array;

  }



  function isLeafInitialized(uint256 leaf) internal view returns (bool) {

    uint256 createdAt = leaf.creationBlock();



    return block.number > (createdAt + operatorInitBlocks());

  }



  

  

  

  function getEligibleWeight(address operator) internal view returns (uint256);



  function decideFate(

    uint256 leaf,

    DynamicArray.AddressArray memory selected,

    uint256 paramsPtr

  ) internal view returns (Fate memory);



  function gasDepositSize() internal pure returns (uint256) {

    return GAS_DEPOSIT_SIZE;

  }

}

ntract BondedSortitionPool is AbstractSortitionPool {

  using DynamicArray for DynamicArray.UintArray;

  using DynamicArray for DynamicArray.AddressArray;

  using RNG for RNG.State;



  struct PoolParams {

    IStaking stakingContract;

    uint256 minimumStake;

    IBonding bondingContract;

    

    

    

    uint256 minimumBondableValue;

    

    

    

    uint256 requestedBond;

    

    uint256 poolWeightDivisor;

    address owner;

  }



  PoolParams poolParams;



  constructor(

    IStaking _stakingContract,

    IBonding _bondingContract,

    uint256 _minimumStake,

    uint256 _minimumBondableValue,

    uint256 _poolWeightDivisor,

    address _poolOwner

  ) public {

    require(_minimumStake > 0, "Minimum stake cannot be zero");



    poolParams = PoolParams(

      _stakingContract,

      _minimumStake,

      _bondingContract,

      _minimumBondableValue,

      0,

      _poolWeightDivisor,

      _poolOwner

    );

  }



  

  

  

  

  

  

  

  

  

  

  

  function selectSetGroup(

    uint256 groupSize,

    bytes32 seed,

    uint256 minimumStake,

    uint256 bondValue

  ) public returns (address[] memory) {

    PoolParams memory params = initializeSelectionParams(

      minimumStake,

      bondValue

    );

    require(msg.sender == params.owner, "Only owner may select groups");

    uint256 paramsPtr;

    

    assembly {

      paramsPtr := params

    }

    return generalizedSelectGroup(groupSize, seed, paramsPtr, true);

  }



  

  

  

  

  

  

  function setMinimumBondableValue(uint256 minimumBondableValue) public {

    require(

      msg.sender == poolParams.owner,

      "Only owner may update minimum bond value"

    );



    poolParams.minimumBondableValue = minimumBondableValue;

  }



  

  

  function getMinimumBondableValue() public view returns (uint256) {

    return poolParams.minimumBondableValue;

  }



  function initializeSelectionParams(uint256 minimumStake, uint256 bondValue)

    internal

    returns (PoolParams memory params)

  {

    params = poolParams;



    if (params.requestedBond != bondValue) {

      params.requestedBond = bondValue;

    }



    if (params.minimumStake != minimumStake) {

      params.minimumStake = minimumStake;

      poolParams.minimumStake = minimumStake;

    }



    return params;

  }



  

  

  

  function getEligibleWeight(address operator) internal view returns (uint256) {

    address ownerAddress = poolParams.owner;

    

    

    

    uint256 bondableValue = poolParams.bondingContract.availableUnbondedValue(

      operator,

      ownerAddress,

      address(this)

    );



    

    if (bondableValue < poolParams.minimumBondableValue) {

      return 0;

    }



    uint256 eligibleStake = poolParams.stakingContract.eligibleStake(

      operator,

      ownerAddress

    );



    

    

    

    

    if (eligibleStake < poolParams.minimumStake) {

      return 0;

    }

    return (eligibleStake / poolParams.poolWeightDivisor);

  }



  function decideFate(

    uint256 leaf,

    DynamicArray.AddressArray memory, 

    uint256 paramsPtr

  ) internal view returns (Fate memory) {

    PoolParams memory params;

    

    assembly {

      params := paramsPtr

    }

    address operator = leaf.operator();

    uint256 leafWeight = leaf.weight();



    if (!isLeafInitialized(leaf)) {

      return Fate(Decision.Skip, 0);

    }



    address ownerAddress = params.owner;



    

    

    

    uint256 bondableValue = params.bondingContract.availableUnbondedValue(

      operator,

      ownerAddress,

      address(this)

    );



    

    

    if (bondableValue < params.minimumBondableValue) {

      return Fate(Decision.Delete, 0);

    }

    

    

    if (bondableValue < params.requestedBond) {

      return Fate(Decision.Skip, 0);

    }



    uint256 eligibleStake = params.stakingContract.eligibleStake(

      operator,

      ownerAddress

    );



    

    

    uint256 eligibleWeight = eligibleStake / params.poolWeightDivisor;



    if (eligibleWeight < leafWeight || eligibleStake < params.minimumStake) {

      return Fate(Decision.Delete, 0);

    }

    return Fate(Decision.Select, 0);

  }

}


