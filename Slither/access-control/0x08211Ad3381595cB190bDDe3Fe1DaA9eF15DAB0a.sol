


pragma solidity 0.6.11;


interface IERC20 {
    
    function totalSupply() external view returns (uint);

    
    function balanceOf(address account) external view returns (uint);

    
    function transfer(address recipient, uint amount) external returns (bool);

    
    function allowance(address owner, address spender) external view returns (uint);

    
    function approve(address spender, uint amount) external returns (bool);

    
    function transferFrom(
        address sender,
        address recipient,
        uint amount
    ) external returns (bool);

    
    event Transfer(address indexed from, address indexed to, uint value);

    
    event Approval(address indexed owner, address indexed spender, uint value);
}




library SafeMath {
    
    function add(uint a, uint b) internal pure returns (uint) {
        uint c = a + b;
        require(c >= a, "SafeMath: addition overflow");

        return c;
    }

    
    function sub(uint a, uint b) internal pure returns (uint) {
        return sub(a, b, "SafeMath: subtraction overflow");
    }

    
    function sub(
        uint a,
        uint b,
        string memory errorMessage
    ) internal pure returns (uint) {
        require(b <= a, errorMessage);
        uint c = a - b;

        return c;
    }

    
    function mul(uint a, uint b) internal pure returns (uint) {
        
        
        
        if (a == 0) {
            return 0;
        }

        uint c = a * b;
        require(c / a == b, "SafeMath: multiplication overflow");

        return c;
    }

    
    function div(uint a, uint b) internal pure returns (uint) {
        return div(a, b, "SafeMath: division by zero");
    }

    
    function div(
        uint a,
        uint b,
        string memory errorMessage
    ) internal pure returns (uint) {
        require(b > 0, errorMessage);
        uint c = a / b;
        

        return c;
    }

    
    function mod(uint a, uint b) internal pure returns (uint) {
        return mod(a, b, "SafeMath: modulo by zero");
    }

    
    function mod(
        uint a,
        uint b,
        string memory errorMessage
    ) internal pure returns (uint) {
        require(b != 0, errorMessage);
        return a % b;
    }
}




library Address {
    
    function isContract(address account) internal view returns (bool) {
        
        
        

        uint size;
        
        assembly {
            size := extcodesize(account)
        }
        return size > 0;
    }

    
    function sendValue(address payable recipient, uint amount) internal {
        require(address(this).balance >= amount, "Address: insufficient balance");

        
        (bool success, ) = recipient.call{value: amount}("");
        require(success, "Address: unable to send value, recipient may have reverted");
    }

    
    function functionCall(address target, bytes memory data)
        internal
        returns (bytes memory)
    {
        return functionCall(target, data, "Address: low-level call failed");
    }

    
    function functionCall(
        address target,
        bytes memory data,
        string memory errorMessage
    ) internal returns (bytes memory) {
        return functionCallWithValue(target, data, 0, errorMessage);
    }

    
    function functionCallWithValue(
        address target,
        bytes memory data,
        uint value
    ) internal returns (bytes memory) {
        return
            functionCallWithValue(
                target,
                data,
                value,
                "Address: low-level call with value failed"
            );
    }

    
    function functionCallWithValue(
        address target,
        bytes memory data,
        uint value,
        string memory errorMessage
    ) internal returns (bytes memory) {
        require(
            address(this).balance >= value,
            "Address: insufficient balance for call"
        );
        require(isContract(target), "Address: call to non-contract");

        
        (bool success, bytes memory returndata) = target.call{value: value}(data);
        return _verifyCallResult(success, returndata, errorMessage);
    }

    
    function functionStaticCall(address target, bytes memory data)
        internal
        view
        returns (bytes memory)
    {
        return
            functionStaticCall(target, data, "Address: low-level static call failed");
    }

    
    function functionStaticCall(
        address target,
        bytes memory data,
        string memory errorMessage
    ) internal view returns (bytes memory) {
        require(isContract(target), "Address: static call to non-contract");

        
        (bool success, bytes memory returndata) = target.staticcall(data);
        return _verifyCallResult(success, returndata, errorMessage);
    }

    function _verifyCallResult(
        bool success,
        bytes memory returndata,
        string memory errorMessage
    ) private pure returns (bytes memory) {
        if (success) {
            return returndata;
        } else {
            
            if (returndata.length > 0) {
                

                
                assembly {
                    let returndata_size := mload(returndata)
                    revert(add(32, returndata), returndata_size)
                }
            } else {
                revert(errorMessage);
            }
        }
    }
}




library SafeERC20 {
    using SafeMath for uint;
    using Address for address;

    function safeTransfer(
        IERC20 token,
        address to,
        uint value
    ) internal {
        _callOptionalReturn(
            token,
            abi.encodeWithSelector(token.transfer.selector, to, value)
        );
    }

    function safeTransferFrom(
        IERC20 token,
        address from,
        address to,
        uint value
    ) internal {
        _callOptionalReturn(
            token,
            abi.encodeWithSelector(token.transferFrom.selector, from, to, value)
        );
    }

    
    function safeApprove(
        IERC20 token,
        address spender,
        uint value
    ) internal {
        
        
        
        
        require(
            (value == 0) || (token.allowance(address(this), spender) == 0),
            "SafeERC20: approve from non-zero to non-zero allowance"
        );
        _callOptionalReturn(
            token,
            abi.encodeWithSelector(token.approve.selector, spender, value)
        );
    }

    function safeIncreaseAllowance(
        IERC20 token,
        address spender,
        uint value
    ) internal {
        uint newAllowance = token.allowance(address(this), spender).add(value);
        _callOptionalReturn(
            token,
            abi.encodeWithSelector(token.approve.selector, spender, newAllowance)
        );
    }

    function safeDecreaseAllowance(
        IERC20 token,
        address spender,
        uint value
    ) internal {
        uint newAllowance =
            token.allowance(address(this), spender).sub(
                value,
                "SafeERC20: decreased allowance below zero"
            );
        _callOptionalReturn(
            token,
            abi.encodeWithSelector(token.approve.selector, spender, newAllowance)
        );
    }

    
    function _callOptionalReturn(IERC20 token, bytes memory data) private {
        
        
        

        bytes memory returndata =
            address(token).functionCall(data, "SafeERC20: low-level call failed");
        if (returndata.length > 0) {
            
            
            require(
                abi.decode(returndata, (bool)),
                "SafeERC20: ERC20 operation did not succeed"
            );
        }
    }
}





interface IStrategy {
    function admin() external view returns (address);

    function controller() external view returns (address);

    function vault() external view returns (address);

    
    function underlying() external view returns (address);

    
    function totalDebt() external view returns (uint);

    function performanceFee() external view returns (uint);

    function slippage() external view returns (uint);

    
    function delta() external view returns (uint);

    function setAdmin(address _admin) external;

    function setController(address _controller) external;

    function setPerformanceFee(uint _fee) external;

    function setSlippage(uint _slippage) external;

    function setDelta(uint _delta) external;

    
    function totalAssets() external view returns (uint);

    
    function withdraw(uint _amount) external;

    
    function withdrawAll() external;

    
    function harvest() external;

    
    function skim() external;

    
    function exit() external;

    
    function sweep(address _token) external;
}



interface IStrategyETH is IStrategy {
    
    function deposit() external payable;
}



interface IController {
    function ADMIN_ROLE() external view returns (bytes32);

    function HARVESTER_ROLE() external view returns (bytes32);

    function admin() external view returns (address);

    function treasury() external view returns (address);

    function setAdmin(address _admin) external;

    function setTreasury(address _treasury) external;

    function grantRole(bytes32 _role, address _addr) external;

    function revokeRole(bytes32 _role, address _addr) external;

    
    function setStrategy(
        address _vault,
        address _strategy,
        uint _min
    ) external;

    
    
    function invest(address _vault) external;

    function harvest(address _strategy) external;

    function skim(address _strategy) external;

    
    function withdraw(
        address _strategy,
        uint _amount,
        uint _min
    ) external;

    
    function withdrawAll(address _strategy, uint _min) external;

    
    function exit(address _strategy, uint _min) external;
}







abstract contract StrategyETH is IStrategyETH {
    using SafeERC20 for IERC20;
    using SafeMath for uint;

    address public override admin;
    address public override controller;
    address public immutable override vault;
    
    address public constant override underlying =
        0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;

    
    uint public override totalDebt;

    
    uint public override performanceFee = 500;
    uint private constant PERFORMANCE_FEE_CAP = 2000; 
    uint internal constant PERFORMANCE_FEE_MAX = 10000;

    
    uint public override slippage = 100;
    uint internal constant SLIPPAGE_MAX = 10000;

    
    uint public override delta = 10050;
    uint private constant DELTA_MIN = 10000;

    constructor(address _controller, address _vault) public {
        require(_controller != address(0), "controller = zero address");
        require(_vault != address(0), "vault = zero address");

        admin = msg.sender;
        controller = _controller;
        vault = _vault;
    }

    

    modifier onlyAdmin() {
        require(msg.sender == admin, "!admin");
        _;
    }

    modifier onlyAuthorized() {
        require(
            msg.sender == admin || msg.sender == controller || msg.sender == vault,
            "!authorized"
        );
        _;
    }

    function setAdmin(address _admin) external override onlyAdmin {
        require(_admin != address(0), "admin = zero address");
        admin = _admin;
    }

    function setController(address _controller) external override onlyAdmin {
        require(_controller != address(0), "controller = zero address");
        controller = _controller;
    }

    function setPerformanceFee(uint _fee) external override onlyAdmin {
        require(_fee <= PERFORMANCE_FEE_CAP, "performance fee > cap");
        performanceFee = _fee;
    }

    function setSlippage(uint _slippage) external override onlyAdmin {
        require(_slippage <= SLIPPAGE_MAX, "slippage > max");
        slippage = _slippage;
    }

    function setDelta(uint _delta) external override onlyAdmin {
        require(_delta >= DELTA_MIN, "delta < min");
        delta = _delta;
    }

    function _sendEthToVault(uint _amount) internal {
        require(address(this).balance >= _amount, "ETH balance < amount");

        (bool sent, ) = vault.call{value: _amount}("");
        require(sent, "Send ETH failed");
    }

    function _increaseDebt(uint _ethAmount) private {
        totalDebt = totalDebt.add(_ethAmount);
    }

    function _decreaseDebt(uint _ethAmount) private {
        _sendEthToVault(_ethAmount);

        if (_ethAmount > totalDebt) {
            totalDebt = 0;
        } else {
            totalDebt -= _ethAmount;
        }
    }

    function _totalAssets() internal view virtual returns (uint);

    
    function totalAssets() external view override returns (uint) {
        return _totalAssets();
    }

    function _deposit() internal virtual;

    
    function deposit() external payable override onlyAuthorized {
        require(msg.value > 0, "deposit = 0");

        _increaseDebt(msg.value);
        _deposit();
    }

    
    function _getTotalShares() internal view virtual returns (uint);

    function _getShares(uint _ethAmount, uint _totalEth) internal view returns (uint) {
        
        if (_totalEth > 0) {
            uint totalShares = _getTotalShares();
            return _ethAmount.mul(totalShares) / _totalEth;
        }
        return 0;
    }

    function _withdraw(uint _shares) internal virtual;

    
    function withdraw(uint _ethAmount) external override onlyAuthorized {
        require(_ethAmount > 0, "withdraw = 0");
        uint totalEth = _totalAssets();
        require(_ethAmount <= totalEth, "withdraw > total");

        uint shares = _getShares(_ethAmount, totalEth);
        if (shares > 0) {
            _withdraw(shares);
        }

        
        uint ethBal = address(this).balance;
        if (ethBal > 0) {
            _decreaseDebt(ethBal);
        }
    }

    function _withdrawAll() internal {
        uint totalShares = _getTotalShares();
        if (totalShares > 0) {
            _withdraw(totalShares);
        }

        
        uint ethBal = address(this).balance;
        if (ethBal > 0) {
            _decreaseDebt(ethBal);
            totalDebt = 0;
        }
    }

    
    function withdrawAll() external override onlyAuthorized {
        _withdrawAll();
    }

    
    function harvest() external virtual override;

    
    function skim() external override onlyAuthorized {
        uint totalEth = _totalAssets();
        require(totalEth > totalDebt, "total ETH < debt");

        uint profit = totalEth - totalDebt;

        
        uint max = totalDebt.mul(delta) / DELTA_MIN;
        if (totalEth <= max) {
            

            
            totalDebt = totalDebt.add(profit);
        } else {
            
            uint shares = _getShares(profit, totalEth);
            if (shares > 0) {
                uint balBefore = address(this).balance;
                _withdraw(shares);
                uint balAfter = address(this).balance;

                uint diff = balAfter.sub(balBefore);
                if (diff > 0) {
                    _sendEthToVault(diff);
                }
            }
        }
    }

    function exit() external virtual override;

    function sweep(address) external virtual override;
}



interface Uniswap {
    function swapExactTokensForTokens(
        uint amountIn,
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external returns (uint[] memory amounts);

    function swapExactTokensForETH(
        uint amountIn,
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external returns (uint[] memory amounts);
}



interface LiquidityGaugeV2 {
    function deposit(uint) external;

    function balanceOf(address) external view returns (uint);

    function withdraw(uint) external;

    function claim_rewards() external;
}




interface Minter {
    function mint(address) external;
}



interface StableSwapSTETH {
    function get_virtual_price() external view returns (uint);

    
    function balances(uint _index) external view returns (uint);

    function add_liquidity(uint[2] memory amounts, uint min) external payable;

    function remove_liquidity_one_coin(
        uint _token_amount,
        int128 i,
        uint min_amount
    ) external;

    function get_dy(
        int128 i,
        int128 j,
        uint dx
    ) external view returns (uint);
}



interface StETH {
    function submit(address) external payable returns (uint);
}



contract StrategyStEth is StrategyETH {
    
    address private constant UNISWAP = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;
    address private constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;

    
    
    address private constant LP = 0x06325440D014e39736583c165C2963BA99fAf14E;
    
    address private constant POOL = 0xDC24316b9AE028F1497c275EB9192a3Ea0f67022;
    
    address private constant GAUGE = 0x182B723a58739a9c974cFDB385ceaDb237453c28;
    
    address private constant MINTER = 0xd061D61a4d941c39E5453435B6345Dc261C2fcE0;
    
    address private constant CRV = 0xD533a949740bb3306d119CC777fa900bA034cd52;

    
    address private constant ST_ETH = 0xae7ab96520DE3A18E5e111B5EaAb095312D7fE84;
    address private constant LDO = 0x5A98FcBEA516Cf06857215779Fd812CA3beF1B32;

    constructor(address _controller, address _vault)
        public
        StrategyETH(_controller, _vault)
    {
        
        
        IERC20(LDO).safeApprove(UNISWAP, uint(-1));
        IERC20(CRV).safeApprove(UNISWAP, uint(-1));
    }

    receive() external payable {
        
        require(msg.sender != vault, "msg.sender == vault");
    }

    function _totalAssets() internal view override returns (uint) {
        uint shares = LiquidityGaugeV2(GAUGE).balanceOf(address(this));
        uint pricePerShare = StableSwapSTETH(POOL).get_virtual_price();

        return shares.mul(pricePerShare) / 1e18;
    }

    
    function _deposit() internal override {
        uint bal = address(this).balance;
        if (bal > 0) {
            uint half = bal / 2;
            if (half > 0) {
                uint dy = StableSwapSTETH(POOL).get_dy(0, 1, half);
                
                if (dy < half) {
                    StETH(ST_ETH).submit{value: half}(address(this));
                }
            }

            uint ethBal = address(this).balance;
            uint stEthBal = IERC20(ST_ETH).balanceOf(address(this));

            if (stEthBal > 0) {
                
                IERC20(ST_ETH).safeApprove(POOL, stEthBal);
            }

            
            uint pricePerShare = StableSwapSTETH(POOL).get_virtual_price();
            uint shares = bal.mul(1e18).div(pricePerShare);
            uint min = shares.mul(SLIPPAGE_MAX - slippage) / SLIPPAGE_MAX;

            StableSwapSTETH(POOL).add_liquidity{value: ethBal}([ethBal, stEthBal], min);
        }

        
        uint lpBal = IERC20(LP).balanceOf(address(this));
        if (lpBal > 0) {
            IERC20(LP).safeApprove(GAUGE, lpBal);
            LiquidityGaugeV2(GAUGE).deposit(lpBal);
        }
    }

    function _getTotalShares() internal view override returns (uint) {
        return LiquidityGaugeV2(GAUGE).balanceOf(address(this));
    }

    function _withdraw(uint _lpAmount) internal override {
        
        LiquidityGaugeV2(GAUGE).withdraw(_lpAmount);

        uint lpBal = IERC20(LP).balanceOf(address(this));
        
        uint pricePerShare = StableSwapSTETH(POOL).get_virtual_price();
        uint ethAmount = lpBal.mul(pricePerShare) / 1e18;
        uint min = ethAmount.mul(SLIPPAGE_MAX - slippage) / SLIPPAGE_MAX;

        StableSwapSTETH(POOL).remove_liquidity_one_coin(lpBal, 0, min);
        
    }

    
    function _swapToEth(address _from, uint _amount) private {
        
        address[] memory path = new address[](2);
        path[0] = _from;
        path[1] = WETH;

        Uniswap(UNISWAP).swapExactTokensForETH(
            _amount,
            1,
            path,
            address(this),
            block.timestamp
        );
    }

    function _claimRewards() private {
        
        LiquidityGaugeV2(GAUGE).claim_rewards();
        
        Minter(MINTER).mint(GAUGE);

        
        uint ldoBal = IERC20(LDO).balanceOf(address(this));
        if (ldoBal > 0) {
            _swapToEth(LDO, ldoBal);
        }

        uint crvBal = IERC20(CRV).balanceOf(address(this));
        if (crvBal > 0) {
            _swapToEth(CRV, crvBal);
        }
    }

    
    function harvest() external override onlyAuthorized {
        _claimRewards();

        uint bal = address(this).balance;
        if (bal > 0) {
            
            uint fee = bal.mul(performanceFee) / PERFORMANCE_FEE_MAX;
            if (fee > 0) {
                address treasury = IController(controller).treasury();
                require(treasury != address(0), "treasury = zero address");
                
                (bool sent, ) = treasury.call{value: fee}("");
                require(sent, "Send ETH failed");
            }
            _deposit();
        }
    }

    
    function exit() external override onlyAuthorized {
        _claimRewards();
        _withdrawAll();
    }

    function sweep(address _token) external override onlyAdmin {
        require(_token != GAUGE, "protected token");
        IERC20(_token).safeTransfer(admin, IERC20(_token).balanceOf(address(this)));
    }
}