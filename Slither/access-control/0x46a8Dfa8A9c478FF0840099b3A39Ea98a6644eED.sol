pragma solidity 0.7.1;

library Address {

    

    function isContract(address account) internal view returns (bool) {

        

        

        



        uint256 size;

        

        assembly {

            size := extcodesize(account)

        }

        return size > 0;

    }



    

    function sendValue(address payable recipient, uint256 amount) internal {

        require(

            address(this).balance >= amount,

            "Address: insufficient balance"

        );



        

        (bool success, ) = recipient.call{value: amount}("");

        require(

            success,

            "Address: unable to send value, recipient may have reverted"

        );

    }



    

    function functionCall(address target, bytes memory data)

        internal

        returns (bytes memory)

    {

        return functionCall(target, data, "Address: low-level call failed");

    }



    

    function functionCall(

        address target,

        bytes memory data,

        string memory errorMessage

    ) internal returns (bytes memory) {

        return _functionCallWithValue(target, data, 0, errorMessage);

    }



    

    function functionCallWithValue(

        address target,

        bytes memory data,

        uint256 value

    ) internal returns (bytes memory) {

        return

            functionCallWithValue(

                target,

                data,

                value,

                "Address: low-level call with value failed"

            );

    }



    

    function functionCallWithValue(

        address target,

        bytes memory data,

        uint256 value,

        string memory errorMessage

    ) internal returns (bytes memory) {

        require(

            address(this).balance >= value,

            "Address: insufficient balance for call"

        );

        return _functionCallWithValue(target, data, value, errorMessage);

    }



    function _functionCallWithValue(

        address target,

        bytes memory data,

        uint256 weiValue,

        string memory errorMessage

    ) private returns (bytes memory) {

        require(isContract(target), "Address: call to non-contract");



        

        (bool success, bytes memory returndata) = target.call{value: weiValue}(

            data

        );

        if (success) {

            return returndata;

        } else {

            

            if (returndata.length > 0) {

                



                

                assembly {

                    let returndata_size := mload(returndata)

                    revert(add(32, returndata), returndata_size)

                }

            } else {

                revert(errorMessage);

            }

        }

    }

}

abstract contract Context {

    function _msgSender() internal virtual view returns (address payable) {

        return msg.sender;

    }



    function _msgData() internal virtual view returns (bytes memory) {

        this; 

        return msg.data;

    }

}

contract ERC20Storage {

  

  bytes32 constant DIAMOND_STORAGE_POSITION_ERC20 = keccak256(

    "diamond.standard.diamond.storage.erc20"

  );



  struct TokenStorage {

    string  name;

    string  symbol;

    uint8  decimals;

    mapping(address => uint256) balances;

    mapping(address => mapping(address => uint256)) allowances;

    uint256   totalSupply;

  }



  

  function erc20Storage() internal pure returns (TokenStorage storage ms) {

    bytes32 position = DIAMOND_STORAGE_POSITION_ERC20;

    assembly {

      ms.slot := position

    }

  }

}

interface IERC20 {

    

    function totalSupply() external view returns (uint256);



    

    function balanceOf(address account) external view returns (uint256);



    

    function transfer(address recipient, uint256 amount)

        external

        returns (bool);



    

    function allowance(address owner, address spender)

        external

        view

        returns (uint256);



    

    function approve(address spender, uint256 amount) external returns (bool);



    

    function transferFrom(

        address sender,

        address recipient,

        uint256 amount

    ) external returns (bool);



    

    event Transfer(address indexed from, address indexed to, uint256 value);



    

    event Approval(

        address indexed owner,

        address indexed spender,

        uint256 value

    );

}

contract Initializable {

    

    bool private initialized;



    

    bool private initializing;



    

    modifier initializer() {

        require(

            initializing || isConstructor() || !initialized,

            "Contract instance has already been initialized"

        );



        bool isTopLevelCall = !initializing;

        if (isTopLevelCall) {

            initializing = true;

            initialized = true;

        }



        _;



        if (isTopLevelCall) {

            initializing = false;

        }

    }



    

    function isConstructor() private view returns (bool) {

        

        

        

        

        

        address self = address(this);

        uint256 cs;

        assembly {

            cs := extcodesize(self)

        }

        return cs == 0;

    }



    

    uint256[50] private ______gap;

}

contract Migrations {

    address public owner;

    uint256 public last_completed_migration;



    constructor() {

        owner = msg.sender;

    }



    modifier restricted() {

        if (msg.sender == owner) _;

    }



    function setCompleted(uint256 completed) public restricted {

        last_completed_migration = completed;

    }

}

abstract contract Ownable is Initializable {

    address private _owner;



    event OwnershipTransferred(

        address indexed previousOwner,

        address indexed newOwner

    );



    

    function _onInitialize(address sender) internal initializer {

        _owner = sender;

        emit OwnershipTransferred(address(0), _owner);

    }



    

    function owner() public view returns (address) {

        return _owner;

    }



    

    modifier onlyOwner() {

        require(isOwner(), "Ownable: caller is not the owner");

        _;

    }



    

    function isOwner() public view returns (bool) {

        return msg.sender == _owner;

    }



    

    function renounceOwnership() public onlyOwner {

        emit OwnershipTransferred(_owner, address(0));

        _owner = address(0);

    }



    

    function transferOwnership(address newOwner) public onlyOwner {

        _transferOwnership(newOwner);

    }



    

    function _transferOwnership(address newOwner) internal {

        require(

            newOwner != address(0),

            "Ownable: new owner is the zero address"

        );

        emit OwnershipTransferred(_owner, newOwner);

        _owner = newOwner;

    }

}

contract PauserRole is Initializable {

    using Roles for Roles.Role;



    event PauserAdded(address indexed account);

    event PauserRemoved(address indexed account);



    Roles.Role private _pausers;



    function initialize(address sender) public virtual initializer {

        if (!isPauser(sender)) {

            _addPauser(sender);

        }

    }



    modifier onlyPauser() {

        require(

            isPauser(msg.sender),

            "PauserRole: caller does not have the Pauser role"

        );

        _;

    }



    function isPauser(address account) public view returns (bool) {

        return _pausers.has(account);

    }



    function addPauser(address account) public onlyPauser {

        _addPauser(account);

    }



    function renouncePauser() public {

        _removePauser(msg.sender);

    }



    function _addPauser(address account) internal {

        _pausers.add(account);

        emit PauserAdded(account);

    }



    function _removePauser(address account) internal {

        _pausers.remove(account);

        emit PauserRemoved(account);

    }



    uint256[50] private ______gap;

}

abstract contract Proxy {

    

    fallback() external payable {

        _fallback();

    }



    

    function _implementation() internal virtual view returns (address);



    

    function _delegate(address implementation) internal {

        assembly {

            

            

            

            calldatacopy(0, 0, calldatasize())



            

            

            let result := delegatecall(

                gas(),

                implementation,

                0,

                calldatasize(),

                0,

                0

            )



            

            returndatacopy(0, 0, returndatasize())



            switch result

                

                case 0 {

                    revert(0, returndatasize())

                }

                default {

                    return(0, returndatasize())

                }

        }

    }



    

    function _willFallback() internal virtual {}



    

    function _fallback() internal {

        _willFallback();

        _delegate(_implementation());

    }

}

library Roles {

    struct Role {

        mapping(address => bool) bearer;

    }



    

    function add(Role storage role, address account) internal {

        require(!has(role, account), "Roles: account already has role");

        role.bearer[account] = true;

    }



    

    function remove(Role storage role, address account) internal {

        require(has(role, account), "Roles: account does not have role");

        role.bearer[account] = false;

    }



    

    function has(Role storage role, address account)

        internal

        view

        returns (bool)

    {

        require(account != address(0), "Roles: account is the zero address");

        return role.bearer[account];

    }

}

library SafeERC20 {

    using SafeMath for uint256;

    using Address for address;



    function safeTransfer(

        IERC20 token,

        address to,

        uint256 value

    ) internal {

        _callOptionalReturn(

            token,

            abi.encodeWithSelector(token.transfer.selector, to, value)

        );

    }



    function safeTransferFrom(

        IERC20 token,

        address from,

        address to,

        uint256 value

    ) internal {

        _callOptionalReturn(

            token,

            abi.encodeWithSelector(token.transferFrom.selector, from, to, value)

        );

    }



    function safeApprove(

        IERC20 token,

        address spender,

        uint256 value

    ) internal {

        

        

        

        

        require(

            (value == 0) || (token.allowance(address(this), spender) == 0),

            "SafeERC20: approve from non-zero to non-zero allowance"

        );

        _callOptionalReturn(

            token,

            abi.encodeWithSelector(token.approve.selector, spender, value)

        );

    }



    function safeIncreaseAllowance(

        IERC20 token,

        address spender,

        uint256 value

    ) internal {

        uint256 newAllowance = token.allowance(address(this), spender).add(

            value

        );

        _callOptionalReturn(

            token,

            abi.encodeWithSelector(

                token.approve.selector,

                spender,

                newAllowance

            )

        );

    }



    function safeDecreaseAllowance(

        IERC20 token,

        address spender,

        uint256 value

    ) internal {

        uint256 newAllowance = token.allowance(address(this), spender).sub(

            value,

            "SafeERC20: decreased allowance below zero"

        );

        _callOptionalReturn(

            token,

            abi.encodeWithSelector(

                token.approve.selector,

                spender,

                newAllowance

            )

        );

    }



    

    function _callOptionalReturn(IERC20 token, bytes memory data) private {

        

        



        

        

        

        

        

        require(address(token).isContract(), "SafeERC20: call to non-contract");



        

        (bool success, bytes memory returndata) = address(token).call(data);

        require(success, "SafeERC20: low-level call failed");



        if (returndata.length > 0) {

            

            

            require(

                abi.decode(returndata, (bool)),

                "SafeERC20: ERC20 operation did not succeed"

            );

        }

    }

}

library SafeMath {

    

    function add(uint256 a, uint256 b) internal pure returns (uint256) {

        uint256 c = a + b;

        require(c >= a, "SafeMath: addition overflow");



        return c;

    }



    

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {

        return sub(a, b, "SafeMath: subtraction overflow");

    }



    

    function sub(

        uint256 a,

        uint256 b,

        string memory errorMessage

    ) internal pure returns (uint256) {

        require(b <= a, errorMessage);

        uint256 c = a - b;



        return c;

    }



    

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {

        

        

        

        if (a == 0) {

            return 0;

        }



        uint256 c = a * b;

        require(c / a == b, "SafeMath: multiplication overflow");



        return c;

    }



    

    function div(uint256 a, uint256 b) internal pure returns (uint256) {

        return div(a, b, "SafeMath: division by zero");

    }



    

    function div(

        uint256 a,

        uint256 b,

        string memory errorMessage

    ) internal pure returns (uint256) {

        require(b > 0, errorMessage);

        uint256 c = a / b;

        



        return c;

    }



    

    function mod(uint256 a, uint256 b) internal pure returns (uint256) {

        return mod(a, b, "SafeMath: modulo by zero");

    }



    

    function mod(

        uint256 a,

        uint256 b,

        string memory errorMessage

    ) internal pure returns (uint256) {

        require(b != 0, errorMessage);

        return a % b;

    }

}

abstract contract BaseUpgradeabilityProxy is Proxy {

  

  event Upgraded(address indexed implementation);



  bytes32 constant DIAMOND_STORAGE_POSITION = keccak256(

    "diamond.standard.diamond.storage.proxy"

  );



  struct DiamondStorage {

    

    address proxyAdmin;

    address implementation;

  }



  function diamondStorage() internal pure returns (DiamondStorage storage ds) {

    bytes32 position = DIAMOND_STORAGE_POSITION;

    assembly {

      ds.slot := position

    }

  }



  

  



  

  function _implementation() internal override view returns (address) {

    DiamondStorage storage ms = diamondStorage();

    return ms.implementation;

  }



  

  function _upgradeTo(address newImplementation) internal {

    _setImplementation(newImplementation);

    emit Upgraded(newImplementation);

  }



  

  function _setImplementation(address newImplementation) internal {

    require(

      Address.isContract(newImplementation),

      "Cannot set a proxy implementation to a non-contract address"

    );

    DiamondStorage storage ms = diamondStorage();

    require(

      newImplementation != ms.implementation,

      "Proxy implementation is already set to this address"

    );

    ms.implementation = newImplementation;

  }

}

contract CanReclaimEther is Ownable {

    function reclaimEther() external onlyOwner {

        msg.sender.transfer(address(this).balance);

    }

}

contract CanReclaimToken is Ownable {

    using SafeERC20 for IERC20;



    function reclaimToken(IERC20 token) external onlyOwner {

        uint256 balance = token.balanceOf(address(this));

        token.safeTransfer(owner(), balance);

    }

}

contract ERC20 is Context, Initializable, IERC20, ERC20Storage {

    using SafeMath for uint256;

    using Address for address;



    

    function initialize(

        string memory name,

        string memory symbol,

        uint8 decimals

    ) public initializer {

        _onInitialize(name, symbol, decimals);

    }



    function _onInitialize(

        string memory name,

        string memory symbol,

        uint8 decimals

    ) internal initializer {

        TokenStorage storage ercs = erc20Storage();

        ercs.name = name;

        ercs.symbol = symbol;

        ercs.decimals = decimals;

    }



    

    function name() public view returns (string memory) {

        TokenStorage storage ercs = erc20Storage();

        return ercs.name;

    }



    

    function symbol() public view returns (string memory) {

        TokenStorage storage ercs = erc20Storage();

        return ercs.symbol;

    }



    

    function decimals() public view returns (uint8) {

        TokenStorage storage ercs = erc20Storage();

        return ercs.decimals;

    }



    

    function totalSupply() public override view returns (uint256) {

        TokenStorage storage ercs = erc20Storage();

        return ercs.totalSupply;

    }



    

    function balanceOf(address account) public override view returns (uint256) {

        TokenStorage storage ercs = erc20Storage();

        return ercs.balances[account];

    }



    

    function transfer(address recipient, uint256 amount)

        public

        virtual

        override

        returns (bool)

    {

        _transfer(_msgSender(), recipient, amount);

        return true;

    }



    

    function allowance(address owner, address spender)

        public

        virtual

        override

        view

        returns (uint256)

    {

        TokenStorage storage ercs = erc20Storage();

        return ercs.allowances[owner][spender];

    }



    

    function approve(address spender, uint256 amount)

        public

        virtual

        override

        returns (bool)

    {

        _approve(_msgSender(), spender, amount);

        return true;

    }



    

    function transferFrom(

        address sender,

        address recipient,

        uint256 amount

    ) public virtual override returns (bool) {

        _transfer(sender, recipient, amount);

        TokenStorage storage ercs = erc20Storage();

        _approve(

            sender,

            _msgSender(),

            ercs.allowances[sender][_msgSender()].sub(

                amount,

                "ERC20: transfer amount exceeds allowance"

            )

        );

        return true;

    }



    

    function increaseAllowance(address spender, uint256 addedValue)

        public

        virtual

        returns (bool)

    {

        TokenStorage storage ercs = erc20Storage();

        _approve(

            _msgSender(),

            spender,

            ercs.allowances[_msgSender()][spender].add(addedValue)

        );

        return true;

    }



    

    function decreaseAllowance(address spender, uint256 subtractedValue)

        public

        virtual

        returns (bool)

    {

        TokenStorage storage ercs = erc20Storage();

        _approve(

            _msgSender(),

            spender,

            ercs.allowances[_msgSender()][spender].sub(

                subtractedValue,

                "ERC20: decreased allowance below zero"

            )

        );

        return true;

    }



    

    function _transfer(

        address sender,

        address recipient,

        uint256 amount

    ) internal virtual {

        require(sender != address(0), "ERC20: transfer from the zero address");

        require(recipient != address(0), "ERC20: transfer to the zero address");

        TokenStorage storage ercs = erc20Storage();



        _beforeTokenTransfer(sender, recipient, amount);

        ercs.balances[sender] = ercs.balances[sender].sub(

            amount,

            "ERC20: transfer amount exceeds balance"

        );

        ercs.balances[recipient] = ercs.balances[recipient].add(amount);

        emit Transfer(sender, recipient, amount);

    }



    

    function _mint(address account, uint256 amount) internal virtual {

        require(account != address(0), "ERC20: mint to the zero address");

        _beforeTokenTransfer(address(0), account, amount);

        TokenStorage storage ercs = erc20Storage();



        ercs.totalSupply = ercs.totalSupply.add(amount);

        ercs.balances[account] = ercs.balances[account].add(amount);

        emit Transfer(address(0), account, amount);

    }



    

    function _burn(address account, uint256 amount) internal virtual {

        require(account != address(0), "ERC20: burn from the zero address");

        _beforeTokenTransfer(account, address(0), amount);

        TokenStorage storage ercs = erc20Storage();



        ercs.balances[account] = ercs.balances[account].sub(

            amount,

            "ERC20: burn amount exceeds balance"

        );

        ercs.totalSupply = ercs.totalSupply.sub(amount);

        emit Transfer(account, address(0), amount);

    }



    

    function _approve(

        address owner,

        address spender,

        uint256 amount

    ) internal virtual {

        require(owner != address(0), "ERC20: approve from the zero address");

        require(spender != address(0), "ERC20: approve to the zero address");

        TokenStorage storage ercs = erc20Storage();



        ercs.allowances[owner][spender] = amount;

        emit Approval(owner, spender, amount);

    }



    

    function _setupDecimals(uint8 decimals_) internal {

        TokenStorage storage ercs = erc20Storage();

        ercs.decimals = decimals_;

    }



    

    function _beforeTokenTransfer(

        address from,

        address to,

        uint256 amount

    ) internal virtual {}



    uint256[50] private ______gap;

}

abstract contract ERC20Burnable is Context, ERC20 {

    using SafeMath for uint256;



    

    function burn(uint256 amount) public virtual {

        _burn(_msgSender(), amount);

    }



    

    function burnFrom(address account, uint256 amount) public virtual {

        uint256 decreasedAllowance = allowance(account, _msgSender()).sub(

            amount,

            "ERC20: burn amount exceeds allowance"

        );



        _approve(account, _msgSender(), decreasedAllowance);

        _burn(account, amount);

    }

}

abstract contract InitializableUpgradeabilityProxy is BaseUpgradeabilityProxy {

    

    function initialize(address _logic, bytes memory _data)

        public

        virtual

        payable

    {

        require(_implementation() == address(0));

        assert(

            DIAMOND_STORAGE_POSITION ==

                keccak256("diamond.standard.diamond.storage.proxy")

        );



        _setImplementation(_logic);

        if (_data.length > 0) {

            (bool success, ) = _logic.delegatecall(_data);

            require(success);

        }

    }

}

contract Pausable is Initializable, PauserRole {

    

    event Paused(address account);



    

    event Unpaused(address account);



    bool private _paused;



    

    function initialize(address sender) public override initializer {

        PauserRole.initialize(sender);



        _paused = false;

    }



    

    function paused() public view returns (bool) {

        return _paused;

    }



    

    modifier whenNotPaused() {

        require(!_paused, "Pausable: paused");

        _;

    }



    

    modifier whenPaused() {

        require(_paused, "Pausable: not paused");

        _;

    }



    

    function pause() public onlyPauser whenNotPaused {

        _paused = true;

        emit Paused(msg.sender);

    }



    

    function unpause() public onlyPauser whenPaused {

        _paused = false;

        emit Unpaused(msg.sender);

    }



    uint256[50] private ______gap;

}

abstract contract UpgradeabilityProxy is BaseUpgradeabilityProxy {

    

    constructor(address _logic, bytes memory _data) payable {

        assert(

            DIAMOND_STORAGE_POSITION ==

                keccak256("diamond.standard.diamond.storage.proxy")

        );

        

        _setImplementation(_logic);

        if (_data.length > 0) {

            (bool success, ) = _logic.delegatecall(_data);

            require(success);

        }

    }

}

abstract contract BaseAdminUpgradeabilityProxy is BaseUpgradeabilityProxy {

    

    event AdminChanged(address previousAdmin, address newAdmin);



    



    



    

    modifier ifAdmin() {

        if (msg.sender == _admin()) {

            _;

        } else {

            _fallback();

        }

    }



    

    function admin() external ifAdmin returns (address) {

        return _admin();

    }



    

    function implementation() external ifAdmin returns (address) {

        return _implementation();

    }



    

    function changeAdmin(address newAdmin) external ifAdmin {

        require(

            newAdmin != address(0),

            "Cannot change the admin of a proxy to the zero address"

        );

        emit AdminChanged(_admin(), newAdmin);

        _setAdmin(newAdmin);

    }



    

    function upgradeTo(address newImplementation) external ifAdmin {

        _upgradeTo(newImplementation);

    }



    

    function upgradeToAndCall(address newImplementation, bytes calldata data)

        external

        payable

        ifAdmin

    {

        _upgradeTo(newImplementation);

        (bool success, ) = newImplementation.delegatecall(data);

        require(

            success,

            "upgradeToAndCall: delegatecall should be successfull"

        );

    }



    

    function _admin() internal view returns (address) {

        DiamondStorage storage ms = diamondStorage();

        return ms.proxyAdmin;

    }



    

    function _setAdmin(address newAdmin) internal {

        DiamondStorage storage ms = diamondStorage();

        ms.proxyAdmin = newAdmin;

    }



    

    

}

abstract contract ERC20Pausable is ERC20, Pausable {

    

    function _beforeTokenTransfer(

        address from,

        address to,

        uint256 amount

    ) internal virtual override {

        super._beforeTokenTransfer(from, to, amount);



        require(!paused(), "ERC20Pausable: token transfer while paused");

    }

}

contract OwnedUpgradeabilityProxy is

    BaseAdminUpgradeabilityProxy,

    InitializableUpgradeabilityProxy

{

    



    function initialize(

        address _logic,

        address _admin,

        bytes memory _data

    ) public payable {

        require(_implementation() == address(0));

        InitializableUpgradeabilityProxy.initialize(_logic, _data);

        _setAdmin(_admin);

        emit Initialized(_admin, _logic);

    }



    event Initialized(address admin, address _logic);



    

    

    function _willFallback() override internal {

        require(

          _admin() != address(0),

          "Can't fallback if admin is not set"

        );

        require(

            msg.sender != _admin(),

            "Cannot call fallback function from the proxy admin"

        );

        super._willFallback();

    }

}

contract UbxToken is

    Initializable,

    Ownable,

    ERC20,

    ERC20Burnable,

    ERC20Pausable,

    CanReclaimEther,

    CanReclaimToken

{

    function initialize(

        string memory name,

        string memory symbol,

        uint8 decimals,

        uint256 initialSupply,

        address initialHolder,

        address owner,

        address[] memory pausers

    ) public initializer {

        require(pausers.length > 0, "At least one pauser should be defined");

        ERC20.initialize(name, symbol, decimals);

        Ownable._onInitialize(owner);



        Pausable.initialize(pausers[0]);



        for (uint256 i = 1; i < pausers.length; ++i) {

            _addPauser(pausers[i]);

        }



        

        _mint(initialHolder, initialSupply);

    }



    

    function _beforeTokenTransfer(

        address from,

        address to,

        uint256 amount

    ) internal virtual override(ERC20, ERC20Pausable) {

        super._beforeTokenTransfer(from, to, amount);

    }

}
