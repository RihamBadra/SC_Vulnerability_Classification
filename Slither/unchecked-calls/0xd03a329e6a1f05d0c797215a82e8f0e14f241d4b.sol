pragma solidity 0.6.12;

enum escrowstatus {CANCELLED, ACTIVATED, SETTLED}

interface DaiErc20 {

    function transfer(address, uint) external returns (bool);

    function transferFrom(address,address,uint256) external returns (bool);

    function approve(address,uint256) external returns (bool);

    function balanceOf(address) external view returns (uint);

    function allowance(address, address) external view returns (uint);

}

library mathlib

{

     

     

    function add(uint x, uint y) internal pure returns (uint z) {

        require((z = x + y) >= x);

    }

    

    function sub(uint x, uint y) internal pure returns (uint z) {

        require((z = x - y) <= x);

    }

    

    function mul(uint x, uint y) internal pure returns (uint z) {

        require(y == 0 || (z = x * y) / y == x);

    }

    

}

contract owned

{

     



    address public manager;

    

    constructor() public 

	{

	    manager = msg.sender;

	}



    modifier onlyManager()

    {

        require(msg.sender == manager);

        _;

    }

    

    function setManager(address newmanager) external onlyManager

    {

        

        

        require(newmanager.balance > 0);

        manager = newmanager;

    }

    

}

contract EscrowFactory is owned

{

    

    

    address constant private dai_ = 0x6B175474E89094C44Da98b954EedeAC495271d0F;

    DaiErc20 constant private daiToken = DaiErc20(dai_);



    

    uint public escrowfee;

    

    

    bool public factorycontractactive;

    

    uint private escrowid;

    

    uint constant private maxuint = 2**256-1;

    

    struct Escrow 

    {

        address escrowpayer;

        address escrowpayee;

        uint escrowamount;

        uint escrowsettlementamount;

        escrowstatus estatus;

        address escrowmoderator;

        uint escrowmoderatorfee;

    }

    

    mapping (bytes32 => Escrow) public Escrows;

    

    

    



    

    event NewEscrowEvent(bytes32 esid, address indexed escrowpayer, address indexed escrowpayee, uint escrowamount, uint eventtime);

    

    

    event NewEscrowEvent(bytes32 esid, address indexed escrowpayer, address indexed escrowpayee, uint escrowamount, address indexed escrowmoderator, 

    uint escrowmoderatorfee,  uint eventtime);

    

    

    event NewEscrowEventById(bytes32 indexed esid, address escrowpayer, address escrowpayee, uint escrowamount, uint eventtime);

    

    

    event NewEscrowEventById(bytes32 indexed esid, address escrowpayer, address escrowpayee,  uint escrowamount, address escrowmoderator, 

    uint escrowmoderatorfee, uint eventtime);

    

    

    event EscrowStatusEvent(bytes32 indexed esid, escrowstatus estatus, uint escrowsettlementamount, uint eventtime);

    

    constructor() public 

	{

		escrowid = 0;

	    escrowfee = 1000000000000000000; 

		factorycontractactive = true;

	}





    function setEscrowFee(uint newfee) external onlyManager

    {

        

        

        require(newfee > 0);

        

        escrowfee = newfee;

    }

    



    function setFactoryContractSwitch() external onlyManager

    {

        

        

        factorycontractactive = factorycontractactive == true ? false : true;

    }

    

  

    

    function createNewEscrow(address escrowpayee, uint escrowamount) external 

    {

        

        require(factorycontractactive, "Factory Contract should be Active");

        require(escrowid < maxuint, "Maximum escrowid reached");

        require(msg.sender != escrowpayee,"The Payer, payee should be different");

        require(escrowpayee != address(0),"The Escrow Payee can not be address(0)");

        require(escrowamount > 0,"Escrow amount has to be greater than 0");

        

        require(daiToken.allowance(msg.sender,address(this)) >= mathlib.add(escrowamount, escrowfee), "daiToken allowance exceeded");

        

        bytes32 esid = keccak256(abi.encodePacked(escrowid));

        

        Escrows[esid] = Escrow({escrowpayer:msg.sender, escrowpayee:escrowpayee, escrowamount:escrowamount,

            escrowsettlementamount:escrowamount, estatus:escrowstatus.ACTIVATED,escrowmoderator:address(0),escrowmoderatorfee:0});

        

        escrowid = mathlib.add(escrowid,1);

        

        

        daiToken.transferFrom(msg.sender, address(this), escrowamount);

        

        

        daiToken.transferFrom(msg.sender, manager, escrowfee);

        

        emit NewEscrowEvent(esid, msg.sender, escrowpayee, escrowamount, now);

        

        emit NewEscrowEventById(esid, msg.sender, escrowpayee, escrowamount, now);

        

    }

    

     

    function createNewEscrow(address escrowpayee, uint escrowamount, address escrowmoderator, uint escrowmoderatorfee) external 

    {

        

        require(factorycontractactive, "Factory Contract should be Active");

        require(escrowid < maxuint, "Maximum escrowid reached");

        require(msg.sender != escrowpayee && msg.sender != escrowmoderator && escrowpayee != escrowmoderator,"The Payer, payee & moderator should be different");

        require(escrowpayee != address(0) && escrowmoderator!=address(0),"Escrow Payee or moderator can not be address(0)");

        require(escrowamount > 0,"Escrow amount has to be greater than 0");

    

        uint dailockedinnewescrow = mathlib.add(escrowamount,escrowmoderatorfee);

  

        require(daiToken.allowance(msg.sender,address(this)) >= mathlib.add(dailockedinnewescrow, escrowfee), "daiToken allowance exceeded");

        

        bytes32 esid = keccak256(abi.encodePacked(escrowid));

        

        Escrows[esid] = Escrows[esid] = Escrow({escrowpayer:msg.sender, escrowpayee:escrowpayee, escrowamount:escrowamount,

            escrowsettlementamount:escrowamount, estatus:escrowstatus.ACTIVATED,escrowmoderator:escrowmoderator,escrowmoderatorfee:escrowmoderatorfee});

        

        escrowid = mathlib.add(escrowid,1);

        

        

        daiToken.transferFrom(msg.sender, address(this), dailockedinnewescrow);

        

        

        daiToken.transferFrom(msg.sender, manager, escrowfee);

        

        emit NewEscrowEvent(esid, msg.sender, escrowpayee, escrowamount, escrowmoderator, escrowmoderatorfee ,now);

        

        emit NewEscrowEventById(esid, msg.sender, escrowpayee, escrowamount, escrowmoderator, escrowmoderatorfee, now);

        

    }

    

    modifier onlyPayerOrModerator(bytes32 esid)

    {

        require(msg.sender == Escrows[esid].escrowpayer || msg.sender == Escrows[esid].escrowmoderator, "Only Payer or Moderator");

        _;

    }

    

    modifier onlyPayeeOrModerator(bytes32 esid)

    {

        require(msg.sender == Escrows[esid].escrowpayee || msg.sender == Escrows[esid].escrowmoderator, "Only Payee or Moderator");

        _;

    }

    

    function getEscrowDetails(bytes32 esid) external view returns (escrowstatus, uint)

    {

        

        

        Escrow memory thisescrow = Escrows[esid];

        

        require(thisescrow.escrowpayee !=address(0),"Escrow does not exist");

        

        return(thisescrow.estatus, thisescrow.escrowsettlementamount);

    }

    

 

     function setEscrowSettlementAmount(bytes32 esid, uint esettlementamount) external onlyPayeeOrModerator(esid)

    {

        

        

        Escrow storage thisescrow = Escrows[esid];

        

        require(thisescrow.estatus == escrowstatus.ACTIVATED,"Escrow should be Activated");

        require(esettlementamount > 0 && esettlementamount <= thisescrow.escrowamount ,"escrow settlementamount is incorrect");

        

        thisescrow.escrowsettlementamount = esettlementamount;

        

        emit EscrowStatusEvent(esid, thisescrow.estatus, thisescrow.escrowsettlementamount,now);

    }

    

     function releaseFundsToPayee(bytes32 esid) external onlyPayerOrModerator(esid)

    {

        

        

        Escrow storage thisescrow = Escrows[esid];

        

        require(thisescrow.estatus == escrowstatus.ACTIVATED, "Escrow Should be activated");

        

        require(thisescrow.escrowsettlementamount > 0, "Escrow Settlement amount is 0");

    

        uint payeramt = thisescrow.escrowamount > thisescrow.escrowsettlementamount ? mathlib.sub(thisescrow.escrowamount,thisescrow.escrowsettlementamount) : 0;

        

        uint settlementamount = thisescrow.escrowsettlementamount;

        thisescrow.escrowsettlementamount = 0;

        thisescrow.estatus = escrowstatus.SETTLED;

        

        

        daiToken.transfer(thisescrow.escrowpayee,settlementamount);

        

        

        if (thisescrow.escrowmoderatorfee > 0)

        {

            daiToken.transfer(thisescrow.escrowmoderator,thisescrow.escrowmoderatorfee);

        }

        

        

        if (payeramt > 0)

        {

            daiToken.transfer(thisescrow.escrowpayer,payeramt);

        }

        

        emit EscrowStatusEvent(esid, thisescrow.estatus, thisescrow.escrowsettlementamount,now);

    

    }

    

    function cancelEscrow(bytes32 esid) external onlyPayeeOrModerator(esid)

    {

        

        

        Escrow storage thisescrow = Escrows[esid];

        

        require(thisescrow.estatus == escrowstatus.ACTIVATED, "Escrow Should be activated");

        

        require(thisescrow.escrowamount == thisescrow.escrowsettlementamount,"Escrow amount and Escrow settlement amount should be equal");

        

        uint settlementamount = thisescrow.escrowsettlementamount;

        thisescrow.escrowsettlementamount = 0;

        thisescrow.estatus = escrowstatus.CANCELLED;

        

        

        if (thisescrow.escrowmoderatorfee > 0)

        {

            daiToken.transfer(thisescrow.escrowmoderator,thisescrow.escrowmoderatorfee);

        }

        

        

        daiToken.transfer(thisescrow.escrowpayer,settlementamount);

        

        emit EscrowStatusEvent(esid, thisescrow.estatus, thisescrow.escrowsettlementamount,now);

    }

    

}
