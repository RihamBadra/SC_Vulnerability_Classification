pragma solidity 0.6.12;

contract Initializable {



  

  bool private initialized;



  

  bool private initializing;



  

  modifier initializer() {

    require(initializing || isConstructor() || !initialized, "Contract instance has already been initialized");



    bool isTopLevelCall = !initializing;

    if (isTopLevelCall) {

      initializing = true;

      initialized = true;

    }



    _;



    if (isTopLevelCall) {

      initializing = false;

    }

  }



  

  function isConstructor() private view returns (bool) {

    

    

    

    

    

    address self = address(this);

    uint256 cs;

    assembly { cs := extcodesize(self) }

    return cs == 0;

  }



  

  uint256[50] private ______gap;

}

interface IERC165 {

    

    function supportsInterface(bytes4 interfaceId) external view returns (bool);

}

interface IERC1820Implementer {

    

    function canImplementInterfaceForAddress(bytes32 interfaceHash, address account) external view returns (bytes32);

}

interface IERC1820Registry {

    

    function setManager(address account, address newManager) external;



    

    function getManager(address account) external view returns (address);



    

    function setInterfaceImplementer(address account, bytes32 interfaceHash, address implementer) external;



    

    function getInterfaceImplementer(address account, bytes32 interfaceHash) external view returns (address);



    

    function interfaceHash(string calldata interfaceName) external pure returns (bytes32);



    

    function updateERC165Cache(address account, bytes4 interfaceId) external;



    

    function implementsERC165Interface(address account, bytes4 interfaceId) external view returns (bool);



    

    function implementsERC165InterfaceNoCache(address account, bytes4 interfaceId) external view returns (bool);



    event InterfaceImplementerSet(address indexed account, bytes32 indexed interfaceHash, address indexed implementer);



    event ManagerChanged(address indexed account, address indexed newManager);

}

interface IERC20 {

    

    function totalSupply() external view returns (uint256);



    

    function balanceOf(address account) external view returns (uint256);



    

    function transfer(address recipient, uint256 amount) external returns (bool);



    

    function allowance(address owner, address spender) external view returns (uint256);



    

    function approve(address spender, uint256 amount) external returns (bool);



    

    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);



    

    event Transfer(address indexed from, address indexed to, uint256 value);



    

    event Approval(address indexed owner, address indexed spender, uint256 value);

}

interface IERC721 is IERC165 {

    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);

    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);

    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);



    

    function balanceOf(address owner) external view returns (uint256 balance);



    

    function ownerOf(uint256 tokenId) external view returns (address owner);



    

    function safeTransferFrom(address from, address to, uint256 tokenId) external;

    

    function transferFrom(address from, address to, uint256 tokenId) external;

    function approve(address to, uint256 tokenId) external;

    function getApproved(uint256 tokenId) external view returns (address operator);



    function setApprovalForAll(address operator, bool _approved) external;

    function isApprovedForAll(address owner, address operator) external view returns (bool);





    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;

}

interface IERC777 {

    

    function name() external view returns (string memory);



    

    function symbol() external view returns (string memory);



    

    function granularity() external view returns (uint256);



    

    function totalSupply() external view returns (uint256);



    

    function balanceOf(address owner) external view returns (uint256);



    

    function send(address recipient, uint256 amount, bytes calldata data) external;



    

    function burn(uint256 amount, bytes calldata data) external;



    

    function isOperatorFor(address operator, address tokenHolder) external view returns (bool);



    

    function authorizeOperator(address operator) external;



    

    function revokeOperator(address operator) external;



    

    function defaultOperators() external view returns (address[] memory);



    

    function operatorSend(

        address sender,

        address recipient,

        uint256 amount,

        bytes calldata data,

        bytes calldata operatorData

    ) external;



    

    function operatorBurn(

        address account,

        uint256 amount,

        bytes calldata data,

        bytes calldata operatorData

    ) external;



    event Sent(

        address indexed operator,

        address indexed from,

        address indexed to,

        uint256 amount,

        bytes data,

        bytes operatorData

    );



    event Minted(address indexed operator, address indexed to, uint256 amount, bytes data, bytes operatorData);



    event Burned(address indexed operator, address indexed from, uint256 amount, bytes data, bytes operatorData);



    event AuthorizedOperator(address indexed operator, address indexed tokenHolder);



    event RevokedOperator(address indexed operator, address indexed tokenHolder);

}

interface IERC777Recipient {

    

    function tokensReceived(

        address operator,

        address from,

        address to,

        uint256 amount,

        bytes calldata userData,

        bytes calldata operatorData

    ) external;

}

interface IERC777Sender {

    

    function tokensToSend(

        address operator,

        address from,

        address to,

        uint256 amount,

        bytes calldata userData,

        bytes calldata operatorData

    ) external;

}

interface PodInterface {

  function tokenToCollateralValue(uint256 tokens) external view returns (uint256);

  function balanceOfUnderlying(address user) external view returns (uint256);

}

contract ContextUpgradeSafe is Initializable {

    

    



    function __Context_init() internal initializer {

        __Context_init_unchained();

    }



    function __Context_init_unchained() internal initializer {





    }





    function _msgSender() internal view virtual returns (address payable) {

        return msg.sender;

    }



    function _msgData() internal view virtual returns (bytes memory) {

        this; 

        return msg.data;

    }



    uint256[50] private __gap;

}

contract OwnableUpgradeSafe is Initializable, ContextUpgradeSafe {

    address private _owner;



    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);



    



    function __Ownable_init() internal initializer {

        __Context_init_unchained();

        __Ownable_init_unchained();

    }



    function __Ownable_init_unchained() internal initializer {





        address msgSender = _msgSender();

        _owner = msgSender;

        emit OwnershipTransferred(address(0), msgSender);



    }





    

    function owner() public view returns (address) {

        return _owner;

    }



    

    modifier onlyOwner() {

        require(_owner == _msgSender(), "Ownable: caller is not the owner");

        _;

    }



    

    function renounceOwnership() public virtual onlyOwner {

        emit OwnershipTransferred(_owner, address(0));

        _owner = address(0);

    }



    

    function transferOwnership(address newOwner) public virtual onlyOwner {

        require(newOwner != address(0), "Ownable: new owner is the zero address");

        emit OwnershipTransferred(_owner, newOwner);

        _owner = newOwner;

    }



    uint256[49] private __gap;

}

contract MigrateV2ToV3 is OwnableUpgradeSafe, IERC777Recipient, IERC1820Implementer {



  IERC1820Registry constant internal ERC1820_REGISTRY = IERC1820Registry(0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24);



  bytes32 constant private _ERC1820_ACCEPT_MAGIC = keccak256(abi.encodePacked("ERC1820_ACCEPT_MAGIC"));



  

  bytes32 constant internal TOKENS_RECIPIENT_INTERFACE_HASH =

  0xb281fc8c12954d22544db45de3159a39272895b169a852b314f9cc762e44c53b;



  event ReceivedTokens(address token, address from, uint256 amount);



  IERC777 public poolDaiToken;

  IERC777 public poolUsdcToken;

  MixedPodInterface public poolDaiPod;

  MixedPodInterface public poolUsdcPod;

  IERC20 public v3Token;



  constructor (

    IERC777 _poolDaiToken,

    IERC777 _poolUsdcToken,

    MixedPodInterface _poolDaiPod,

    MixedPodInterface _poolUsdcPod,

    IERC20 _v3Token

  ) public {

    poolDaiToken = _poolDaiToken;

    poolUsdcToken = _poolUsdcToken;

    poolDaiPod = _poolDaiPod;

    poolUsdcPod = _poolUsdcPod;

    v3Token = _v3Token;



    

    ERC1820_REGISTRY.setInterfaceImplementer(address(this), TOKENS_RECIPIENT_INTERFACE_HASH, address(this));



    __Ownable_init();

  }



  function tokensReceived(

    address,

    address from,

    address to,

    uint256 amount,

    bytes calldata,

    bytes calldata

  ) external override {

    require(to == address(this), "MigrateV2ToV3/only-tokens");



    if (msg.sender == address(poolDaiToken)) {

      v3Token.transfer(from, amount);

    } else if (msg.sender == address(poolUsdcToken)) {

      v3Token.transfer(from, amount * 1e12);

    } else if (msg.sender == address(poolDaiPod)) {

      uint256 collateral = poolDaiPod.tokenToCollateralValue(amount);

      v3Token.transfer(from, collateral);

    } else if (msg.sender == address(poolUsdcPod)) {

      uint256 collateral = poolUsdcPod.tokenToCollateralValue(amount);

      v3Token.transfer(from, collateral * 1e12);

    } else {

      revert("MigrateV2ToV3/unknown-token");

    }



    emit ReceivedTokens(msg.sender, from, amount);

  }



  function withdrawERC777(IERC777 token) external onlyOwner {

    uint256 amount = token.balanceOf(address(this));

    token.send(msg.sender, amount, "");

  }



  function withdrawERC20(IERC20 token) external onlyOwner {

    uint256 amount = token.balanceOf(address(this));

    token.transfer(msg.sender, amount);

  }



  function withdrawERC721(IERC721 token, uint256 id) external onlyOwner {

    IERC721(token).transferFrom(address(this), msg.sender, id);

  }



  function canImplementInterfaceForAddress(bytes32 interfaceHash, address account) external override view returns (bytes32) {

    if (account == address(this) && interfaceHash == TOKENS_RECIPIENT_INTERFACE_HASH) {

      return _ERC1820_ACCEPT_MAGIC;

    } else {

      return bytes32(0x00);

    }

  }

}

interface MixedPodInterface is IERC777, PodInterface {

}
