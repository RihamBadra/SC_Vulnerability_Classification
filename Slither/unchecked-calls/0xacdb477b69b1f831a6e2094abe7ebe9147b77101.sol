pragma solidity 0.6.5;
pragma experimental ABIEncoderV2;

struct ProtocolBalance {

    ProtocolMetadata metadata;

    AdapterBalance[] adapterBalances;

}

struct ProtocolMetadata {

    string name;

    string description;

    string websiteURL;

    string iconURL;

    uint256 version;

}

struct AdapterBalance {

    AdapterMetadata metadata;

    FullTokenBalance[] balances;

}

struct AdapterMetadata {

    address adapterAddress;

    string adapterType; 

}

struct FullTokenBalance {

    TokenBalance base;

    TokenBalance[] underlying;

}

struct TokenBalance {

    TokenMetadata metadata;

    uint256 amount;

}

struct TokenMetadata {

    address token;

    string name;

    string symbol;

    uint8 decimals;

}

struct Component {

    address token;

    string tokenType;  

    uint256 rate;  

}

interface ERC20 {

    function approve(address, uint256) external returns (bool);

    function transfer(address, uint256) external returns (bool);

    function transferFrom(address, address, uint256) external returns (bool);

    function name() external view returns (string memory);

    function symbol() external view returns (string memory);

    function decimals() external view returns (uint8);

    function totalSupply() external view returns (uint256);

    function balanceOf(address) external view returns (uint256);

}

interface ProtocolAdapter {



    

    function adapterType() external pure returns (string memory);



    

    function tokenType() external pure returns (string memory);



    

    function getBalance(address token, address account) external view returns (uint256);

}

interface TokenAdapter {



    

    function getMetadata(address token) external view returns (TokenMetadata memory);



    

    function getComponents(address token) external view returns (Component[] memory);

}

interface IBerezkaTokenAdapterGovernance {

    function listTokens() external view returns (address[] memory);

    function listProtocols() external view returns (address[] memory);

    function listEthProtocols() external view returns (address[] memory);

    function listProducts() external view returns (address[] memory);

    function getVaults(address _token) external view returns (address[] memory);

}

contract BerezkaTokenAdapter is TokenAdapter {



    address internal constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;



    string internal constant ERC20_TOKEN = "ERC20";



    IBerezkaTokenAdapterGovernance immutable private governance;



    constructor(address _governance) public {

        governance = IBerezkaTokenAdapterGovernance(_governance);

    }



    

    function getMetadata(address token) 

        external 

        view 

        override 

        returns (TokenMetadata memory) 

    {

        return TokenMetadata({

            token: token,

            name: ERC20(token).name(),

            symbol: ERC20(token).symbol(),

            decimals: ERC20(token).decimals()

        });

    }



    

    function getComponents(address token)

        external

        view

        override

        returns (Component[] memory)

    {

        address[] memory vaults = governance.getVaults(token);

        address[] memory assets = governance.listTokens();

        address[] memory debtAdapters = governance.listProtocols();

        uint256 length = assets.length;

        uint256 totalSupply = ERC20(token).totalSupply();



        Component[] memory underlyingTokens = new Component[](1 + length);



        

        for (uint256 i = 0; i < length; i++) {

            underlyingTokens[i] = _getTokenComponents(assets[i], vaults, debtAdapters, totalSupply);

        }



        

        underlyingTokens[length] = _getEthComponents(vaults, totalSupply);

        



        

        return underlyingTokens;

    }



    



    function _getEthComponents(

        address[] memory _vaults,

        uint256 _totalSupply

    )

        internal

        view

        returns (Component memory)

    {

        address[] memory debtsInEth = governance.listEthProtocols();



        uint256 ethBalance = 0;

        uint256 ethDebt = 0;



        

        for (uint256 j = 0; j < _vaults.length; j++) {

            address vault = _vaults[j];

            ethBalance += vault.balance;

            ethDebt += _computeDebt(debtsInEth, ETH, vault);

        }



        return Component({

            token: ETH,

            tokenType: ERC20_TOKEN,

            rate: (ethBalance * 1e18 / _totalSupply) - (ethDebt * 1e18 / _totalSupply)

        });

    }



    function _getTokenComponents(

        address _asset,

        address[] memory _vaults,

        address[] memory _debtAdapters,

        uint256 _totalSupply

    ) 

        internal

        view

        returns (Component memory)

    {

        uint256 componentBalance = 0;

        uint256 componentDebt = 0;



        

        uint256 vaultsLength = _vaults.length;

        for (uint256 j = 0; j < vaultsLength; j++) {

            address vault = _vaults[j];

            componentBalance += ERC20(_asset).balanceOf(vault);

            componentDebt += _computeDebt(_debtAdapters, _asset, vault);

        }



        

        return(Component({

            token: _asset,

            tokenType: ERC20_TOKEN,

            rate: (componentBalance * 1e18 / _totalSupply) - (componentDebt * 1e18 / _totalSupply)

        }));

    }



    function _computeDebt(

        address[] memory _debtAdapters,

        address _asset,

        address _vault

    ) 

        internal

        view

        returns (uint256)

    {

        

        uint256 componentDebt = 0;

        uint256 debtsLength = _debtAdapters.length;

        for (uint256 k = 0; k < debtsLength; k++) {

            ProtocolAdapter debtAdapter = ProtocolAdapter(_debtAdapters[k]);

            try debtAdapter.getBalance(_asset, _vault) returns (uint256 _amount) {

                componentDebt += _amount;

            } catch {} 

        }

        return componentDebt;

    }

}
