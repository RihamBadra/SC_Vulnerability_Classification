pragma solidity 0.6.5;
pragma experimental ABIEncoderV2;

library EnumerableSet {

    

    

    

    

    

    

    

    



    struct Set {

        

        bytes32[] _values;



        

        

        mapping (bytes32 => uint256) _indexes;

    }



    

    function _add(Set storage set, bytes32 value) private returns (bool) {

        if (!_contains(set, value)) {

            set._values.push(value);

            

            

            set._indexes[value] = set._values.length;

            return true;

        } else {

            return false;

        }

    }



    

    function _remove(Set storage set, bytes32 value) private returns (bool) {

        

        uint256 valueIndex = set._indexes[value];



        if (valueIndex != 0) { 

            

            

            



            uint256 toDeleteIndex = valueIndex - 1;

            uint256 lastIndex = set._values.length - 1;



            

            



            bytes32 lastvalue = set._values[lastIndex];



            

            set._values[toDeleteIndex] = lastvalue;

            

            set._indexes[lastvalue] = toDeleteIndex + 1; 



            

            set._values.pop();



            

            delete set._indexes[value];



            return true;

        } else {

            return false;

        }

    }



    

    function _contains(Set storage set, bytes32 value) private view returns (bool) {

        return set._indexes[value] != 0;

    }



    

    function _length(Set storage set) private view returns (uint256) {

        return set._values.length;

    }



   

    function _at(Set storage set, uint256 index) private view returns (bytes32) {

        require(set._values.length > index, "EnumerableSet: index out of bounds");

        return set._values[index];

    }



    



    struct AddressSet {

        Set _inner;

    }



    

    function add(AddressSet storage set, address value) internal returns (bool) {

        return _add(set._inner, bytes32(uint256(value)));

    }



    

    function remove(AddressSet storage set, address value) internal returns (bool) {

        return _remove(set._inner, bytes32(uint256(value)));

    }



    

    function contains(AddressSet storage set, address value) internal view returns (bool) {

        return _contains(set._inner, bytes32(uint256(value)));

    }



    

    function length(AddressSet storage set) internal view returns (uint256) {

        return _length(set._inner);

    }



   

    function at(AddressSet storage set, uint256 index) internal view returns (address) {

        return address(uint256(_at(set._inner, index)));

    }





    



    struct UintSet {

        Set _inner;

    }



    

    function add(UintSet storage set, uint256 value) internal returns (bool) {

        return _add(set._inner, bytes32(value));

    }



    

    function remove(UintSet storage set, uint256 value) internal returns (bool) {

        return _remove(set._inner, bytes32(value));

    }



    

    function contains(UintSet storage set, uint256 value) internal view returns (bool) {

        return _contains(set._inner, bytes32(value));

    }



    

    function length(UintSet storage set) internal view returns (uint256) {

        return _length(set._inner);

    }



   

    function at(UintSet storage set, uint256 index) internal view returns (uint256) {

        return uint256(_at(set._inner, index));

    }

}

abstract contract Ownable {



    modifier onlyOwner {

        require(msg.sender == owner, "O: onlyOwner function!");

        _;

    }



    address public owner;



    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);



    

    constructor() internal {

        owner = msg.sender;

        emit OwnershipTransferred(address(0), msg.sender);

    }



    

    function transferOwnership(address _owner) external onlyOwner {

        require(_owner != address(0), "O: new owner is the zero address!");

        emit OwnershipTransferred(owner, _owner);

        owner = _owner;

    }

}

contract BerezkaTokenAdapterGovernance is Ownable() {



    using EnumerableSet for EnumerableSet.AddressSet;



    

    

    EnumerableSet.AddressSet private tokens;



    

    EnumerableSet.AddressSet private ethProtocols;



    

    EnumerableSet.AddressSet private protocols;



    

    mapping(address => address[]) private productVaults;



    constructor(address[] memory _tokens, address[] memory _protocols, address[] memory _ethProtocols) public {

        _add(protocols, _protocols);

        _add(tokens, _tokens);

        _add(ethProtocols, _ethProtocols);

    }



    



    function setProductVaults(address _product, address[] memory _vaults) public onlyOwner() {

        require(_product != address(0), "_product is 0");

        require(_vaults.length > 0, "_vaults.length should be > 0");



        productVaults[_product] = _vaults;

    }



    function removeProduct(address _product) public onlyOwner() {

        require(_product != address(0), "_product is 0");



        delete productVaults[_product];

    }



    function addTokens(address[] memory _tokens) public onlyOwner() {

        _add(tokens, _tokens);

    }



    function addProtocols(address[] memory _protocols) public onlyOwner() {

        _add(protocols, _protocols);

    }



    function removeTokens(address[] memory _tokens) public onlyOwner() {

        _remove(tokens, _tokens);

    }



    function removeProtocols(address[] memory _protocols) public onlyOwner() {

        _remove(protocols, _protocols);

    }



    function removeEthProtocols(address[] memory _ethProtocols) public onlyOwner() {

        _remove(ethProtocols, _ethProtocols);

    }



    



    function listTokens() external view returns (address[] memory) {

        return _list(tokens);

    }



    function listProtocols() external view returns (address[] memory) {

        return _list(protocols);

    }



    function listEthProtocols() external view returns (address[] memory) {

        return _list(ethProtocols);

    }



    function getVaults(address _token) external view returns (address[] memory) {

        return productVaults[_token];

    }



    



    function _add(EnumerableSet.AddressSet storage _set, address[] memory _addresses) internal {

        for (uint i = 0; i < _addresses.length; i++) {

            _set.add(_addresses[i]);

        }

    }



    function _remove(EnumerableSet.AddressSet storage _set, address[] memory _addresses) internal {

        for (uint i = 0; i < _addresses.length; i++) {

            _set.remove(_addresses[i]);

        }

    }



    function _list(EnumerableSet.AddressSet storage _set) internal view returns(address[] memory) {

        address[] memory result = new address[](_set.length());

        for (uint i = 0; i < _set.length(); i++) {

            result[i] = _set.at(i);

        }

        return result;

    }

}
