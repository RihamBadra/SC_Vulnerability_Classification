pragma solidity 0.7.4;

library SafeMathLib {

  function times(uint a, uint b) public pure returns (uint) {

    uint c = a * b;

    require(a == 0 || c / a == b, 'Overflow detected');

    return c;

  }



  function minus(uint a, uint b) public pure returns (uint) {

    require(b <= a, 'Underflow detected');

    return a - b;

  }



  function plus(uint a, uint b) public pure returns (uint) {

    uint c = a + b;

    require(c>=a && c>=b, 'Overflow detected');

    return c;

  }



}

interface IERC20 {

    

    function totalSupply() external view returns (uint256);



    

    function balanceOf(address account) external view returns (uint256);



    

    function transfer(address recipient, uint256 amount) external returns (bool);



    

    function allowance(address owner, address spender) external view returns (uint256);



    

    function approve(address spender, uint256 amount) external returns (bool);



    

    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);



    

    event Transfer(address indexed from, address indexed to, uint256 value);



    

    event Approval(address indexed owner, address indexed spender, uint256 value);

}

interface IERC721 {

    

    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);



    

    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);



    

    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);



    

    function balanceOf(address owner) external view returns (uint256 balance);



    

    function ownerOf(uint256 tokenId) external view returns (address owner);



    

    function safeTransferFrom(address from, address to, uint256 tokenId) external;



    

    function transferFrom(address from, address to, uint256 tokenId) external;



    

    function approve(address to, uint256 tokenId) external;



    

    function getApproved(uint256 tokenId) external view returns (address operator);



    

    function setApprovalForAll(address operator, bool _approved) external;



    

    function isApprovedForAll(address owner, address operator) external view returns (bool);



    

    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;

}

contract Trollbox {

    using SafeMathLib for uint;



    

    struct Vote {

        mapping(uint => uint) weights;

        bytes32 metadataHash;

    }



    

    struct Round {

        uint roundId;

        mapping (uint => Vote) votes;

        mapping (uint => uint) voteTotals;

        uint winningOption;

    }



    

    struct Tournament {

        uint tournamentId;

        bytes32 metadataHash;  

        uint startTime;

        uint roundLengthSeconds;

        uint tokenRoundBonus;

        uint minimumRank;

        uint voiceUBI;   

        bytes32 tokenListENS;

        address winnerOracle;  

        mapping (uint => uint) voiceCredits;

        mapping (uint => Round) rounds;

    }



    

    struct IdMetadata {

        mapping (uint => uint) lastRoundVoted;





        uint cumulativeBonus;

        uint rank;

    }



    address public management; 

    address public rankManager;

    IERC20 public token;

    IERC721 public identity;



    uint public numTournaments = 0; 

    bytes32 public siteHash;



    mapping (uint => Tournament) public tournaments; 

    mapping (uint => IdMetadata) public identities; 

    mapping (uint => uint) public tokensWon; 

    mapping (uint => mapping (uint => mapping (uint => bool))) public syncMap; 



    

    event VoteOccurred(uint indexed tournamentId, uint indexed roundId, uint indexed voterId, uint[] choices, uint[] weights, bytes32 metadata);

    event RoundResolved(uint indexed tournamentId, uint roundId, uint winningChoice);

    event TournamentCreated(uint tournamentId, bytes32 metadataHash, uint startTime, uint roundLengthSeconds, uint tokenRoundBonus, uint minimumRank, uint voiceUBI, bytes32 tokenListENS, address winnerOracle);

    event ManagementUpdated(address oldManagement, address newManagement);

    event SiteHashUpdated(bytes32 oldSiteHash, bytes32 newSiteHash);

    event RankUpdated(uint voterId, uint oldRank, uint newRank);

    event RankManagerUpdated(address oldManager, address newManager);

    event TournamentUpdated(uint tournamentId, bytes32 metadataHash, uint tokenRoundBonus, uint minimumRank, uint voiceUBI, bytes32 tokenListENS, address winnerOracle);

    event AccountSynced(uint tournamentId, uint voterId);



    modifier managementOnly() {

        require (msg.sender == management, 'Only management may call this');

        _;

    }



    constructor(address mgmt, address rankMgmt, address id) {

        management = mgmt;

        rankManager = rankMgmt;

        identity = IERC721(id);

    }



    

    function createTournament(

        bytes32 hash,

        uint startTime,

        uint roundLengthSeconds,

        uint tokenRoundBonus,

        bytes32 tokenListENS,

        address oracle,

        uint minRank,

        uint voiceUBI) public managementOnly {

        numTournaments = numTournaments.plus(1);

        Tournament storage tournament = tournaments[numTournaments];

        tournament.metadataHash = hash;

        tournament.startTime = startTime == 0 ? block.timestamp : startTime;

        tournament.tournamentId = numTournaments;

        tournament.roundLengthSeconds = roundLengthSeconds;

        tournament.tokenRoundBonus = tokenRoundBonus;

        tournament.minimumRank = minRank;

        tournament.voiceUBI = voiceUBI;

        tournament.tokenListENS = tokenListENS;

        tournament.winnerOracle = oracle;

        emit TournamentCreated(numTournaments, hash, startTime, roundLengthSeconds, tokenRoundBonus, minRank, voiceUBI, tokenListENS, oracle);

    }







    

    function resolveRound(uint tournamentId, uint roundId, uint winningOption) public {

        Tournament storage tournament = tournaments[tournamentId];

        require(msg.sender == tournament.winnerOracle, 'Only winner oracle can call this');

        uint currentRoundId = getCurrentRoundId(tournamentId);

        Round storage round = tournament.rounds[roundId];

        require(roundAlreadyResolved(tournamentId, roundId) == false, 'Round already resolved');

        require(currentRoundId > roundId + 1, 'Too early to resolve');

        round.roundId = roundId;

        round.winningOption = winningOption;

        emit RoundResolved(tournamentId, roundId, winningOption);

    }



    function voteCheck(uint voterId, uint tournamentId, uint roundId) internal view {

        require(roundId > 0, 'Tournament not started yet');

        require(identity.ownerOf(voterId) == msg.sender, 'Must own identity to vote with it');

        require(roundId > identities[voterId].lastRoundVoted[tournamentId], 'Can only vote one time per round');

        require(tournaments[tournamentId].minimumRank <= identities[voterId].rank, 'Insufficient rank to participate in this tournament');

    }



    

    function vote(

        uint voterId,

        uint tournamentId,

        uint[] memory choices,

        uint[] memory weights,

        bytes32 hash,

        uint updateRoundId

    ) public {

        uint roundId = getCurrentRoundId(tournamentId);

        Round storage currentRound = tournaments[tournamentId].rounds[roundId];



        voteCheck(voterId, tournamentId, roundId);

        require(choices.length == weights.length, 'Mismatched choices and lengths');



        updateAccount(voterId, tournamentId, updateRoundId);



        identities[voterId].lastRoundVoted[tournamentId] = roundId;



        Vote storage currentVote = currentRound.votes[voterId];

        currentVote.metadataHash = hash;

        uint balance = getVoiceCredits(tournamentId, voterId);

        uint sum = 0;



        for (uint i = 0; i < weights.length; i++) {

            currentVote.weights[choices[i]] = weights[i];

            currentRound.voteTotals[choices[i]] = currentRound.voteTotals[choices[i]].plus(weights[i]);

            sum = sum.plus(weights[i].times(weights[i]));

        }

        require(sum <= balance, 'Must not spend more than your balance');



        emit VoteOccurred(tournamentId, roundId, voterId, choices, weights, hash);

    }



    function withdrawWinnings(uint voterId) public {

        uint winnings = tokensWon[voterId];

        address owner = identity.ownerOf(voterId);

        require(winnings > 0, 'Nothing to withdraw');

        

        tokensWon[voterId] = 0;

        token.transfer(owner, winnings);

    }



    

    function updateAccount(uint voterId, uint tournamentId, uint roundId) public {

        IdMetadata storage id = identities[voterId];

        Tournament storage tournament = tournaments[tournamentId];

        bool roundResolved = roundAlreadyResolved(tournamentId, roundId);

        bool shouldSync = isSynced(voterId, tournamentId, roundId) == false;



        if (shouldSync && roundResolved) {

            

            syncMap[voterId][tournamentId][roundId] = true; 



            (uint voiceCreditBonus, uint tokenBonus) = getRoundBonus(voterId, tournamentId, roundId);

            tournament.voiceCredits[voterId] = getVoiceCredits(tournamentId, voterId).plus(voiceCreditBonus);

            tokensWon[voterId] = tokensWon[voterId].plus(tokenBonus);

            id.cumulativeBonus = id.cumulativeBonus.plus(voiceCreditBonus);

            emit AccountSynced(tournamentId, voterId);

        }

    }







    function getRound(uint tournamentId, uint roundId) public view returns (uint[2] memory) {

        Round storage round = tournaments[tournamentId].rounds[roundId];

        return [round.roundId, round.winningOption];

    }



    

    function getCurrentRoundId(uint tournamentId) public view returns (uint) {

        Tournament storage tournament = tournaments[tournamentId];

        uint startTime = tournament.startTime;

        uint roundLengthSeconds = tournament.roundLengthSeconds;

        if (block.timestamp >= startTime) {

            return 1 + ((block.timestamp - startTime) / roundLengthSeconds);

        } else {

            return 0;

        }

    }



    function getVoiceCredits(uint tournamentId, uint voterId) public view returns (uint) {

        Tournament storage tournament = tournaments[tournamentId];

        uint voiceCredits = tournament.voiceCredits[voterId];

        if (voiceCredits > 0) {

            return voiceCredits;

        } else {

            return tournament.voiceUBI;

        }

    }



    function getLastRoundVoted(uint tournamentId, uint voterId) public view returns (uint) {

        return identities[voterId].lastRoundVoted[tournamentId];

    }



    function getVoteTotals(uint tournamentId, uint roundId, uint option) public view returns (uint) {

        return tournaments[tournamentId].rounds[roundId].voteTotals[option];

    }



    function getVoteMetadata(uint tournamentId, uint roundId, uint voterId) public view returns (bytes32) {

        return tournaments[tournamentId].rounds[roundId].votes[voterId].metadataHash;

    }



    function getVoiceUBI(uint tournamentId) public view  returns (uint)  {

        return tournaments[tournamentId].voiceUBI;

    }



    function getRoundResults(uint voterId, uint tournamentId, uint roundId) public view returns (uint, uint) {

        Tournament storage tournament = tournaments[tournamentId];

        Round storage round = tournament.rounds[roundId];

        Vote storage thisVote = round.votes[voterId];

        return (thisVote.weights[round.winningOption], round.voteTotals[round.winningOption]);

    }



    

    function getRoundBonus(uint voterId, uint tournamentId, uint roundId) public view returns (uint, uint) {

        Tournament storage tournament = tournaments[tournamentId];

        (uint voteWeight, uint totalVotes) = getRoundResults(voterId, tournamentId, roundId);

        uint tokenBonus = 0;

        

        if (totalVotes > 0) {

            tokenBonus = tournament.tokenRoundBonus.times(voteWeight) / totalVotes;

        }

        uint voiceCreditBonus = voteWeight.times(voteWeight);

        return (voiceCreditBonus, tokenBonus);

    }



    function isSynced(uint voterId, uint tournamentId, uint roundId) public view returns (bool) {

        return syncMap[voterId][tournamentId][roundId];

    }



    function roundAlreadyResolved(uint tournamentId, uint roundId) public view returns (bool) {

        return tournaments[tournamentId].rounds[roundId].winningOption > 0;

    }







    

    function setSiteHash(bytes32 newHash) public managementOnly {

        bytes32 oldHash = siteHash;

        siteHash = newHash;

        emit SiteHashUpdated(oldHash, newHash);

    }



    function setRank(uint voterId, uint newRank) public {

        require(msg.sender == rankManager, 'Only rankManager may call this');

        IdMetadata storage id = identities[voterId];

        uint oldRank = id.rank;

        id.rank = newRank;

        emit RankUpdated(voterId, oldRank, newRank);

    }



    function setToken(address tokenAddr) public managementOnly {

        token = IERC20(tokenAddr);

    }



    function updateTournament(uint tournamentId, bytes32 newMetadata, uint newBonus,  uint newMinRank, uint newUBI, bytes32 newTokenList, address newOracle) public managementOnly {

        Tournament storage tournament = tournaments[tournamentId];

        tournament.metadataHash = newMetadata;

        

        tournament.tokenRoundBonus = newBonus;

        tournament.minimumRank = newMinRank;

        tournament.voiceUBI = newUBI;

        tournament.tokenListENS = newTokenList;

        tournament.winnerOracle = newOracle;

        emit TournamentUpdated(tournamentId, newMetadata, newBonus, newMinRank, newUBI, newTokenList, newOracle);

    }



    function setRankManager(address newManager) public managementOnly {

        address oldManager = rankManager;

        rankManager = newManager;

        emit RankManagerUpdated(oldManager, newManager);

    }



    

    function setManagement(address newMgmt) public managementOnly {

        address oldMgmt =  management;

        management = newMgmt;

        emit ManagementUpdated(oldMgmt, newMgmt);

    }





}
