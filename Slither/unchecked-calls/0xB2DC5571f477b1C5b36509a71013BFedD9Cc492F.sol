pragma solidity 0.6.6;

contract VRFRequestIDBase {



  

  function makeVRFInputSeed(bytes32 _keyHash, uint256 _userSeed,

    address _requester, uint256 _nonce)

    internal pure returns (uint256)

  {

    return  uint256(keccak256(abi.encode(_keyHash, _userSeed, _requester, _nonce)));

  }



  

  function makeRequestId(

    bytes32 _keyHash, uint256 _vRFInputSeed) internal pure returns (bytes32) {

    return keccak256(abi.encodePacked(_keyHash, _vRFInputSeed));

  }

}

interface LinkTokenInterface {

  function allowance(address owner, address spender) external view returns (uint256 remaining);

  function approve(address spender, uint256 value) external returns (bool success);

  function balanceOf(address owner) external view returns (uint256 balance);

  function decimals() external view returns (uint8 decimalPlaces);

  function decreaseApproval(address spender, uint256 addedValue) external returns (bool success);

  function increaseApproval(address spender, uint256 subtractedValue) external;

  function name() external view returns (string memory tokenName);

  function symbol() external view returns (string memory tokenSymbol);

  function totalSupply() external view returns (uint256 totalTokensIssued);

  function transfer(address to, uint256 value) external returns (bool success);

  function transferAndCall(address to, uint256 value, bytes calldata data) external returns (bool success);

  function transferFrom(address from, address to, uint256 value) external returns (bool success);

}

library SafeMath {

  

  function add(uint256 a, uint256 b) internal pure returns (uint256) {

    uint256 c = a + b;

    require(c >= a, "SafeMath: addition overflow");



    return c;

  }



  

  function sub(uint256 a, uint256 b) internal pure returns (uint256) {

    require(b <= a, "SafeMath: subtraction overflow");

    uint256 c = a - b;



    return c;

  }



  

  function mul(uint256 a, uint256 b) internal pure returns (uint256) {

    

    

    

    if (a == 0) {

      return 0;

    }



    uint256 c = a * b;

    require(c / a == b, "SafeMath: multiplication overflow");



    return c;

  }



  

  function div(uint256 a, uint256 b) internal pure returns (uint256) {

    

    require(b > 0, "SafeMath: division by zero");

    uint256 c = a / b;

    



    return c;

  }



  

  function mod(uint256 a, uint256 b) internal pure returns (uint256) {

    require(b != 0, "SafeMath: modulo by zero");

    return a % b;

  }

}

abstract contract Context {

    function _msgSender() internal view virtual returns (address payable) {

        return msg.sender;

    }



    function _msgData() internal view virtual returns (bytes memory) {

        this; 

        return msg.data;

    }

}

contract Ownable is Context {

    address private _owner;



    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);



    

    constructor () internal {

        address msgSender = _msgSender();

        _owner = msgSender;

        emit OwnershipTransferred(address(0), msgSender);

    }



    

    function owner() public view returns (address) {

        return _owner;

    }



    

    modifier onlyOwner() {

        require(_owner == _msgSender(), "Ownable: caller is not the owner");

        _;

    }



    

    function renounceOwnership() public virtual onlyOwner {

        emit OwnershipTransferred(_owner, address(0));

        _owner = address(0);

    }



    

    function transferOwnership(address newOwner) public virtual onlyOwner {

        require(newOwner != address(0), "Ownable: new owner is the zero address");

        emit OwnershipTransferred(_owner, newOwner);

        _owner = newOwner;

    }

}

library SafeCast {



    

    function toUint128(uint256 value) internal pure returns (uint128) {

        require(value < 2**128, "SafeCast: value doesn\'t fit in 128 bits");

        return uint128(value);

    }



    

    function toUint64(uint256 value) internal pure returns (uint64) {

        require(value < 2**64, "SafeCast: value doesn\'t fit in 64 bits");

        return uint64(value);

    }



    

    function toUint32(uint256 value) internal pure returns (uint32) {

        require(value < 2**32, "SafeCast: value doesn\'t fit in 32 bits");

        return uint32(value);

    }



    

    function toUint16(uint256 value) internal pure returns (uint16) {

        require(value < 2**16, "SafeCast: value doesn\'t fit in 16 bits");

        return uint16(value);

    }



    

    function toUint8(uint256 value) internal pure returns (uint8) {

        require(value < 2**8, "SafeCast: value doesn\'t fit in 8 bits");

        return uint8(value);

    }



    

    function toUint256(int256 value) internal pure returns (uint256) {

        require(value >= 0, "SafeCast: value must be positive");

        return uint256(value);

    }



    

    function toInt128(int256 value) internal pure returns (int128) {

        require(value >= -2**127 && value < 2**127, "SafeCast: value doesn\'t fit in 128 bits");

        return int128(value);

    }



    

    function toInt64(int256 value) internal pure returns (int64) {

        require(value >= -2**63 && value < 2**63, "SafeCast: value doesn\'t fit in 64 bits");

        return int64(value);

    }



    

    function toInt32(int256 value) internal pure returns (int32) {

        require(value >= -2**31 && value < 2**31, "SafeCast: value doesn\'t fit in 32 bits");

        return int32(value);

    }



    

    function toInt16(int256 value) internal pure returns (int16) {

        require(value >= -2**15 && value < 2**15, "SafeCast: value doesn\'t fit in 16 bits");

        return int16(value);

    }



    

    function toInt8(int256 value) internal pure returns (int8) {

        require(value >= -2**7 && value < 2**7, "SafeCast: value doesn\'t fit in 8 bits");

        return int8(value);

    }



    

    function toInt256(uint256 value) internal pure returns (int256) {

        require(value < 2**255, "SafeCast: value doesn't fit in an int256");

        return int256(value);

    }

}

interface RNGInterface {



  

  

  

  event RandomNumberRequested(uint32 indexed requestId, address indexed sender);



  

  

  

  event RandomNumberCompleted(uint32 indexed requestId, uint256 randomNumber);



  

  

  function getLastRequestId() external view returns (uint32 requestId);



  

  

  

  function getRequestFee() external view returns (address feeToken, uint256 requestFee);



  

  

  

  

  

  

  function requestRandomNumber() external returns (uint32 requestId, uint32 lockBlock);



  

  

  

  

  function isRequestComplete(uint32 requestId) external view returns (bool isCompleted);



  

  

  

  function randomNumber(uint32 requestId) external returns (uint256 randomNum);

}

abstract contract VRFConsumerBase is VRFRequestIDBase {



  using SafeMath_Chainlink for uint256;



  

  function fulfillRandomness(bytes32 requestId, uint256 randomness)

    internal virtual;



  

  function requestRandomness(bytes32 _keyHash, uint256 _fee, uint256 _seed)

    public returns (bytes32 requestId)

  {

    LINK.transferAndCall(vrfCoordinator, _fee, abi.encode(_keyHash, _seed));

    

    

    

    uint256 vRFSeed  = makeVRFInputSeed(_keyHash, _seed, address(this), nonces[_keyHash]);

    

    

    

    

    

    nonces[_keyHash] = nonces[_keyHash].add(1);

    return makeRequestId(_keyHash, vRFSeed);

  }



  LinkTokenInterface immutable internal LINK;

  address immutable private vrfCoordinator;



  

  

  

  mapping(bytes32  => uint256 ) public nonces;

  constructor(address _vrfCoordinator, address _link) public {

    vrfCoordinator = _vrfCoordinator;

    LINK = LinkTokenInterface(_link);

  }



  

  

  

  function rawFulfillRandomness(bytes32 requestId, uint256 randomness) external {

    require(msg.sender == vrfCoordinator, "Only VRFCoordinator can fulfill");

    fulfillRandomness(requestId, randomness);

  }

}

contract RNGChainlink is RNGInterface, VRFConsumerBase, Ownable {

  

  using SafeCast for uint256;



  event KeyHashSet(bytes32 keyHash);

  event FeeSet(uint256 fee);

  event VrfCoordinatorSet(address indexed vrfCoordinator);

  event VRFRequested(uint256 indexed requestId, bytes32 indexed chainlinkRequestId);



  

  bytes32 public keyHash;



  

  uint256 public fee;



  

  uint32 public requestCount;



  

  mapping(uint32 => uint256) internal randomNumbers;



  

  mapping(uint32 => uint32) internal requestLockBlock;



  

  mapping(bytes32 => uint32) internal chainlinkRequestIds;



  

  constructor(address _vrfCoordinator, address _link)

    public

    VRFConsumerBase(_vrfCoordinator, _link)

  {

    emit VrfCoordinatorSet(_vrfCoordinator);

  }



  function getLink() external view returns (address) {

    return address(LINK);

  }



  

  

  function setKeyhash(bytes32 _keyhash) external onlyOwner {

    keyHash = _keyhash;



    emit KeyHashSet(keyHash);

  }



  

  

  function setFee(uint256 _fee) external onlyOwner {

    fee = _fee;



    emit FeeSet(fee);

  }



  

  

  function getLastRequestId() external override view returns (uint32 requestId) {

    return requestCount;

  }



  

  

  

  function getRequestFee() external override view returns (address feeToken, uint256 requestFee) {

    return (address(LINK), fee);

  }



  

  

  

  

  

  

  function requestRandomNumber() external override returns (uint32 requestId, uint32 lockBlock) {

    uint256 seed = _getSeed();

    lockBlock = uint32(block.number);



    

    require(LINK.transferFrom(msg.sender, address(this), fee), "RNGChainlink/fee-transfer-failed");



    

    requestId = _requestRandomness(seed);



    requestLockBlock[requestId] = lockBlock;



    emit RandomNumberRequested(requestId, msg.sender);

  }



  

  

  

  

  function isRequestComplete(uint32 requestId) external override view returns (bool isCompleted) {

    return randomNumbers[requestId] != 0;

  }



  

  

  

  function randomNumber(uint32 requestId) external override returns (uint256 randomNum) {

    return randomNumbers[requestId];

  }



  

  

  

  function _requestRandomness(uint256 seed) internal returns (uint32 requestId) {

    

    requestId = _getNextRequestId();



    

    bytes32 vrfRequestId = requestRandomness(keyHash, fee, seed);

    chainlinkRequestIds[vrfRequestId] = requestId;



    emit VRFRequested(requestId, vrfRequestId);

  }



  

  

  

  function fulfillRandomness(bytes32 requestId, uint256 randomness) internal override {

    uint32 internalRequestId = chainlinkRequestIds[requestId];



    

    randomNumbers[internalRequestId] = randomness;



    emit RandomNumberCompleted(internalRequestId, randomness);

  }



  

  

  function _getNextRequestId() internal returns (uint32 requestId) {

    requestCount = uint256(requestCount).add(1).toUint32();

    requestId = requestCount;

  }



  

  

  function _getSeed() internal virtual view returns (uint256 seed) {

    return uint256(blockhash(block.number - 1));

  }

}
