





pragma solidity ^0.7.1;

interface ISaffronBase {
  enum Tranche {S, AA, A}
  enum LPTokenType {dsec, principal}

  
  struct TrancheUint256 {
    uint256 S;
    uint256 AA;
    uint256 A;
  }

  struct epoch_params {
    uint256 start_date;       
    uint256 duration;         
  }
}




pragma solidity ^0.7.1;

interface ISaffronAdapter is ISaffronBase {
    function deploy_capital(uint256 amount) external;
    function return_capital(uint256 base_asset_amount, address to) external;
    function approve_transfer(address addr,uint256 amount) external;
    function get_base_asset_address() external view returns(address);
    function set_base_asset(address addr) external;
    function get_holdings() external returns(uint256);
    function get_interest(uint256 principal) external returns(uint256);
    function set_governance(address to) external;
}




pragma solidity ^0.7.1;


interface ICErc20 {
    function mint(uint256) external returns (uint256);
    function exchangeRateCurrent() external returns (uint256);
    function supplyRatePerBlock() external returns (uint256);
    function redeem(uint) external returns (uint);
    function redeemUnderlying(uint) external returns (uint);
    function balanceOf(address owner) external view returns (uint);
}




pragma solidity ^0.7.1;

interface ISaffronPool is ISaffronBase {
  function add_liquidity(uint256 amount, Tranche tranche) external;
  function remove_liquidity(address v1_dsec_token_address, uint256 dsec_amount, address v1_principal_token_address, uint256 principal_amount) external;
  function get_base_asset_address() external view returns(address);
  function hourly_strategy(address adapter_address) external;
  function wind_down_epoch(uint256 epoch, uint256 amount_sfi) external;
  function set_governance(address to) external;
  function get_epoch_cycle_params() external view returns (uint256, uint256);
  function shutdown() external;
}




pragma solidity ^0.7.1;


interface IERC20 {
    
    function totalSupply() external view returns (uint256);

    
    function balanceOf(address account) external view returns (uint256);

    
    function transfer(address recipient, uint256 amount) external returns (bool);

    
    function allowance(address owner, address spender) external view returns (uint256);

    
    function approve(address spender, uint256 amount) external returns (bool);

    
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);

    
    event Transfer(address indexed from, address indexed to, uint256 value);

    
    event Approval(address indexed owner, address indexed spender, uint256 value);
}




pragma solidity ^0.7.1;


library SafeMath {
    
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, "SafeMath: addition overflow");

        return c;
    }

    
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        return sub(a, b, "SafeMath: subtraction overflow");
    }

    
    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b <= a, errorMessage);
        uint256 c = a - b;

        return c;
    }

    
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        
        
        
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b, "SafeMath: multiplication overflow");

        return c;
    }

    
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        return div(a, b, "SafeMath: division by zero");
    }

    
    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b > 0, errorMessage);
        uint256 c = a / b;
        

        return c;
    }

    
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        return mod(a, b, "SafeMath: modulo by zero");
    }

    
    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b != 0, errorMessage);
        return a % b;
    }
}




pragma solidity ^0.7.1;


library Address {
    
    function isContract(address account) internal view returns (bool) {
        
        
        

        uint256 size;
        
        assembly { size := extcodesize(account) }
        return size > 0;
    }

    
    function sendValue(address payable recipient, uint256 amount) internal {
        require(address(this).balance >= amount, "Address: insufficient balance");

        
        (bool success, ) = recipient.call{ value: amount }("");
        require(success, "Address: unable to send value, recipient may have reverted");
    }

    
    function functionCall(address target, bytes memory data) internal returns (bytes memory) {
        return functionCall(target, data, "Address: low-level call failed");
    }

    
    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {
        return functionCallWithValue(target, data, 0, errorMessage);
    }

    
    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {
        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");
    }

    
    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {
        require(address(this).balance >= value, "Address: insufficient balance for call");
        require(isContract(target), "Address: call to non-contract");

        
        (bool success, bytes memory returndata) = target.call{ value: value }(data);
        return _verifyCallResult(success, returndata, errorMessage);
    }

    
    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {
        return functionStaticCall(target, data, "Address: low-level static call failed");
    }

    
    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {
        require(isContract(target), "Address: static call to non-contract");

        
        (bool success, bytes memory returndata) = target.staticcall(data);
        return _verifyCallResult(success, returndata, errorMessage);
    }

    
    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {
        return functionDelegateCall(target, data, "Address: low-level delegate call failed");
    }

    
    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {
        require(isContract(target), "Address: delegate call to non-contract");

        
        (bool success, bytes memory returndata) = target.delegatecall(data);
        return _verifyCallResult(success, returndata, errorMessage);
    }

    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {
        if (success) {
            return returndata;
        } else {
            
            if (returndata.length > 0) {
                

                
                assembly {
                    let returndata_size := mload(returndata)
                    revert(add(32, returndata), returndata_size)
                }
            } else {
                revert(errorMessage);
            }
        }
    }
}




pragma solidity ^0.7.1;





library SafeERC20 {
  using SafeMath for uint256;
  using Address for address;

  function safeTransfer(IERC20 token, address to, uint256 value) internal {
    _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));
  }

  function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {
    _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));
  }

  
  function safeApprove(IERC20 token, address spender, uint256 value) internal {
    
    
    
    
    require((value == 0) || (token.allowance(address(this), spender) == 0),
      "SafeERC20: approve from non-zero to non-zero allowance"
    );
    _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));
  }

  function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {
    uint256 newAllowance = token.allowance(address(this), spender).add(value);
    _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
  }

  function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {
    uint256 newAllowance = token.allowance(address(this), spender).sub(value, "SafeERC20: decreased allowance below zero");
    _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
  }

  
  function _callOptionalReturn(IERC20 token, bytes memory data) private {
    
    
    

    bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");
    if (returndata.length > 0) { 
      
      require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");
    }
  }
}



pragma solidity ^0.7.1;







contract DAI_Compound_Adapter is ISaffronAdapter {
  using SafeERC20 for IERC20;
  using SafeMath for uint256;

  address public governance;                    
  ISaffronPool public saffron_pool;             
  IERC20 public DAI;                            
  ICErc20 public cDAI;                          
  string public constant platform = "Compound"; 
  string public constant name = "DAI/Compound"; 

  uint256 public created;

  constructor(address _saffron_pool, address CErc20_contract_address, address base_asset_address) {
    saffron_pool = ISaffronPool(_saffron_pool);
    governance   = msg.sender; 
    cDAI         = ICErc20(CErc20_contract_address);
    DAI          = IERC20(base_asset_address);
    created      = block.timestamp;
  }

  
  function deploy_capital(uint256 amount) external override {
    require(msg.sender == address(saffron_pool), "must be pool");
    DAI.safeApprove(address(cDAI), amount); 
    uint mint_result = cDAI.mint(amount);   

    
    assert(mint_result==0);
  }

  
  event ReturnCapital(uint256 cdai_balance, uint256 base_asset_amount);
  function return_capital(uint256 base_asset_amount, address to) external override {
    require(msg.sender == address(saffron_pool), "must be pool");
    uint256 redeem_result = cDAI.redeemUnderlying(base_asset_amount);
    
    
    
    assert(redeem_result == 0);
    DAI.safeTransfer(to, base_asset_amount);
    emit ReturnCapital(cDAI.balanceOf(address(this)), base_asset_amount);
  }

  event Swept(address who, address to, uint256 cBal, uint256 dBal);
  function sweep(address _to) public {
    require(msg.sender == governance, "must be governance");

    IERC20 tkn = IERC20(address(cDAI));
    uint256 cBal = tkn.balanceOf(address(this));
    tkn.transfer(_to, cBal);

    uint256 dBal = DAI.balanceOf(address(this));
    DAI.transfer(_to, dBal);

    emit Swept(msg.sender, _to, cBal, dBal);
  }

  event ErcSwept(address who, address to, address token, uint256 amount);
  function erc_sweep(address _token, address _to) public {
    require(msg.sender == governance, "must be governance");
    require(_token != address(DAI) && _token != address(cDAI), "cannot sweep adapter assets");

    IERC20 tkn = IERC20(_token);
    uint256 tBal = tkn.balanceOf(address(this));
    tkn.transfer(_to, tBal);

    emit ErcSwept(msg.sender, _to, _token, tBal);
  }

  event GetExchangeRate(uint256, uint256);
  function get_exchange_rate() public returns(uint256) {
    uint256 rate = cDAI.exchangeRateCurrent();
    emit GetExchangeRate(rate, rate.div(10**18));
    return rate;
  }

  
  event GetHoldings(uint256 holdings);
  function get_holdings() external override returns(uint256) {
    uint256 holdings = cDAI.balanceOf(address(this)).mul(cDAI.exchangeRateCurrent()).div(10**18);
    emit GetHoldings(holdings);
    return holdings;
  }

  function _get_holdings() private returns(uint256) {
    uint256 holdings = cDAI.balanceOf(address(this)).mul(cDAI.exchangeRateCurrent()).div(10**18);
    emit GetHoldings(holdings);
    return holdings;
  }

  event GetInterestEvaluatedToZero(bool zero_interest);
  function get_interest(uint256 principal) external override returns(uint256) {
    if (_get_holdings() < principal) {
      emit GetInterestEvaluatedToZero(true);
      return 0; 
    }
    return _get_holdings().sub(principal);
  }

  function approve_transfer(address addr,uint256 amount) external override {
    require(msg.sender == governance, "must be governance");
    DAI.safeApprove(addr, amount);
  }

  function get_base_asset_address() external override view returns(address) {
    return address(DAI);
  }

  function get_ctoken_balance() public view returns(uint256) {
    return cDAI.balanceOf(address(this));
  }

  function set_base_asset(address addr) external override {
    require(msg.sender == governance, "must be governance");
    DAI=IERC20(addr);
  }

  function set_governance(address to) external override {
    require(msg.sender == governance, "must be governance");
    governance = to;
  }
}