pragma solidity 0.6.5;
pragma experimental ABIEncoderV2;

struct ProtocolBalance {

    ProtocolMetadata metadata;

    AdapterBalance[] adapterBalances;

}

struct ProtocolMetadata {

    string name;

    string description;

    string websiteURL;

    string iconURL;

    uint256 version;

}

struct AdapterBalance {

    AdapterMetadata metadata;

    FullTokenBalance[] balances;

}

struct AdapterMetadata {

    address adapterAddress;

    string adapterType; 

}

struct FullTokenBalance {

    TokenBalance base;

    TokenBalance[] underlying;

}

struct TokenBalance {

    TokenMetadata metadata;

    uint256 amount;

}

struct TokenMetadata {

    address token;

    string name;

    string symbol;

    uint8 decimals;

}

struct Component {

    address token;

    string tokenType;  

    uint256 rate;  

}

struct TypedToken {

    string tokenType;

    address token;

}

interface ERC20 {

    function approve(address, uint256) external returns (bool);

    function transfer(address, uint256) external returns (bool);

    function transferFrom(address, address, uint256) external returns (bool);

    function name() external view returns (string memory);

    function symbol() external view returns (string memory);

    function decimals() external view returns (uint8);

    function totalSupply() external view returns (uint256);

    function balanceOf(address) external view returns (uint256);

}

abstract contract Ownable {



    modifier onlyOwner {

        require(msg.sender == owner, "O: onlyOwner function!");

        _;

    }



    address public owner;



    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);



    

    constructor() internal {

        owner = msg.sender;

        emit OwnershipTransferred(address(0), msg.sender);

    }



    

    function transferOwnership(address _owner) external onlyOwner {

        require(_owner != address(0), "O: new owner is the zero address!");

        emit OwnershipTransferred(owner, _owner);

        owner = _owner;

    }

}

interface ProtocolAdapter {



    

    function adapterType() external pure returns (string memory);



    

    function tokenType() external pure returns (string memory);



    

    function getBalance(address token, address account) external view returns (uint256);

}

interface TokenAdapter {



    

    function getMetadata(address token) external view returns (TokenMetadata memory);



    

    function getComponents(address token) external view returns (Component[] memory);

}

interface IBerezkaTokenAdapterGovernance {

    

    function listTokens() external view returns (TypedToken[] memory);



    function listProtocols() external view returns (address[] memory);



    function listEthProtocols() external view returns (address[] memory);



    function listProducts() external view returns (address[] memory);



    function getVaults(address _token) external view returns (address[] memory);

}

contract BerezkaTokenAdapter is TokenAdapter {



    address internal constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;



    string internal constant ERC20_TOKEN = "ERC20";



    IBerezkaTokenAdapterGovernance immutable private governance;



    constructor(address _governance) public {

        governance = IBerezkaTokenAdapterGovernance(_governance);

    }



    

    function getMetadata(address token) 

        external 

        view 

        override 

        returns (TokenMetadata memory) 

    {

        return TokenMetadata({

            token: token,

            name: ERC20(token).name(),

            symbol: ERC20(token).symbol(),

            decimals: ERC20(token).decimals()

        });

    }



    

    function getComponents(address token)

        external

        view

        override

        returns (Component[] memory)

    {

        address[] memory vaults = governance.getVaults(token);

        TypedToken[] memory assets = governance.listTokens();

        address[] memory debtAdapters = governance.listProtocols();

        uint256 length = assets.length;

        uint256 totalSupply = ERC20(token).totalSupply();



        Component[] memory underlyingTokens = new Component[](1 + length);

        

        

        for (uint256 i = 0; i < length; i++) {

            Component memory tokenComponent =

                _getTokenComponents(

                    assets[i].token, 

                    assets[i].tokenType, 

                    vaults, 

                    debtAdapters, 

                    totalSupply

                );

            underlyingTokens[i] = tokenComponent;

        }



        

        {

            Component memory ethComponent = _getEthComponents(vaults, totalSupply);

            underlyingTokens[length] = ethComponent;

        }

        

        return underlyingTokens;

    }



    



    function _getEthComponents(

        address[] memory _vaults,

        uint256 _totalSupply

    )

        internal

        view

        returns (Component memory)

    {

        address[] memory debtsInEth = governance.listEthProtocols();



        uint256 ethBalance = 0;

        uint256 ethDebt = 0;



        

        for (uint256 j = 0; j < _vaults.length; j++) {

            address vault = _vaults[j];

            ethBalance += vault.balance;

            ethDebt += _computeDebt(debtsInEth, ETH, vault);

        }



        return Component({

            token: ETH,

            tokenType: ERC20_TOKEN,

            rate: (ethBalance * 1e18 / _totalSupply) - (ethDebt * 1e18 / _totalSupply)

        });

    }



    function _getTokenComponents(

        address _asset,

        string memory _type,

        address[] memory _vaults,

        address[] memory _debtAdapters,

        uint256 _totalSupply

    ) 

        internal

        view

        returns (Component memory)

    {

        uint256 componentBalance = 0;

        uint256 componentDebt = 0;



        

        uint256 vaultsLength = _vaults.length;

        for (uint256 j = 0; j < vaultsLength; j++) {

            address vault = _vaults[j];

            componentBalance += ERC20(_asset).balanceOf(vault);

            componentDebt += _computeDebt(_debtAdapters, _asset, vault);

        }



        

        return(Component({

            token: _asset,

            tokenType: _type,

            rate: (componentBalance * 1e18 / _totalSupply) - (componentDebt * 1e18 / _totalSupply)

        }));

    }



    function _computeDebt(

        address[] memory _debtAdapters,

        address _asset,

        address _vault

    ) 

        internal

        view

        returns (uint256)

    {

        

        uint256 componentDebt = 0;

        uint256 debtsLength = _debtAdapters.length;

        for (uint256 k = 0; k < debtsLength; k++) {

            ProtocolAdapter debtAdapter = ProtocolAdapter(_debtAdapters[k]);

            try debtAdapter.getBalance(_asset, _vault) returns (uint256 _amount) {

                componentDebt += _amount;

            } catch {} 

        }

        return componentDebt;

    }

}

interface AdapterRegistry {



    function isValidTokenAdapter(

        string calldata tokenAdapterName

    ) 

        external 

        returns (bool);

}

contract BerezkaTokenAdapterGovernance is Ownable() {



    AdapterRegistry internal constant ADAPTER_REGISTRY = 

        AdapterRegistry(0x06FE76B2f432fdfEcAEf1a7d4f6C3d41B5861672);



    using EnumerableSet for EnumerableSet.AddressSet;



    

    

    mapping (string => EnumerableSet.AddressSet) private tokens;



    

    

    string[] public tokenTypes;



    

    EnumerableSet.AddressSet private ethProtocols;



    

    EnumerableSet.AddressSet private protocols;



    

    mapping(address => address[]) private productVaults;



    constructor(address[] memory _protocols, address[] memory _ethProtocols) public {

        _add(protocols, _protocols);

        _add(ethProtocols, _ethProtocols);

    }



    



    function setProductVaults(address _product, address[] memory _vaults) public onlyOwner() {

        require(_product != address(0), "_product is 0");

        require(_vaults.length > 0, "_vaults.length should be > 0");



        productVaults[_product] = _vaults;

    }



    function removeProduct(address _product) public onlyOwner() {

        require(_product != address(0), "_product is 0");



        delete productVaults[_product];

    }



    function addTokens(string memory _type, address[] memory _tokens) public onlyOwner() {

        require(_tokens.length > 0, "Length should be > 0");

        require(ADAPTER_REGISTRY.isValidTokenAdapter(_type), "Invalid token adapter name");



        if (tokens[_type].length() == 0) {

            tokenTypes.push(_type);

        }

        _add(tokens[_type], _tokens);

    }



    function addProtocols(address[] memory _protocols) public onlyOwner() {

        require(_protocols.length > 0, "Length should be > 0");



        _add(protocols, _protocols);

    }



    function addEthProtocols(address[] memory _ethProtocols) public onlyOwner() {

        require(_ethProtocols.length > 0, "Length should be > 0");



        _add(ethProtocols, _ethProtocols);

    }



    function removeTokens(string memory _type, address[] memory _tokens) public onlyOwner() {

        require(_tokens.length > 0, "Length should be > 0");



        _remove(tokens[_type], _tokens);

    }



    function removeProtocols(address[] memory _protocols) public onlyOwner() {

        require(_protocols.length > 0, "Length should be > 0");



        _remove(protocols, _protocols);

    }



    function removeEthProtocols(address[] memory _ethProtocols) public onlyOwner() {

        require(_ethProtocols.length > 0, "Length should be > 0");



        _remove(ethProtocols, _ethProtocols);

    }



    function setTokenTypes(string[] memory _tokenTypes) public onlyOwner() {

        require(_tokenTypes.length > 0, "Length should be > 0");



        tokenTypes = _tokenTypes;

    }



    



    function listTokens() external view returns (TypedToken[] memory) {

        uint256 tokenLength = tokenTypes.length;

        uint256 resultLength = 0;

        for (uint256 i = 0; i < tokenLength; i++) {

            resultLength += tokens[tokenTypes[i]].length();

        }

        TypedToken[] memory result = new TypedToken[](resultLength);

        uint256 resultIndex = 0;

        for (uint256 i = 0; i < tokenLength; i++) {

            string memory tokenType = tokenTypes[i];

            address[] memory typedTokens = _list(tokens[tokenType]);

            uint256 typedTokenLength = typedTokens.length;

            for (uint256 j = 0; j < typedTokenLength; j++) {

                result[resultIndex] = TypedToken(tokenType, typedTokens[j]);

                resultIndex++;

            }

        }

        return result;

    }



    function listTokens(string calldata _type) external view returns (address[] memory) {

        return _list(tokens[_type]);

    }



    function listProtocols() external view returns (address[] memory) {

        return _list(protocols);

    }



    function listEthProtocols() external view returns (address[] memory) {

        return _list(ethProtocols);

    }



    function getVaults(address _token) external view returns (address[] memory) {

        return productVaults[_token];

    }



    



    function _add(EnumerableSet.AddressSet storage _set, address[] memory _addresses) internal {

        for (uint i = 0; i < _addresses.length; i++) {

            _set.add(_addresses[i]);

        }

    }



    function _remove(EnumerableSet.AddressSet storage _set, address[] memory _addresses) internal {

        for (uint i = 0; i < _addresses.length; i++) {

            _set.remove(_addresses[i]);

        }

    }



    function _list(EnumerableSet.AddressSet storage _set) internal view returns(address[] memory) {

        address[] memory result = new address[](_set.length());

        for (uint i = 0; i < _set.length(); i++) {

            result[i] = _set.at(i);

        }

        return result;

    }

}

library EnumerableSet {

    

    

    

    

    

    

    

    



    struct Set {

        

        bytes32[] _values;



        

        

        mapping (bytes32 => uint256) _indexes;

    }



    

    function _add(Set storage set, bytes32 value) private returns (bool) {

        if (!_contains(set, value)) {

            set._values.push(value);

            

            

            set._indexes[value] = set._values.length;

            return true;

        } else {

            return false;

        }

    }



    

    function _remove(Set storage set, bytes32 value) private returns (bool) {

        

        uint256 valueIndex = set._indexes[value];



        if (valueIndex != 0) { 

            

            

            



            uint256 toDeleteIndex = valueIndex - 1;

            uint256 lastIndex = set._values.length - 1;



            

            



            bytes32 lastvalue = set._values[lastIndex];



            

            set._values[toDeleteIndex] = lastvalue;

            

            set._indexes[lastvalue] = toDeleteIndex + 1; 



            

            set._values.pop();



            

            delete set._indexes[value];



            return true;

        } else {

            return false;

        }

    }



    

    function _contains(Set storage set, bytes32 value) private view returns (bool) {

        return set._indexes[value] != 0;

    }



    

    function _length(Set storage set) private view returns (uint256) {

        return set._values.length;

    }



   

    function _at(Set storage set, uint256 index) private view returns (bytes32) {

        require(set._values.length > index, "EnumerableSet: index out of bounds");

        return set._values[index];

    }



    



    struct AddressSet {

        Set _inner;

    }



    

    function add(AddressSet storage set, address value) internal returns (bool) {

        return _add(set._inner, bytes32(uint256(value)));

    }



    

    function remove(AddressSet storage set, address value) internal returns (bool) {

        return _remove(set._inner, bytes32(uint256(value)));

    }



    

    function contains(AddressSet storage set, address value) internal view returns (bool) {

        return _contains(set._inner, bytes32(uint256(value)));

    }



    

    function length(AddressSet storage set) internal view returns (uint256) {

        return _length(set._inner);

    }



   

    function at(AddressSet storage set, uint256 index) internal view returns (address) {

        return address(uint256(_at(set._inner, index)));

    }





    



    struct UintSet {

        Set _inner;

    }



    

    function add(UintSet storage set, uint256 value) internal returns (bool) {

        return _add(set._inner, bytes32(value));

    }



    

    function remove(UintSet storage set, uint256 value) internal returns (bool) {

        return _remove(set._inner, bytes32(value));

    }



    

    function contains(UintSet storage set, uint256 value) internal view returns (bool) {

        return _contains(set._inner, bytes32(value));

    }



    

    function length(UintSet storage set) internal view returns (uint256) {

        return _length(set._inner);

    }



   

    function at(UintSet storage set, uint256 index) internal view returns (uint256) {

        return uint256(_at(set._inner, index));

    }

}
