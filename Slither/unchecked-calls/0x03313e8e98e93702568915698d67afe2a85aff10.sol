





pragma solidity >=0.6.0 <0.8.0;


interface IERC20 {
    
    function totalSupply() external view returns (uint256);

    
    function balanceOf(address account) external view returns (uint256);

    
    function transfer(address recipient, uint256 amount) external returns (bool);

    
    function allowance(address owner, address spender) external view returns (uint256);

    
    function approve(address spender, uint256 amount) external returns (bool);

    
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);

    
    event Transfer(address indexed from, address indexed to, uint256 value);

    
    event Approval(address indexed owner, address indexed spender, uint256 value);
}





pragma solidity >=0.6.0 <0.8.0;


library SafeMath {
    
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, "SafeMath: addition overflow");

        return c;
    }

    
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        return sub(a, b, "SafeMath: subtraction overflow");
    }

    
    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b <= a, errorMessage);
        uint256 c = a - b;

        return c;
    }

    
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        
        
        
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b, "SafeMath: multiplication overflow");

        return c;
    }

    
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        return div(a, b, "SafeMath: division by zero");
    }

    
    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b > 0, errorMessage);
        uint256 c = a / b;
        

        return c;
    }

    
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        return mod(a, b, "SafeMath: modulo by zero");
    }

    
    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b != 0, errorMessage);
        return a % b;
    }
}





pragma solidity >=0.6.2 <0.8.0;


library Address {
    
    function isContract(address account) internal view returns (bool) {
        
        
        

        uint256 size;
        
        assembly { size := extcodesize(account) }
        return size > 0;
    }

    
    function sendValue(address payable recipient, uint256 amount) internal {
        require(address(this).balance >= amount, "Address: insufficient balance");

        
        (bool success, ) = recipient.call{ value: amount }("");
        require(success, "Address: unable to send value, recipient may have reverted");
    }

    
    function functionCall(address target, bytes memory data) internal returns (bytes memory) {
      return functionCall(target, data, "Address: low-level call failed");
    }

    
    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {
        return functionCallWithValue(target, data, 0, errorMessage);
    }

    
    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {
        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");
    }

    
    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {
        require(address(this).balance >= value, "Address: insufficient balance for call");
        require(isContract(target), "Address: call to non-contract");

        
        (bool success, bytes memory returndata) = target.call{ value: value }(data);
        return _verifyCallResult(success, returndata, errorMessage);
    }

    
    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {
        return functionStaticCall(target, data, "Address: low-level static call failed");
    }

    
    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {
        require(isContract(target), "Address: static call to non-contract");

        
        (bool success, bytes memory returndata) = target.staticcall(data);
        return _verifyCallResult(success, returndata, errorMessage);
    }

    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {
        if (success) {
            return returndata;
        } else {
            
            if (returndata.length > 0) {
                

                
                assembly {
                    let returndata_size := mload(returndata)
                    revert(add(32, returndata), returndata_size)
                }
            } else {
                revert(errorMessage);
            }
        }
    }
}





pragma solidity >=0.6.0 <0.8.0;





library SafeERC20 {
    using SafeMath for uint256;
    using Address for address;

    function safeTransfer(IERC20 token, address to, uint256 value) internal {
        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));
    }

    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {
        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));
    }

    
    function safeApprove(IERC20 token, address spender, uint256 value) internal {
        
        
        
        
        require((value == 0) || (token.allowance(address(this), spender) == 0),
            "SafeERC20: approve from non-zero to non-zero allowance"
        );
        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));
    }

    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {
        uint256 newAllowance = token.allowance(address(this), spender).add(value);
        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
    }

    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {
        uint256 newAllowance = token.allowance(address(this), spender).sub(value, "SafeERC20: decreased allowance below zero");
        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
    }

    
    function _callOptionalReturn(IERC20 token, bytes memory data) private {
        
        
        

        bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");
        if (returndata.length > 0) { 
            
            require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");
        }
    }
}



pragma solidity 0.7.5;


interface ITokenTransferProxy {

    function transferFrom(
        address token,
        address from,
        address to,
        uint256 amount
    )
        external;
}



pragma solidity 0.7.5;
pragma experimental ABIEncoderV2;





interface IERC20Permit {
    function permit(address owner, address spender, uint256 amount, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external;
}

library Utils {
    using SafeMath for uint256;
    using SafeERC20 for IERC20;

    address constant ETH_ADDRESS = address(
        0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE
    );
    
    uint256 constant MAX_UINT = type(uint256).max;

    
    struct SellData {
        address fromToken;
        uint256 fromAmount;
        uint256 toAmount;
        uint256 expectedAmount;
        address payable beneficiary;
        Utils.Path[] path;
        address payable partner;
        uint256 feePercent;
        bytes permit;
        uint256 deadline;
        bytes16 uuid;
    }

    struct MegaSwapSellData {
        address fromToken;
        uint256 fromAmount;
        uint256 toAmount;
        uint256 expectedAmount;
        address payable beneficiary;
        Utils.MegaSwapPath[] path;
        address payable partner;
        uint256 feePercent;
        bytes permit;
        uint256 deadline;
        bytes16 uuid;
    }

    struct SimpleData {
        address fromToken;
        address toToken;
        uint256 fromAmount;
        uint256 toAmount;
        uint256 expectedAmount;
        address[] callees;
        bytes exchangeData;
        uint256[] startIndexes;
        uint256[] values;
        address payable beneficiary;
        address payable partner;
        uint256 feePercent;
        bytes permit;
        uint256 deadline;
        bytes16 uuid;
    }

    struct Adapter {
        address payable adapter;
        uint256 percent;
        uint256 networkFee;
        Route[] route;
    }

    struct Route {
        uint256 index;
        address targetExchange;
        uint percent;
        bytes payload;
        uint256 networkFee;
    }

    struct MegaSwapPath {
        uint256 fromAmountPercent;
        Path[] path;
    }

    struct Path {
        address to;
        uint256 totalNetworkFee;
        Adapter[] adapters;
    }

    function ethAddress() internal pure returns (address) {return ETH_ADDRESS;}

    function maxUint() internal pure returns (uint256) {return MAX_UINT;}

    function approve(
        address addressToApprove,
        address token,
        uint256 amount
    ) internal {
        if (token != ETH_ADDRESS) {
            IERC20 _token = IERC20(token);

            uint allowance = _token.allowance(address(this), addressToApprove);

            if (allowance < amount) {
                _token.safeApprove(addressToApprove, 0);
                _token.safeIncreaseAllowance(addressToApprove, MAX_UINT);
            }
        }
    }

    function transferTokens(
        address token,
        address payable destination,
        uint256 amount
    )
    internal
    {
        if (amount > 0) {
            if (token == ETH_ADDRESS) {
                (bool result, ) = destination.call{value: amount, gas: 10000}("");
                require(result, "Failed to transfer Ether");
            }
            else {
                IERC20(token).safeTransfer(destination, amount);
            }
        }

    }

    function tokenBalance(
        address token,
        address account
    )
    internal
    view
    returns (uint256)
    {
        if (token == ETH_ADDRESS) {
            return account.balance;
        } else {
            return IERC20(token).balanceOf(account);
        }
    }

    function permit(
        address token,
        bytes memory permit
    )
        internal
    {
        if (permit.length == 32 * 7) {
            (bool success,) = token.call(abi.encodePacked(IERC20Permit.permit.selector, permit));
            require(success, "Permit failed");
        }
    }

}



pragma solidity 0.7.5;



interface IAdapter {

    
    function initialize(bytes calldata data) external;

    
    function swap(
        IERC20 fromToken,
        IERC20 toToken,
        uint256 fromAmount,
        uint256 networkFee,
        Utils.Route[] calldata route
    )
        external
        payable;
}



pragma solidity 0.7.5;


interface IAaveToken {
    function redeem(uint256 amount) external;
    function underlyingAssetAddress() external view returns(address);

}

interface IAaveV1LendingPool {
    function deposit(
        IERC20 token,
        uint256 amount,
        uint16 refCode
    )
        external
        payable;

}



pragma solidity 0.7.5;




contract Aavee {

    struct AaveeDataV1 {
        address aToken;
    }

    uint16 public immutable refCodeV1;
    address public immutable spender;

    constructor(uint16 _refCode, address _spender) public {
        refCodeV1 = _refCode;
        spender = _spender;
    }

    function swapOnAavee(
        IERC20 fromToken,
        IERC20 toToken,
        uint256 fromAmount,
        address exchange,
        bytes calldata payload
    )
        internal
    {
        _swapOnAavee(
            fromToken,
            toToken,
            fromAmount,
            exchange,
            payload
        );
    }

    function buyOnAavee(
        IERC20 fromToken,
        IERC20 toToken,
        uint256 fromAmount,
        address exchange,
        bytes calldata payload
    )
        internal
    {
        _swapOnAavee(
            fromToken,
            toToken,
            fromAmount,
            exchange,
            payload
        );
    }

    function _swapOnAavee(
        IERC20 fromToken,
        IERC20 toToken,
        uint256 fromAmount,
        address exchange,
        bytes memory payload
    )
      private
    {
        AaveeDataV1 memory data = abi.decode(payload, (AaveeDataV1));

        Utils.approve(spender, address(fromToken), fromAmount);

        if (address(fromToken) == address(data.aToken)) {
            require(
                IAaveToken(data.aToken).underlyingAssetAddress() == address(toToken),
                "Invalid to token"
            );

            IAaveToken(data.aToken).redeem(fromAmount);
        }
        else if(address(toToken) == address(data.aToken)) {
            require(
                IAaveToken(data.aToken).underlyingAssetAddress() == address(fromToken),
                "Invalid to token"
            );
            if (address(fromToken) == Utils.ethAddress()) {
                IAaveV1LendingPool(exchange).deposit{value: fromAmount}(fromToken, fromAmount, refCodeV1);
            }
            else {
                IAaveV1LendingPool(exchange).deposit(fromToken, fromAmount, refCodeV1);
            }
        }
        else {
            revert("Invalid aToken");
        }
    }
}



pragma solidity 0.7.5;


interface IChai {

    function join(address dst, uint wad) external;

    function exit(address src, uint wad) external;
}



pragma solidity 0.7.5;





contract ChaiExchange {

    address public immutable chai;
    address public immutable dai ;

    constructor(address _chai, address _dai) public {
        chai = _chai;
        dai = _dai;
    }

    function swapOnChai(
        IERC20 fromToken,
        IERC20 toToken,
        uint256 fromAmount
    )
        internal

    {

        _swapOnChai(
            fromToken,
            toToken,
            fromAmount
        );
    }

    function buyOnChai(
        IERC20 fromToken,
        IERC20 toToken,
        uint256 fromAmount
    )
        internal

    {

        _swapOnChai(
            fromToken,
            toToken,
            fromAmount
        );
    }

    function _swapOnChai(
        IERC20 fromToken,
        IERC20 toToken,
        uint256 fromAmount
    )
        private
    {

        Utils.approve(address(chai), address(fromToken), fromAmount);

        if (address(fromToken) == chai){
            require(address(toToken) == dai, "Destination token should be dai");
            IChai(chai).exit(address(this), fromAmount);
        }
        else if (address(fromToken) == dai) {
            require(address(toToken) == chai, "Destination token should be chai");
            IChai(chai).join(address(this), fromAmount);
        }
        else {
            revert("Invalid fromToken");
        }
    }
}



pragma solidity 0.7.5;

interface IBProtocolAMM {
    function swap(
        uint lusdAmount,
        uint minEthReturn,
        address payable dest
    ) external returns(uint);
}



pragma solidity 0.7.5;




contract BProtocol {

    function swapOnBProtocol(
        IERC20 fromToken,
        IERC20 toToken,
        uint256 fromAmount,
        address exchange,
        bytes calldata payload
    )
    internal

    {

        Utils.approve(address(exchange), address(fromToken), fromAmount);

        IBProtocolAMM(exchange).swap(fromAmount, 1, payable(address(this)));
    }
}



pragma solidity 0.7.5;


interface IBZX {

    function mint(
        address receiver,
        uint256 depositAmount
    )
    external
    returns (uint256 mintAmount);

    function mintWithEther(address receiver) external payable returns (uint256 mintAmount);

    function burn(
        address receiver,
        uint256 burnAmount
    )
        external
        returns (uint256 loanAmountPaid);

    function burnToEther(
        address payable receiver,
        uint256 burnAmount
    )
        external
        returns (uint256 loanAmountPaid);

    function loanTokenAddress() external view returns(address );
}



pragma solidity 0.7.5;


contract WethProvider {
    address public immutable WETH;

    constructor(address weth) public {
        WETH = weth;
    }
}



pragma solidity 0.7.5;





abstract contract BZX is WethProvider {

    struct BZXData {
        address iToken;
    }

    function swapOnBzx(
        IERC20 fromToken,
        IERC20 toToken,
        uint256 fromAmount,
        bytes calldata payload
    )
        internal

    {
        _swapOnBZX(
            fromToken,
            toToken,
            fromAmount,
            payload
        );
    }

    function buyOnBzx(
        IERC20 fromToken,
        IERC20 toToken,
        uint256 fromAmount,
        bytes calldata payload
    )
        internal

    {
        _swapOnBZX(
            fromToken,
            toToken,
            fromAmount,
            payload
        );
    }

    function _swapOnBZX(
        IERC20 fromToken,
        IERC20 toToken,
        uint256 fromAmount,
        bytes memory payload
    )
        private
    {
        BZXData memory data = abi.decode(payload, (BZXData));

        Utils.approve(address(data.iToken), address(fromToken), fromAmount);

        if (address(fromToken) == address(data.iToken)) {
            if (address(toToken) == Utils.ethAddress()) {
                require(
                    IBZX(data.iToken).loanTokenAddress() == WETH,
                    "Invalid to token"
                );
                IBZX(data.iToken).burnToEther(payable(address(this)), fromAmount);
            }
            else {
                require(
                    IBZX(data.iToken).loanTokenAddress() == address(toToken),
                    "Invalid to token"
                );
                IBZX(data.iToken).burn(address(this), fromAmount);
            }
        }
        else if (address(toToken) == address(data.iToken)){
            if (address(fromToken) == Utils.ethAddress()) {
                require(
                    IBZX(data.iToken).loanTokenAddress() == WETH,
                    "Invalid from token"
                );

                IBZX(data.iToken).mintWithEther{value: fromAmount}(address(this));
            }
            else {
                require(
                    IBZX(data.iToken).loanTokenAddress() == address(fromToken),
                    "Invalid from token"
                );
                IBZX(data.iToken).mint(address(this), fromAmount);
            }
        }
        else {
            revert("Invalid token pair!!");
        }
    }
}



pragma solidity 0.7.5;

interface ISmoothyV1 {

  function swap(
    uint256 bTokenIdxIn,
    uint256 bTokenIdxOut,
    uint256 bTokenInAmount,
    uint256 bTokenOutMin
  )
  external;

}



pragma solidity 0.7.5;



abstract contract IWETH is IERC20 {
    function deposit() external virtual payable;
    function withdraw(uint256 amount) external virtual;
}



pragma solidity 0.7.5;





contract SmoothyV1 {

  struct SmoothyV1Data {
    uint256 i;
    uint256 j;
  }

  function swapOnSmoothyV1(
    IERC20 fromToken,
    IERC20 toToken,
    uint256 fromAmount,
    address exchange,
    bytes calldata payload
  )
    internal
  {

    SmoothyV1Data memory data = abi.decode(payload, (SmoothyV1Data));

    Utils.approve(exchange, address(fromToken), fromAmount);

    ISmoothyV1(exchange).swap(data.i, data.j, fromAmount, 1);

  }
}



pragma solidity 0.7.5;

interface IUniswapExchange {
    function ethToTokenSwapInput(
        uint256 minTokens,
        uint256 deadline) external payable returns (uint256 tokensBought);

     function ethToTokenSwapOutput(
        uint256 tokensBought,
        uint256 deadline) external payable returns (uint256 ethSold);

    function tokenToEthSwapInput(
        uint256 tokensSold,
        uint256 minEth,
        uint256 deadline) external returns (uint256 ethBought);

    function tokenToEthSwapOutput(
        uint256 ethBought,
        uint256 maxTokens,
        uint256 deadline) external returns (uint256 tokensSold);

    function tokenToTokenSwapInput(
        uint256 tokensSold,
        uint256 minTokensBought,
        uint256 minEthBought,
        uint256 deadline,
        address tokenAddr
    ) external returns (uint256 tokensBought);

    function tokenToTokenSwapOutput(
        uint256 tokensBought,
        uint256 maxTokensSold,
        uint256 maxEthSold,
        uint256 deadline,
        address toToken
    ) external returns (uint256 tokensSold);

    function ethToTokenTransferInput(
        uint256 min_tokens,
        uint256 deadline,
        address recipient
    ) external payable returns (uint256 tokens_bought);

    function ethToTokenTransferOutput(
        uint256 tokens_bought,
        uint256 deadline,
        address recipient
    ) external payable returns (uint256 eth_sold);

    function tokenToEthTransferInput(
        uint256 tokens_sold,
        uint256 min_tokens,
        uint256 deadline,
        address recipient
    ) external returns (uint256 eth_bought);

    function tokenToEthTransferOutput(
        uint256 eth_bought,
        uint256 max_tokens,
        uint256 deadline,
        address recipient
    ) external returns (uint256 tokens_sold);

    function tokenToTokenTransferInput(
        uint256 tokens_sold,
        uint256 min_tokens_bought,
        uint256 min_eth_bought,
        uint256 deadline,
        address recipient,
        address token_addr
    ) external returns (uint256 tokens_bought);

    function tokenToTokenTransferOutput(
        uint256 tokens_bought,
        uint256 max_tokens_sold,
        uint256 max_eth_sold,
        uint256 deadline,
        address recipient,
        address token_addr
    ) external returns (uint256 tokens_sold);
}



pragma solidity 0.7.5;


interface IUniswapFactory {
    function getExchange(address token) external view returns (address exchange);
}



pragma solidity 0.7.5;






contract UniswapV1 {
    using SafeMath for uint256;

    address public immutable factory;

    constructor(address _factory) public {
        factory = _factory;
    }

    function swapOnUniswapV1(
        IERC20 fromToken,
        IERC20 toToken,
        uint256 fromAmount
    )
        internal

    {

        _swapOnUniswapV1(
            fromToken,
            toToken,
            fromAmount,
            1
        );
    }

    function buyOnUniswapV1(
        IERC20 fromToken,
        IERC20 toToken,
        uint256 fromAmount,
        uint256 toAmount
    )
        internal

    {

        address exchange = getExchange(fromToken, toToken);

        Utils.approve(address(exchange), address(fromToken), fromAmount);

        if (address(fromToken) == Utils.ethAddress()) {
            IUniswapExchange(exchange).ethToTokenSwapOutput{value: fromAmount}(toAmount, block.timestamp);
        }
        else if (address(toToken) == Utils.ethAddress()) {
            IUniswapExchange(exchange).tokenToEthSwapOutput(toAmount, fromAmount, block.timestamp);
        }
        else {
            IUniswapExchange(exchange).tokenToTokenSwapOutput(
              toAmount,
              fromAmount,
              Utils.maxUint(),
              block.timestamp,
              address(toToken)
            );
        }

    }

    function getExchange(
        IERC20 fromToken,
        IERC20 toToken
    )
      private
      view
      returns (address)
    {
        address exchangeAddress = address(fromToken) == Utils.ethAddress() ? address(toToken) : address(fromToken);

        return IUniswapFactory(factory).getExchange(exchangeAddress);
    }

    function _swapOnUniswapV1(
        IERC20 fromToken,
        IERC20 toToken,
        uint256 fromAmount,
        uint256 toAmount
    )
      private
      returns(uint256)
    {
        address exchange = getExchange(fromToken, toToken);

        Utils.approve(
          exchange,
          address(fromToken),
          fromAmount
        );

        uint256 receivedAmount = 0;

        if (address(fromToken) == Utils.ethAddress()) {
            receivedAmount = IUniswapExchange(exchange).ethToTokenSwapInput{value: fromAmount}(toAmount, block.timestamp);
        }
        else if (address(toToken) == Utils.ethAddress()) {
            receivedAmount = IUniswapExchange(exchange).tokenToEthSwapInput(fromAmount, toAmount, block.timestamp);
        }
        else {
            receivedAmount = IUniswapExchange(exchange).tokenToTokenSwapInput(fromAmount, toAmount, 1, block.timestamp, address(toToken));
        }

        return receivedAmount;
    }

}



pragma solidity 0.7.5;


interface IDMMExchangeRouter {
    function swapExactTokensForTokens(
        uint256 amountIn,
        uint256 amountOutMin,
        address[] calldata poolsPath,
        IERC20[] calldata path,
        address to,
        uint256 deadline
    ) external returns (uint256[] memory amounts);

    function swapTokensForExactTokens(
        uint256 amountOut,
        uint256 amountInMax,
        address[] calldata poolsPath,
        IERC20[] calldata path,
        address to,
        uint256 deadline
    ) external returns (uint256[] memory amounts);
}



pragma solidity 0.7.5;






abstract contract KyberDmm is WethProvider {

    uint256 constant MAX_INT = 115792089237316195423570985008687907853269984665640564039457584007913129639935;

    struct KyberDMMData {
        address[] poolPath;
        IERC20[] path;
    }

    function swapOnKyberDmm(
        IERC20 fromToken,
        IERC20 toToken,
        uint256 fromAmount,
        address exchange,
        bytes calldata payload
    )
    internal
    {

        KyberDMMData memory data = abi.decode(payload, (KyberDMMData));

        address _fromToken = address(fromToken) == Utils.ethAddress()
        ? WETH : address(fromToken);
        address _toToken = address(toToken) == Utils.ethAddress()
        ? WETH : address(toToken);

        if (address(fromToken) == Utils.ethAddress()) {
            IWETH(WETH).deposit{value : fromAmount}();
        }

        Utils.approve(address(exchange), _fromToken, fromAmount);

        IDMMExchangeRouter(exchange).swapExactTokensForTokens(
            fromAmount,
            1,
            data.poolPath,
            data.path,
            address(this),
            MAX_INT 
        );

        if (address(toToken) == Utils.ethAddress()) {
            IWETH(WETH).withdraw(
                IERC20(WETH).balanceOf(address(this))
            );
        }

    }
}



pragma solidity 0.7.5;



interface IJarvisPool {
    struct MintParams {
        
        address derivative;
        
        uint256 minNumTokens;
        
        uint256 collateralAmount;
        
        uint256 feePercentage;
        
        uint256 expiration;
        
        address recipient;
    }

    struct RedeemParams {
        
        address derivative;
        
        uint256 numTokens;
        
        uint256 minCollateral;
        
        uint256 feePercentage;
        
        uint256 expiration;
        
        address recipient;
    }

    struct ExchangeParams {
        
        address derivative;
        
        address destPool;
        
        address destDerivative;
        
        uint256 numTokens;
        
        uint256 minDestNumTokens;
        
        uint256 feePercentage;
        
        uint256 expiration;
        
        address recipient;
    }

    function mint(MintParams memory mintParams)
    external
    returns (uint256 syntheticTokensMinted, uint256 feePaid);

    function redeem(RedeemParams memory redeemParams)
    external
    returns (uint256 collateralRedeemed, uint256 feePaid);

    function exchange(ExchangeParams memory exchangeParams)
    external
    returns (uint256 destNumTokensMinted, uint256 feePaid);
}



contract Jarvis {
    enum MethodType {
        mint,
        redeem,
        exchange
    }

    struct JarvisData {
        uint opType;
        address derivatives;
        address destDerivatives;
        uint128 fee;
        address destPool;
        uint128 expiration;
    }

    function swapOnJarvis(
        IERC20 fromToken,
        IERC20 toToken,
        uint256 fromAmount,
        address exchange,
        bytes calldata payload
    )
    internal

    {

        JarvisData memory data = abi.decode(payload, (JarvisData));
        Utils.approve(exchange, address(fromToken), fromAmount);

        if (data.opType == uint(MethodType.mint)) {
            IJarvisPool.MintParams memory mintParam = IJarvisPool.MintParams(data.derivatives, 1, fromAmount, data.fee, data.expiration, address(this));

            IJarvisPool(exchange).mint(mintParam);
        } else if (data.opType == uint(MethodType.redeem)) {
            IJarvisPool.RedeemParams memory redeemParam = IJarvisPool.RedeemParams(data.derivatives, fromAmount, 1, data.fee, data.expiration, address(this));

            IJarvisPool(exchange).redeem(redeemParam);
        } else if (data.opType == uint(MethodType.exchange)) {
            IJarvisPool.ExchangeParams memory exchangeParam = IJarvisPool.ExchangeParams(data.derivatives, data.destPool, data.destDerivatives, fromAmount, 1, data.fee, data.expiration, address(this));

            IJarvisPool(exchange).exchange(exchangeParam);
        } else {
            revert("Invalid opType");
        }
    }
}



pragma solidity 0.7.5;












contract Adapter03 is IAdapter, ChaiExchange, UniswapV1, SmoothyV1, BZX, BProtocol, Aavee, KyberDmm, Jarvis {
    using SafeMath for uint256;

    constructor(
        uint16 aaveeRefCode,
        address aaveeSpender,
        address uniswapFactory,
        address chai,
        address dai,
        address weth
    )
        WethProvider(weth)
        Aavee(aaveeRefCode, aaveeSpender)
        UniswapV1(uniswapFactory)
        ChaiExchange(chai, dai)
        public
    {
    }

    function initialize(bytes calldata data) override external {
        revert("METHOD NOT IMPLEMENTED");
    }

    function swap(
        IERC20 fromToken,
        IERC20 toToken,
        uint256 fromAmount,
        uint256 networkFee,
        Utils.Route[] calldata route
    )
        external
        override
        payable
    {
        for (uint256 i = 0; i < route.length; i++) {
            if (route[i].index == 0) {
                
                swapOnChai(
                    fromToken,
                    toToken,
                    fromAmount.mul(route[i].percent).div(10000)
                );
            }
            else if (route[i].index == 1) {
                
                swapOnUniswapV1(
                    fromToken,
                    toToken,
                    fromAmount.mul(route[i].percent).div(10000)
                );
            }
            else if (route[i].index == 2) {
                
                swapOnSmoothyV1(
                    fromToken,
                    toToken,
                    fromAmount.mul(route[i].percent).div(10000),
                    route[i].targetExchange,
                    route[i].payload
                );
            }
            else if (route[i].index == 3) {
                
                swapOnBzx(
                    fromToken,
                    toToken,
                    fromAmount.mul(route[i].percent).div(10000),
                    route[i].payload
                );
            }
            else if (route[i].index == 4) {
                
                swapOnBProtocol(
                    fromToken,
                    toToken,
                    fromAmount.mul(route[i].percent).div(10000),
                    route[i].targetExchange,
                    route[i].payload
                );
            }
            else if (route[i].index == 5) {
                
                swapOnAavee(
                    fromToken,
                    toToken,
                    fromAmount.mul(route[i].percent).div(10000),
                    route[i].targetExchange,
                    route[i].payload
                );
            }
            else if (route[i].index == 6) {
                
                swapOnKyberDmm(
                    fromToken,
                    toToken,
                    fromAmount.mul(route[i].percent).div(10000),
                    route[i].targetExchange,
                    route[i].payload
                );
            }
            else if (route[i].index == 7) {
                
                swapOnJarvis(
                    fromToken,
                    toToken,
                    fromAmount.mul(route[i].percent).div(10000),
                    route[i].targetExchange,
                    route[i].payload
                );
            }
            else {
                revert("Index not supported");
            }
        }
    }
}