pragma solidity 0.5.17;

interface IUniswapV2Router02 {

    function swapTokensForExactTokens(

        uint amountOut,

        uint amountInMax,

        address[] calldata path,

        address to,

        uint deadline

    ) external returns (uint[] memory amounts);

}

interface IERC20FeeProxy {

  event TransferWithReferenceAndFee(

    address tokenAddress,

    address to,

    uint256 amount,

    bytes indexed paymentReference,

    uint256 feeAmount,

    address feeAddress

  );



  function transferFromWithReferenceAndFee(

    address _tokenAddress,

    address _to,

    uint256 _amount,

    bytes calldata _paymentReference,

    uint256 _feeAmount,

    address _feeAddress

    ) external;

}

interface IERC20 {

    

    function totalSupply() external view returns (uint256);



    

    function balanceOf(address account) external view returns (uint256);



    

    function transfer(address recipient, uint256 amount) external returns (bool);



    

    function allowance(address owner, address spender) external view returns (uint256);



    

    function approve(address spender, uint256 amount) external returns (bool);



    

    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);



    

    event Transfer(address indexed from, address indexed to, uint256 value);



    

    event Approval(address indexed owner, address indexed spender, uint256 value);

}

contract Context {

    function _msgSender() internal view returns (address payable) {

        return msg.sender;

    }



    function _msgData() internal view returns (bytes memory) {

        this; 

        return msg.data;

    }

}

contract Ownable is Context {

    address private _owner;



    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);



    

    constructor () internal {

        address msgSender = _msgSender();

        _owner = msgSender;

        emit OwnershipTransferred(address(0), msgSender);

    }



    

    function owner() public view returns (address) {

        return _owner;

    }



    

    modifier onlyOwner() {

        require(_owner == _msgSender(), "Ownable: caller is not the owner");

        _;

    }



    

    function renounceOwnership() public onlyOwner {

        emit OwnershipTransferred(_owner, address(0));

        _owner = address(0);

    }



    

    function transferOwnership(address newOwner) public onlyOwner {

        require(newOwner != address(0), "Ownable: new owner is the zero address");

        emit OwnershipTransferred(_owner, newOwner);

        _owner = newOwner;

    }

}

library SafeERC20 {



  

  function safeTransferFrom(IERC20  _token, address _from, address _to, uint256 _amount) internal returns (bool result) {

    address tokenAddress = address(_token);

    

    

    assembly {

      if iszero(extcodesize(tokenAddress)) { revert(0, 0) }

    }

    

    

    (bool success, ) = tokenAddress.call(abi.encodeWithSignature(

      "transferFrom(address,address,uint256)",

      _from,

      _to,

      _amount

    ));



    assembly {

        switch returndatasize()

        case 0 { 

            result := 1

        }

        case 32 { 

            returndatacopy(0, 0, 32)

            result := mload(0)

        }

        default { 

            revert(0, 0)

        }

    }



    require(success, "transferFrom() has been reverted");



    

    return result;

  }

  

  

  function safeApprove(IERC20 _token, address _spender, uint256 _amount) internal returns (bool result) {

    address tokenAddress = address(_token);

    

    

    assembly {

      if iszero(extcodesize(tokenAddress)) { revert(0, 0) }

    }

    

    

    (bool success, ) = tokenAddress.call(abi.encodeWithSignature(

      "approve(address,uint256)",

      _spender,

      _amount

    ));



    assembly {

        switch returndatasize()

        case 0 { 

            result := 1

        }

        case 32 { 

            returndatacopy(0, 0, 32)

            result := mload(0)

        }

        default { 

            revert(0, 0)

        }

    }



    require(success, "approve() has been reverted");



    

    return result;

  }

}

contract ERC20SwapToPay is Ownable {

  using SafeERC20 for IERC20;



  IUniswapV2Router02 public swapRouter;

  IERC20FeeProxy public paymentProxy;



  constructor(address _swapRouterAddress, address _paymentProxyAddress) public {

    swapRouter = IUniswapV2Router02(_swapRouterAddress);

    paymentProxy = IERC20FeeProxy(_paymentProxyAddress);

  }



 

  function approvePaymentProxyToSpend(address _erc20Address) public {

    IERC20 erc20 = IERC20(_erc20Address);

    uint256 max = 2**256 - 1;

    erc20.safeApprove(address(paymentProxy), max);

  }

  

 

  function approveRouterToSpend(address _erc20Address) public {

    IERC20 erc20 = IERC20(_erc20Address);

    uint256 max = 2**256 - 1;

    erc20.safeApprove(address(swapRouter), max);

  }

  

  

  function swapTransferWithReference(

    address _to,

    uint256 _amount,      

    uint256 _amountInMax, 

    address[] calldata _path, 

    bytes calldata _paymentReference,

    uint256 _feeAmount,   

    address _feeAddress,

    uint256 _deadline

  )

    external

  {

    IERC20 spentToken = IERC20(_path[0]);

    IERC20 requestedToken = IERC20(_path[_path.length-1]);

    

    uint256 requestedTotalAmount = _amount + _feeAmount;



    require(spentToken.allowance(msg.sender, address(this)) > _amountInMax, "Not sufficient allowance for swap to pay.");

    require(spentToken.safeTransferFrom(msg.sender, address(this), _amountInMax), "Could not transfer payment token from swapper-payer");



    

    if (spentToken.allowance(address(this),address(swapRouter)) < _amountInMax) {

        approveRouterToSpend(address(spentToken));

    }

    

    swapRouter.swapTokensForExactTokens(

        requestedTotalAmount,

        _amountInMax,

        _path,

        address(this),

        _deadline

    );

    

    

    if (requestedToken.allowance(address(this),address(paymentProxy)) < requestedTotalAmount) {

        approvePaymentProxyToSpend(address(requestedToken));

    }

    

    

    paymentProxy.transferFromWithReferenceAndFee(

        address(requestedToken),

        _to,

        _amount,

        _paymentReference,

        _feeAmount,

        _feeAddress

    );

    

    



    if (spentToken.balanceOf(address(this)) > 0) {

      spentToken.transfer(msg.sender, spentToken.balanceOf(address(this)));

    }    

    if (requestedToken.balanceOf(address(this)) > 0) {

      requestedToken.transfer(msg.sender, requestedToken.balanceOf(address(this)));

    }

  }

  



  

  

  function setPaymentProxy(address _paymentProxyAddress) public onlyOwner {

    paymentProxy = IERC20FeeProxy(_paymentProxyAddress);

  }

  

  function setRouter(address _newSwapRouterAddress) public onlyOwner {

    swapRouter = IUniswapV2Router02(_newSwapRouterAddress);

  }

}
