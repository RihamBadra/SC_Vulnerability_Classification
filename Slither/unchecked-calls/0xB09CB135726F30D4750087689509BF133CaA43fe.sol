pragma solidity 0.7.4;

enum MathError { NO_ERROR, DIVISION_BY_ZERO, INTEGER_OVERFLOW, INTEGER_UNDERFLOW, MODULO_BY_ZERO }

library Address {

    

    function isContract(address account) internal view returns (bool) {

        

        

        

        bytes32 codehash;

        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;

        

        assembly {

            codehash := extcodehash(account)

        }

        return (codehash != accountHash && codehash != 0x0);

    }

}

abstract contract AdminStorage {

    

    address public admin;

}

abstract contract BalanceSheetStorage {

    struct Vault {

        uint256 debt;

        uint256 freeCollateral;

        uint256 lockedCollateral;

        bool isOpen;

    }



    

    FintrollerInterface public fintroller;



    

    mapping(address => mapping(address => Vault)) internal vaults;



    

    bool public constant isBalanceSheet = true;

}

abstract contract CarefulMath {

    

    function addUInt(uint256 a, uint256 b) internal pure returns (MathError, uint256) {

        uint256 c = a + b;



        if (c >= a) {

            return (MathError.NO_ERROR, c);

        } else {

            return (MathError.INTEGER_OVERFLOW, 0);

        }

    }



    

    function addThenSubUInt(

        uint256 a,

        uint256 b,

        uint256 c

    ) internal pure returns (MathError, uint256) {

        (MathError err0, uint256 sum) = addUInt(a, b);



        if (err0 != MathError.NO_ERROR) {

            return (err0, 0);

        }



        return subUInt(sum, c);

    }



    

    function divUInt(uint256 a, uint256 b) internal pure returns (MathError, uint256) {

        if (b == 0) {

            return (MathError.DIVISION_BY_ZERO, 0);

        }



        return (MathError.NO_ERROR, a / b);

    }



    

    function modUInt(uint256 a, uint256 b) internal pure returns (MathError, uint256) {

        if (b == 0) {

            return (MathError.MODULO_BY_ZERO, 0);

        }



        return (MathError.NO_ERROR, a % b);

    }



    

    function mulUInt(uint256 a, uint256 b) internal pure returns (MathError, uint256) {

        if (a == 0) {

            return (MathError.NO_ERROR, 0);

        }



        uint256 c = a * b;



        if (c / a != b) {

            return (MathError.INTEGER_OVERFLOW, 0);

        } else {

            return (MathError.NO_ERROR, c);

        }

    }



    

    function subUInt(uint256 a, uint256 b) internal pure returns (MathError, uint256) {

        if (b <= a) {

            return (MathError.NO_ERROR, a - b);

        } else {

            return (MathError.INTEGER_UNDERFLOW, 0);

        }

    }

}

abstract contract Erc20Storage {

    

    uint8 public decimals;



    

    string public name;



    

    string public symbol;



    

    uint256 public totalSupply;



    mapping(address => mapping(address => uint256)) internal allowances;



    mapping(address => uint256) internal balances;

}

abstract contract ExponentialStorage {

    struct Exp {

        uint256 mantissa;

    }



    

    uint256 internal constant expScale = 1e18;

    uint256 internal constant halfExpScale = expScale / 2;

    uint256 internal constant mantissaOne = expScale;

}

abstract contract FyTokenStorage {

    

    struct Vault {

        uint256 debt;

        uint256 freeCollateral;

        uint256 lockedCollateral;

        bool isOpen;

    }



    



    

    BalanceSheetInterface public balanceSheet;



    

    Erc20Interface public collateral;



    

    uint256 public collateralPrecisionScalar;



    

    uint256 public expirationTime;



    

    FintrollerInterface public fintroller;



    

    RedemptionPoolInterface public redemptionPool;



    

    Erc20Interface public underlying;



    

    uint256 public underlyingPrecisionScalar;



    

    bool public constant isFyToken = true;

}

abstract contract RedemptionPoolStorage {

    

    FintrollerInterface public fintroller;



    

    uint256 public totalUnderlyingSupply;



    

    FyTokenInterface public fyToken;



    

    bool public constant isRedemptionPool = true;

}

library SafeErc20 {

    using Address for address;



    



    function safeTransfer(

        Erc20Interface token,

        address to,

        uint256 value

    ) internal {

        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));

    }



    function safeTransferFrom(

        Erc20Interface token,

        address from,

        address to,

        uint256 value

    ) internal {

        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));

    }



    



    

    function callOptionalReturn(Erc20Interface token, bytes memory data) private {

        

        

        

        bytes memory returndata = functionCallWithValue(address(token), data, "ERR_SAFE_ERC20_LOW_LEVEL_CALL");

        if (returndata.length > 0) {

            

            require(abi.decode(returndata, (bool)), "ERR_SAFE_ERC20_ERC20_OPERATION");

        }

    }



    function functionCallWithValue(

        address target,

        bytes memory data,

        string memory errorMessage

    ) private returns (bytes memory) {

        require(target.isContract(), "ERR_SAFE_ERC20_CALL_TO_NON_CONTRACT");



        

        (bool success, bytes memory returndata) = target.call(data);

        if (success) {

            return returndata;

        } else {

            

            if (returndata.length > 0) {

                



                

                assembly {

                    let returndata_size := mload(returndata)

                    revert(add(32, returndata), returndata_size)

                }

            } else {

                revert(errorMessage);

            }

        }

    }

}

interface UniswapAnchoredViewInterface {

    

    function price(string memory symbol) external view returns (uint256);

}

abstract contract AdminInterface is AdminStorage {

    

    function _renounceAdmin() external virtual;



    function _transferAdmin(address newAdmin) external virtual;



    

    event TransferAdmin(address indexed oldAdmin, address indexed newAdmin);

}

abstract contract BalanceSheetInterface is BalanceSheetStorage {

    

    function getClutchableCollateral(FyTokenInterface fyToken, uint256 repayAmount)

        external

        view

        virtual

        returns (uint256);



    function getCurrentCollateralizationRatio(FyTokenInterface fyToken, address account)

        public

        view

        virtual

        returns (uint256);



    function getHypotheticalCollateralizationRatio(

        FyTokenInterface fyToken,

        address account,

        uint256 lockedCollateral,

        uint256 debt

    ) public view virtual returns (uint256);



    function getVault(FyTokenInterface fyToken, address account)

        external

        view

        virtual

        returns (

            uint256,

            uint256,

            uint256,

            bool

        );



    function getVaultDebt(FyTokenInterface fyToken, address account) external view virtual returns (uint256);



    function getVaultLockedCollateral(FyTokenInterface fyToken, address account)

        external

        view

        virtual

        returns (uint256);



    function isAccountUnderwater(FyTokenInterface fyToken, address account) external view virtual returns (bool);



    function isVaultOpen(FyTokenInterface fyToken, address account) external view virtual returns (bool);



    



    function clutchCollateral(

        FyTokenInterface fyToken,

        address liquidator,

        address borrower,

        uint256 clutchedCollateralAmount

    ) external virtual returns (bool);



    function depositCollateral(FyTokenInterface fyToken, uint256 collateralAmount) external virtual returns (bool);



    function freeCollateral(FyTokenInterface fyToken, uint256 collateralAmount) external virtual returns (bool);



    function lockCollateral(FyTokenInterface fyToken, uint256 collateralAmount) external virtual returns (bool);



    function openVault(FyTokenInterface fyToken) external virtual returns (bool);



    function setVaultDebt(

        FyTokenInterface fyToken,

        address account,

        uint256 newVaultDebt

    ) external virtual returns (bool);



    function withdrawCollateral(FyTokenInterface fyToken, uint256 collateralAmount) external virtual returns (bool);



    



    event ClutchCollateral(

        FyTokenInterface indexed fyToken,

        address indexed liquidator,

        address indexed borrower,

        uint256 clutchedCollateralAmount

    );



    event DepositCollateral(FyTokenInterface indexed fyToken, address indexed account, uint256 collateralAmount);



    event FreeCollateral(FyTokenInterface indexed fyToken, address indexed account, uint256 collateralAmount);



    event LockCollateral(FyTokenInterface indexed fyToken, address indexed account, uint256 collateralAmount);



    event OpenVault(FyTokenInterface indexed fyToken, address indexed account);



    event SetVaultDebt(FyTokenInterface indexed fyToken, address indexed account, uint256 oldDebt, uint256 newDebt);



    event WithdrawCollateral(FyTokenInterface indexed fyToken, address indexed account, uint256 collateralAmount);

}

abstract contract Erc20Interface is Erc20Storage {

    

    function allowance(address owner, address spender) external view virtual returns (uint256);



    function balanceOf(address account) external view virtual returns (uint256);



    

    function approve(address spender, uint256 amount) external virtual returns (bool);



    function transfer(address recipient, uint256 amount) external virtual returns (bool);



    function transferFrom(

        address sender,

        address recipient,

        uint256 amount

    ) external virtual returns (bool);



    

    event Approval(address indexed owner, address indexed spender, uint256 value);



    event Burn(address indexed account, uint256 burnAmount);



    event Mint(address indexed account, uint256 mintAmount);



    event Transfer(address indexed from, address indexed to, uint256 value);

}

abstract contract Exponential is

    CarefulMath, 

    ExponentialStorage 

{

    

    function addExp(Exp memory a, Exp memory b) internal pure returns (MathError, Exp memory) {

        (MathError error, uint256 result) = addUInt(a.mantissa, b.mantissa);



        return (error, Exp({ mantissa: result }));

    }



    

    function divExp(Exp memory a, Exp memory b) internal pure returns (MathError, Exp memory) {

        (MathError err0, uint256 scaledNumerator) = mulUInt(a.mantissa, expScale);

        if (err0 != MathError.NO_ERROR) {

            return (err0, Exp({ mantissa: 0 }));

        }



        (MathError err1, uint256 rational) = divUInt(scaledNumerator, b.mantissa);

        if (err1 != MathError.NO_ERROR) {

            return (err1, Exp({ mantissa: 0 }));

        }



        return (MathError.NO_ERROR, Exp({ mantissa: rational }));

    }



    

    function mulExp(Exp memory a, Exp memory b) internal pure returns (MathError, Exp memory) {

        (MathError err0, uint256 doubleScaledProduct) = mulUInt(a.mantissa, b.mantissa);

        if (err0 != MathError.NO_ERROR) {

            return (err0, Exp({ mantissa: 0 }));

        }



        

        (MathError err1, uint256 doubleScaledProductWithHalfScale) = addUInt(halfExpScale, doubleScaledProduct);

        if (err1 != MathError.NO_ERROR) {

            return (err1, Exp({ mantissa: 0 }));

        }



        (MathError err2, uint256 product) = divUInt(doubleScaledProductWithHalfScale, expScale);

        

        assert(err2 == MathError.NO_ERROR);



        return (MathError.NO_ERROR, Exp({ mantissa: product }));

    }



    

    function mulExp3(

        Exp memory a,

        Exp memory b,

        Exp memory c

    ) internal pure returns (MathError, Exp memory) {

        (MathError err, Exp memory ab) = mulExp(a, b);

        if (err != MathError.NO_ERROR) {

            return (err, ab);

        }

        return mulExp(ab, c);

    }



    

    function subExp(Exp memory a, Exp memory b) internal pure returns (MathError, Exp memory) {

        (MathError error, uint256 result) = subUInt(a.mantissa, b.mantissa);



        return (error, Exp({ mantissa: result }));

    }

}

abstract contract FintrollerStorage is Exponential {

    struct Bond {

        Exp collateralizationRatio;

        uint256 debtCeiling;

        bool isBorrowAllowed;

        bool isDepositCollateralAllowed;

        bool isLiquidateBorrowAllowed;

        bool isListed;

        bool isRedeemFyTokenAllowed;

        bool isRepayBorrowAllowed;

        bool isSupplyUnderlyingAllowed;

    }



    

    mapping(FyTokenInterface => Bond) internal bonds;



    

    UniswapAnchoredViewInterface public oracle;



    

    uint256 public liquidationIncentiveMantissa;



    

    uint256 public constant oraclePricePrecisionScalar = 1.0e12;



    

    uint256 internal constant collateralizationRatioLowerBoundMantissa = 1.0e18;



    

    uint256 internal constant collateralizationRatioUpperBoundMantissa = 1.0e20;



    

    uint256 internal constant defaultCollateralizationRatioMantissa = 1.5e18;



    

    uint256 internal constant liquidationIncentiveLowerBoundMantissa = 1.0e18;



    

    uint256 internal constant liquidationIncentiveUpperBoundMantissa = 1.5e18;



    

    bool public constant isFintroller = true;

}

abstract contract FyTokenInterface is FyTokenStorage {

    

    function borrow(uint256 borrowAmount) external virtual returns (bool);



    function burn(address holder, uint256 burnAmount) external virtual returns (bool);



    function liquidateBorrow(address borrower, uint256 repayAmount) external virtual returns (bool);



    function mint(address beneficiary, uint256 borrowAmount) external virtual returns (bool);



    function repayBorrow(uint256 repayAmount) external virtual returns (bool);



    function repayBorrowBehalf(address borrower, uint256 repayAmount) external virtual returns (bool);



    function _setFintroller(FintrollerInterface newFintroller) external virtual returns (bool);



    

    event Borrow(address indexed account, uint256 repayAmount);



    event LiquidateBorrow(

        address indexed liquidator,

        address indexed borrower,

        uint256 repayAmount,

        uint256 clutchedCollateralAmount

    );



    event RepayBorrow(address indexed payer, address indexed borrower, uint256 repayAmount, uint256 newDebt);



    event SetFintroller(address indexed admin, FintrollerInterface oldFintroller, FintrollerInterface newFintroller);

}

abstract contract RedemptionPoolInterface is RedemptionPoolStorage {

    

    function redeemFyTokens(uint256 underlyingAmount) external virtual returns (bool);



    function supplyUnderlying(uint256 underlyingAmount) external virtual returns (bool);



    

    event RedeemFyTokens(address indexed account, uint256 fyTokenAmount, uint256 underlyingAmount);



    event SupplyUnderlying(address indexed account, uint256 underlyingAmount, uint256 fyTokenAmount);

}

abstract contract Admin is AdminInterface {

    

    modifier onlyAdmin() {

        require(admin == msg.sender, "ERR_NOT_ADMIN");

        _;

    }



    

    constructor() {

        address msgSender = msg.sender;

        admin = msgSender;

        emit TransferAdmin(address(0x00), msgSender);

    }



    

    function _renounceAdmin() external virtual override onlyAdmin {

        emit TransferAdmin(admin, address(0x00));

        admin = address(0x00);

    }



    

    function _transferAdmin(address newAdmin) external virtual override onlyAdmin {

        require(newAdmin != address(0x00), "ERR_SET_ADMIN_ZERO_ADDRESS");

        emit TransferAdmin(admin, newAdmin);

        admin = newAdmin;

    }

}

abstract contract FintrollerInterface is FintrollerStorage {

    



    function getBond(FyTokenInterface fyToken)

        external

        view

        virtual

        returns (

            uint256 debtCeiling,

            uint256 collateralizationRatioMantissa,

            bool isBorrowAllowed,

            bool isDepositCollateralAllowed,

            bool isLiquidateBorrowAllowed,

            bool isListed,

            bool isRedeemFyTokenAllowed,

            bool isRepayBorrowAllowed,

            bool isSupplyUnderlyingAllowed

        );



    function getBorrowAllowed(FyTokenInterface fyToken) external view virtual returns (bool);



    function getBondDebtCeiling(FyTokenInterface fyToken) external view virtual returns (uint256);



    function getBondCollateralizationRatio(FyTokenInterface fyToken) external view virtual returns (uint256);



    function getDepositCollateralAllowed(FyTokenInterface fyToken) external view virtual returns (bool);



    function getLiquidateBorrowAllowed(FyTokenInterface fyToken) external view virtual returns (bool);



    function getRedeemFyTokensAllowed(FyTokenInterface fyToken) external view virtual returns (bool);



    function getRepayBorrowAllowed(FyTokenInterface fyToken) external view virtual returns (bool);



    function getSupplyUnderlyingAllowed(FyTokenInterface fyToken) external view virtual returns (bool);



    



    function listBond(FyTokenInterface fyToken) external virtual returns (bool);



    function setBorrowAllowed(FyTokenInterface fyToken, bool state) external virtual returns (bool);



    function setCollateralizationRatio(FyTokenInterface fyToken, uint256 newCollateralizationRatioMantissa)

        external

        virtual

        returns (bool);



    function setDebtCeiling(FyTokenInterface fyToken, uint256 newDebtCeiling) external virtual returns (bool);



    function setDepositCollateralAllowed(FyTokenInterface fyToken, bool state) external virtual returns (bool);



    function setLiquidateBorrowAllowed(FyTokenInterface fyToken, bool state) external virtual returns (bool);



    function setLiquidationIncentive(uint256 newLiquidationIncentiveMantissa) external virtual returns (bool);



    function setOracle(UniswapAnchoredViewInterface newOracle) external virtual returns (bool);



    function setRedeemFyTokensAllowed(FyTokenInterface fyToken, bool state) external virtual returns (bool);



    function setRepayBorrowAllowed(FyTokenInterface fyToken, bool state) external virtual returns (bool);



    function setSupplyUnderlyingAllowed(FyTokenInterface fyToken, bool state) external virtual returns (bool);



    

    event ListBond(address indexed admin, FyTokenInterface indexed fyToken);



    event SetBorrowAllowed(address indexed admin, FyTokenInterface indexed fyToken, bool state);



    event SetCollateralizationRatio(

        address indexed admin,

        FyTokenInterface indexed fyToken,

        uint256 oldCollateralizationRatio,

        uint256 newCollateralizationRatio

    );



    event SetDebtCeiling(

        address indexed admin,

        FyTokenInterface indexed fyToken,

        uint256 oldDebtCeiling,

        uint256 newDebtCeiling

    );



    event SetDepositCollateralAllowed(address indexed admin, FyTokenInterface indexed fyToken, bool state);



    event SetLiquidateBorrowAllowed(address indexed admin, FyTokenInterface indexed fyToken, bool state);



    event SetLiquidationIncentive(

        address indexed admin,

        uint256 oldLiquidationIncentive,

        uint256 newLiquidationIncentive

    );



    event SetRedeemFyTokensAllowed(address indexed admin, FyTokenInterface indexed fyToken, bool state);



    event SetRepayBorrowAllowed(address indexed admin, FyTokenInterface indexed fyToken, bool state);



    event SetOracle(address indexed admin, address oldOracle, address newOracle);



    event SetSupplyUnderlyingAllowed(address indexed admin, FyTokenInterface indexed fyToken, bool state);

}

contract Fintroller is

    FintrollerInterface, 

    Admin 

{

    

    constructor() Admin() {

        

        liquidationIncentiveMantissa = 1.1e18;

    }



    



    

    function getBond(FyTokenInterface fyToken)

        external

        view

        override

        returns (

            uint256 collateralizationRatioMantissa,

            uint256 debtCeiling,

            bool isBorrowAllowed,

            bool isDepositCollateralAllowed,

            bool isLiquidateBorrowAllowed,

            bool isListed,

            bool isRedeemFyTokenAllowed,

            bool isRepayBorrowAllowed,

            bool isSupplyUnderlyingAllowed

        )

    {

        collateralizationRatioMantissa = bonds[fyToken].collateralizationRatio.mantissa;

        debtCeiling = bonds[fyToken].debtCeiling;

        isBorrowAllowed = bonds[fyToken].isBorrowAllowed;

        isDepositCollateralAllowed = bonds[fyToken].isDepositCollateralAllowed;

        isLiquidateBorrowAllowed = bonds[fyToken].isLiquidateBorrowAllowed;

        isListed = bonds[fyToken].isListed;

        isRedeemFyTokenAllowed = bonds[fyToken].isRedeemFyTokenAllowed;

        isRepayBorrowAllowed = bonds[fyToken].isRepayBorrowAllowed;

        isSupplyUnderlyingAllowed = bonds[fyToken].isSupplyUnderlyingAllowed;

    }



    

    function getBondDebtCeiling(FyTokenInterface fyToken) external view override returns (uint256) {

        return bonds[fyToken].debtCeiling;

    }



    

    function getBondCollateralizationRatio(FyTokenInterface fyToken) external view override returns (uint256) {

        return bonds[fyToken].collateralizationRatio.mantissa;

    }



    

    function getBorrowAllowed(FyTokenInterface fyToken) external view override returns (bool) {

        Bond memory bond = bonds[fyToken];

        require(bond.isListed, "ERR_BOND_NOT_LISTED");

        return bond.isBorrowAllowed;

    }



    

    function getDepositCollateralAllowed(FyTokenInterface fyToken) external view override returns (bool) {

        Bond memory bond = bonds[fyToken];

        require(bond.isListed, "ERR_BOND_NOT_LISTED");

        return bond.isDepositCollateralAllowed;

    }



    

    function getLiquidateBorrowAllowed(FyTokenInterface fyToken) external view override returns (bool) {

        Bond memory bond = bonds[fyToken];

        require(bond.isListed, "ERR_BOND_NOT_LISTED");

        return bond.isLiquidateBorrowAllowed;

    }



    

    function getRedeemFyTokensAllowed(FyTokenInterface fyToken) external view override returns (bool) {

        Bond memory bond = bonds[fyToken];

        require(bond.isListed, "ERR_BOND_NOT_LISTED");

        return bond.isRedeemFyTokenAllowed;

    }



    

    function getRepayBorrowAllowed(FyTokenInterface fyToken) external view override returns (bool) {

        Bond memory bond = bonds[fyToken];

        require(bond.isListed, "ERR_BOND_NOT_LISTED");

        return bond.isRepayBorrowAllowed;

    }



    

    function getSupplyUnderlyingAllowed(FyTokenInterface fyToken) external view override returns (bool) {

        Bond memory bond = bonds[fyToken];

        require(bond.isListed, "ERR_BOND_NOT_LISTED");

        return bond.isSupplyUnderlyingAllowed;

    }



    



    

    function listBond(FyTokenInterface fyToken) external override onlyAdmin returns (bool) {

        fyToken.isFyToken();

        bonds[fyToken] = Bond({

            collateralizationRatio: Exp({ mantissa: defaultCollateralizationRatioMantissa }),

            debtCeiling: 0,

            isBorrowAllowed: true,

            isDepositCollateralAllowed: true,

            isLiquidateBorrowAllowed: true,

            isListed: true,

            isRedeemFyTokenAllowed: true,

            isRepayBorrowAllowed: true,

            isSupplyUnderlyingAllowed: true

        });

        emit ListBond(admin, fyToken);

        return true;

    }



    

    function setBorrowAllowed(FyTokenInterface fyToken, bool state) external override onlyAdmin returns (bool) {

        require(bonds[fyToken].isListed, "ERR_BOND_NOT_LISTED");

        bonds[fyToken].isBorrowAllowed = state;

        emit SetBorrowAllowed(admin, fyToken, state);

        return true;

    }



    

    function setCollateralizationRatio(FyTokenInterface fyToken, uint256 newCollateralizationRatioMantissa)

        external

        override

        onlyAdmin

        returns (bool)

    {

        

        require(bonds[fyToken].isListed, "ERR_BOND_NOT_LISTED");



        

        require(

            newCollateralizationRatioMantissa <= collateralizationRatioUpperBoundMantissa,

            "ERR_SET_COLLATERALIZATION_RATIO_UPPER_BOUND"

        );

        require(

            newCollateralizationRatioMantissa >= collateralizationRatioLowerBoundMantissa,

            "ERR_SET_COLLATERALIZATION_RATIO_LOWER_BOUND"

        );



        

        uint256 oldCollateralizationRatioMantissa = bonds[fyToken].collateralizationRatio.mantissa;

        bonds[fyToken].collateralizationRatio = Exp({ mantissa: newCollateralizationRatioMantissa });



        emit SetCollateralizationRatio(

            admin,

            fyToken,

            oldCollateralizationRatioMantissa,

            newCollateralizationRatioMantissa

        );



        return true;

    }



    

    function setDebtCeiling(FyTokenInterface fyToken, uint256 newDebtCeiling)

        external

        override

        onlyAdmin

        returns (bool)

    {

        

        require(bonds[fyToken].isListed, "ERR_BOND_NOT_LISTED");



        

        require(newDebtCeiling > 0, "ERR_SET_DEBT_CEILING_ZERO");



        

        uint256 oldDebtCeiling = bonds[fyToken].debtCeiling;

        bonds[fyToken].debtCeiling = newDebtCeiling;



        emit SetDebtCeiling(admin, fyToken, oldDebtCeiling, newDebtCeiling);



        return true;

    }



    

    function setDepositCollateralAllowed(FyTokenInterface fyToken, bool state)

        external

        override

        onlyAdmin

        returns (bool)

    {

        require(bonds[fyToken].isListed, "ERR_BOND_NOT_LISTED");

        bonds[fyToken].isDepositCollateralAllowed = state;

        emit SetDepositCollateralAllowed(admin, fyToken, state);

        return true;

    }



    

    function setLiquidateBorrowAllowed(FyTokenInterface fyToken, bool state)

        external

        override

        onlyAdmin

        returns (bool)

    {

        require(bonds[fyToken].isListed, "ERR_BOND_NOT_LISTED");

        bonds[fyToken].isLiquidateBorrowAllowed = state;

        emit SetLiquidateBorrowAllowed(admin, fyToken, state);

        return true;

    }



    

    function setLiquidationIncentive(uint256 newLiquidationIncentiveMantissa)

        external

        override

        onlyAdmin

        returns (bool)

    {

        

        require(

            newLiquidationIncentiveMantissa <= liquidationIncentiveUpperBoundMantissa,

            "ERR_SET_LIQUIDATION_INCENTIVE_UPPER_BOUND"

        );

        require(

            newLiquidationIncentiveMantissa >= liquidationIncentiveLowerBoundMantissa,

            "ERR_SET_LIQUIDATION_INCENTIVE_LOWER_BOUND"

        );



        

        uint256 oldLiquidationIncentiveMantissa = liquidationIncentiveMantissa;

        liquidationIncentiveMantissa = newLiquidationIncentiveMantissa;



        emit SetLiquidationIncentive(admin, oldLiquidationIncentiveMantissa, newLiquidationIncentiveMantissa);



        return true;

    }



    

    function setOracle(UniswapAnchoredViewInterface newOracle) external override onlyAdmin returns (bool) {

        require(address(newOracle) != address(0x00), "ERR_SET_ORACLE_ZERO_ADDRESS");

        address oldOracle = address(oracle);

        oracle = newOracle;

        emit SetOracle(admin, oldOracle, address(newOracle));

        return true;

    }



    

    function setRedeemFyTokensAllowed(FyTokenInterface fyToken, bool state) external override onlyAdmin returns (bool) {

        require(bonds[fyToken].isListed, "ERR_BOND_NOT_LISTED");

        bonds[fyToken].isRedeemFyTokenAllowed = state;

        emit SetRedeemFyTokensAllowed(admin, fyToken, state);

        return true;

    }



    

    function setRepayBorrowAllowed(FyTokenInterface fyToken, bool state) external override onlyAdmin returns (bool) {

        require(bonds[fyToken].isListed, "ERR_BOND_NOT_LISTED");

        bonds[fyToken].isRepayBorrowAllowed = state;

        emit SetRepayBorrowAllowed(admin, fyToken, state);

        return true;

    }



    

    function setSupplyUnderlyingAllowed(FyTokenInterface fyToken, bool state)

        external

        override

        onlyAdmin

        returns (bool)

    {

        require(bonds[fyToken].isListed, "ERR_BOND_NOT_LISTED");

        bonds[fyToken].isSupplyUnderlyingAllowed = state;

        emit SetSupplyUnderlyingAllowed(admin, fyToken, state);

        return true;

    }

}
