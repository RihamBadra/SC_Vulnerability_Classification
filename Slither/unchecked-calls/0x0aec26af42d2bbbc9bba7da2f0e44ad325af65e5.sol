

pragma solidity 0.7.4;




interface IESDS {
    function redeemCoupons(uint256 _epoch, uint256 _couponAmount) external;
    function transferCoupons(address _sender, address _recipient, uint256 _epoch, uint256 _amount) external;
    function totalRedeemable() external view returns (uint256);
    function epoch() external view returns (uint256);
    function balanceOfCoupons(address _account, uint256 _epoch) external view returns (uint256);
    function advance() external;
}

interface IERC20 {
    function transfer(address recipient, uint256 amount) external returns (bool);
}

interface ICHI {
    function freeFromUpTo(address _addr, uint256 _amount) external returns (uint256);
}






contract CouponClipperV2 {
    using SafeMath for uint256;

    IERC20 constant private ESD = IERC20(0x36F3FD68E7325a35EB768F1AedaAe9EA0689d723);
    IESDS constant private ESDS = IESDS(0x443D2f2755DB5942601fa062Cc248aAA153313D3);
    ICHI  constant private CHI = ICHI(0x0000000000004946c0e9F43F4Dee607b0eF1fA1c);
    uint256 constant private HOUSE_RATE = 100; 
    
    address public house = 0x7Fb471734271b732FbEEd4B6073F401983a406e1; 
    
    event SetOffer(address indexed user, uint256 offer);
    
    
    
    modifier useCHI {
        uint256 gasStart = gasleft();
        _;
        uint256 gasSpent = 21000 + gasStart - gasleft() + (16 * msg.data.length);
        CHI.freeFromUpTo(msg.sender, (gasSpent + 14154) / 41947);
    }

    
    
    mapping(address => uint256) private offers;

    
    
    
    
    
    
    function getOffer(address _user) public view returns (uint256) {
        uint256 offer = offers[_user];
        return offer < 200 ? 200 : offer;
    }

    
    
    
    
    function setOffer(uint256 _newOffer) external {
        require(_newOffer <= 10_000, "Offer exceeds 100%.");
        require(_newOffer >= 200, "Minimum offer is 2%.");
        uint256 oldOffer = offers[msg.sender];
        if (_newOffer < oldOffer) {
            uint256 nextEpoch = ESDS.epoch() + 1;
            uint256 nextEpochStartTIme = getEpochStartTime(nextEpoch);
            uint256 timeUntilNextEpoch = nextEpochStartTIme.sub(block.timestamp);
            require(timeUntilNextEpoch > 15 minutes, "You cannot reduce your offer within 15 minutes of the next epoch");
        }
        
        offers[msg.sender] = _newOffer;
        
        emit SetOffer(msg.sender, _newOffer);
    }
    
    
    
    
    
    function _redeem(address _user, uint256 _epoch, uint256 _couponAmount) internal {
        
        
        ESDS.transferCoupons(_user, address(this), _epoch, _couponAmount); 
        
        
        ESDS.redeemCoupons(_epoch, _couponAmount); 
        
        
        uint256 botFeeRate = getOffer(_user).sub(HOUSE_RATE);
        uint256 botFee = _couponAmount.mul(botFeeRate).div(10_000);
        uint256 houseFee = _couponAmount.mul(HOUSE_RATE).div(10_000);
        ESD.transfer(house, houseFee); 
        ESD.transfer(msg.sender, botFee); 
        
        
        ESD.transfer(_user, _couponAmount.sub(houseFee).sub(botFee)); 
    }
    
    
    
    function redeem(address _user, uint256 _epoch, uint256 _couponAmount) external {
        _redeem(_user, _epoch, _couponAmount);
    }
    
    
    
    
    
    
    
    
    
    function advanceAndRedeemMax(address _user, uint256 _epoch, uint256 _targetEpoch) external useCHI {
        
        uint256 targetEpochStartTime = getEpochStartTime(_targetEpoch);
        if (block.timestamp < targetEpochStartTime) { return; }
        
        
        if (ESDS.epoch() != _targetEpoch) { ESDS.advance(); }
        
        
        uint256 totalRedeemable = ESDS.totalRedeemable();
        if (totalRedeemable == 0) { return; } 
        uint256 userBalance = ESDS.balanceOfCoupons(_user, _epoch);
        if (userBalance == 0) { return; } 
        uint256 maxRedeemableAmount = totalRedeemable < userBalance ? totalRedeemable : userBalance;
        
        
        _redeem(_user, _epoch, maxRedeemableAmount);
    }

    
    
    function getEpochStartTime(uint256 _targetEpoch) public pure returns (uint256) {
        return _targetEpoch.sub(106).mul(28800).add(1602201600);
    }
    
    
    function changeHouseAddress(address _newAddress) external {
        require(msg.sender == house);
        house = _newAddress;
    }
}



library SafeMath {
    
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, "SafeMath: addition overflow");

        return c;
    }

    
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        return sub(a, b, "SafeMath: subtraction overflow");
    }

    
    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b <= a, errorMessage);
        uint256 c = a - b;

        return c;
    }

    
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        
        
        
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b, "SafeMath: multiplication overflow");

        return c;
    }

    
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        return div(a, b, "SafeMath: division by zero");
    }

    
    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b > 0, errorMessage);
        uint256 c = a / b;
        

        return c;
    }

    
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        return mod(a, b, "SafeMath: modulo by zero");
    }

    
    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b != 0, errorMessage);
        return a % b;
    }
}