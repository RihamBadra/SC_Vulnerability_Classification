



pragma solidity 0.8.0;

interface IERC165 {
    
    function supportsInterface(bytes4 interfaceId) external view returns (bool);
}

pragma solidity 0.8.0;


interface IERC721 is IERC165 {
    
    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);

    
    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);

    
    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);

    
    function balanceOf(address owner) external view returns (uint256 balance);

    
    function ownerOf(uint256 tokenId) external view returns (address owner);

    
    function safeTransferFrom(
        address from,
        address to,
        uint256 tokenId
    ) external;

    
    function transferFrom(
        address from,
        address to,
        uint256 tokenId
    ) external;

    
    function approve(address to, uint256 tokenId) external;

    
    function getApproved(uint256 tokenId) external view returns (address operator);

    
    function setApprovalForAll(address operator, bool _approved) external;

    
    function isApprovedForAll(address owner, address operator) external view returns (bool);

    
    function safeTransferFrom(
        address from,
        address to,
        uint256 tokenId,
        bytes calldata data
    ) external;
}

pragma solidity 0.8.0;


interface IERC721Enumerable is IERC721 {
    
    function totalSupply() external view returns (uint256);

    
    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256 tokenId);

    
    function tokenByIndex(uint256 index) external view returns (uint256);
}

pragma solidity 0.8.0;


interface IERC721Metadata is IERC721 {
    
    function name() external view returns (string memory);

    
    function symbol() external view returns (string memory);

    
    function tokenURI(uint256 tokenId) external view returns (string memory);
}

pragma solidity 0.8.0;


interface IERC721Receiver {
    
    function onERC721Received(
        address operator,
        address from,
        uint256 tokenId,
        bytes calldata data
    ) external returns (bytes4);
}

pragma solidity 0.8.0;


library Address {
    
    function isContract(address account) internal view returns (bool) {
        
        
        

        uint256 size;
        assembly {
            size := extcodesize(account)
        }
        return size > 0;
    }

    
    function sendValue(address payable recipient, uint256 amount) internal {
        require(address(this).balance >= amount, "Address: insufficient balance");

        (bool success, ) = recipient.call{value: amount}("");
        require(success, "Address: unable to send value, recipient may have reverted");
    }

    
    function functionCall(address target, bytes memory data) internal returns (bytes memory) {
        return functionCall(target, data, "Address: low-level call failed");
    }

    
    function functionCall(
        address target,
        bytes memory data,
        string memory errorMessage
    ) internal returns (bytes memory) {
        return functionCallWithValue(target, data, 0, errorMessage);
    }

    
    function functionCallWithValue(
        address target,
        bytes memory data,
        uint256 value
    ) internal returns (bytes memory) {
        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");
    }

    
    function functionCallWithValue(
        address target,
        bytes memory data,
        uint256 value,
        string memory errorMessage
    ) internal returns (bytes memory) {
        require(address(this).balance >= value, "Address: insufficient balance for call");
        require(isContract(target), "Address: call to non-contract");

        (bool success, bytes memory returndata) = target.call{value: value}(data);
        return _verifyCallResult(success, returndata, errorMessage);
    }

    
    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {
        return functionStaticCall(target, data, "Address: low-level static call failed");
    }

    
    function functionStaticCall(
        address target,
        bytes memory data,
        string memory errorMessage
    ) internal view returns (bytes memory) {
        require(isContract(target), "Address: static call to non-contract");

        (bool success, bytes memory returndata) = target.staticcall(data);
        return _verifyCallResult(success, returndata, errorMessage);
    }

    
    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {
        return functionDelegateCall(target, data, "Address: low-level delegate call failed");
    }

    
    function functionDelegateCall(
        address target,
        bytes memory data,
        string memory errorMessage
    ) internal returns (bytes memory) {
        require(isContract(target), "Address: delegate call to non-contract");

        (bool success, bytes memory returndata) = target.delegatecall(data);
        return _verifyCallResult(success, returndata, errorMessage);
    }

    function _verifyCallResult(
        bool success,
        bytes memory returndata,
        string memory errorMessage
    ) private pure returns (bytes memory) {
        if (success) {
            return returndata;
        } else {
            
            if (returndata.length > 0) {
                

                assembly {
                    let returndata_size := mload(returndata)
                    revert(add(32, returndata), returndata_size)
                }
            } else {
                revert(errorMessage);
            }
        }
    }
}

pragma solidity 0.8.0;





library Base64 {

    bytes internal constant TABLE = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    bytes constant private base64urlchars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=";


    
    function encode(bytes memory data) internal pure returns (string memory) {
        uint256 len = data.length;
        if (len == 0) return "";

        
        uint256 encodedLen = 4 * ((len + 2) / 3);

        
        bytes memory result = new bytes(encodedLen + 32);

        bytes memory table = TABLE;

        assembly {
            let tablePtr := add(table, 1)
            let resultPtr := add(result, 32)

            for {
                let i := 0
            } lt(i, len) {

            } {
                i := add(i, 3)
                let input := and(mload(add(data, i)), 0xffffff)

                let out := mload(add(tablePtr, and(shr(18, input), 0x3F)))
                out := shl(8, out)
                out := add(out, and(mload(add(tablePtr, and(shr(12, input), 0x3F))), 0xFF))
                out := shl(8, out)
                out := add(out, and(mload(add(tablePtr, and(shr(6, input), 0x3F))), 0xFF))
                out := shl(8, out)
                out := add(out, and(mload(add(tablePtr, and(input, 0x3F))), 0xFF))
                out := shl(224, out)

                mstore(resultPtr, out)

                resultPtr := add(resultPtr, 4)
            }

            switch mod(len, 3)
            case 1 {
                mstore(sub(resultPtr, 2), shl(240, 0x3d3d))
            }
            case 2 {
                mstore(sub(resultPtr, 1), shl(248, 0x3d))
            }

            mstore(result, encodedLen)
        }

        return string(result);
    }

    function decode(string memory _str) internal pure returns (string memory) {
        require( (bytes(_str).length % 4) == 0, "Length not multiple of 4");
        bytes memory _bs = bytes(_str);

        uint i = 0;
        uint j = 0;
        uint dec_length = (_bs.length/4) * 3;
        bytes memory dec = new bytes(dec_length);

        for (; i< _bs.length; i+=4 ) {
            (dec[j], dec[j+1], dec[j+2]) = dencode4(
                bytes1(_bs[i]),
                bytes1(_bs[i+1]),
                bytes1(_bs[i+2]),
                bytes1(_bs[i+3])
            );
            j += 3;
        }
        while (dec[--j]==0)
        {}

        bytes memory res = new bytes(j+1);
        for (i=0; i<=j;i++)
            res[i] = dec[i];

        return string(res);
    }

    function dencode4 (bytes1 b0, bytes1 b1, bytes1 b2, bytes1 b3) private pure returns (bytes1 a0, bytes1 a1, bytes1 a2)
    {
        uint pos0 = charpos(b0);
        uint pos1 = charpos(b1);
        uint pos2 = charpos(b2)%64;
        uint pos3 = charpos(b3)%64;

        a0 = bytes1(uint8(( pos0 << 2 | pos1 >> 4 )));
        a1 = bytes1(uint8(( (pos1&15)<<4 | pos2 >> 2)));
        a2 = bytes1(uint8(( (pos2&3)<<6 | pos3 )));
    }

    function charpos(bytes1 char) private pure returns (uint pos) {
        for (; base64urlchars[pos] != char; pos++)
        {}    
        require (base64urlchars[pos]==char, "Illegal char in string");
        return pos;
    }

}

pragma solidity 0.8.0;

library TokenIds {
    uint256 private constant TOKEN_ID_MASK = 0x7fffffff;
    uint256 private constant WELD_MASK = 0x80000000;
    uint256 private constant WELD_UNMASK = ~WELD_MASK;

    function getTokenId(uint256 self, uint256 i) internal pure returns (uint256) {
        uint256 shifts = i * 32;
        return (self & (TOKEN_ID_MASK << shifts)) >> shifts;
    }


    function setTokenId(uint256 self, uint256 i, uint256 tokenId) internal pure returns (uint256) {
        require(tokenId <= TOKEN_ID_MASK, "TOKEN_ID");
        uint256 shifts = i * 32;
        return (self & (~(TOKEN_ID_MASK << shifts))) | (tokenId << shifts);
    }

    function getTokenIds(uint256 self) internal pure returns (uint256[8] memory tokenIds) {
        for (uint256 i = 0; i < 8; i++) {
            tokenIds[i] = getTokenId(self, i);
        }
    }

    function getSeal(uint256 self) internal pure returns (bool) {
        return self & WELD_MASK != 0;
    }

    function setSeal(uint256 self, bool weld) internal pure returns (uint256) {
        return weld ? (self | WELD_MASK) : (self & WELD_UNMASK);
    }
}

library ComponentBitmap {
    function setIdxAttr(mapping(uint256 => uint256) storage slot, uint256 tokenId, uint256 idx, uint256 attr) internal {
        require(idx <= 0xff && attr <= 0xff, "OF_IDX_ATTR");
        uint256 prev = slot[tokenId / 16];
        uint256 mask = (0xffff << ((tokenId % 16) * 16));
        prev = prev & (~mask);
        prev |= ((idx << 8) | attr) << ((tokenId % 16) * 16);
        slot[tokenId / 16] = prev;
    }

    function getIdxAttr(mapping(uint256 => uint256) storage slot, uint256 tokenId) internal view returns (uint256 idx, uint256 attr) {
        uint256 prev = slot[tokenId / 16];
        uint256 mask = (0xffff << ((tokenId % 16) * 16));
        idx = ((prev & mask) >> ((tokenId % 16) * 16));
        attr = idx & 0xff;
        idx = idx >> 8;
    }
}

library AvatarBitmap {
    uint256 private constant BG_MASK = 0xf;
    uint256 private constant BG_SHIFTS = 4;

    uint256 private constant EYES_MASK = 0x1f << BG_SHIFTS;
    uint256 private constant EYES_SHIFTS = BG_SHIFTS + 5;

    uint256 private constant MONTH_MASK = 63 << EYES_SHIFTS;
    uint256 private constant MONTH_SHIFTS = EYES_SHIFTS + 6;

    uint256 private constant BODY_MASK = 63 << MONTH_SHIFTS;
    uint256 private constant BODY_SHIFTS = MONTH_SHIFTS + 6;

    uint256 private constant TOP_MASK = 0xf << BODY_SHIFTS;
    uint256 private constant TOP_SHIFTS = BODY_SHIFTS + 4;

    uint256 private constant STRAW_MASK = 0xf << TOP_SHIFTS;
    uint256 private constant STRAW_SHIFTS = TOP_SHIFTS + 4;

    uint256 private constant GESTURE_MASK = 0xf << STRAW_SHIFTS;
    uint256 private constant GESTURE_SHIFTS = STRAW_SHIFTS + 4;

    uint256 private constant TEMPLATE_MASK = 0xffff << GESTURE_SHIFTS;
    uint256 private constant TEMPLATE_SHIFTS = GESTURE_SHIFTS + 16;

    function setAttr(
        uint256 self,
        uint256 i,
        uint256 attr
    ) internal pure returns (uint256) {
        require(i < 8, "I");
        if (i == 0) return setTemplate(self, attr);
        if (i == 1) return setBG(self, attr);
        if (i == 2) return setEyes(self, attr);
        if (i == 3) return setMonth(self, attr);
        if (i == 4) return setBody(self, attr);
        if (i == 5) return setTop(self, attr);
        if (i == 6) return setStraw(self, attr);
        if (i == 7) return setGesture(self, attr);
        return 0;
    }

    function getAttr(uint256 self, uint256 i) internal pure returns (uint256) {
        require(i < 8, "I");
        if (i == 0) return getTemplate(self);
        if (i == 1) return getBG(self);
        if (i == 2) return getEyes(self);
        if (i == 3) return getMonth(self);
        if (i == 4) return getBody(self);
        if (i == 5) return getTop(self);
        if (i == 6) return getStraw(self);
        if (i == 7) return getGesture(self);
        return 0;
    }

    function getBG(uint256 self) internal pure returns (uint256) {
        return (self & BG_MASK);
    }

    function getEyes(uint256 self) internal pure returns (uint256) {
        return (self & EYES_MASK) >> BG_SHIFTS;
    }

    function getMonth(uint256 self) internal pure returns (uint256) {
        return (self & MONTH_MASK) >> EYES_SHIFTS;
    }

    function getBody(uint256 self) internal pure returns (uint256) {
        return (self & BODY_MASK) >> MONTH_SHIFTS;
    }

    function getTop(uint256 self) internal pure returns (uint256) {
        return (self & TOP_MASK) >> BODY_SHIFTS;
    }

    function getStraw(uint256 self) internal pure returns (uint256) {
        return (self & STRAW_MASK) >> TOP_SHIFTS;
    }

    function getGesture(uint256 self) internal pure returns (uint256) {
        return (self & GESTURE_MASK) >> STRAW_SHIFTS;
    }

    function setBG(uint256 self, uint256 bg) internal pure returns (uint256) {
        require(bg < 16, "BG");
        return (self & (~BG_MASK)) | bg;
    }

    function setEyes(uint256 self, uint256 eyes)
    internal
    pure
    returns (uint256)
    {
        require(eyes < 32, "EYES");
        return (self & (~EYES_MASK)) | (eyes << BG_SHIFTS);
    }

    function setMonth(uint256 self, uint256 month)
    internal
    pure
    returns (uint256)
    {
        require(month < 64, "month");
        return (self & (~MONTH_MASK)) | (month << EYES_SHIFTS);
    }

    function setBody(uint256 self, uint256 body)
    internal
    pure
    returns (uint256)
    {
        require(body < 64, "EYES");
        return (self & (~BODY_MASK)) | (body << MONTH_SHIFTS);
    }

    function setTop(uint256 self, uint256 top) internal pure returns (uint256) {
        require(top < 16, "TOP");
        return (self & (~TOP_MASK)) | (top << BODY_SHIFTS);
    }

    function setStraw(uint256 self, uint256 straw)
    internal
    pure
    returns (uint256)
    {
        require(straw < 32, "STRAW");
        return (self & (~STRAW_MASK)) | (straw << TOP_SHIFTS);
    }

    function setGesture(uint256 self, uint256 gesture)
    internal
    pure
    returns (uint256)
    {
        require(gesture < 16, "EYES");
        return (self & (~GESTURE_MASK)) | (gesture << STRAW_SHIFTS);
    }

    function getTemplate(uint256 self) internal pure returns (uint256) {
        return (self & TEMPLATE_MASK) >> GESTURE_SHIFTS;
    }

    function setTemplate(uint256 self, uint256 template)
    internal
    pure
    returns (uint256)
    {
        require(template <= 0xffff, "TEMPLATE");
        return (self & (~TEMPLATE_MASK)) | (template << GESTURE_SHIFTS);
    }
}

pragma solidity 0.8.0;


library ECDSA {
    enum RecoverError {
        NoError,
        InvalidSignature,
        InvalidSignatureLength,
        InvalidSignatureS,
        InvalidSignatureV
    }

    function _throwError(RecoverError error) private pure {
        if (error == RecoverError.NoError) {
            return; 
        } else if (error == RecoverError.InvalidSignature) {
            revert("ECDSA: invalid signature");
        } else if (error == RecoverError.InvalidSignatureLength) {
            revert("ECDSA: invalid signature length");
        } else if (error == RecoverError.InvalidSignatureS) {
            revert("ECDSA: invalid signature 's' value");
        } else if (error == RecoverError.InvalidSignatureV) {
            revert("ECDSA: invalid signature 'v' value");
        }
    }

    
    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {
        
        
        
        if (signature.length == 65) {
            bytes32 r;
            bytes32 s;
            uint8 v;
            
            
            assembly {
                r := mload(add(signature, 0x20))
                s := mload(add(signature, 0x40))
                v := byte(0, mload(add(signature, 0x60)))
            }
            return tryRecover(hash, v, r, s);
        } else if (signature.length == 64) {
            bytes32 r;
            bytes32 vs;
            
            
            assembly {
                r := mload(add(signature, 0x20))
                vs := mload(add(signature, 0x40))
            }
            return tryRecover(hash, r, vs);
        } else {
            return (address(0), RecoverError.InvalidSignatureLength);
        }
    }

    
    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {
        (address recovered, RecoverError error) = tryRecover(hash, signature);
        _throwError(error);
        return recovered;
    }

    
    function tryRecover(
        bytes32 hash,
        bytes32 r,
        bytes32 vs
    ) internal pure returns (address, RecoverError) {
        bytes32 s;
        uint8 v;
        assembly {
            s := and(vs, 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)
            v := add(shr(255, vs), 27)
        }
        return tryRecover(hash, v, r, s);
    }

    
    function recover(
        bytes32 hash,
        bytes32 r,
        bytes32 vs
    ) internal pure returns (address) {
        (address recovered, RecoverError error) = tryRecover(hash, r, vs);
        _throwError(error);
        return recovered;
    }

    
    function tryRecover(
        bytes32 hash,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) internal pure returns (address, RecoverError) {
        
        
        
        
        
        
        
        
        
        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {
            return (address(0), RecoverError.InvalidSignatureS);
        }
        if (v != 27 && v != 28) {
            return (address(0), RecoverError.InvalidSignatureV);
        }

        
        address signer = ecrecover(hash, v, r, s);
        if (signer == address(0)) {
            return (address(0), RecoverError.InvalidSignature);
        }

        return (signer, RecoverError.NoError);
    }

    
    function recover(
        bytes32 hash,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) internal pure returns (address) {
        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);
        _throwError(error);
        return recovered;
    }

    
    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {
        
        
        return keccak256(abi.encodePacked("\x19Ethereum Signed Message:\n32", hash));
    }

    
    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked("\x19Ethereum Signed Message:\n", Strings.toString(s.length), s));
    }

    
    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked("\x19\x01", domainSeparator, structHash));
    }
}

pragma solidity 0.8.0;


library Strings {
    bytes16 private constant _HEX_SYMBOLS = "0123456789abcdef";

    
    function toString(uint256 value) internal pure returns (string memory) {
        
        

        if (value == 0) {
            return "0";
        }
        uint256 temp = value;
        uint256 digits;
        while (temp != 0) {
            digits++;
            temp /= 10;
        }
        bytes memory buffer = new bytes(digits);
        while (value != 0) {
            digits -= 1;
            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));
            value /= 10;
        }
        return string(buffer);
    }

    
    function toHexString(uint256 value) internal pure returns (string memory) {
        if (value == 0) {
            return "0x00";
        }
        uint256 temp = value;
        uint256 length = 0;
        while (temp != 0) {
            length++;
            temp >>= 8;
        }
        return toHexString(value, length);
    }

    
    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {
        bytes memory buffer = new bytes(2 * length + 2);
        buffer[0] = "0";
        buffer[1] = "x";
        for (uint256 i = 2 * length + 1; i > 1; --i) {
            buffer[i] = _HEX_SYMBOLS[value & 0xf];
            value >>= 4;
        }
        require(value == 0, "Strings: hex length insufficient");
        return string(buffer);
    }
}

pragma solidity 0.8.0;


abstract contract ERC165 is IERC165 {
    
    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {
        return interfaceId == type(IERC165).interfaceId;
    }
}


pragma solidity 0.8.0;


abstract contract Context {
    function _msgSender() internal view virtual returns (address) {
        return msg.sender;
    }

    function _msgData() internal view virtual returns (bytes calldata) {
        return msg.data;
    }
}

pragma solidity 0.8.0;


abstract contract Ownable is Context {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    
    constructor() {
        _setOwner(_msgSender());
    }

    
    function owner() public view virtual returns (address) {
        return _owner;
    }

    
    modifier onlyOwner() {
        require(owner() == _msgSender(), "Ownable: caller is not the owner");
        _;
    }

    
    function renounceOwnership() public virtual onlyOwner {
        _setOwner(address(0));
    }

    
    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), "Ownable: new owner is the zero address");
        _setOwner(newOwner);
    }

    function _setOwner(address newOwner) private {
        address oldOwner = _owner;
        _owner = newOwner;
        emit OwnershipTransferred(oldOwner, newOwner);
    }
}

pragma solidity 0.8.0;


abstract contract ReentrancyGuard {
    
    
    
    
    

    
    
    
    
    
    uint256 private constant _NOT_ENTERED = 1;
    uint256 private constant _ENTERED = 2;

    uint256 private _status;

    constructor() {
        _status = _NOT_ENTERED;
    }

    
    modifier nonReentrant() {
        
        require(_status != _ENTERED, "ReentrancyGuard: reentrant call");

        
        _status = _ENTERED;

        _;

        
        
        _status = _NOT_ENTERED;
    }
}

pragma solidity 0.8.0;






library SafeMath {
    
    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {
    unchecked {
        uint256 c = a + b;
        if (c < a) return (false, 0);
        return (true, c);
    }
    }

    
    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {
    unchecked {
        if (b > a) return (false, 0);
        return (true, a - b);
    }
    }

    
    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {
    unchecked {
        
        
        
        if (a == 0) return (true, 0);
        uint256 c = a * b;
        if (c / a != b) return (false, 0);
        return (true, c);
    }
    }

    
    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {
    unchecked {
        if (b == 0) return (false, 0);
        return (true, a / b);
    }
    }

    
    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {
    unchecked {
        if (b == 0) return (false, 0);
        return (true, a % b);
    }
    }

    
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        return a + b;
    }

    
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        return a - b;
    }

    
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        return a * b;
    }

    
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        return a / b;
    }

    
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        return a % b;
    }

    
    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
    unchecked {
        require(b <= a, errorMessage);
        return a - b;
    }
    }

    
    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
    unchecked {
        require(b > 0, errorMessage);
        return a / b;
    }
    }

    
    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
    unchecked {
        require(b > 0, errorMessage);
        return a % b;
    }
    }
}

pragma solidity 0.8.0;


contract ERC721 is Context, ERC165, IERC721, IERC721Metadata {
    using Address for address;
    using Strings for uint256;

    
    string private _name;

    
    string private _symbol;

    
    mapping(uint256 => address) private _owners;

    
    mapping(address => uint256) private _balances;

    
    mapping(uint256 => address) private _tokenApprovals;

    
    mapping(address => mapping(address => bool)) private _operatorApprovals;

    
    constructor(string memory name_, string memory symbol_) {
        _name = name_;
        _symbol = symbol_;
    }

    
    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {
        return
        interfaceId == type(IERC721).interfaceId ||
        interfaceId == type(IERC721Metadata).interfaceId ||
        super.supportsInterface(interfaceId);
    }

    
    function balanceOf(address owner) public view virtual override returns (uint256) {
        require(owner != address(0), "ERC721: balance query for the zero address");
        return _balances[owner];
    }

    
    function ownerOf(uint256 tokenId) public view virtual override returns (address) {
        address owner = _owners[tokenId];
        require(owner != address(0), "ERC721: owner query for nonexistent token");
        return owner;
    }

    
    function name() public view virtual override returns (string memory) {
        return _name;
    }

    
    function symbol() public view virtual override returns (string memory) {
        return _symbol;
    }

    
    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {
        require(_exists(tokenId), "ERC721Metadata: URI query for nonexistent token");

        string memory baseURI = _baseURI();
        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : "";
    }

    
    function _baseURI() internal view virtual returns (string memory) {
        return "";
    }

    
    function approve(address to, uint256 tokenId) public virtual override {
        address owner = ERC721.ownerOf(tokenId);
        require(to != owner, "ERC721: approval to current owner");

        require(
            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),
            "ERC721: approve caller is not owner nor approved for all"
        );

        _approve(to, tokenId);
    }

    
    function getApproved(uint256 tokenId) public view virtual override returns (address) {
        require(_exists(tokenId), "ERC721: approved query for nonexistent token");

        return _tokenApprovals[tokenId];
    }

    
    function setApprovalForAll(address operator, bool approved) public virtual override {
        require(operator != _msgSender(), "ERC721: approve to caller");

        _operatorApprovals[_msgSender()][operator] = approved;
        emit ApprovalForAll(_msgSender(), operator, approved);
    }

    
    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {
        return _operatorApprovals[owner][operator];
    }

    
    function transferFrom(
        address from,
        address to,
        uint256 tokenId
    ) public virtual override {
        
        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: transfer caller is not owner nor approved");

        _transfer(from, to, tokenId);
    }

    
    function safeTransferFrom(
        address from,
        address to,
        uint256 tokenId
    ) public virtual override {
        safeTransferFrom(from, to, tokenId, "");
    }

    
    function safeTransferFrom(
        address from,
        address to,
        uint256 tokenId,
        bytes memory _data
    ) public virtual override {
        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: transfer caller is not owner nor approved");
        _safeTransfer(from, to, tokenId, _data);
    }

    
    function _safeTransfer(
        address from,
        address to,
        uint256 tokenId,
        bytes memory _data
    ) internal virtual {
        _transfer(from, to, tokenId);
        require(_checkOnERC721Received(from, to, tokenId, _data), "ERC721: transfer to non ERC721Receiver implementer");
    }

    
    function _exists(uint256 tokenId) internal view virtual returns (bool) {
        return _owners[tokenId] != address(0);
    }

    
    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {
        require(_exists(tokenId), "ERC721: operator query for nonexistent token");
        address owner = ERC721.ownerOf(tokenId);
        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));
    }

    
    function _safeMint(address to, uint256 tokenId) internal virtual {
        _safeMint(to, tokenId, "");
    }

    
    function _safeMint(
        address to,
        uint256 tokenId,
        bytes memory _data
    ) internal virtual {
        _mint(to, tokenId);
        require(
            _checkOnERC721Received(address(0), to, tokenId, _data),
            "ERC721: transfer to non ERC721Receiver implementer"
        );
    }

    
    function _mint(address to, uint256 tokenId) internal virtual {
        require(to != address(0), "ERC721: mint to the zero address");
        require(!_exists(tokenId), "ERC721: token already minted");

        _beforeTokenTransfer(address(0), to, tokenId);

        _balances[to] += 1;
        _owners[tokenId] = to;

        emit Transfer(address(0), to, tokenId);
    }

    
    function _burn(uint256 tokenId) internal virtual {
        address owner = ERC721.ownerOf(tokenId);

        _beforeTokenTransfer(owner, address(0), tokenId);

        
        _approve(address(0), tokenId);

        _balances[owner] -= 1;
        delete _owners[tokenId];

        emit Transfer(owner, address(0), tokenId);
    }

    
    function _transfer(
        address from,
        address to,
        uint256 tokenId
    ) internal virtual {
        require(ERC721.ownerOf(tokenId) == from, "ERC721: transfer of token that is not own");
        require(to != address(0), "ERC721: transfer to the zero address");

        _beforeTokenTransfer(from, to, tokenId);

        
        _approve(address(0), tokenId);

        _balances[from] -= 1;
        _balances[to] += 1;
        _owners[tokenId] = to;

        emit Transfer(from, to, tokenId);
    }

    
    function _approve(address to, uint256 tokenId) internal virtual {
        _tokenApprovals[tokenId] = to;
        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);
    }

    
    function _checkOnERC721Received(
        address from,
        address to,
        uint256 tokenId,
        bytes memory _data
    ) private returns (bool) {
        if (to.isContract()) {
            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {
                return retval == IERC721Receiver(to).onERC721Received.selector;
            } catch (bytes memory reason) {
                if (reason.length == 0) {
                    revert("ERC721: transfer to non ERC721Receiver implementer");
                } else {
                    assembly {
                        revert(add(32, reason), mload(reason))
                    }
                }
            }
        } else {
            return true;
        }
    }

    
    function _beforeTokenTransfer(
        address from,
        address to,
        uint256 tokenId
    ) internal virtual {}
}

pragma solidity 0.8.0;


abstract contract ERC721Enumerable is ERC721, IERC721Enumerable {
    
    mapping(address => mapping(uint256 => uint256)) private _ownedTokens;

    
    mapping(uint256 => uint256) private _ownedTokensIndex;

    
    uint256[] private _allTokens;

    
    mapping(uint256 => uint256) private _allTokensIndex;

    
    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC721) returns (bool) {
        return interfaceId == type(IERC721Enumerable).interfaceId || super.supportsInterface(interfaceId);
    }

    
    function tokenOfOwnerByIndex(address owner, uint256 index) public view virtual override returns (uint256) {
        require(index < ERC721.balanceOf(owner), "ERC721Enumerable: owner index out of bounds");
        return _ownedTokens[owner][index];
    }

    
    function totalSupply() public view virtual override returns (uint256) {
        return _allTokens.length;
    }

    
    function tokenByIndex(uint256 index) public view virtual override returns (uint256) {
        require(index < ERC721Enumerable.totalSupply(), "ERC721Enumerable: global index out of bounds");
        return _allTokens[index];
    }

    
    function _beforeTokenTransfer(
        address from,
        address to,
        uint256 tokenId
    ) internal virtual override {
        super._beforeTokenTransfer(from, to, tokenId);

        if (from == address(0)) {
            _addTokenToAllTokensEnumeration(tokenId);
        } else if (from != to) {
            _removeTokenFromOwnerEnumeration(from, tokenId);
        }
        if (to == address(0)) {
            _removeTokenFromAllTokensEnumeration(tokenId);
        } else if (to != from) {
            _addTokenToOwnerEnumeration(to, tokenId);
        }
    }

    
    function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {
        uint256 length = ERC721.balanceOf(to);
        _ownedTokens[to][length] = tokenId;
        _ownedTokensIndex[tokenId] = length;
    }

    
    function _addTokenToAllTokensEnumeration(uint256 tokenId) private {
        _allTokensIndex[tokenId] = _allTokens.length;
        _allTokens.push(tokenId);
    }

    
    function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {
        
        

        uint256 lastTokenIndex = ERC721.balanceOf(from) - 1;
        uint256 tokenIndex = _ownedTokensIndex[tokenId];

        
        if (tokenIndex != lastTokenIndex) {
            uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];

            _ownedTokens[from][tokenIndex] = lastTokenId; 
            _ownedTokensIndex[lastTokenId] = tokenIndex; 
        }

        
        delete _ownedTokensIndex[tokenId];
        delete _ownedTokens[from][lastTokenIndex];
    }

    
    function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {
        
        

        uint256 lastTokenIndex = _allTokens.length - 1;
        uint256 tokenIndex = _allTokensIndex[tokenId];

        
        
        
        uint256 lastTokenId = _allTokens[lastTokenIndex];

        _allTokens[tokenIndex] = lastTokenId; 
        _allTokensIndex[lastTokenId] = tokenIndex; 

        
        delete _allTokensIndex[tokenId];
        _allTokens.pop();
    }
}

pragma solidity 0.8.0;


abstract contract EIP712 {
    
    
    
    bytes32 private immutable _CACHED_DOMAIN_SEPARATOR;
    uint256 private immutable _CACHED_CHAIN_ID;
    address private immutable _CACHED_THIS;

    bytes32 private immutable _HASHED_NAME;
    bytes32 private immutable _HASHED_VERSION;
    bytes32 private immutable _TYPE_HASH;

    

    
    constructor(string memory name, string memory version) {
        bytes32 hashedName = keccak256(bytes(name));
        bytes32 hashedVersion = keccak256(bytes(version));
        bytes32 typeHash = keccak256(
            "EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"
        );
        _HASHED_NAME = hashedName;
        _HASHED_VERSION = hashedVersion;
        _CACHED_CHAIN_ID = block.chainid;
        _CACHED_DOMAIN_SEPARATOR = _buildDomainSeparator(typeHash, hashedName, hashedVersion);
        _CACHED_THIS = address(this);
        _TYPE_HASH = typeHash;
    }

    
    function _domainSeparatorV4() internal view returns (bytes32) {
        if (address(this) == _CACHED_THIS && block.chainid == _CACHED_CHAIN_ID) {
            return _CACHED_DOMAIN_SEPARATOR;
        } else {
            return _buildDomainSeparator(_TYPE_HASH, _HASHED_NAME, _HASHED_VERSION);
        }
    }

    function _buildDomainSeparator(
        bytes32 typeHash,
        bytes32 nameHash,
        bytes32 versionHash
    ) private view returns (bytes32) {
        return keccak256(abi.encode(typeHash, nameHash, versionHash, block.chainid, address(this)));
    }

    
    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {
        return ECDSA.toTypedDataHash(_domainSeparatorV4(), structHash);
    }
}

pragma solidity 0.8.0;

contract TimersLock is Ownable {

    uint256 private InitalTime;

    uint256[] public timers = [0, 30 days, 30 days, 30 days, 30 days];

    constructor() Ownable() {
        InitalTime = block.timestamp;
    }

    function getInitalTime() public view returns (uint256) {
        return InitalTime;
    }

    function getTimers() public view returns (uint256[] memory) {
        return timers;
    }

    function setTimers(uint256 index, uint256 time) external onlyOwner {
        require(index < timers.length, "Abnormal index");
        timers[index] = time;
    }

    function IsUnLock(uint256 count) external view returns (bool) {
        if (count < 2001) return true;
        uint256 index = (count - 1) / 2e03;
        uint256 times = InitalTime;
        for (uint256 x = 1; x <= index; x++) {
            times += timers[x];
        }
        return block.timestamp < times ? false : true;
    }
}

pragma solidity 0.8.0;

contract MadCanner is ERC721Enumerable, EIP712, ReentrancyGuard, Ownable, IERC721Receiver {
    using SafeMath for uint256;
    using Strings for uint256;
    using ECDSA for bytes32;

    
    bytes32 public constant PERMIT_TYPEHASH = 0xc242e34b93f9ad1ffc2c2c079dea5dccebcd284285197f32e072ea272cc3eef1;
    uint256 public constant FIXEDCOUNT = 8;
    uint256 public constant FIXEDNUMBRER = 1e04;
    uint256 public constant Fee = 0.02 ether;
    string public constant baseURI_prefix = "ipfs:
    string public constant sprit = "/";
    string public constant baseURI_part = "QmUcPhoXfFgNXdvU69cBUZerSVQi8y1o4KUsVuf5M79VMn/";
    string public constant baseURI = "QmaUrqFgD27LQoZUPD1snZNxiReyn6ybENKRtSYUhxyUFN/";

    uint256 public TokenId = 2e04;
    uint256 public CannerTotal;
    TimersLock public timersLock;

    mapping(uint256 => uint256) public FinishHead;
    mapping(uint256 => uint256) public PartMap;
    mapping(uint256 => bool) public ClaimMap;

    enum CannerType {Template, Background, Eyes, Mouth, Body, Top, Straw, Gesture}

    string[] private template = [
    "Template", "Background", "Eyes", "Mouth", "Body", "Top", "Straw", "Gesture"
    ];

    string[] private background = [
    "", "Wallflower Pink", "Tangerine", "Gray Screen", "Pistachio Green", "Celestial Blue", "Dried Lavender", "Loggia", "Wenge",
    "Agate Green", "Sonic Silver"
    ];

    string[] private eyes = [
    "", "Wide-Eyed", "Mad", "Hypnotized", "Puzzled", "Sleepy", "Blindfold", "Angry",
    "Closed", "Central Heterochromia", "Sad", "3D Glasses", "Love", "Coins", "Sunglasses", "VR glasses",
    "Holographic Glasses", "Bloodshot", "Star Eyes", "Piercing Eyes", "Fire", "Cyborg", "Compound Eyes", "Laser Eyes",
    "Eyepatch"
    ];

    string[] private mouth = [
    "", "Grin", "Small Grin", "Mad Laugher", "Rage", "Flaming Red Lips", "Drool", "Dumbfounded",
    "Tongue Out", "Cigarette", "Phoneme Oh", "Lollipop", "Spoon", "Bread", "Plastic Straw", "Cigar",
    "Phoneme OOO", "Cheese", "Toothpick", "Mad Pizza", "Flower", "Pipe", "Grin Colored Grill", "Party Horn",
    "Jovial", "Gold Pipe", "Grin Red Agate Grill", "Grin Diamond Grill", "Grin Gold Grill", "Bubblegum", "Mad Cigar", "Mad Cigarette",
    "Flaming"
    ];

    string[] private body = [
    "", "Swirl", "Black and White", "Magic Red", "Laser", "Captain", "IronMan", "Fukurai",
    "Japanese", "Cyberpunk", "Tiger", "Zebra", "Leopard", "Marble", "Bandage", "Universe",
    "Gold", "Gengon", "Ocean", "Acidic Laser", "Heartwarming", "Mosaic", "Playboy", "Halloween",
    "Paper Waste", "De sterrennacht", "Auspicious", "Spider", "Merry Christmas", "Eyeball", "Maple Leaf", "Bubble Tea",
    "Plaid", "Abstract Art", "Candy", "Crystal Ball", "Blue Leather", "White Leather", "Dripping Glass", "Rusty Steel",
    "Blood", "Comics", "Space Swirl", "Blackhole"
    ];

    string[] private top = [
    "", "Orange", "Green", "Purple", "Blue", "Glass", "Golden", "Iron Sheet",
    "Jade", "Rainbow", "Rusty", "Wooden", "Diamond"
    ];

    string[] private straw = [
    "", "Coloured", "Dripping", "Flexible", "Recycle Paper", "Couple", "Pipe", "Diamond",
    "Golden", "Reed", "Bamboo", "Ladder", "Snake"
    ];

    string[] private gesture = [
    "", "Beer", "Diamond Ring", "Bag", "Coffee", "Thanos Gloves", "Golden Tactical Gloves", "Boxing Gloves",
    "Fabric Gloves", "Grab Doge", "Grab Kitty", "Grab Punk", "Bot Arm"
    ];

    uint256[][] private level = [
    [0, 0, 0, 0, 0],
    [11, 0, 0, 0, 0],
    [6, 11, 6, 8, 17],
    [10, 13, 10, 10, 23],
    [44, 0, 0, 0, 0],
    [5, 4, 5, 4, 9],
    [5, 4, 5, 4, 9],
    [5, 4, 5, 4, 9]
    ];

    event Claim(uint256 tokenId, address from, uint256[8] tokenIds);
    event Split(uint256 tokenId, address to);
    event Merge(uint256 indexed templateId, uint256[] ids, address to);
    event Seal(uint256 tokenId);
    event Replace(uint256 tokenId, uint256[] _headTokenIds);
    event Withdraw(address to);

    constructor() ERC721("MadCanner", "MadCanner") EIP712("MadCanner", "1") Ownable() {}

    function random(string memory input) internal pure returns (uint256) {
        return uint256(keccak256(abi.encodePacked(input)));
    }

    function getBackground(uint256 tokenId) internal view returns (uint256) {
        return pluck(tokenId, "BACKGROUND", uint(CannerType.Background));
    }

    function getEyes(uint256 tokenId) internal view returns (uint256) {
        return pluck(tokenId, "EYE", uint(CannerType.Eyes));
    }

    function getMouth(uint256 tokenId) internal view returns (uint256) {
        return pluck(tokenId, "MOUTH", uint(CannerType.Mouth));
    }

    function getBody(uint256 tokenId) internal view returns (uint256) {
        return pluck(tokenId, "BODY", uint(CannerType.Body));
    }

    function getTop(uint256 tokenId) internal view returns (uint256) {
        return pluck(tokenId, "TOP", uint(CannerType.Top));
    }

    function getStraw(uint256 tokenId) internal view returns (uint256) {
        return pluck(tokenId, "STRAW", uint(CannerType.Straw));
    }

    function getGesture(uint256 tokenId) internal view returns (uint256) {
        return pluck(tokenId, "GESTURE", uint(CannerType.Gesture));
    }

    function pluck(uint256 tokenId, string memory keyPrefix, uint256 headType) internal view returns (uint256) {
        uint256 rand = random(string(abi.encodePacked(keyPrefix, tokenId.toString())));
        uint256 output = rand % level[headType][0];
        if (uint(CannerType.Background) == headType || uint(CannerType.Body) == headType) {
            return output;
        }
        uint256 greatness = rand % 21;
        if (greatness > 19) {
            output = level[headType][4].add(rand % level[headType][3]);
            return output;
        }
        if (greatness >= 14) {
            output = level[headType][2].add(rand % level[headType][1]);
            return output;
        }
        return output;
    }

    function claim(uint256 tokenId) external payable nonReentrant {
        require(tokenId > 0 && tokenId < 9501, "Token ID invalid");
        require(timersLock.IsUnLock(++CannerTotal), "Locking");
        require(msg.value >= charges(), "Insufficient handling fee");
        _claim(tokenId);
    }

    function claimPermit(uint256 tokenId, bytes calldata _signature) external {
        require(tokenId > 9500 && tokenId < 10001, "Token ID invalid");
        if (_msgSender() != owner()) {
            bytes32 digst = _hashTypedDataV4(keccak256(abi.encode(PERMIT_TYPEHASH, _msgSender(), tokenId)));
            require(digst.recover(_signature) == owner(), "Permit Failure");
        }
        _claim(tokenId);
    }

    function _claim(uint256 tokenId) internal {
        require(!ClaimMap[tokenId], "Token ID already claim");
        _safeMint(_msgSender(), tokenId);

        uint256 parts = reallocate(tokenId);
        for (uint256 x = 0; x < FIXEDCOUNT; x++) {
            uint256 attr = AvatarBitmap.getAttr(parts, x);
            if (attr == 0) continue;
            uint256 tokenId_part;
            if (uint(CannerType.Template) == x) {
                tokenId_part = tokenId.add(FIXEDNUMBRER);
            } else {
                tokenId_part = ++TokenId;
            }
            FinishHead[tokenId] = TokenIds.setTokenId(FinishHead[tokenId], x, tokenId_part);
            ComponentBitmap.setIdxAttr(PartMap, tokenId_part, x, attr);

            _safeMint(address(this), tokenId_part);
        }

        ClaimMap[tokenId] = true;
        emit Claim(tokenId, _msgSender(), TokenIds.getTokenIds(FinishHead[tokenId]));
    }

    function reallocate(uint256 tokenId) internal view returns (uint256) {
        uint256 parts;
        uint256 attr;
        for (uint256 x = 0; x < FIXEDCOUNT; x++) {
            if (uint(CannerType.Template) == x) attr = 100;
            if (uint(CannerType.Background) == x) attr = getBackground(tokenId);
            if (uint(CannerType.Eyes) == x) attr = getEyes(tokenId);
            if (uint(CannerType.Mouth) == x) attr = getMouth(tokenId);
            if (uint(CannerType.Body) == x) attr = getBody(tokenId);
            if (uint(CannerType.Top) == x) attr = getTop(tokenId);
            if (uint(CannerType.Straw) == x) attr = getStraw(tokenId);
            if (uint(CannerType.Gesture) == x) attr = getGesture(tokenId);
            if (attr == 0) continue;
            parts = AvatarBitmap.setAttr(parts, x, attr);
        }
        return parts;
    }

    function split(uint256 tokenId, address to) external nonReentrant {
        require(_msgSender() == ownerOf(tokenId), "Caller is not the owner");
        require(to != address(0), "To the zero address");
        uint256 metahead = FinishHead[tokenId];
        require(metahead > 0, "Token ID invalid");
        require(!TokenIds.getSeal(metahead), "Token ID is sealed");

        _transferFromBatch(metahead, to);

        delete FinishHead[tokenId];
        _burn(tokenId);

        emit Split(tokenId, to);
    }

    function merge(uint256 templateId, uint256[] calldata ids, address to) external nonReentrant {
        (, uint256 attr) = ComponentBitmap.getIdxAttr(PartMap, templateId);
        require(templateId > 10000 && templateId < 20001 && attr == 100, "Template Token ID invalid");

        uint256 tokenId = templateId.sub(FIXEDNUMBRER);
        _safeMint(to, tokenId);
        setCanner(tokenId, templateId, ids);

        emit Merge(templateId, ids, to);
    }

    function seal(uint256 tokenId) external {
        require(_msgSender() == ownerOf(tokenId), "Caller is not the owner");
        uint256 metaHead = FinishHead[tokenId];
        require(metaHead > 0, "Token ID abnormal");
        require(!TokenIds.getSeal(metaHead), "Token ID is sealed");
        FinishHead[tokenId] = TokenIds.setSeal(metaHead, true);

        emit Seal(tokenId);
    }

    function isSeal(uint256 tokenId) external view returns (bool) {
        uint256 metaHead = FinishHead[tokenId];
        return TokenIds.getSeal(metaHead);
    }

    function replace(uint256 tokenId, uint256[] calldata _headTokenIds) external nonReentrant {
        require(_msgSender() == ownerOf(tokenId), "Caller is not the owner");
        require(_headTokenIds.length > 0, "The headTokenIds length invalid");

        uint256 metaHead = FinishHead[tokenId];
        require(metaHead > 0, "Token ID abnormal");
        require(!TokenIds.getSeal(metaHead), "Token ID is sealed");

        for (uint256 x = 0; x < _headTokenIds.length; x++) {
            metaHead = FinishHead[tokenId];
            (uint256 index,) = ComponentBitmap.getIdxAttr(PartMap, _headTokenIds[x]);
            require(index > 0 && _headTokenIds[x] > 20000, "The Id abnormal");

            safeTransferFrom(_msgSender(), address(this), _headTokenIds[x]);

            uint256 tokenId_part = TokenIds.getTokenId(metaHead, index);
            if (tokenId_part > 0) {
                _safeTransfer(address(this), _msgSender(), tokenId_part, "");
            }
            FinishHead[tokenId] = TokenIds.setTokenId(metaHead, index, _headTokenIds[x]);
        }

        emit Replace(tokenId, _headTokenIds);
    }

    function tokenURI(uint256 tokenId) override public view returns (string memory) {
        require(_exists(tokenId), "URI query for nonexistent token");
        uint256 metaHead = FinishHead[tokenId];
        if (metaHead == 0) {
            (uint256 index, uint256 attr) = ComponentBitmap.getIdxAttr(PartMap, tokenId);
            return string(abi.encodePacked(baseURI_prefix, baseURI, template[index], sprit, attr.toString()));
        } else {
            return getFullTokenURI(tokenId, metaHead);
        }
    }

    function getFullTokenURI(uint256 tokenId, uint256 metaHead) internal view returns (string memory) {
        string[15] memory parts;
        parts[0] = '<svg width="100%" height="100%" xmlns="http:
        parts[1] = getPartURI(metaHead, uint(CannerType.Background));
        parts[2] = '" id="svg_1" height="100%" width="100%" /><image xlink:href="https:
        parts[3] = getPartURI(metaHead, uint(CannerType.Top));
        parts[4] = '" id="svg_1" height="100%" width="100%" /><image xlink:href="https:
        parts[5] = getPartURI(metaHead, uint(CannerType.Straw));
        parts[6] = '" id="svg_1" height="100%" width="100%" /><image xlink:href="https:
        parts[7] = getPartURI(metaHead, uint(CannerType.Body));
        parts[8] = '" id="svg_1" height="100%" width="100%" /><image xlink:href="https:
        parts[9] = getPartURI(metaHead, uint(CannerType.Gesture));
        parts[10] = '" id="svg_1" height="100%" width="100%" /><image xlink:href="https:
        parts[11] = getPartURI(metaHead, uint(CannerType.Mouth));
        parts[12] = '" id="svg_1" height="100%" width="100%" /><image xlink:href="https:
        parts[13] = getPartURI(metaHead, uint(CannerType.Eyes));
        parts[14] = '" id="svg_1" height="100%" width="100%" /></g></svg>';

        string memory output = string(abi.encodePacked(parts[0], parts[1], parts[2], parts[3], parts[4], parts[5], parts[6], parts[7]));
        output = string(abi.encodePacked(output, parts[8], parts[9], parts[10], parts[11], parts[12], parts[13], parts[14]));

        string memory json = Base64.encode(bytes(string(abi.encodePacked('{"name": "Mad Canner #', tokenId.toString(),
            '", "description": "Mad Canner is the world first synthetic avatar collection of 10,000 unique NFTs created by Particle Protocol. Each Canner has 7 components: Background, Eyes, Mouth, Skin, Top, Straw and Gesture, and collectors can easily buy and sell parts in the marketplace and dress up their avatars.", "external_url": "www.particleprotocol.com", "image": "data:image/svg+xml;base64,',
            Base64.encode(bytes(output)), '", "attributes": ', getAttributes(metaHead), '}'))));
        output = string(abi.encodePacked('data:application/json;base64,', json));
        return output;
    }

    function getAttributes(uint256 metaHead) internal view returns (string memory) {
        string memory output = '[{"trait_type":"Template","value":"Canner"}';
        for (uint256 x = 1; x < FIXEDCOUNT; x++) {
            uint256 tokenId = TokenIds.getTokenId(metaHead, x);
            if (tokenId == 0) {
                output = string(abi.encodePacked(output, ',{"trait_type": "', template[x], '","value": "null"}'));
                continue;
            }
            (, uint256 attr) = ComponentBitmap.getIdxAttr(PartMap, tokenId);
            output = string(abi.encodePacked(output, ',{"trait_type": "', template[x], '","value": "', getPartAttr(x, attr), '"}'));
        }
        output = string(abi.encodePacked(output, ']'));
        return output;
    }

    function getPartAttr(uint256 index, uint256 attr) internal view returns (string memory) {
        if (uint(CannerType.Background) == index) return background[attr];
        if (uint(CannerType.Eyes) == index) return eyes[attr];
        if (uint(CannerType.Mouth) == index) return mouth[attr];
        if (uint(CannerType.Body) == index) return body[attr];
        if (uint(CannerType.Top) == index) return top[attr];
        if (uint(CannerType.Straw) == index) return straw[attr];
        if (uint(CannerType.Gesture) == index) return gesture[attr];
        return "";
    }

    function getPartURI(uint256 metaHead, uint256 index) internal view returns (string memory) {
        uint256 tokenId = TokenIds.getTokenId(metaHead, index);
        if (tokenId == 0) {
            return string(abi.encodePacked(baseURI_part, template[0], sprit, index.toString()));
        }
        (, uint256 attr) = ComponentBitmap.getIdxAttr(PartMap, tokenId);
        return string(abi.encodePacked(baseURI_part, template[index], sprit, attr.toString()));
    }

    function setCanner(uint256 tokenId, uint256 templateId, uint256[] memory ids) internal {
        require(ids.length > 0 && ids.length < FIXEDCOUNT, "The ids length invalid");

        safeTransferFrom(_msgSender(), address(this), templateId);
        FinishHead[tokenId] = TokenIds.setTokenId(FinishHead[tokenId], 0, templateId);

        uint256 record;
        for (uint256 x = 0; x < ids.length; x++) {
            require(ids[x] > 20000, "The ids invalid");
            (uint256 index, uint256 attr) = ComponentBitmap.getIdxAttr(PartMap, ids[x]);
            if (AvatarBitmap.getAttr(record, index) > 0) revert("Repeat types");
            record = AvatarBitmap.setAttr(record, index, attr);

            safeTransferFrom(_msgSender(), address(this), ids[x]);
            FinishHead[tokenId] = TokenIds.setTokenId(FinishHead[tokenId], index, ids[x]);
        }
    }

    function _transferFromBatch(uint256 metahead, address to) internal {
        uint256[8] memory tokenIds = TokenIds.getTokenIds(metahead);
        for (uint256 x = 0; x < tokenIds.length; x++) {
            if (tokenIds[x] > FIXEDNUMBRER) _safeTransfer(address(this), to, tokenIds[x], "");
        }
    }

    function getCanner(uint256 tokenId) external view returns (uint256[8] memory tokenIds, uint256[8] memory indexs, uint256[8] memory attrs) {
        uint256 metaHead = FinishHead[tokenId];
        if (metaHead == 0) {
            (uint256 index, uint256 attr) = ComponentBitmap.getIdxAttr(PartMap, tokenId);
            if (attr != 0) {
                tokenIds[0] = tokenId;
                indexs[0] = index;
                attrs[0] = attr;
            }
        } else {
            uint256[8] memory tokenIds_part = TokenIds.getTokenIds(metaHead);
            for (uint256 x = 0; x < tokenIds_part.length; x++) {
                indexs[x] = x;
                if (tokenIds_part[x] == 0) continue;
                tokenIds[x] = tokenIds_part[x];
                (, attrs[x]) = ComponentBitmap.getIdxAttr(PartMap, tokenIds_part[x]);
            }
        }
    }

    function withdraw() external onlyOwner {
        payable(_msgSender()).transfer(address(this).balance);

        emit Withdraw(_msgSender());
    }

    function setTimersLock(address _timers) external onlyOwner {
        timersLock = TimersLock(_timers);
    }

    function onERC721Received(
        address operator,
        address from,
        uint256 tokenId,
        bytes calldata data
    ) external pure override returns (bytes4) {
        return this.onERC721Received.selector;
    }

    function charges() internal view returns (uint256) {
        if (CannerTotal < 2001) return Fee;
        return Fee * 2 ** ((CannerTotal - 1) / 2e03);
    }
}