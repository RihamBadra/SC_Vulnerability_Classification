




pragma solidity 0.6.12;


contract Initializable {

  
  bool private initialized;

  
  bool private initializing;

  
  modifier initializer() {
    require(initializing || isConstructor() || !initialized, "Contract instance has already been initialized");

    bool isTopLevelCall = !initializing;
    if (isTopLevelCall) {
      initializing = true;
      initialized = true;
    }

    _;

    if (isTopLevelCall) {
      initializing = false;
    }
  }

  
  function isConstructor() private view returns (bool) {
    
    
    
    
    
    address self = address(this);
    uint256 cs;
    assembly { cs := extcodesize(self) }
    return cs == 0;
  }

  
  uint256[50] private ______gap;
}



contract ContextUpgradeSafe is Initializable {
    
    

    function __Context_init() internal initializer {
        __Context_init_unchained();
    }

    function __Context_init_unchained() internal initializer {


    }


    function _msgSender() internal view virtual returns (address payable) {
        return msg.sender;
    }

    function _msgData() internal view virtual returns (bytes memory) {
        this; 
        return msg.data;
    }

    uint256[50] private __gap;
}


contract OwnableUpgradeSafe is Initializable, ContextUpgradeSafe {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    

    function __Ownable_init() internal initializer {
        __Context_init_unchained();
        __Ownable_init_unchained();
    }

    function __Ownable_init_unchained() internal initializer {


        address msgSender = _msgSender();
        _owner = msgSender;
        emit OwnershipTransferred(address(0), msgSender);

    }


    
    function owner() public view returns (address) {
        return _owner;
    }

    
    modifier onlyOwner() {
        require(_owner == _msgSender(), "Ownable: caller is not the owner");
        _;
    }

    
    function renounceOwnership() public virtual onlyOwner {
        emit OwnershipTransferred(_owner, address(0));
        _owner = address(0);
    }

    
    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), "Ownable: new owner is the zero address");
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }

    uint256[49] private __gap;
}


contract ReentrancyGuardUpgradeSafe is Initializable {
    bool private _notEntered;


    function __ReentrancyGuard_init() internal initializer {
        __ReentrancyGuard_init_unchained();
    }

    function __ReentrancyGuard_init_unchained() internal initializer {


        
        
        
        
        
        
        _notEntered = true;

    }


    
    modifier nonReentrant() {
        
        require(_notEntered, "ReentrancyGuard: reentrant call");

        
        _notEntered = false;

        _;

        
        
        _notEntered = true;
    }

    uint256[49] private __gap;
}


library SafeMath {
    
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, "SafeMath: addition overflow");

        return c;
    }

    
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        return sub(a, b, "SafeMath: subtraction overflow");
    }

    
    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b <= a, errorMessage);
        uint256 c = a - b;

        return c;
    }

    
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        
        
        
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b, "SafeMath: multiplication overflow");

        return c;
    }

    
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        return div(a, b, "SafeMath: division by zero");
    }

    
    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        
        require(b > 0, errorMessage);
        uint256 c = a / b;
        

        return c;
    }

    
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        return mod(a, b, "SafeMath: modulo by zero");
    }

    
    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b != 0, errorMessage);
        return a % b;
    }
}


interface IERC20 {
    
    function totalSupply() external view returns (uint256);

    
    function balanceOf(address account) external view returns (uint256);

    
    function transfer(address recipient, uint256 amount) external returns (bool);

    
    function allowance(address owner, address spender) external view returns (uint256);

    
    function approve(address spender, uint256 amount) external returns (bool);

    
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);

    
    event Transfer(address indexed from, address indexed to, uint256 value);

    
    event Approval(address indexed owner, address indexed spender, uint256 value);
}


library TransferHelper {
    function safeApprove(
        address token,
        address to,
        uint256 value
    ) internal {
        
        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));
        require(
            success && (data.length == 0 || abi.decode(data, (bool))),
            'TransferHelper::safeApprove: approve failed'
        );
    }

    function safeTransfer(
        address token,
        address to,
        uint256 value
    ) internal {
        
        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));
        require(
            success && (data.length == 0 || abi.decode(data, (bool))),
            'TransferHelper::safeTransfer: transfer failed'
        );
    }

    function safeTransferFrom(
        address token,
        address from,
        address to,
        uint256 value
    ) internal {
        
        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));
        require(
            success && (data.length == 0 || abi.decode(data, (bool))),
            'TransferHelper::transferFrom: transferFrom failed'
        );
    }

    function safeTransferETH(address to, uint256 value) internal {
        (bool success, ) = to.call{value: value}(new bytes(0));
        require(success, 'TransferHelper::safeTransferETH: ETH transfer failed');
    }
}


contract SwitchStakingVoice is OwnableUpgradeSafe, ReentrancyGuardUpgradeSafe {
    using SafeMath for uint256;
    using TransferHelper for address;

    address public tokenEth;
    address public token;

    uint256 public totalStakers;
    uint256 public totalRewards;
    uint256 public totalClaimedRewards;
    uint256 public startTime;
    uint256 public firstStakeTime;
    uint256 public endTime;

    uint256 private _totalStakeTokenEth;
    uint256 private _totalWeight;
    uint256 private _mostRecentValueCalcTime;

    uint256 public _stakeDivisor;

    mapping(address => uint256) public userClaimedRewards;

    mapping(address => uint256) private _userStakedTokenEth;
    mapping(address => uint256) private _userWeighted;
    mapping(address => uint256) private _userAccumulated;

    event Deposit(uint256 totalRewards, uint256 startTime, uint256 endTime);
    event Stake(address indexed staker, uint256 tokenEthIn);
    event Payout(address indexed staker, uint256 reward);
    event Withdraw(address indexed staker, uint256 tokenEthOut);
    event Refresh(uint256 totalRewards, uint256 startTime, uint256 endTime);

    
    function initialize(address _tokenEth, address _token, uint256 divisor) public initializer {
        __Ownable_init();
        __ReentrancyGuard_init();
        tokenEth = _tokenEth;
        token = _token;
        _stakeDivisor = divisor;
    }

    function changeDivisor(uint256 divisor) public onlyOwner {
        _stakeDivisor = divisor;
    }

    function deposit(uint256 _startTime, uint256 _endTime) public virtual onlyOwner {
        require(startTime == 0, "LiquidityMining::deposit: already received deposit");
        require(_startTime >= block.timestamp, "LiquidityMining::deposit: start time must be in future");
        require(_endTime > _startTime, "LiquidityMining::deposit: end time must after start time");
        

        totalRewards = IERC20(token).balanceOf(address(this));

        
        startTime = _startTime;
        endTime = _endTime;

        emit Deposit(totalRewards, _startTime, _endTime);
    }

    function refreshRewards(uint256 _endTime) public onlyOwner {
        totalRewards = IERC20(token).balanceOf(address(this));
        startTime = block.timestamp;
        endTime = _endTime;

        emit Refresh(totalRewards, block.timestamp, _endTime);
    }

    function totalStake() public view returns (uint256 total) {
        total = _totalStakeTokenEth;
    }

    function totalUserStake(address user) public view returns (uint256 total) {
        total = _userStakedTokenEth[user];
    }

    modifier update() {
        if (_mostRecentValueCalcTime == 0) {
            _mostRecentValueCalcTime = firstStakeTime;
        }

        uint256 totalCurrentStake = totalStake();

        if (totalCurrentStake > 0 && _mostRecentValueCalcTime < endTime) {
            uint256 value = 0;
            uint256 sinceLastCalc = block.timestamp.sub(_mostRecentValueCalcTime);
            uint256 perSecondReward = totalRewards.div(endTime.sub(firstStakeTime));

            if (block.timestamp < endTime) {
                value = sinceLastCalc.mul(perSecondReward);
            } else {
                uint256 sinceEndTime = block.timestamp.sub(endTime);
                value = (sinceLastCalc.sub(sinceEndTime)).mul(perSecondReward);
            }

            _totalWeight = _totalWeight.add(value.mul(10**18).div(totalCurrentStake));

            _mostRecentValueCalcTime = block.timestamp;
        }

        _;
    }

    function stake(uint256 tokenEthIn) public virtual update nonReentrant {
        require(tokenEthIn > 0, "LiquidityMining::stake: missing stake");
        require(block.timestamp >= startTime, "LiquidityMining::stake: not live yet");
        require(IERC20(token).balanceOf(address(this)) > 0, "LiquidityMining::stake: no reward balance");

        if (firstStakeTime == 0) {
            firstStakeTime = block.timestamp;
        } else {
            require(block.timestamp < endTime, "LiquidityMining::stake: staking is over");
        }

        if (tokenEthIn > 0) {
            tokenEth.safeTransferFrom(msg.sender, address(this), tokenEthIn);
        }

        if (totalUserStake(msg.sender) == 0) {
            totalStakers = totalStakers.add(1);
        }

        _stake(tokenEthIn, msg.sender);

        emit Stake(msg.sender, tokenEthIn);
    }

    function withdraw() public virtual update nonReentrant returns (uint256 tokenEthOut, uint256 reward) {
        totalStakers = totalStakers.sub(1);

        (tokenEthOut, reward) = _applyReward(msg.sender);

        if (tokenEthOut > 0) {
            tokenEth.safeTransfer(msg.sender, tokenEthOut);
        }

        if (reward > 0) {
            IERC20(token).transfer(msg.sender, reward);
            userClaimedRewards[msg.sender] = userClaimedRewards[msg.sender].add(
                reward
            );
            totalClaimedRewards = totalClaimedRewards.add(reward);

            emit Payout(msg.sender, reward);
        }

        emit Withdraw(msg.sender, tokenEthOut);
    }

    function payout() public virtual update nonReentrant returns (uint256 reward) {
        require(block.timestamp < endTime, "LiquidityMining::payout: withdraw instead");

        (uint256 tokenEthOut, uint256 _reward) = _applyReward(msg.sender);

        reward = _reward;

        if (reward > 0) {
            IERC20(token).transfer(msg.sender, reward);
            userClaimedRewards[msg.sender] = userClaimedRewards[msg.sender].add(
                reward
            );
            totalClaimedRewards = totalClaimedRewards.add(reward);
        }

        _stake(tokenEthOut, msg.sender);

        emit Payout(msg.sender, _reward);
    }

    function _stake(uint256 tokenEthIn, address account) private {
        uint256 addBackTokenEth;

        if (totalUserStake(account) > 0) {
            (uint256 tokenEthOut, uint256 reward) = _applyReward(account);
            addBackTokenEth = tokenEthOut;
            _userStakedTokenEth[account] = tokenEthOut;
            _userAccumulated[account] = reward;
        }

        _userStakedTokenEth[account] = _userStakedTokenEth[account].add(
            tokenEthIn
        );

        _userWeighted[account] = _totalWeight;

        _totalStakeTokenEth = _totalStakeTokenEth.add(tokenEthIn);

        if (addBackTokenEth > 0) {
            _totalStakeTokenEth = _totalStakeTokenEth.add(addBackTokenEth);
        }
    }

    function _applyReward(address account) private returns (uint256 tokenEthOut, uint256 reward) {
        uint256 _totalUserStake = totalUserStake(account);
        require(_totalUserStake > 0, "LiquidityMining::_applyReward: no coins staked");

        tokenEthOut = _userStakedTokenEth[account];

        reward = _totalUserStake
                .mul(_totalWeight.sub(_userWeighted[account]))
                
                .div(calculateMultiplier(account))
                .add(_userAccumulated[account]);

        _totalStakeTokenEth = _totalStakeTokenEth.sub(tokenEthOut);

        _userStakedTokenEth[account] = 0;

        _userAccumulated[account] = 0;
    }

    function rescueTokens(address tokenToRescue, address to, uint256 amount) public virtual onlyOwner nonReentrant {
        if (tokenToRescue == tokenEth) {
            require(amount <= IERC20(tokenEth).balanceOf(address(this)).sub(_totalStakeTokenEth),
                "LiquidityMining::rescueTokens: that Token-Eth belongs to stakers"
            );
        } else if (tokenToRescue == token) {
            if (totalStakers > 0) {
                require(amount <= IERC20(token).balanceOf(address(this)).sub(totalRewards.sub(totalClaimedRewards)),
                    "LiquidityMining::rescueTokens: that token belongs to stakers"
                );
            }
        }

        IERC20(tokenToRescue).transfer(to, amount);
    }

    
    
    
    function calculateMultiplier(address account) public view returns (uint256) {
        require(account != address(0), "LiquidityMining::calculateMultiplier: missing account");

        uint256 accountBaseBalance = IERC20(token).balanceOf(account);

        
        uint256 liquidityContractBalance = IERC20(token).balanceOf(tokenEth);
        
        uint256 liquidityContractSupply = IERC20(tokenEth).totalSupply();

        uint256 userLP = totalUserStake(account);

        uint256 lpBaseBalance = userLP.mul(liquidityContractBalance).div(liquidityContractSupply);

        if(accountBaseBalance == 0 || liquidityContractSupply == 0 || lpBaseBalance == 0){
          return _stakeDivisor;
        }

        return _stakeDivisor.sub(_stakeDivisor.sub(10**18).mul(clamp_value(accountBaseBalance.mul(10**18).div(lpBaseBalance), 10**18)).div(10**18));
    }

    function clamp_value(uint min, uint max) view public returns (uint) {
        if (min < max) {
            return min;
        } else {
            return max;
        }
    }
}