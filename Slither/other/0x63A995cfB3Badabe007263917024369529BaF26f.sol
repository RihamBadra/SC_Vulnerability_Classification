pragma solidity 0.5.15;

library Addresses {

    function isContract(address account) internal view returns (bool) {

        uint256 size;

        

        assembly {

            size := extcodesize(account)

        }

        return size > 0;

    }



    function performEthTransfer(address recipient, uint256 amount) internal {

        

        (bool success, ) = recipient.call.value(amount)(""); 

        require(success, "ETH_TRANSFER_FAILED");

    }



    

    function safeTokenContractCall(address tokenAddress, bytes memory callData) internal {

        require(isContract(tokenAddress), "BAD_TOKEN_ADDRESS");

        

        

        (bool success, bytes memory returndata) = address(tokenAddress).call(callData);

        require(success, string(returndata));



        if (returndata.length > 0) {

            require(abi.decode(returndata, (bool)), "TOKEN_OPERATION_FAILED");

        }

    }

}

library StarkExTypes {



    

    

    

    

    

    

    

    struct ApprovalChainData {

        address[] list;

        

        

        

        mapping (address => uint256) unlockedForRemovalTime;

    }



}

contract GovernanceStorage {



    struct GovernanceInfoStruct {

        mapping (address => bool) effectiveGovernors;

        address candidateGovernor;

        bool initialized;

    }



    

    mapping (string => GovernanceInfoStruct) internal governanceInfo;

}

contract IDispatcher {



    function getSubContract(bytes4 selector) internal view returns (address);



    function setSubContractAddress(uint256 index, address subContract) internal;



    function getNumSubcontracts() internal pure returns (uint256);



    function validateSubContractIndex(uint256 index, address subContract) internal pure;



    

    function initializationSentinel() internal view;

}

contract IFactRegistry {

    

    function isValid(bytes32 fact)

        external view

        returns(bool);

}

contract Identity {



    

    function identify()

        external pure

        returns(string memory);

}

contract MainDispatcher is IDispatcher {



    using Addresses for address;



    function() external payable {

        address subContractAddress = getSubContract(msg.sig);

        require(subContractAddress != address(0x0), "NO_CONTRACT_FOR_FUNCTION");



        

        assembly {

            

            

            

            calldatacopy(0, 0, calldatasize)



            

            

            let result := delegatecall(gas, subContractAddress, 0, calldatasize, 0, 0)



            

            returndatacopy(0, 0, returndatasize)



            switch result

                

                case 0 {

                    revert(0, returndatasize)

                }

                default {

                    return(0, returndatasize)

                }

        }

    }



    

    

    function initialize(bytes memory data) public {

        

        uint256 nSubContracts = getNumSubcontracts();



        

        require(nSubContracts <= 15, "TOO_MANY_SUB_CONTRACTS");



        

        require(data.length >= 32 * (nSubContracts + 1), "SUB_CONTRACTS_NOT_PROVIDED");



        

        uint256 additionalDataSize = data.length - 32 * (nSubContracts + 1);



        

        uint256 totalInitSizes = 0;



        

        

        uint256 initDataContractsOffset = 32 * (nSubContracts + 1);



        

        for (uint256 nContract = 1; nContract <= nSubContracts; nContract++) {

            address contractAddress;



            

            

            assembly {

                contractAddress := mload(add(data, mul(32, nContract)))

            }



            validateSubContractIndex(nContract, contractAddress);



            

            setSubContractAddress(nContract, contractAddress);

        }



        

        address externalInitializerAddr;



        

        

        assembly {

            externalInitializerAddr := mload(add(data, mul(32, add(nSubContracts, 1))))

        }



        

        if (externalInitializerAddr != address(0x0)) {

            callExternalInitializer(data, externalInitializerAddr, additionalDataSize);

            return;

        }



        

        

        if (additionalDataSize == 0) {

            return;

        }



        

        assert(externalInitializerAddr == address(0x0));



        

        initializationSentinel();



        

        for (uint256 nContract = 1; nContract <= nSubContracts; nContract++) {

            address contractAddress;



            

            

            assembly {

                contractAddress := mload(add(data, mul(32, nContract)))

            }

            

            

            



            

            

            

            

            (bool success, bytes memory returndata) = contractAddress.delegatecall(

                abi.encodeWithSelector(SubContractor(contractAddress).initializerSize.selector));

            require(success, string(returndata));

            uint256 initSize = abi.decode(returndata, (uint256));

            require(initSize <= additionalDataSize, "INVALID_INITIALIZER_SIZE");

            require(totalInitSizes + initSize <= additionalDataSize, "INVALID_INITIALIZER_SIZE");



            if (initSize == 0) {

                continue;

            }



            

            bytes memory subContractInitData = new bytes(initSize);

            for (uint256 trgOffset = 32; trgOffset <= initSize; trgOffset += 32) {

                

                assembly {

                    mstore(

                        add(subContractInitData, trgOffset),

                        mload(add(add(data, trgOffset), initDataContractsOffset))

                    )

                }

            }



            

            

            

            (success, returndata) = contractAddress.delegatecall(

                abi.encodeWithSelector(this.initialize.selector, subContractInitData)

            );

            require(success, string(returndata));

            totalInitSizes += initSize;

            initDataContractsOffset += initSize;

        }

        require(

            additionalDataSize == totalInitSizes,

            "MISMATCHING_INIT_DATA_SIZE");

    }



    function callExternalInitializer(

        bytes memory data,

        address externalInitializerAddr,

        uint256 dataSize)

        private {

        require(externalInitializerAddr.isContract(), "NOT_A_CONTRACT");

        require(dataSize <= data.length, "INVALID_DATA_SIZE");

        bytes memory extInitData = new bytes(dataSize);



        

        uint256 srcDataOffset = 32 + data.length - dataSize;

        uint256 srcData;

        uint256 trgData;



        

        assembly {

            srcData := add(data, srcDataOffset)

            trgData := add(extInitData, 32)

        }



        

        for (uint256 seek = 0; seek < dataSize; seek += 32) {

            

            assembly {

                mstore(

                    add(trgData, seek),

                    mload(add(srcData, seek))

                )

            }

        }



        

        

        (bool success, bytes memory returndata) = externalInitializerAddr.delegatecall(

            abi.encodeWithSelector(this.initialize.selector, extInitData)

        );

        require(success, string(returndata));

        require(returndata.length == 0, string(returndata));

    }

}

contract ProxyStorage is GovernanceStorage {



    

    

    

    mapping (address => bytes32) internal initializationHash;



    

    mapping (address => uint256) internal enabledTime;



    

    

    

    mapping (bytes32 => bool) internal initialized;

}

contract SubContractor is Identity {



    function initialize(bytes calldata data)

        external;



    function initializerSize()

        external view

        returns(uint256);



}

contract MainStorage is ProxyStorage {



    IFactRegistry escapeVerifier_;



    

    bool stateFrozen;                               



    

    uint256 unFreezeTime;                           



    

    

    mapping (uint256 => mapping (uint256 => mapping (uint256 => uint256))) pendingDeposits;



    

    

    mapping (uint256 => mapping (uint256 => mapping (uint256 => uint256))) cancellationRequests;



    

    

    mapping (uint256 => mapping (uint256 => uint256)) pendingWithdrawals;



    

    mapping (uint256 => bool) escapesUsed;



    

    uint256 escapesUsedCount;                       



    

    

    mapping (uint256 => mapping (uint256 => uint256)) fullWithdrawalRequests;



    

    uint256 sequenceNumber;                         



    

    uint256 vaultRoot;                              

    uint256 vaultTreeHeight;                        



    

    uint256 orderRoot;                              

    uint256 orderTreeHeight;                        



    

    mapping (address => bool) tokenAdmins;



    

    mapping (address => bool) userAdmins;



    

    mapping (address => bool) operators;



    

    mapping (uint256 => bytes) assetTypeToAssetInfo;    



    

    mapping (uint256 => bool) registeredAssetType;      



    

    mapping (uint256 => uint256) assetTypeToQuantum;    



    

    mapping (address => uint256) starkKeys_DEPRECATED;  



    

    mapping (uint256 => address) ethKeys;               



    

    StarkExTypes.ApprovalChainData verifiersChain;

    StarkExTypes.ApprovalChainData availabilityVerifiersChain;



    

    uint256 lastBatchId;                            



    

    mapping(uint256 => address) subContracts;       

}

contract StarkExchange is MainStorage, MainDispatcher {

    string public constant VERSION = "2.0.1";

    string constant INIT_TAG = "INIT_TAG_Starkware.StarkExchange.2020.2.0.1";



    uint256 constant SUBCONTRACT_BITS = 4;



    

    

    uint256 constant MAGIC_SALT = 45733;

    uint256 constant IDX_MAP_0 = 0x201220230201001000221220210222000000020303010211120120200003002;

    uint256 constant IDX_MAP_1 = 0x2100003000200010003000000300100220220203000020000101022100011100;

    



    function validateSubContractIndex(uint256 index, address subContract) internal pure{

        string memory id = SubContractor(subContract).identify();

        bytes32 hashed_expected_id = keccak256(abi.encodePacked(expectedIdByIndex(index)));

        require(

            hashed_expected_id == keccak256(abi.encodePacked(id)),

            "MISPLACED_INDEX_OR_BAD_CONTRACT_ID");

    }



    function expectedIdByIndex(uint256 index)

        private pure returns (string memory id) {

        if (index == 1){

            id = "StarkWare_AllVerifiers_2020_1";

        } else if (index == 2){

            id = "StarkWare_TokensAndRamping_2020_1";

        } else if (index == 3){

            id = "StarkWare_StarkExState_2020_1";

        } else {

            revert("UNEXPECTED_INDEX");

        }

    }



    function getNumSubcontracts() internal pure returns (uint256) {

        return 3;

    }



    function getSubContract(bytes4 selector)

        internal view returns (address) {

        uint256 location = 0x7F & uint256(keccak256(abi.encodePacked(selector, MAGIC_SALT)));

        uint256 subContractIdx;

        uint256 offset = SUBCONTRACT_BITS * location % 256;

        if (location < 64) {

            subContractIdx = (IDX_MAP_0 >> offset) & 0xF;

        } else {

            subContractIdx = (IDX_MAP_1 >> offset) & 0xF;

        }

        return subContracts[subContractIdx];

    }



    function setSubContractAddress(uint256 index, address subContractAddress) internal {

        subContracts[index] = subContractAddress;

    }



    function initializationSentinel()

        internal view {

        string memory REVERT_MSG = "INITIALIZATION_BLOCKED";

        

        

        require(vaultRoot == 0, REVERT_MSG);

        require(vaultTreeHeight == 0, REVERT_MSG);

        require(orderRoot == 0, REVERT_MSG);

        require(orderTreeHeight == 0, REVERT_MSG);

    }

}
