



pragma solidity ^0.8.9;

abstract contract Context {
    function _msgSender() internal view virtual returns (address) {
        return msg.sender;
    }

    function _msgData() internal view virtual returns (bytes calldata) {
        return msg.data;
    }
}




pragma solidity ^0.8.9;


interface IERC165 {
    
    function supportsInterface(bytes4 interfaceId) external view returns (bool);
}





pragma solidity ^0.8.9;


contract ERC165 is IERC165 {
    
    bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;

    
    mapping(bytes4 => bool) private _supportedInterfaces;

    constructor() {
        
        
        _registerInterface(_INTERFACE_ID_ERC165);
    }

    
    function supportsInterface(bytes4 interfaceId)
        external
        view
        virtual
        override
        returns (bool)
    {
        return _supportedInterfaces[interfaceId];
    }

    
    function _registerInterface(bytes4 interfaceId) internal {
        require(interfaceId != 0xffffffff, "ERC165: invalid interface id");
        _supportedInterfaces[interfaceId] = true;
    }
}





pragma solidity ^0.8.9;


abstract contract IERC721 is IERC165 {
    event Transfer(
        address indexed from,
        address indexed to,
        uint256 indexed tokenId
    );
    event Approval(
        address indexed owner,
        address indexed approved,
        uint256 indexed tokenId
    );
    event ApprovalForAll(
        address indexed owner,
        address indexed operator,
        bool approved
    );

    
    function balanceOf(address owner)
        public
        view
        virtual
        returns (uint256 balance);

    
    function ownerOf(uint256 tokenId)
        public
        view
        virtual
        returns (address owner);

    
    function safeTransferFrom(
        address from,
        address to,
        uint256 tokenId
    ) public virtual;

    
    function transferFrom(
        address from,
        address to,
        uint256 tokenId
    ) public virtual;

    function approve(address to, uint256 tokenId) public virtual;

    function getApproved(uint256 tokenId)
        public
        view
        virtual
        returns (address operator);

    function setApprovalForAll(address operator, bool _approved) public virtual;

    function isApprovedForAll(address owner, address operator)
        public
        view
        virtual
        returns (bool);

    function safeTransferFrom(
        address from,
        address to,
        uint256 tokenId,
        bytes memory data
    ) public virtual;
}


abstract contract IERC721Enumerable is IERC721 {
    
    function totalSupply() external virtual view returns (uint256);

    
    function tokenOfOwnerByIndex(address owner, uint256 index) external virtual view returns (uint256);

    
    function tokenByIndex(uint256 index) external virtual view returns (uint256);
}





pragma solidity ^0.8.9;


library Address {
    
    function isContract(address account) internal view returns (bool) {
        
        
        

        uint256 size;
        
        assembly {
            size := extcodesize(account)
        }
        return size > 0;
    }
}

pragma solidity ^0.8.9;

library Strings {
    bytes16 private constant _HEX_SYMBOLS = "0123456789abcdef";

    function concatenate(string memory a, string memory b)
        internal
        pure
        returns (string memory)
    {
        return string(abi.encodePacked(a, b));
    }

    

    function str2int(string memory numString) internal pure returns (uint256) {
        uint256 val = 0;
        bytes memory stringBytes = bytes(numString);
        for (uint256 i; i < stringBytes.length; i++) {
            uint256 exp = stringBytes.length - i;
            bytes1 ival = stringBytes[i];
            uint8 uval = uint8(ival);
            uint256 jval = uval - uint256(0x30);

            val += (uint256(jval) * (10**(exp - 1)));
        }
        return val;
    }

    
    function substring(
        string memory str,
        uint256 startIndex,
        uint256 endIndex
    ) internal pure returns (string memory) {
        bytes memory strBytes = bytes(str);
        bytes memory result = new bytes(endIndex - startIndex);
        for (uint256 i = startIndex; i < endIndex; i++) {
            result[i - startIndex] = strBytes[i];
        }
        return string(result);
    }

    
    function stringLength(string memory str)
        internal
        pure
        returns (uint256 length)
    {
        uint256 i = 0;
        bytes memory string_rep = bytes(str);

        while (i < string_rep.length) {
            if (string_rep[i] >> 7 == 0) i += 1;
            else if (string_rep[i] >> 5 == bytes1(uint8(0x6))) i += 2;
            else if (string_rep[i] >> 4 == bytes1(uint8(0xE))) i += 3;
            else if (string_rep[i] >> 3 == bytes1(uint8(0x1E)))
                i += 4;
                
            else i += 1;

            length++;
        }
    }

    
    function reverse(string memory _base)
        internal
        pure
        returns (string memory)
    {
        bytes memory _baseBytes = bytes(_base);
        assert(_baseBytes.length > 0);

        string memory _tempValue = new string(_baseBytes.length);
        bytes memory _newValue = bytes(_tempValue);

        for (uint256 i = 0; i < _baseBytes.length; i++) {
            _newValue[_baseBytes.length - i - 1] = _baseBytes[i];
        }

        return string(_newValue);
    }
}

pragma solidity ^0.8.9;

library Ints {
    bytes16 private constant _HEX_SYMBOLS = "0123456789abcdef";

    
    function toString(uint256 value) internal pure returns (string memory) {
        
        

        if (value == 0) {
            return "0";
        }
        uint256 temp = value;
        uint256 digits;
        while (temp != 0) {
            digits++;
            temp /= 10;
        }
        bytes memory buffer = new bytes(digits);
        while (value != 0) {
            digits -= 1;
            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));
            value /= 10;
        }
        return string(buffer);
    }
}





pragma solidity ^0.8.9;


abstract contract IERC721Receiver {
    function onERC721Received(
        address operator,
        address from,
        uint256 tokenId,
        bytes memory data
    ) public virtual returns (bytes4);
}


interface IERC721Metadata {
    
    function name() external view returns (string memory);

    
    function symbol() external view returns (string memory);

    
    function tokenURI(uint256 tokenId) external view returns (string memory);
}



error ApprovalCallerNotOwnerNorApproved();
error ApprovalQueryForNonexistentToken();
error ApproveToCaller();
error ApprovalToCurrentOwner();
error BalanceQueryForZeroAddress();
error MintedQueryForZeroAddress();
error MintToZeroAddress();
error MintZeroQuantity();
error OwnerQueryForNonexistentToken();
error TransferCallerNotOwnerNorApproved();
error TransferFromIncorrectOwner();
error TransferToNonERC721ReceiverImplementer();
error TransferToZeroAddress();
error UnableDetermineTokenOwner();
error UnableGetTokenOwnerByIndex();
error URIQueryForNonexistentToken();
error BurnedQueryForZeroAddress();

pragma solidity ^0.8.9;

abstract contract ERC721A is Context, ERC165, IERC721, IERC721Metadata, IERC721Enumerable {
    using Address for address;
    using Ints for uint256;

    struct TokenOwnership {
        
        address addr;
        
        uint64 startTimestamp;
        
        bool burned;
    }

    struct AddressData {
        
        uint64 balance;
        
        uint64 numberMinted;
        
        uint64 numberBurned;
    }

    uint256 internal currentIndex;

    uint256[] internal burnedTokens;

    
    string private _name;

    
    string private _symbol;

    
    
    mapping(uint256 => TokenOwnership) internal _ownerships;

    
    mapping(address => AddressData) private _addressData;

    
    mapping(uint256 => address) private _tokenApprovals;

    
    mapping(address => mapping(address => bool)) private _operatorApprovals;

    constructor(string memory name_, string memory symbol_) {
        _name = name_;
        _symbol = symbol_;
    }

    
    function totalSupply() public view override returns (uint256) {
        return currentIndex - burnedTokens.length;
    }

    
    function supportsInterface(bytes4 interfaceId)
        public
        view
        virtual
        override(ERC165, IERC165)
        returns (bool)
    {
        return
            interfaceId == type(IERC721).interfaceId ||
            interfaceId == type(IERC721Metadata).interfaceId ||
            interfaceId == type(IERC165).interfaceId;
    }

    
    function balanceOf(address owner) public view override returns (uint256) {
        if (owner == address(0)) revert BalanceQueryForZeroAddress();
        return uint256(_addressData[owner].balance);
    }

    function _numberMinted(address owner) internal view returns (uint256) {
        if (owner == address(0)) revert MintedQueryForZeroAddress();
        return uint256(_addressData[owner].numberMinted);
    }

    function _numberBurned(address owner) internal view returns (uint256) {
        if (owner == address(0)) revert BurnedQueryForZeroAddress();
        return uint256(_addressData[owner].numberBurned);
    }

    
    function ownershipOf(uint256 tokenId)
        internal
        view
        returns (TokenOwnership memory)
    {
        if (!_exists(tokenId)) revert OwnerQueryForNonexistentToken();

        unchecked {
            for (uint256 curr = tokenId; curr >= 0; curr--) {
                TokenOwnership memory ownership = _ownerships[curr];
                if (!ownership.burned) {
                    if (ownership.addr != address(0)) {
                        return ownership;
                    }
                }
            }
        }

        revert UnableDetermineTokenOwner();
    }

    
    function ownerOf(uint256 tokenId) public view override returns (address) {
        return ownershipOf(tokenId).addr;
    }

    
    function isBurned(uint256 tokenId) public view returns (bool) {
        return _ownerships[tokenId].burned;
    }

    function getBurnedTokens() public view returns (uint256[] memory) {
        return burnedTokens;
    }

    

    function _isApprovedOrOwner(address spender, uint256 tokenId)
        internal
        view
        returns (bool)
    {
        require(
            _exists(tokenId),
            "ERC721: operator query for nonexistent token"
        );
        address owner = ownerOf(tokenId);
        return (spender == owner ||
            getApproved(tokenId) == spender ||
            isApprovedForAll(owner, spender));
    }

    
    function name() public view virtual override returns (string memory) {
        return _name;
    }

    
    function symbol() public view virtual override returns (string memory) {
        return _symbol;
    }

    
    function tokenURI(uint256 tokenId)
        public
        view
        virtual
        override
        returns (string memory)
    {
        if (!_exists(tokenId)) revert URIQueryForNonexistentToken();

        string memory baseURI = _baseURI();
        return
            bytes(baseURI).length != 0
                ? string(abi.encodePacked(baseURI, tokenId.toString()))
                : "";
    }

    
    function _baseURI() internal view virtual returns (string memory) {
        return "";
    }

    
    function approve(address to, uint256 tokenId) public override {
        address owner = ERC721A.ownerOf(tokenId);
        if (to == owner) revert ApprovalToCurrentOwner();

        if (_msgSender() != owner && !isApprovedForAll(owner, _msgSender()))
            revert ApprovalCallerNotOwnerNorApproved();

        _approve(to, tokenId, owner);
    }

    
    function getApproved(uint256 tokenId)
        public
        view
        override
        returns (address)
    {
        if (!_exists(tokenId)) revert ApprovalQueryForNonexistentToken();

        return _tokenApprovals[tokenId];
    }

    
    function setApprovalForAll(address operator, bool approved)
        public
        override
    {
        if (operator == _msgSender()) revert ApproveToCaller();

        _operatorApprovals[_msgSender()][operator] = approved;
        emit ApprovalForAll(_msgSender(), operator, approved);
    }

    
    function isApprovedForAll(address owner, address operator)
        public
        view
        virtual
        override
        returns (bool)
    {
        return _operatorApprovals[owner][operator];
    }

    
    function transferFrom(
        address from,
        address to,
        uint256 tokenId
    ) public virtual override {
        _transfer(from, to, tokenId);
    }

    
    function safeTransferFrom(
        address from,
        address to,
        uint256 tokenId
    ) public virtual override {
        safeTransferFrom(from, to, tokenId, "");
    }

    
    function safeTransferFrom(
        address from,
        address to,
        uint256 tokenId,
        bytes memory _data
    ) public override {
        _transfer(from, to, tokenId);
        if (!_checkOnERC721Received(from, to, tokenId, _data))
            revert TransferToNonERC721ReceiverImplementer();
    }

    
    function _exists(uint256 tokenId) internal view virtual returns (bool) {
        return tokenId < currentIndex;
    }

    function _safeMint(
        address to,
        uint256 startTokenId,
        uint256 quantity
    ) internal {
        _safeMint(to, startTokenId, quantity, "");
    }

    
    function _safeMint(
        address to,
        uint256 startTokenId,
        uint256 quantity,
        bytes memory _data
    ) internal {
        _mint(to, startTokenId, quantity, _data, true);
    }

    
    function _mint(
        address to,
        uint256 startTokenId,
        uint256 quantity,
        bytes memory _data,
        bool safe
    ) internal {
        if (to == address(0)) revert MintToZeroAddress();
        if (quantity == 0) revert MintZeroQuantity();

        _beforeTokenTransfers(address(0), to, startTokenId, quantity);

        
        
        
        unchecked {
            _addressData[to].balance += uint64(quantity);
            _addressData[to].numberMinted += uint64(quantity);

            _ownerships[startTokenId].addr = to;
            _ownerships[startTokenId].startTimestamp = uint64(block.timestamp);

            uint256 updatedIndex = startTokenId;

            for (uint256 i; i < quantity; i++) {
                emit Transfer(address(0), to, updatedIndex);
                if (
                    safe &&
                    !_checkOnERC721Received(address(0), to, updatedIndex, _data)
                ) {
                    revert TransferToNonERC721ReceiverImplementer();
                }

                updatedIndex++;
            }

            currentIndex = currentIndex + quantity;
        }

        _afterTokenTransfers(address(0), to, startTokenId, quantity);
    }

    

    function _burn(uint256 tokenId) internal {
        TokenOwnership memory prevOwnership = ownershipOf(tokenId);

        _beforeTokenTransfers(prevOwnership.addr, address(0), tokenId, 1);

        
        _approve(address(0), tokenId, prevOwnership.addr);

        
        _addressData[prevOwnership.addr].balance -= 1;
        _addressData[prevOwnership.addr].numberBurned += 1;

        
        _ownerships[tokenId].addr = prevOwnership.addr;
        _ownerships[tokenId].startTimestamp = uint64(block.timestamp);
        _ownerships[tokenId].burned = true;

        
        burnedTokens.push(tokenId);

        unchecked {
            
            
            uint256 nextTokenId = tokenId + 1;
            if (_ownerships[nextTokenId].addr == address(0)) {
                if (_exists(nextTokenId)) {
                    _ownerships[nextTokenId].addr = prevOwnership.addr;
                    _ownerships[nextTokenId].startTimestamp = prevOwnership
                        .startTimestamp;
                }
            }
        }

        emit Transfer(prevOwnership.addr, address(0), tokenId);

        _afterTokenTransfers(prevOwnership.addr, address(0), tokenId, 1);
    }

    
    function _transfer(
        address from,
        address to,
        uint256 tokenId
    ) internal {
        TokenOwnership memory prevOwnership = ownershipOf(tokenId);

        bool isApprovedOrOwner = (_msgSender() == prevOwnership.addr ||
            getApproved(tokenId) == _msgSender() ||
            isApprovedForAll(prevOwnership.addr, _msgSender()));

        if (!isApprovedOrOwner) revert TransferCallerNotOwnerNorApproved();
        if (prevOwnership.addr != from) revert TransferFromIncorrectOwner(); 
        if (to == address(0)) revert TransferToZeroAddress();

        _beforeTokenTransfers(from, to, tokenId, 1);

        
        _approve(address(0), tokenId, prevOwnership.addr);

        
        
        
        unchecked {
            _addressData[from].balance -= 1;
            _addressData[to].balance += 1;

            _ownerships[tokenId].addr = to;
            _ownerships[tokenId].startTimestamp = uint64(block.timestamp);

            
            
            uint256 nextTokenId = tokenId + 1;
            if (_ownerships[nextTokenId].addr == address(0)) {
                if (_exists(nextTokenId)) {
                    _ownerships[nextTokenId].addr = prevOwnership.addr;
                    _ownerships[nextTokenId].startTimestamp = prevOwnership
                        .startTimestamp;
                }
            }
        }

        emit Transfer(from, to, tokenId);
        _afterTokenTransfers(from, to, tokenId, 1);
    }

    
    function _approve(
        address to,
        uint256 tokenId,
        address owner
    ) private {
        _tokenApprovals[tokenId] = to;
        emit Approval(owner, to, tokenId);
    }

    
    function _checkOnERC721Received(
        address from,
        address to,
        uint256 tokenId,
        bytes memory _data
    ) private returns (bool) {
        if (to.isContract()) {
            try
                IERC721Receiver(to).onERC721Received(
                    _msgSender(),
                    from,
                    tokenId,
                    _data
                )
            returns (bytes4 retval) {
                return retval == IERC721Receiver(to).onERC721Received.selector;
            } catch (bytes memory reason) {
                if (reason.length == 0)
                    revert TransferToNonERC721ReceiverImplementer();
                else {
                    assembly {
                        revert(add(32, reason), mload(reason))
                    }
                }
            }
        } else {
            return true;
        }
    }

    
    function _beforeTokenTransfers(
        address from,
        address to,
        uint256 startTokenId,
        uint256 quantity
    ) internal virtual {}

    
    function _afterTokenTransfers(
        address from,
        address to,
        uint256 startTokenId,
        uint256 quantity
    ) internal virtual {}
}

pragma solidity ^0.8.9;

interface NtentTokenUri {
    function tokenUri(uint256 _tokenId) external view returns (string memory);
}

interface NtentTransfer {
    function onTransfer(
        address _from,
        address _to,
        uint256 _tokenId,
        uint256 _quantity
    ) external view returns (string memory);
}

contract NtentArtX is ERC721A {
    using Ints for uint256;
    using Strings for string;

    event Mint(
        uint256 indexed _startTokenId,
        uint256 indexed _endTokenId,
        uint256 indexed _projectId
    );

    event TokenBurned(address indexed _tokenOwner, uint256 indexed _tokenId);

    struct Project {
        string name;
        string artist;
        string description;
        string website;
        string license;
        address purchaseContract;
        address dataContract;
        address tokenUriContract;
        address transferContract;
        bool acceptsMintPass;
        uint256 mintPassProjectId;
        bool dynamic;
        string projectBaseURI;
        string projectBaseIpfsURI;
        uint256 invocations;
        uint256 maxInvocations;
        string scriptJSON;
        mapping(uint256 => string) scripts;
        uint256 scriptCount;
        string ipfsHash;
        bool useHashString;
        bool useIpfs;
        bool active;
        bool locked;
        bool paused;
    }

    uint256 constant ONE_MILLION = 1_000_000;
    mapping(uint256 => Project) projects;

    
    mapping(uint256 => address) public projectIdToArtistAddress;
    mapping(uint256 => uint256) public projectIdToPricePerTokenInWei;

    address public ntentAddress;
    uint256 public ntentPercentage = 10;

    mapping(uint256 => string) public staticIpfsImageLink;

    address public admin;
    mapping(address => bool) public isRainbowlisted;
    mapping(address => bool) public isMintRainbowlisted;

    uint256 public nextProjectId = 3;
    uint256 public startProjectId = 3;

    uint256 private _royaltyBps;
    address payable private _royaltyRecipient;
    bytes4 private constant _INTERFACE_ID_ROYALTIES_CREATORCORE = 0xbb3bafd6;
    bytes4 private constant _INTERFACE_ID_ROYALTIES_EIP2981 = 0x2a55205a;
    bytes4 private constant _INTERFACE_ID_ROYALTIES_RARIBLE = 0xb7799584;

    mapping(address => bool) proxyToApproved;

    modifier onlyValidTokenId(uint256 _tokenId) {
        require(_exists(_tokenId), "Token ID not exists");
        _;
    }

    modifier onlyUnlocked(uint256 _projectId) {
        require(!projects[_projectId].locked, "Only if unlocked");
        _;
    }

    modifier onlyArtist(uint256 _projectId) {
        require(
            msg.sender == projectIdToArtistAddress[_projectId],
            "Only artist"
        );
        _;
    }

    modifier onlyAdmin() {
        require(msg.sender == admin, "Only admin");
        _;
    }

    modifier onlyRainbowlisted() {
        require(isRainbowlisted[msg.sender], "Only Rainbowlisted");
        _;
    }

    modifier onlyArtistOrRainbowlisted(uint256 _projectId) {
        require(
            isRainbowlisted[msg.sender] ||
                msg.sender == projectIdToArtistAddress[_projectId],
            "Only artist or Rainbowlisted"
        );
        _;
    }

    constructor(string memory _tokenName, string memory _tokenSymbol)
        ERC721A(_tokenName, _tokenSymbol)
    {
        admin = msg.sender;
        isRainbowlisted[msg.sender] = true;
        ntentAddress = msg.sender;
    }

    function supportsInterface(bytes4 interfaceId)
        public
        view
        virtual
        override(ERC721A)
        returns (bool)
    {
        return
            interfaceId == type(IERC721).interfaceId ||
            ERC721A.supportsInterface(interfaceId) ||
            interfaceId == type(IERC721Metadata).interfaceId ||
            interfaceId == type(IERC721Enumerable).interfaceId ||
            interfaceId == _INTERFACE_ID_ROYALTIES_CREATORCORE ||
            interfaceId == _INTERFACE_ID_ROYALTIES_EIP2981 ||
            interfaceId == _INTERFACE_ID_ROYALTIES_RARIBLE;
    }

    function _exists(uint256 tokenId) internal view override returns (bool) {
        uint256 projectId = tokenIdToProjectId(tokenId);
        return
            (tokenId <
                ((projectId * ONE_MILLION) +
                    projects[projectId].invocations)) &&
            (tokenId >= (projectId * ONE_MILLION) && !isBurned(tokenId));
    }

    function mint(
        address _to,
        uint256 _projectId,
        uint256 quantity,
        address _by
    ) external returns (uint256 _tokenId) {
        require(
            isMintRainbowlisted[msg.sender],
            "Must mint from Rainbowlisted minter"
        );
        require(
            projects[_projectId].invocations + quantity <=
                projects[_projectId].maxInvocations,
            "Exceeds max invocations"
        );
        require(
            projects[_projectId].active ||
                _by == projectIdToArtistAddress[_projectId],
            "Proj must exist and be active"
        );
        require(
            !projects[_projectId].paused ||
                _by == projectIdToArtistAddress[_projectId],
            "Purchases are paused"
        );

        uint256 tokenId = _mintTokens(_to, _projectId, quantity);

        return tokenId;
    }

    function _mintTokens(
        address _to,
        uint256 _projectId,
        uint256 quantity
    ) internal returns (uint256 _tokenId) {
        uint256 nextStartTokenId = (_projectId * ONE_MILLION) +
            projects[_projectId].invocations;

        projects[_projectId].invocations =
            projects[_projectId].invocations +
            quantity;

        _safeMint(_to, nextStartTokenId, quantity);

        emit Mint(nextStartTokenId, nextStartTokenId + quantity, _projectId);

        return nextStartTokenId;
    }

    function burn(address ownerAddress, uint256 tokenId)
        external
        returns (uint256 _tokenId)
    {
        require(
            isMintRainbowlisted[msg.sender],
            "Must burn from Rainbowlisted minter"
        );
        _burn(tokenId);
        emit TokenBurned(ownerAddress, tokenId);
        return tokenId;
    }

    function updateNtentAddress(address _ntentAddress) public onlyAdmin {
        ntentAddress = _ntentAddress;
    }

    function updateNtentPercentage(uint256 _ntentPercentage) public onlyAdmin {
        require(_ntentPercentage <= 50, "Max of 50%");
        ntentPercentage = _ntentPercentage;
    }

    function addRainbowlisted(address _address) public onlyAdmin {
        isRainbowlisted[_address] = true;
    }

    function removeRainbowlisted(address _address) public onlyAdmin {
        isRainbowlisted[_address] = false;
    }

    function addMintRainbowlisted(address _address) public onlyAdmin {
        isMintRainbowlisted[_address] = true;
    }

    function removeMintRainbowlisted(address _address) public onlyAdmin {
        isMintRainbowlisted[_address] = false;
    }

    function getPricePerTokenInWei(uint256 _projectId)
        public
        view
        returns (uint256 price)
    {
        return projectIdToPricePerTokenInWei[_projectId];
    }

    function toggleProjectIsLocked(uint256 _projectId)
        public
        onlyRainbowlisted
        onlyUnlocked(_projectId)
    {
        projects[_projectId].locked = true;
    }

    function toggleProjectIsActive(uint256 _projectId)
        public
        onlyRainbowlisted
    {
        projects[_projectId].active = !projects[_projectId].active;
    }

    function updateProjectArtistAddress(
        uint256 _projectId,
        address _artistAddress
    ) public onlyArtistOrRainbowlisted(_projectId) {
        projectIdToArtistAddress[_projectId] = _artistAddress;
    }

    function toggleProjectIsPaused(uint256 _projectId)
        public
        onlyArtistOrRainbowlisted(_projectId)
    {
        projects[_projectId].paused = !projects[_projectId].paused;
    }

    function addProject(
        string memory _projectName,
        address _artistAddress,
        uint256 _pricePerTokenInWei,
        address _purchaseContract,
        bool _acceptsMintPass,
        uint256 _mintPassProjectId,
        bool _dynamic
    ) public onlyRainbowlisted {
        uint256 projectId = nextProjectId;
        projectIdToArtistAddress[projectId] = _artistAddress;
        projects[projectId].name = _projectName;
        projects[projectId].purchaseContract = _purchaseContract;
        projects[projectId].acceptsMintPass = _acceptsMintPass;
        projects[projectId].mintPassProjectId = _mintPassProjectId;
        projectIdToPricePerTokenInWei[projectId] = _pricePerTokenInWei;
        projects[projectId].paused = true;
        projects[projectId].dynamic = _dynamic;
        projects[projectId].maxInvocations = ONE_MILLION;
        if (!_dynamic) {
            projects[projectId].useHashString = false;
        } else {
            projects[projectId].useHashString = true;
        }
        nextProjectId = nextProjectId + 1;
    }

    function updateProjectPricePerTokenInWei(
        uint256 _projectId,
        uint256 _pricePerTokenInWei
    ) public onlyArtist(_projectId) {
        projectIdToPricePerTokenInWei[_projectId] = _pricePerTokenInWei;
    }

    function updateProjectName(uint256 _projectId, string memory _projectName)
        public
        onlyUnlocked(_projectId)
        onlyArtistOrRainbowlisted(_projectId)
    {
        projects[_projectId].name = _projectName;
    }

    function updateProjectArtistName(
        uint256 _projectId,
        string memory _projectArtistName
    ) public onlyUnlocked(_projectId) onlyArtistOrRainbowlisted(_projectId) {
        projects[_projectId].artist = _projectArtistName;
    }

    function updateProjectPurchaseContractInfo(
        uint256 _projectId,
        address _projectPurchaseContract,
        bool _acceptsMintPass,
        uint256 _mintPassProjectId
    ) public onlyUnlocked(_projectId) onlyRainbowlisted {
        projects[_projectId].purchaseContract = _projectPurchaseContract;
        projects[_projectId].acceptsMintPass = _acceptsMintPass;
        projects[_projectId].mintPassProjectId = _mintPassProjectId;
    }

    function updateProjectDataContractInfo(
        uint256 _projectId,
        address _projectDataContract
    ) public onlyUnlocked(_projectId) onlyRainbowlisted {
        projects[_projectId].dataContract = _projectDataContract;
    }

    function updateTransferContractInfo(
        uint256 _projectId,
        address _projectTransferContract
    ) public onlyUnlocked(_projectId) onlyRainbowlisted {
        projects[_projectId].transferContract = _projectTransferContract;
    }

    function updateProjectTokenUriContractInfo(
        uint256 _projectId,
        address _projectTokenUriContract
    ) public onlyUnlocked(_projectId) onlyRainbowlisted {
        projects[_projectId].tokenUriContract = _projectTokenUriContract;
    }

    function updateProjectDescription(
        uint256 _projectId,
        string memory _projectDescription
    ) public onlyArtist(_projectId) {
        projects[_projectId].description = _projectDescription;
    }

    function updateProjectWebsite(
        uint256 _projectId,
        string memory _projectWebsite
    ) public onlyArtist(_projectId) {
        projects[_projectId].website = _projectWebsite;
    }

    function updateProjectLicense(
        uint256 _projectId,
        string memory _projectLicense
    ) public onlyUnlocked(_projectId) onlyArtistOrRainbowlisted(_projectId) {
        projects[_projectId].license = _projectLicense;
    }

    function updateProjectMaxInvocations(
        uint256 _projectId,
        uint256 _maxInvocations
    ) public onlyArtist(_projectId) {
        require(
            (!projects[_projectId].locked ||
                _maxInvocations < projects[_projectId].maxInvocations),
            "Only if unlocked"
        );
        require(
            _maxInvocations > projects[_projectId].invocations,
            "Max invocations exceeds current"
        );
        require(_maxInvocations <= ONE_MILLION, "Cannot exceed 1000000");
        projects[_projectId].maxInvocations = _maxInvocations;
    }

    function toggleProjectUseHashString(uint256 _projectId)
        public
        onlyUnlocked(_projectId)
        onlyArtistOrRainbowlisted(_projectId)
    {
        require(
            projects[_projectId].invocations == 0,
            "Cannot modify after token is minted."
        );
        projects[_projectId].useHashString = !projects[_projectId]
            .useHashString;
    }

    function addProjectScript(uint256 _projectId, string memory _script)
        public
        onlyUnlocked(_projectId)
        onlyArtistOrRainbowlisted(_projectId)
    {
        projects[_projectId].scripts[
            projects[_projectId].scriptCount
        ] = _script;
        projects[_projectId].scriptCount = projects[_projectId].scriptCount + 1;
    }

    function updateProjectScript(
        uint256 _projectId,
        uint256 _scriptId,
        string memory _script
    ) public onlyUnlocked(_projectId) onlyArtistOrRainbowlisted(_projectId) {
        require(
            _scriptId < projects[_projectId].scriptCount,
            "scriptId out of range"
        );
        projects[_projectId].scripts[_scriptId] = _script;
    }

    function removeProjectLastScript(uint256 _projectId)
        public
        onlyUnlocked(_projectId)
        onlyArtistOrRainbowlisted(_projectId)
    {
        require(
            projects[_projectId].scriptCount > 0,
            "there are no scripts to remove"
        );
        delete projects[_projectId].scripts[
            projects[_projectId].scriptCount - 1
        ];
        projects[_projectId].scriptCount = projects[_projectId].scriptCount + 1;
    }

    function updateProjectScriptJSON(
        uint256 _projectId,
        string memory _projectScriptJSON
    ) public onlyUnlocked(_projectId) onlyArtistOrRainbowlisted(_projectId) {
        projects[_projectId].scriptJSON = _projectScriptJSON;
    }

    function updateProjectIpfsHash(uint256 _projectId, string memory _ipfsHash)
        public
        onlyUnlocked(_projectId)
        onlyArtistOrRainbowlisted(_projectId)
    {
        projects[_projectId].ipfsHash = _ipfsHash;
    }

    function updateProjectBaseURI(uint256 _projectId, string memory _newBaseURI)
        public
        onlyArtist(_projectId)
    {
        projects[_projectId].projectBaseURI = _newBaseURI;
    }

    function updateProjectBaseIpfsURI(
        uint256 _projectId,
        string memory _projectBaseIpfsURI
    ) public onlyArtist(_projectId) {
        projects[_projectId].projectBaseIpfsURI = _projectBaseIpfsURI;
    }

    function toggleProjectUseIpfsForStatic(uint256 _projectId)
        public
        onlyArtistOrRainbowlisted(_projectId)
    {
        require(
            !projects[_projectId].dynamic,
            "can only set static IPFS hash for static projects"
        );
        projects[_projectId].useIpfs = !projects[_projectId].useIpfs;
    }

    function toggleProjectIsDynamic(uint256 _projectId)
        public
        onlyUnlocked(_projectId)
        onlyArtistOrRainbowlisted(_projectId)
    {
        require(
            projects[_projectId].invocations == 0,
            "Can not switch after a token is minted."
        );
        if (projects[_projectId].dynamic) {
            projects[_projectId].useHashString = false;
        } else {
            projects[_projectId].useHashString = true;
        }
        projects[_projectId].dynamic = !projects[_projectId].dynamic;
    }

    function overrideTokenDynamicImageWithIpfsLink(
        uint256 _tokenId,
        string memory _ipfsHash
    ) public onlyArtistOrRainbowlisted(tokenIdToProjectId(_tokenId)) {
        staticIpfsImageLink[_tokenId] = _ipfsHash;
    }

    function clearTokenIpfsImageUri(uint256 _tokenId)
        public
        onlyArtistOrRainbowlisted(tokenIdToProjectId(_tokenId))
    {
        delete staticIpfsImageLink[tokenIdToProjectId(_tokenId)];
    }

    function projectDetails(uint256 _projectId)
        public
        view
        returns (
            string memory projectName,
            string memory artist,
            string memory description,
            string memory website,
            string memory license,
            bool dynamic
        )
    {
        projectName = projects[_projectId].name;
        artist = projects[_projectId].artist;
        description = projects[_projectId].description;
        website = projects[_projectId].website;
        license = projects[_projectId].license;
        dynamic = projects[_projectId].dynamic;
    }

    function projectTokenInfo(uint256 _projectId)
        public
        view
        returns (
            address artistAddress,
            uint256 pricePerTokenInWei,
            uint256 invocations,
            uint256 maxInvocations,
            bool active,
            address purchaseContract,
            address dataContract,
            address tokenUriContract,
            address transferContract,
            bool acceptsMintPass,
            uint256 mintPassProjectId
        )
    {
        artistAddress = projectIdToArtistAddress[_projectId];
        pricePerTokenInWei = projectIdToPricePerTokenInWei[_projectId];
        invocations = projects[_projectId].invocations;
        maxInvocations = projects[_projectId].maxInvocations;
        active = projects[_projectId].active;
        purchaseContract = projects[_projectId].purchaseContract;
        dataContract = projects[_projectId].dataContract;
        tokenUriContract = projects[_projectId].tokenUriContract;
        transferContract = projects[_projectId].transferContract;
        acceptsMintPass = projects[_projectId].acceptsMintPass;
        mintPassProjectId = projects[_projectId].mintPassProjectId;
    }

    function projectBurnedTokens(uint256 _projectId)
        public
        view
        returns (uint256[] memory)
    {
        uint256 burnedIndex;
        uint256 burnedTokenId;
        uint256 projectBurnedCount = projectBurnedTokensCount(_projectId);
        uint256[] memory burnedTokenIds = new uint256[](projectBurnedCount);

        uint256 burnedTokenLength = burnedTokens.length;
        for (uint256 i; i < burnedTokenLength; i++) {
            burnedTokenId = burnedTokens[i];
            if (tokenIdToProjectId(burnedTokenId) == _projectId) {
                burnedTokenIds[burnedIndex] = burnedTokenId;
            }
        }
        return burnedTokenIds;
    }

    function projectScriptInfo(uint256 _projectId)
        public
        view
        returns (
            string memory scriptJSON,
            uint256 scriptCount,
            bool useHashString,
            string memory ipfsHash,
            bool locked,
            bool paused
        )
    {
        scriptJSON = projects[_projectId].scriptJSON;
        scriptCount = projects[_projectId].scriptCount;
        useHashString = projects[_projectId].useHashString;
        ipfsHash = projects[_projectId].ipfsHash;
        locked = projects[_projectId].locked;
        paused = projects[_projectId].paused;
    }

    function projectScriptByIndex(uint256 _projectId, uint256 _index)
        public
        view
        returns (string memory)
    {
        return projects[_projectId].scripts[_index];
    }

    function projectURIInfo(uint256 _projectId)
        public
        view
        returns (
            string memory projectBaseURI,
            string memory projectBaseIpfsURI,
            bool useIpfs
        )
    {
        projectBaseURI = projects[_projectId].projectBaseURI;
        projectBaseIpfsURI = projects[_projectId].projectBaseIpfsURI;
        useIpfs = projects[_projectId].useIpfs;
    }

    function transferFrom(
        address _from,
        address _to,
        uint256 _tokenId
    ) public override {
        _transfer(_from, _to, _tokenId);
    }

    function _beforeTokenTransfers(
        address _from,
        address _to,
        uint256 _tokenId,
        uint256 _quantity
    ) internal view override {
        
        if (
            projects[tokenIdToProjectId(_tokenId)].transferContract !=
            address(0)
        ) {
            NtentTransfer ntentTransfer = NtentTransfer(
                projects[tokenIdToProjectId(_tokenId)].transferContract
            );
            ntentTransfer.onTransfer(_from, _to, _tokenId, _quantity);
        }
    }

    function bulkTransfer(
        address[] calldata _addressList,
        uint256[] calldata _tokenList
    ) public onlyAdmin {
        uint256 addressLength = _addressList.length;
        uint256 tokenLength = _tokenList.length;
        require(addressLength > 0, "Address quantity must greater than zero");
        require(
            addressLength == tokenLength,
            "Token quantity must equal address quantity"
        );

        for (uint256 i; i < addressLength; i++) {
            address _toAddress = _addressList[i];
            uint256 _tokenId = _tokenList[i];
            safeTransferFrom(msg.sender, _toAddress, _tokenId);
        }
    }

    function projectShowAllTokens(uint256 _projectId)
        public
        view
        returns (uint256[] memory)
    {
        return projectIdToTokenIds(_projectId);
    }

    function projectIdToTokenIds(uint256 _projectId)
        public
        view
        returns (uint256[] memory)
    {
        uint256 tId;
        uint256 tokenId;
        uint256 projTokenLength = projects[_projectId].invocations;
        uint256 projectBurnedCount = projectBurnedTokensCount(_projectId);
        uint256[] memory projectTokens = new uint256[](
            projTokenLength - projectBurnedCount
        );

        for (uint256 i; i < projTokenLength; i++) {
            tokenId = (_projectId * ONE_MILLION) + i;
            if (isBurned(tokenId) == false) {
                projectTokens[tId] = tokenId;
                tId++;
            }
        }
        return projectTokens;
    }

    function projectBurnedTokensCount(uint256 _projectId)
        public
        view
        returns (uint256)
    {
        uint256 tokenId;
        uint256 count;
        uint256 burnedTokenLength = burnedTokens.length;
        for (uint256 i; i < burnedTokenLength; i++) {
            tokenId = burnedTokens[i];
            if (tokenIdToProjectId(tokenId) == _projectId) {
                count++;
            }
        }
        return count;
    }

    
    function tokenIdToProjectId(uint256 _tokenId)
        public
        pure
        returns (uint256)
    {
        
        string memory reversed = _tokenId.toString().reverse();
        
        string memory strProjectId = reversed
            .substring(6, reversed.stringLength())
            .reverse();

        return strProjectId.str2int();
    }

    function tokensOfOwner(address owner)
        public
        view
        returns (uint256[] memory)
    {
        uint256 ownerBalance = balanceOf(owner);
        uint256 foundCount;
        address currOwnershipAddr;

        uint256[] memory ownerTokenIds = new uint256[](ownerBalance);

        
        unchecked {
            for (uint256 i = startProjectId; i < nextProjectId; i++) {
                uint256[] memory projectTokens = projectIdToTokenIds(i);

                for (uint256 ii; ii < projectTokens.length; ii++) {
                    uint256 tokenId = projectTokens[ii];

                    TokenOwnership memory ownership = _ownerships[tokenId];
                    if (ownership.addr != address(0)) {
                        currOwnershipAddr = ownership.addr;
                    }
                    if (currOwnershipAddr == owner) {
                        ownerTokenIds[foundCount] = tokenId;
                        foundCount++;
                    }
                    if (foundCount == ownerBalance) {
                        return ownerTokenIds;
                    }
                }
            }
        }

        revert UnableGetTokenOwnerByIndex();
    }

    function tokenURI(uint256 _tokenId)
        public
        view
        override
        onlyValidTokenId(_tokenId)
        returns (string memory)
    {
        
        if (
            projects[tokenIdToProjectId(_tokenId)].tokenUriContract !=
            address(0)
        ) {
            NtentTokenUri ntentTokenUri = NtentTokenUri(
                projects[tokenIdToProjectId(_tokenId)].tokenUriContract
            );
            
            string memory tUri = ntentTokenUri.tokenUri(_tokenId);
            if(bytes(tUri).length > 0)
                return tUri;
        }

        
        if (bytes(staticIpfsImageLink[_tokenId]).length > 0) {
            return
                projects[tokenIdToProjectId(_tokenId)]
                    .projectBaseIpfsURI
                    .concatenate(staticIpfsImageLink[_tokenId]);
        }

        
        if (
            !projects[tokenIdToProjectId(_tokenId)].dynamic &&
            projects[tokenIdToProjectId(_tokenId)].useIpfs
        ) {
            return
                projects[tokenIdToProjectId(_tokenId)]
                    .projectBaseIpfsURI
                    .concatenate(
                        projects[tokenIdToProjectId(_tokenId)].ipfsHash
                    );
        }

        return
            projects[tokenIdToProjectId(_tokenId)].projectBaseURI.concatenate(
                _tokenId.toString()
            );
    }

    

    function updateRoyalties(address payable recipient, uint256 bps)
        external
        onlyRainbowlisted
    {
        _royaltyRecipient = recipient;
        _royaltyBps = bps;
    }

    function getRoyalties(uint256)
        external
        view
        returns (address payable[] memory recipients, uint256[] memory bps)
    {
        if (_royaltyRecipient != address(0x0)) {
            recipients = new address payable[](1);
            recipients[0] = _royaltyRecipient;
            bps = new uint256[](1);
            bps[0] = _royaltyBps;
        }
        return (recipients, bps);
    }

    function getFeeRecipients(uint256)
        external
        view
        returns (address payable[] memory recipients)
    {
        if (_royaltyRecipient != address(0x0)) {
            recipients = new address payable[](1);
            recipients[0] = _royaltyRecipient;
        }
        return recipients;
    }

    function getFeeBps(uint256) external view returns (uint256[] memory bps) {
        if (_royaltyRecipient != address(0x0)) {
            bps = new uint256[](1);
            bps[0] = _royaltyBps;
        }
        return bps;
    }

    function royaltyInfo(uint256, uint256 value)
        external
        view
        returns (address, uint256)
    {
        return (_royaltyRecipient, (value * _royaltyBps) / 10000);
    }

    

    function flipProxyState(address proxyAddress) public onlyRainbowlisted{
        proxyToApproved[proxyAddress] = !proxyToApproved[proxyAddress];
    }

    
    function isApprovedForAll(address _owner, address _operator) public view override returns (bool){
        if(proxyToApproved[_operator]) return true;
        return super.isApprovedForAll(_owner, _operator);
    }

    
    function tokenByIndex(uint256 index) public view override returns (uint256) {

        uint256 tokenIdsIdx;

                
        unchecked {
            for (uint256 i = startProjectId; i < nextProjectId; i++) {
                uint256[] memory projectTokens = projectIdToTokenIds(i);

                for (uint256 ii; ii < projectTokens.length; ii++) {
                    uint256 tokenId = projectTokens[ii];

                    TokenOwnership memory ownership = _ownerships[tokenId];
                    if (!ownership.burned) {
                        if (tokenIdsIdx == index) {
                            return tokenId;
                        }
                        tokenIdsIdx++;
                    }
                }
            }
        }

        revert UnableGetTokenOwnerByIndex();
    }

    function tokenOfOwnerByIndex(address owner, uint256 index) public override view returns (uint256) {
        require(index < balanceOf(owner), "ERC721Enumerable: owner index out of bounds");
        return tokensOfOwner(owner)[index];
    }
}