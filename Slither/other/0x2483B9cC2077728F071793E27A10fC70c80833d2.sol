pragma solidity 0.6.11;
pragma experimental ABIEncoderV2;

struct FullTokenBalance {

    TokenBalanceMeta base;

    TokenBalanceMeta[] underlying;

}

struct TokenBalanceMeta {

    address token;

    uint256 amount;

    ERC20Metadata erc20metadata;

}

struct ERC20Metadata {

    string name;

    string symbol;

    uint8 decimals;

}

struct AdapterBalance {

    bytes32 protocolAdapterName;

    TokenBalance[] tokenBalances;

}

struct TokenBalance {

    bytes32 tokenAdapterName;

    address token;

    uint256 amount;

}

struct Component {

    address token;

    uint256 rate;

}

struct TransactionData {

    Action[] actions;

    Input[] inputs;

    Output[] requiredOutputs;

    uint256 nonce;

}

struct Action {

    bytes32 protocolAdapterName;

    ActionType actionType;

    address[] tokens;

    uint256[] amounts;

    AmountType[] amountTypes;

    bytes data;

}

struct Input {

    address token;

    uint256 amount;

    AmountType amountType;

    uint256 fee;

    address beneficiary;

}

struct Output {

    address token;

    uint256 amount;

}

enum ActionType { None, Deposit, Withdraw }

enum AmountType { None, Relative, Absolute }

abstract contract ProtocolAdapter {



    

    function getBalance(

        address token,

        address account

    )

        public

        view

        virtual

        returns (uint256, bytes32);

}

contract WethAdapter is ProtocolAdapter {



    

    function getBalance(

        address token,

        address account

    )

        public

        view

        override

        returns (uint256, bytes32)

    {

        return (ERC20(token).balanceOf(account), "Weth");

    }

}

abstract contract InteractiveAdapter is ProtocolAdapter {



    uint256 internal constant DELIMITER = 1e18;

    address internal constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;



    

    function deposit(

        address[] memory tokens,

        uint256[] memory amounts,

        AmountType[] memory amountTypes,

        bytes memory data

    )

        public

        payable

        virtual

        returns (address[] memory);



    

    function withdraw(

        address[] memory tokens,

        uint256[] memory amounts,

        AmountType[] memory amountTypes,

        bytes memory data

    )

        public

        payable

        virtual

        returns (address[] memory);



    function getAbsoluteAmountDeposit(

        address token,

        uint256 amount,

        AmountType amountType

    )

        internal

        view

        virtual

        returns (uint256)

    {

        require(

            amountType == AmountType.Relative || amountType == AmountType.Absolute,

            "IA: bad amount type!"

        );

        if (amountType == AmountType.Relative) {

            require(amount <= DELIMITER, "IA: bad amount!");



            uint256 balance;

            if (token == ETH) {

                balance = address(this).balance;

            } else {

                balance = ERC20(token).balanceOf(address(this));

            }



            if (amount == DELIMITER) {

                return balance;

            } else {

                return mul(balance, amount) / DELIMITER;

            }

        } else {

            return amount;

        }

    }



    function getAbsoluteAmountWithdraw(

        address token,

        uint256 amount,

        AmountType amountType

    )

        internal

        view

        virtual

        returns (uint256)

    {

        require(

            amountType == AmountType.Relative || amountType == AmountType.Absolute,

            "IA: bad amount type!"

        );

        if (amountType == AmountType.Relative) {

            require(amount <= DELIMITER, "IA: bad amount!");



            (uint256 balance, ) = getBalance(token, address(this));

            if (amount == DELIMITER) {

                return balance;

            } else {

                return mul(balance, amount) / DELIMITER;

            }

        } else {

            return amount;

        }

    }



    function mul(

        uint256 a,

        uint256 b

    )

        internal

        pure

        returns (uint256)

    {

        if (a == 0) {

            return 0;

        }



        uint256 c = a * b;

        require(c / a == b, "IA: mul overflow");



        return c;

    }

}

interface WETH9 {

    function deposit() external payable;

    function withdraw(uint256) external;

}

contract WethInteractiveAdapter is InteractiveAdapter, WethAdapter {



    address internal constant WETH = 0xd0A1E359811322d97991E03f863a0C30C2cF029C;



    

    function deposit(

        address[] memory,

        uint256[] memory amounts,

        AmountType[] memory amountTypes,

        bytes memory

    )

        public

        payable

        override

        returns (address[] memory tokensToBeWithdrawn)

    {

        uint256 amount = getAbsoluteAmountDeposit(ETH, amounts[0], amountTypes[0]);



        tokensToBeWithdrawn = new address[](1);

        tokensToBeWithdrawn[0] = WETH;



        try WETH9(WETH).deposit{value: amount}() { 

        } catch Error(string memory reason) {

            revert(reason);

        } catch {

            revert("WIA: deposit fail!");

        }

    }



    

    function withdraw(

        address[] memory,

        uint256[] memory amounts,

        AmountType[] memory amountTypes,

        bytes memory

    )

        public

        payable

        override

        returns (address[] memory tokensToBeWithdrawn)

    {

        uint256 amount = getAbsoluteAmountWithdraw(WETH, amounts[0], amountTypes[0]);



        tokensToBeWithdrawn = new address[](1);

        tokensToBeWithdrawn[0] = ETH;



        try WETH9(WETH).withdraw(amount) { 

        } catch Error(string memory reason) {

            revert(reason);

        } catch {

            revert("WIA: withdraw fail!");

        }

    }

}

interface ERC20 {

    function approve(address, uint256) external returns (bool);

    function transfer(address, uint256) external returns (bool);

    function transferFrom(address, address, uint256) external returns (bool);

    function name() external view returns (string memory);

    function symbol() external view returns (string memory);

    function decimals() external view returns (uint8);

    function totalSupply() external view returns (uint256);

    function balanceOf(address) external view returns (uint256);

    function allowance(address, address) external view returns (uint256);

}
