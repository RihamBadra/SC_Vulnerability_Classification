pragma solidity 0.6.11;
pragma experimental ABIEncoderV2;

struct FullAbsoluteTokenAmount {

    AbsoluteTokenAmountMeta base;

    AbsoluteTokenAmountMeta[] underlying;

}

struct AbsoluteTokenAmountMeta {

    AbsoluteTokenAmount absoluteTokenAmount;

    ERC20Metadata erc20metadata;

}

struct ERC20Metadata {

    string name;

    string symbol;

    uint8 decimals;

}

struct AdapterBalance {

    bytes32 protocolAdapterName;

    AbsoluteTokenAmount[] absoluteTokenAmounts;

}

struct AbsoluteTokenAmount {

    address token;

    uint256 amount;

}

struct Component {

    address token;

    uint256 rate;

}

struct TransactionData {

    Action[] actions;

    TokenAmount[] inputs;

    Fee fee;

    AbsoluteTokenAmount[] requiredOutputs;

    uint256 nonce;

}

struct Action {

    bytes32 protocolAdapterName;

    ActionType actionType;

    TokenAmount[] tokenAmounts;

    bytes data;

}

struct TokenAmount {

    address token;

    uint256 amount;

    AmountType amountType;

}

struct Fee {

    uint256 share;

    address beneficiary;

}

enum ActionType { None, Deposit, Withdraw }

enum AmountType { None, Relative, Absolute }

abstract contract ProtocolAdapter {



    

    function getBalance(

        address token,

        address account

    )

        public

        view

        virtual

        returns (uint256);

}

contract WethAdapter is ProtocolAdapter {



    

    function getBalance(

        address token,

        address account

    )

        public

        view

        override

        returns (uint256)

    {

        return ERC20(token).balanceOf(account);

    }

}

abstract contract InteractiveAdapter is ProtocolAdapter {



    uint256 internal constant DELIMITER = 1e18;

    address internal constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;



    

    function deposit(

        TokenAmount[] memory tokenAmounts,

        bytes memory data

    )

        public

        payable

        virtual

        returns (address[] memory);



    

    function withdraw(

        TokenAmount[] memory tokenAmounts,

        bytes memory data

    )

        public

        payable

        virtual

        returns (address[] memory);



    function getAbsoluteAmountDeposit(

        TokenAmount memory tokenAmount

    )

        internal

        view

        virtual

        returns (uint256)

    {

        address token = tokenAmount.token;

        uint256 amount = tokenAmount.amount;

        AmountType amountType = tokenAmount.amountType;



        require(

            amountType == AmountType.Relative || amountType == AmountType.Absolute,

            "IA: bad amount type"

        );

        if (amountType == AmountType.Relative) {

            require(amount <= DELIMITER, "IA: bad amount");



            uint256 balance;

            if (token == ETH) {

                balance = address(this).balance;

            } else {

                balance = ERC20(token).balanceOf(address(this));

            }



            if (amount == DELIMITER) {

                return balance;

            } else {

                return mul(balance, amount) / DELIMITER;

            }

        } else {

            return amount;

        }

    }



    function getAbsoluteAmountWithdraw(

        TokenAmount memory tokenAmount

    )

        internal

        view

        virtual

        returns (uint256)

    {

        address token = tokenAmount.token;

        uint256 amount = tokenAmount.amount;

        AmountType amountType = tokenAmount.amountType;



        require(

            amountType == AmountType.Relative || amountType == AmountType.Absolute,

            "IA: bad amount type"

        );

        if (amountType == AmountType.Relative) {

            require(amount <= DELIMITER, "IA: bad amount");



            uint256 balance = getBalance(token, address(this));

            if (amount == DELIMITER) {

                return balance;

            } else {

                return mul(balance, amount) / DELIMITER;

            }

        } else {

            return amount;

        }

    }



    function mul(

        uint256 a,

        uint256 b

    )

        internal

        pure

        returns (uint256)

    {

        if (a == 0) {

            return 0;

        }



        uint256 c = a * b;

        require(c / a == b, "IA: mul overflow");



        return c;

    }

}

interface WETH9 {

    function deposit() external payable;

    function withdraw(uint256) external;

}

contract WethInteractiveAdapter is InteractiveAdapter, WethAdapter {



    address internal constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;



    

    function deposit(

        TokenAmount[] memory tokenAmounts,

        bytes memory

    )

        public

        payable

        override

        returns (address[] memory tokensToBeWithdrawn)

    {

        require(tokenAmounts.length == 1, "WIA: should be 1 tokenAmount");

        require(tokenAmounts[0].token == ETH, "WIA: should be ETH");



        uint256 amount = getAbsoluteAmountDeposit(tokenAmounts[0]);



        tokensToBeWithdrawn = new address[](1);

        tokensToBeWithdrawn[0] = WETH;



        try WETH9(WETH).deposit{value: amount}() { 

        } catch Error(string memory reason) {

            revert(reason);

        } catch {

            revert("WIA: deposit fail");

        }

    }



    

    function withdraw(

        TokenAmount[] memory tokenAmounts,

        bytes memory

    )

        public

        payable

        override

        returns (address[] memory tokensToBeWithdrawn)

    {

        require(tokenAmounts.length == 1, "WIA: should be 1 tokenAmount");

        require(tokenAmounts[0].token == WETH, "WIA: should be WETH");



        uint256 amount = getAbsoluteAmountWithdraw(tokenAmounts[0]);



        tokensToBeWithdrawn = new address[](1);

        tokensToBeWithdrawn[0] = ETH;



        try WETH9(WETH).withdraw(amount) { 

        } catch Error(string memory reason) {

            revert(reason);

        } catch {

            revert("WIA: withdraw fail");

        }

    }

}

interface ERC20 {

    function approve(address, uint256) external returns (bool);

    function transfer(address, uint256) external returns (bool);

    function transferFrom(address, address, uint256) external returns (bool);

    function name() external view returns (string memory);

    function symbol() external view returns (string memory);

    function decimals() external view returns (uint8);

    function totalSupply() external view returns (uint256);

    function balanceOf(address) external view returns (uint256);

    function allowance(address, address) external view returns (uint256);

}
