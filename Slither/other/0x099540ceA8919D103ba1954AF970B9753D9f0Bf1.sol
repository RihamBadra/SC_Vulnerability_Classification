pragma solidity 0.4.24;

contract ERC1132 {

    

    mapping(address => bytes32[]) public lockReason;



    

    struct lockToken {

        uint256 amount;

        uint256 validity;

        bool claimed;

    }



    

    mapping(address => mapping(bytes32 => lockToken)) public locked;



    

    event Locked(

        address indexed _of,

        bytes32 indexed _reason,

        uint256 _amount,

        uint256 _validity

    );



    

    event Unlocked(

        address indexed _of,

        bytes32 indexed _reason,

        uint256 _amount

    );

    

    

    function lock(bytes32 _reason, uint256 _amount, uint256 _time)

        public returns (bool);

  

    

    function tokensLocked(address _of, bytes32 _reason)

        public view returns (uint256 amount);

    

    

    function tokensLockedAtTime(address _of, bytes32 _reason, uint256 _time)

        public view returns (uint256 amount);

    

    

    function totalBalanceOf(address _of)

        public view returns (uint256 amount);

    

    

    function extendLock(bytes32 _reason, uint256 _time)

        public returns (bool);

    

    

    function increaseLockAmount(bytes32 _reason, uint256 _amount)

        public returns (bool);



    

    function tokensUnlockable(address _of, bytes32 _reason)

        public view returns (uint256 amount);

 

    

    function unlock(address _of)

        public returns (uint256 unlockableTokens);



    

    function getUnlockableTokens(address _of)

        public view returns (uint256 unlockableTokens);



}

library AddressUtils {



    

    function isContract(address addr) internal view returns (bool) {

        uint256 size;

        

        

        

        

        

        

        

        assembly { size := extcodesize(addr) }

        return size > 0;

    }



}

contract ERC20Basic {

    function totalSupply() public view returns (uint256);

    function balanceOf(address who) public view returns (uint256);

    function transfer(address to, uint256 value) public returns (bool);

    event Transfer(address indexed from, address indexed to, uint256 value);

}

library SafeMath {

    

    function add(uint256 a, uint256 b) internal pure returns (uint256) {

        uint256 c = a + b;

        require(c >= a, "SafeMath: addition overflow");



        return c;

    }



    

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {

        require(b <= a, "SafeMath: subtraction overflow");

        uint256 c = a - b;



        return c;

    }



    

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {

        

        

        

        if (a == 0) {

            return 0;

        }



        uint256 c = a * b;

        require(c / a == b, "SafeMath: multiplication overflow");



        return c;

    }



    

    function div(uint256 a, uint256 b) internal pure returns (uint256) {

        

        require(b > 0, "SafeMath: division by zero");

        uint256 c = a / b;

        



        return c;

    }



    

    function mod(uint256 a, uint256 b) internal pure returns (uint256) {

        require(b != 0, "SafeMath: modulo by zero");

        return a % b;

    }

}

contract BasicToken is ERC20Basic {

    using SafeMath for uint256;



    mapping(address => uint256) balances;



    uint256 totalSupply_;



    

    function totalSupply() public view returns (uint256) {

        return totalSupply_;

    }



    

    function transfer(address _to, uint256 _value) public returns (bool) {

        require(_to != address(0), "Recipient address is zero address(0). Check the address again.");

        require(_value <= balances[msg.sender], "The balance of account is insufficient.");



        balances[msg.sender] = balances[msg.sender].sub(_value);

        balances[_to] = balances[_to].add(_value);

        emit Transfer(msg.sender, _to, _value);

        return true;

    }



    

    function balanceOf(address _owner) public view returns (uint256) {

        return balances[_owner];

    }



}

contract ERC20 is ERC20Basic {

    function allowance(address owner, address spender)

    public view returns (uint256);



    function transferFrom(address from, address to, uint256 value)

    public returns (bool);



    function approve(address spender, uint256 value) public returns (bool);

    event Approval(

        address indexed owner,

        address indexed spender,

        uint256 value

    );

}

contract StandardToken is ERC20, BasicToken {



    mapping (address => mapping (address => uint256)) internal allowed;





    

    function transferFrom(

        address _from,

        address _to,

        uint256 _value

    )

    public

    returns (bool)

    {

        require(_to != address(0), "Recipient address is zero address(0). Check the address again.");

        require(_value <= balances[_from], "The balance of account is insufficient.");

        require(_value <= allowed[_from][msg.sender], "Insufficient tokens approved from account owner.");



        balances[_from] = balances[_from].sub(_value);

        balances[_to] = balances[_to].add(_value);

        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);

        emit Transfer(_from, _to, _value);

        return true;

    }



    

    function approve(address _spender, uint256 _value) public returns (bool) {

        allowed[msg.sender][_spender] = _value;

        emit Approval(msg.sender, _spender, _value);

        return true;

    }



    

    function allowance(

        address _owner,

        address _spender

    )

    public

    view

    returns (uint256)

    {

        return allowed[_owner][_spender];

    }



    

    function increaseApproval(

        address _spender,

        uint256 _addedValue

    )

    public

    returns (bool)

    {

        allowed[msg.sender][_spender] = (

        allowed[msg.sender][_spender].add(_addedValue));

        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);

        return true;

    }



    

    function decreaseApproval(

        address _spender,

        uint256 _subtractedValue

    )

    public

    returns (bool)

    {

        uint256 oldValue = allowed[msg.sender][_spender];

        if (_subtractedValue > oldValue) {

            allowed[msg.sender][_spender] = 0;

        } else {

            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);

        }

        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);

        return true;

    }



}

sing SafeMath for uint256;



    address public root; 

    address public superOwner;

    mapping (address => bool) public owners;

    address[] public ownerList;



    event ChangedRoot(address newRoot);

    event ChangedSuperOwner(address newSuperOwner);

    event AddedNewOwner(address newOwner);

    event DeletedOwner(address deletedOwner);



    constructor() public {

        root = msg.sender;

        superOwner = msg.sender;

        owners[root] = true;



        ownerList.push(msg.sender);

    }



    modifier onlyRoot() {

        require(msg.sender == root, "Root privilege is required.");

        _;

    }



    modifier onlySuperOwner() {

        require(msg.sender == superOwner, "SuperOwner priviledge is required.");

        _;

    }



    modifier onlyOwner() {

        require(owners[msg.sender], "Owner priviledge is required.");

        _;

    }



    

    function changeRoot(address newRoot) onlyRoot public returns (bool) {

        require(newRoot != address(0), "This address to be set is zero address(0). Check the input address.");



        root = newRoot;



        emit ChangedRoot(newRoot);

        return true;

    }



    

    function changeSuperOwner(address newSuperOwner) onlyRoot public returns (bool) {

        require(newSuperOwner != address(0), "This address to be set is zero address(0). Check the input address.");



        superOwner = newSuperOwner;



        emit ChangedSuperOwner(newSuperOwner);

        return true;

    }





    function newOwner(address owner) onlySuperOwner public returns (bool) {

        require(owner != address(0), "This address to be set is zero address(0). Check the input address.");

        require(!owners[owner], "This address is already registered.");



        owners[owner] = true;

        ownerList.push(owner);



        emit AddedNewOwner(owner);

        return true;

    }



    function deleteOwner(address owner) onlySuperOwner public returns (bool) {

        require(owners[owner], "This input address is not an owner.");

        delete owners[owner];



        for (uint256 i = 0; i < ownerList.length; i++) {

            if (ownerList[i] == owner) {

                ownerList[i] = ownerList[ownerList.length.sub(1)];

                ownerList.length = ownerList.length.sub(1);

                break;

            }

        }



        emit DeletedOwner(owner);

        return true;

    }

}





contract LockableToken is StandardToken, MultiOwnable {

    bool public locked = true;

    uint256 public constant LOCK_MAX = uint256(-1);



    

    mapping(address => bool) public unlockAddrs;

e 만큼 잔고가 잠김

     * @dev - 값이 0 일 때 : 잔고가 0 이어도 되므로 제한이 없는 것임.

     * @dev - 값이 LOCK_MAX 일 때 : 잔고가 uint256 의 최대값이므로 아예 잠긴 것임.

     */

    mapping(address => uint256) public lockValues;



    event Locked(bool locked, string note);

    event LockedTo(address indexed addr, bool locked, string note);

    event SetLockValue(address indexed addr, uint256 value, string note);



    constructor() public {

        unlockTo(msg.sender,  "Default Unlock To Root");

    }



    modifier checkUnlock (address addr, uint256 value) {

        require(!locked || unlockAddrs[addr], "The account is currently locked.");

        require(balances[addr].sub(value) >= lockValues[addr], "Transferable limit exceeded. Check the status of the lock value.");

        _;

    }



    function lock(string note) onlyOwner public {

        locked = true;

        emit Locked(locked, note);

    }



    function unlock(string note) onlyOwner public {

        locked = false;

        emit Locked(locked, note);

    }



    function lockTo(address addr, string note) onlyOwner public {

        setLockValue(addr, LOCK_MAX, note);

        unlockAddrs[addr] = false;



        emit LockedTo(addr, true, note);

    }



    function unlockTo(address addr, string note) onlyOwner public {

        if (lockValues[addr] == LOCK_MAX)

            setLockValue(addr, 0, note);

        unlockAddrs[addr] = true;



        emit LockedTo(addr, false, note);

    }



    function setLockValue(address addr, uint256 value, string note) onlyOwner public {

        lockValues[addr] = value;

        emit SetLockValue(addr, value, note);

    }



    

    function getMyUnlockValue() public view returns (uint256) {

        address addr = msg.sender;

        if ((!locked || unlockAddrs[addr]) && balances[addr] > lockValues[addr])

            return balances[addr].sub(lockValues[addr]);

        else

            return 0;

    }



    function transfer(address to, uint256 value) checkUnlock(msg.sender, value) public returns (bool) {

        return super.transfer(to, value);

    }



    function transferFrom(address from, address to, uint256 value) checkUnlock(from, value) public returns (bool) {

        return super.transferFrom(from, to, value);

    }

}







contract SobloTokenReceiver {

    enum SobloTokenReceiveType { TOKEN_TRANSFER, TOKEN_MINT }

    function onSobloTokenReceived(address owner, address spender, uint256 value, SobloTokenReceiveType receiveType) public returns (bool);

}







contract SobloToken is LockableToken {

    using AddressUtils for address;

    

    enum SobloTransferType 

NER, 

        TRANSFER_TO_ECOSYSTEM, 

        TRANSFER_TO_BOUNTY, 

        TRANSFER_TO_RESERVE, 

        TRANSFER_TO_ETC 

    }

    

    event SobloTransferred(address indexed from, address indexed to, uint256 value, uint256 fro

te);

    event SobloTransferredFrom(address indexed owner, address indexed spender, address indexed to, uint256 value, uint256 fromBalance, uint256 toBalance, string note);

    event SobloApproval(address indexed owner, address indexed spender, uint256 value, string note);

 

    

    event SobloMultiTransferred(address indexed owner, address indexed spender, address indexed to, uint256 value, SobloTransferType purpose, uint256 fromBalance, uint256 toBalance, string note);



    event TransferredToSobloDapp(

        address indexed owner,

        address indexed spender,

        address indexed to, 

        uint256 value, 

        string note, 

        SobloTokenReceiver.SobloTokenReceiveType receiveType

    );



    constructor() public {

	}





    

    function transfer(address to, uint256 value) public returns (bool ret) {

        return sobloTransfer(to, value, "called by transfer()");

    }



    function sobloTransfer(address to, uint256 value, string note) public returns (bool ret) {

        require(to != address(this), "The receive address is the Contact Address of Soblo Token. You cannot send money to this address.");



        ret = super.transfer(to, value);

        postTransfer(msg.sender, msg.sender, to, value, note, SobloTokenReceiver.SobloTokenReceiveType.TOKEN_TRANSFER);

        

        emit SobloTransferred(msg.sender, to, value, balanceOf(msg.sender), balanceOf(to), note);

    }



    function transferFrom(address from, address to, uint256 value) public returns (bool) {

        return sobloTransferFrom(from, to, value, "called by transferFrom()");

    }



    function sobloTransferFrom(address from, address to, uint256 value, string note) public returns (bool ret) {

        require(to != address(this), "The receive address is the Contact Address of Soblo Token. You cannot send money to this address.");



        ret = super.transferFrom(from, to, value);

        postTransfer(from, msg.sender, to, value, note, SobloTokenReceiver.SobloTokenReceiveType.TOKEN_TRANSFER);



        emit SobloTransferredFrom(from, msg.sender, to, value, balanceOf(from), balanceOf(to), note);

    }



    function approve(address spender, uint256 value) public returns (bool) {

        return sobloApprove(spender, value, "called by approve()");

    }



    function sobloApprove(address spender, uint256 value, string note) public returns (bool ret) {

        ret = super.approve(spender, value);

        emit SobloApproval(msg.sender, spender, value, note);

    }



    function increaseApproval(address spender, uint256 addedValue) public returns (bool) {

        return sobloIncreaseApproval(spender, addedValue, "called by increaseApproval()");

    }



    function sobloIncreaseApproval(address spender, uint256 addedValue, string note) public returns (bool ret) {

        ret = super.increaseApproval(spender, addedValue);

        emit SobloApproval(msg.sender, spender, allowed[msg.sender][spender], note);

    }



    function decreaseApproval(address spender, uint256 subtractedValue) public returns (bool) {

        return sobloDecreaseApproval(spender, subtractedValue, "called by decreaseApproval()");

    }



    function sobloDecreaseApproval(address spender, uint256 subtractedValue, string note) public returns (bool ret) {

        ret = super.decreaseApproval(spender, subtractedValue);

        emit SobloApproval(msg.sender, spender, allowed[msg.sender][spender], note);

    }





    

    function postTransfer(

        address owner, 

        address spender,

        address to,

        uint256 value,

        string note,

        SobloTokenReceiver.SobloTokenReceiveType receiveType

    ) internal returns (bool) {

        if (to.isContract()) {

            bool callOk = address(to).call(

                bytes4(keccak256("onSobloTokenReceived(address,address,uint256,uint8)")),

                owner,

                spender,

                value,

                receiveType

            );

            if (callOk) {

                emit TransferredToSobloDapp(owner, spender, to, value, note, receiveType);

                return true;

            }

        }

        

        return false;

    }    



     

    function sobloMultiTransfer(

        address from, address[] to,

        uint256[] values,

        SobloTransferType purpose,

        string note

    ) onlyOwner public returns (bool ret) {

        uint256 length = to.length;

        require(length == values.length, "The size of \'to\' and \'values\' array is different.");

        require(uint8(purpose) < 6);



        ret = true;

        for (uint256 i = 0; i < length; i++) {

            require(to[i] != address(this), "The receive address is the Contact Address of Soblo Token. You cannot send money to this address.");



            ret = ret && super.transferFrom(from, to[i], values[i]); 

            emit SobloMultiTransferred(from, msg.sender, to[i], values[i], purpose, balanceOf(from), balanceOf(to[i]), note);

        }

    }



    function destroy() onlyRoot public {

        selfdestruct(root);

    }

    

    

    

}











contract SobloTokenDappBase is SobloTokenReceiver {

    address internal _sobloToken;

    event LogOnReceivedSobloToken(address indexed owner, address indexed spender, uint256 value, SobloTokenReceiveType receiveType);



    constructor(address sobloToken) public {

        _sobloToken = sobloToken;

    }

    

    modifier onlySobloToken() {

        require(msg.sender == _sobloToken, "msg.sender must be the registered token contract");

        _;

    }

    

    

    function onSobloTokenReceived(address owner, address spender, uint256 value, SobloTokenReceiveType receiveType)

        public onlySobloToken returns

en(owner, spender, value, receiveType);

    }

}

contract HINTToken is SobloToken {

    string public constant name = "WHint Token";

    string public constant symbol = "WHINT";

    uint8 public constant decimals = 18;

    

    uint256 public constant INITIAL_SUPPLY = 1e9 * (10 ** uint256(decimals));



    constructor() public {

        totalSupply_ = INITIAL_SUPPLY;

        balances[msg.sender] = INITIAL_SUPPLY;

        emit Transfer(0x0, msg.sender, INITIAL_SUPPLY);

    }

}
