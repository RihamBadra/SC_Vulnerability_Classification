

pragma solidity ^0.4.23;



library UniqueAddresses {
    function uniquify(address[]) external view returns(address[]) {
        assembly {
            
            0x24 calldataload 0x01 lt has_data jumpi
            calldatacopy(0, 0x04, calldatasize)
            return(0x00, sub(calldatasize, 0x04))
        has_data:
            0x44
            dup1 calldataload
            dup2 0x20 add calldataload
        test_run:
            lt input_is_ordered jumpi
            jump(maybe_has_non_trivial_structure)
        input_is_ordered:
            0x20 add
            dup1 calldataload
            dup2 0x20 add calldataload
            0x140 calldatasize sub dup4 lt test_run jumpi
        calldatacopy(0, 0x04, calldatasize)
        return(0x00, sub(calldatasize, 0x04))

        maybe_has_non_trivial_structure:
            pop
            0x44
            dup1 calldataload
            dup2 0x20 add calldataload
        test_reverse_run:
            gt input_is_reverse_ordered jumpi
            jump(probably_has_non_trivial_structure)
        input_is_reverse_ordered:
            0x20 add
            dup1 calldataload
            dup2 0x20 add calldataload
            0x140 calldatasize sub dup4 lt test_reverse_run jumpi
        calldatacopy(0, 0x04, calldatasize)
        return(0x00, sub(calldatasize, 0x04))

        probably_has_non_trivial_structure:
        pop
        0x64 0x44 calldataload         
        test_identical_loop:
            dup2 calldataload              
            dup1 swap2                     
            eq iszero somewhat_likely_has_non_trivial_structure jumpi         
            swap1 0x20 add swap1           
            dup2 0x140 gt test_identical_loop jumpi
            0x20 0x00 mstore
            0x01 0x20 mstore
            0x44 calldataload 0x40 mstore
        return(0x00, 0x60) 

        somewhat_likely_has_non_trivial_structure:
        pop pop
        0x44 0x44 calldataload
        test_pairs_outer_loop:
            swap1 0x20 add swap1            
            dup2 calldataload               
            dup1 swap2                      
            eq test_pairs_outer_loop jumpi  
            
            0x44 calldataload                   
            test_pairs_inner_loop:
                swap2 0x20 add swap2            
                dup2                        
                dup4 calldataload           
                dup3 dup2                   
                eq                          
                swap2 eq or                 
                iszero definitely_has_non_trivial_structure jumpi   
                dup3 0x140 calldatasize sub gt test_pairs_inner_loop jumpi
                
                0x20 0x00 mstore
                0x02 0x20 mstore
                0x40 mstore
                0x60 mstore
                0x80 0x00 return


        definitely_has_non_trivial_structure:
            pop pop pop
            
            
            0x44
            
            
            
            1 0x0 mstore
            2 0x20 mstore
            4 0x40 mstore
            8 0x60 mstore
            16 0x80 mstore
            32 0xa0 mstore
            64 0xc0 mstore
            128 0xe0 mstore

            
            
            
            
            
            
            
            

            
            
            
            
            
            0x01 0x500 mstore
    
    
        loop_start:
            dup1 calldataload           
            0x30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd47 mul 
            dup1 0x3e0 and 0x100 add    
            swap1 28 byte mload         
            dup2 mload dup2 and skip_add_to_set jumpi
                dup3 calldataload msize mstore
                dup2 mload or           
                swap1 mstore            
                0x20 add                

        
            dup1 calldataload           
            0x30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd47 mul 
            dup1 0x3e0 and 0x100 add    
            swap1 28 byte mload         
            dup2 mload dup2 and skip_add_to_set jumpi
                dup3 calldataload msize mstore
                dup2 mload or           
                swap1 mstore            
                0x20 add                

            calldatasize dup2 lt loop_start jumpi

            0x20 0x4e0 mstore          
            0x520 msize sub            
            0x20 dup2 div 0x500 mstore 
            0x40 add 0x4e0 return

            skip_add_to_set:
                pop pop
                0x20 add
                calldatasize dup2 lt loop_start jumpi
            0x20 0x4e0 mstore          
            0x520 msize sub            
            0x20 dup2 div 0x500 mstore 
            0x40 add 0x4e0 return

            
            
            pop
        }
    }
}