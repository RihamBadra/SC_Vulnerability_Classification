

pragma solidity >=0.4.24 <0.7.0;



contract Initializable {

  
  bool private initialized;

  
  bool private initializing;

  
  modifier initializer() {
    require(initializing || isConstructor() || !initialized, "Contract instance has already been initialized");

    bool isTopLevelCall = !initializing;
    if (isTopLevelCall) {
      initializing = true;
      initialized = true;
    }

    _;

    if (isTopLevelCall) {
      initializing = false;
    }
  }

  
  function isConstructor() private view returns (bool) {
    
    
    
    
    
    address self = address(this);
    uint256 cs;
    assembly { cs := extcodesize(self) }
    return cs == 0;
  }

  
  uint256[50] private ______gap;
}



pragma solidity ^0.5.0;



contract Context is Initializable {
    
    
    constructor () internal { }
    

    function _msgSender() internal view returns (address payable) {
        return msg.sender;
    }

    function _msgData() internal view returns (bytes memory) {
        this; 
        return msg.data;
    }
}



pragma solidity ^0.5.0;


interface IERC20 {
    
    function totalSupply() external view returns (uint256);

    
    function balanceOf(address account) external view returns (uint256);

    
    function transfer(address recipient, uint256 amount) external returns (bool);

    
    function allowance(address owner, address spender) external view returns (uint256);

    
    function approve(address spender, uint256 amount) external returns (bool);

    
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);

    
    event Transfer(address indexed from, address indexed to, uint256 value);

    
    event Approval(address indexed owner, address indexed spender, uint256 value);
}



pragma solidity ^0.5.0;


library SafeMath {
    
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, "SafeMath: addition overflow");

        return c;
    }

    
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        return sub(a, b, "SafeMath: subtraction overflow");
    }

    
    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b <= a, errorMessage);
        uint256 c = a - b;

        return c;
    }

    
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        
        
        
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b, "SafeMath: multiplication overflow");

        return c;
    }

    
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        return div(a, b, "SafeMath: division by zero");
    }

    
    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        
        require(b > 0, errorMessage);
        uint256 c = a / b;
        

        return c;
    }

    
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        return mod(a, b, "SafeMath: modulo by zero");
    }

    
    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b != 0, errorMessage);
        return a % b;
    }
}



pragma solidity ^0.5.0;






contract ERC20 is Initializable, Context, IERC20 {
    using SafeMath for uint256;

    mapping (address => uint256) private _balances;

    mapping (address => mapping (address => uint256)) private _allowances;

    uint256 private _totalSupply;

    
    function totalSupply() public view returns (uint256) {
        return _totalSupply;
    }

    
    function balanceOf(address account) public view returns (uint256) {
        return _balances[account];
    }

    
    function transfer(address recipient, uint256 amount) public returns (bool) {
        _transfer(_msgSender(), recipient, amount);
        return true;
    }

    
    function allowance(address owner, address spender) public view returns (uint256) {
        return _allowances[owner][spender];
    }

    
    function approve(address spender, uint256 amount) public returns (bool) {
        _approve(_msgSender(), spender, amount);
        return true;
    }

    
    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {
        _transfer(sender, recipient, amount);
        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, "ERC20: transfer amount exceeds allowance"));
        return true;
    }

    
    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));
        return true;
    }

    
    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, "ERC20: decreased allowance below zero"));
        return true;
    }

    
    function _transfer(address sender, address recipient, uint256 amount) internal {
        require(sender != address(0), "ERC20: transfer from the zero address");
        require(recipient != address(0), "ERC20: transfer to the zero address");

        _balances[sender] = _balances[sender].sub(amount, "ERC20: transfer amount exceeds balance");
        _balances[recipient] = _balances[recipient].add(amount);
        emit Transfer(sender, recipient, amount);
    }

    
    function _mint(address account, uint256 amount) internal {
        require(account != address(0), "ERC20: mint to the zero address");

        _totalSupply = _totalSupply.add(amount);
        _balances[account] = _balances[account].add(amount);
        emit Transfer(address(0), account, amount);
    }

    
    function _burn(address account, uint256 amount) internal {
        require(account != address(0), "ERC20: burn from the zero address");

        _balances[account] = _balances[account].sub(amount, "ERC20: burn amount exceeds balance");
        _totalSupply = _totalSupply.sub(amount);
        emit Transfer(account, address(0), amount);
    }

    
    function _approve(address owner, address spender, uint256 amount) internal {
        require(owner != address(0), "ERC20: approve from the zero address");
        require(spender != address(0), "ERC20: approve to the zero address");

        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }

    
    function _burnFrom(address account, uint256 amount) internal {
        _burn(account, amount);
        _approve(account, _msgSender(), _allowances[account][_msgSender()].sub(amount, "ERC20: burn amount exceeds allowance"));
    }

    uint256[50] private ______gap;
}



pragma solidity ^0.5.0;





contract ERC20Burnable is Initializable, Context, ERC20 {
    
    function burn(uint256 amount) public {
        _burn(_msgSender(), amount);
    }

    
    function burnFrom(address account, uint256 amount) public {
        _burnFrom(account, amount);
    }

    uint256[50] private ______gap;
}



pragma solidity ^0.5.0;


interface IERC165 {
    
    function supportsInterface(bytes4 interfaceId) external view returns (bool);
}



pragma solidity ^0.5.0;




contract IERC721 is Initializable, IERC165 {
    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);
    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);
    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);

    
    function balanceOf(address owner) public view returns (uint256 balance);

    
    function ownerOf(uint256 tokenId) public view returns (address owner);

    
    function safeTransferFrom(address from, address to, uint256 tokenId) public;
    
    function transferFrom(address from, address to, uint256 tokenId) public;
    function approve(address to, uint256 tokenId) public;
    function getApproved(uint256 tokenId) public view returns (address operator);

    function setApprovalForAll(address operator, bool _approved) public;
    function isApprovedForAll(address owner, address operator) public view returns (bool);


    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public;
}



pragma solidity ^0.5.0;




contract Ownable is Initializable, Context {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    
    function initialize(address sender) public initializer {
        _owner = sender;
        emit OwnershipTransferred(address(0), _owner);
    }

    
    function owner() public view returns (address) {
        return _owner;
    }

    
    modifier onlyOwner() {
        require(isOwner(), "Ownable: caller is not the owner");
        _;
    }

    
    function isOwner() public view returns (bool) {
        return _msgSender() == _owner;
    }

    
    function renounceOwnership() public onlyOwner {
        emit OwnershipTransferred(_owner, address(0));
        _owner = address(0);
    }

    
    function transferOwnership(address newOwner) public onlyOwner {
        _transferOwnership(newOwner);
    }

    
    function _transferOwnership(address newOwner) internal {
        require(newOwner != address(0), "Ownable: new owner is the zero address");
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }

    uint256[50] private ______gap;
}



pragma solidity ^0.5.5;


library Address {
    
    function isContract(address account) internal view returns (bool) {
        
        
        
        bytes32 codehash;
        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;
        
        assembly { codehash := extcodehash(account) }
        return (codehash != accountHash && codehash != 0x0);
    }

    
    function toPayable(address account) internal pure returns (address payable) {
        return address(uint160(account));
    }

    
    function sendValue(address payable recipient, uint256 amount) internal {
        require(address(this).balance >= amount, "Address: insufficient balance");

        
        (bool success, ) = recipient.call.value(amount)("");
        require(success, "Address: unable to send value, recipient may have reverted");
    }
}




pragma solidity 0.5.17;



library BasisPoints {
    using SafeMath for uint;

    uint constant private BASIS_POINTS = 10000;


    function mulBP(uint amt, uint bp) internal pure returns (uint) {
        if (amt == 0) return 0;
        return amt.mul(bp).div(BASIS_POINTS);
    }

    function addBP(uint amt, uint bp) internal pure returns (uint) {
        if (amt == 0) return 0;
        if (bp == 0) return amt;
        return amt.add(mulBP(amt, bp));
    }

    function subBP(uint amt, uint bp) internal pure returns (uint) {
        if (amt == 0) return 0;
        if (bp == 0) return amt;
        return amt.sub(mulBP(amt, bp));
    }
}



pragma solidity 0.5.17;









contract BiffysPortraitAuction is Initializable, Ownable {
    using SafeMath for uint;
    using BasisPoints for uint;
    using Address for address;

    struct Auction {
      uint portraitId;
      uint startingBid;
      uint minIncreaseBP;
      uint artistComissionBP;
      uint timerSeconds;
      uint startTime;
      address artist;
    }

    ERC20Burnable lovePoints;
    IERC721 biffysPortraits;

    uint public auctionNonce;

    mapping(address => uint) public loveBalances;

    mapping(uint => uint) public auctionEndTime;
    mapping(uint => address) public auctionLastBidder;
    mapping(uint => uint) public auctionLastBid;
    mapping(uint => bool) public auctionIsClaimed;
    mapping(uint => Auction) public auctions;


    function initialize(
        ERC20Burnable _lovePoints,
        IERC721 _biffysPortraits,
        address _owner
    ) external initializer {
        Ownable.initialize(_owner);
        lovePoints = _lovePoints;
        biffysPortraits = _biffysPortraits;
    }

    function startAuction(
      uint _portraitId,
      uint _startingBid,
      uint _minIncreaseBP,
      uint _artistComissionBP,
      uint _timerSeconds,
      uint _startTime,
      address _artist
    ) external onlyOwner {
      biffysPortraits.transferFrom(msg.sender,address(this), _portraitId);
      auctions[auctionNonce] = Auction(
        _portraitId,
        _startingBid,
        _minIncreaseBP,
        _artistComissionBP,
        _timerSeconds,
        _startTime,
        _artist
      );
      auctionEndTime[auctionNonce] = _startTime.add(_timerSeconds);
      auctionNonce = auctionNonce.add(1);
    }

    function claimPortrait(uint auctionId) external {
      Auction memory auction = auctions[auctionId];
      require(now > auctionEndTime[auctionId], "Auction not ended");
      require(now > auction.startTime && auction.startTime != 0, "Auction not started");
      require(auctionLastBidder[auctionId] != address(0x0), "No winner");
      require(auctionIsClaimed[auctionId] == false, "Already claimed");

      auctionIsClaimed[auctionId] == true;
      uint bid = auctionLastBid[auctionId];
      if(auction.artist != address(0x0)) {
        uint comission = bid.mulBP(auction.artistComissionBP);
        require(lovePoints.transfer(auction.artist,comission),"Transfer failed.");
        lovePoints.burn(bid.sub(comission));
      } else {
        lovePoints.burn(bid);
      }

      biffysPortraits.transferFrom(address(this),auctionLastBidder[auctionId],auction.portraitId);
    }

    function depositAndBid(uint auctionId, uint amount) external {
      if(amount > loveBalances[msg.sender]){
        deposit(amount.sub(loveBalances[msg.sender]));
      }
      bid(auctionId,amount);
    }

    function bid(uint auctionId, uint amount) public {
      Auction memory auction = auctions[auctionId];
      require(now < auctionEndTime[auctionId], "Auction ended");
      require(now > auction.startTime && auction.startTime != 0, "Auction not started");
      require(amount >= auctionLastBid[auctionId].addBP(auction.minIncreaseBP), "Bid too low");
      require(amount >= auction.startingBid, "Bid below starting bid");
      require(loveBalances[msg.sender] >= amount, "Love balance too low");
      require(msg.sender != auctionLastBidder[auctionId]);
      address lastBidder = auctionLastBidder[auctionId];
      if(auctionLastBid[auctionId] != 0) {
        loveBalances[lastBidder] = loveBalances[lastBidder].add(auctionLastBid[auctionId]);
      }
      loveBalances[msg.sender] = loveBalances[msg.sender].sub(amount);
      auctionLastBid[auctionId] = amount;
      auctionLastBidder[auctionId] = msg.sender;
      auctionEndTime[auctionId] = now.add(auction.timerSeconds);
    }

    function deposit(uint amount) public {
      require(lovePoints.transferFrom(msg.sender, address(this), amount),"Transfer failed");
      loveBalances[msg.sender] = loveBalances[msg.sender].add(amount);
    }

    function withdrawAll() external {
      withdraw(loveBalances[msg.sender], msg.sender);
    }

    function withdraw(uint amount, address to) public {
      require(loveBalances[msg.sender] >= amount, "Cannot withdraw more than balance");
      require(amount > 0, "Must withdraw at least 1 wei of Love");
      loveBalances[msg.sender] = loveBalances[msg.sender].sub(amount);
      uint toBurn = amount.mulBP(500); 
      lovePoints.burn(toBurn); 
      require(lovePoints.transfer(to, amount.sub(toBurn)),"Transfer Failed");
    }

    function zRescue(uint id, address receiver) external onlyOwner {
      biffysPortraits.transferFrom(address(this),receiver,id);
    }

    function getAuction(uint auctionId) external view returns(
      uint portraitId,
      uint startingBid,
      uint minIncreaseBP,
      uint artistComissionBP,
      uint timerSeconds,
      uint startTime,
      address artist,
      uint endTime,
      address lastBidder,
      uint lastBid,
      bool isClaimed
    ) {
      Auction memory auction = auctions[auctionId];
      portraitId = auction.portraitId;
      startingBid = auction.startingBid;
      minIncreaseBP = auction.minIncreaseBP;
      artistComissionBP = auction.artistComissionBP;
      timerSeconds = auction.timerSeconds;
      startTime = auction.startTime;
      artist = auction.artist;
      endTime = auctionEndTime[auctionId];
      lastBidder = auctionLastBidder[auctionId];
      lastBid = auctionLastBid[auctionId];
      isClaimed = auctionIsClaimed[auctionId];
    }
}