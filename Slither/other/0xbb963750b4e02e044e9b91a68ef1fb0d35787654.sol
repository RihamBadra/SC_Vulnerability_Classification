pragma solidity 0.6.12;
pragma experimental ABIEncoderV2;

library Address {


  function isContract(


    address account


  ) internal view returns (bool) {


    uint256 size;


    assembly { size := extcodesize(account) }


    return size > 0;


  }





  function sendValue(


    address payable recipient,


    uint256 amount


  ) internal {


    require(address(this).balance >= amount, "Address: insufficient balance");





    (bool success, ) = recipient.call{ value: amount }("");


    require(success, "Address: unable to send value, recipient may have reverted");


  }





  function functionCall(


    address target,


    bytes memory data


  ) internal returns (bytes memory) {


    return functionCall(target, data, "Address: low-level call failed");


  }





  function functionCall(


    address target,


    bytes memory data,


    string memory errorMessage


  ) internal returns (bytes memory) {


    return _functionCallWithValue(target, data, 0, errorMessage);


  }





  function functionCallWithValue(


    address target,


    bytes memory data,


    uint256 value


  ) internal returns (bytes memory) {


    return functionCallWithValue(target, data, value, "Address: low-level call with value failed");


  }





  function functionCallWithValue(


    address target,


    bytes memory data,


    uint256 value,


    string memory errorMessage


  ) internal returns (bytes memory) {


    require(address(this).balance >= value, "Address: insufficient balance for call");


    return _functionCallWithValue(target, data, value, errorMessage);


  }





  function _functionCallWithValue(


    address target,


    bytes memory data,


    uint256 weiValue,


    string memory errorMessage


  ) private returns (bytes memory) {


    require(isContract(target), "Address: call to non-contract");





    (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);


    if (success) {


      return returndata;


    } else {


      if (returndata.length > 0) {


        assembly {


          let returndata_size := mload(returndata)


          revert(add(32, returndata), returndata_size)


        }


      } else {


        revert(errorMessage);


      }


    }


  }


}

contract Burnable {


  


  


  bool private _burningEnabled;





  


  


  


  


  bytes32 public constant ROLE_BURNER = keccak256("BURNER");





  


  


  


  


  event BurningEnabled(address indexed _from);


  event BurningDisabled(address indexed _from);





  


  


  


  


  


  


  


  


  modifier isBurnable(


    uint256 _amount,


    bool _hasRole


  ) {


    require(


      _hasRole,


      "BC:500"


    );





    require(


      _amount > 0,


      "BC:30"


    );





    _enableBurning();





    require(


      burningEnabled(),


      "BC:210"


    );


    _;


  }





  


  


  constructor()


  internal {


    _burningEnabled = false;


  }





  


  


  


  


  function burningEnabled()


  public view returns (bool) {


    return _burningEnabled;


  }





  


  


  


  function _enableBurning()


  internal virtual {


    _burningEnabled = true;


    emit BurningEnabled(msg.sender);


  }





  


  


  


  function _disableBurning()


  internal virtual {


    _burningEnabled = false;


    emit BurningDisabled(msg.sender);


  }


}

library EnumerableSet {


  struct Set {


    bytes32[] _values;


    mapping (bytes32 => uint256) _indexes;


  }





  function _add(


    Set storage set,


    bytes32 value


  ) private returns (bool) {


    if (!_contains(set, value)) {


      set._values.push(value);


      set._indexes[value] = set._values.length;


      return true;


    } else {


      return false;


    }


  }





  function _remove(


    Set storage set,


    bytes32 value


  ) private returns (bool) {


    uint256 valueIndex = set._indexes[value];





    if (valueIndex != 0) {


      uint256 toDeleteIndex = valueIndex - 1;


      uint256 lastIndex = set._values.length - 1;


      bytes32 lastvalue = set._values[lastIndex];


      set._values[toDeleteIndex] = lastvalue;


      set._indexes[lastvalue] = toDeleteIndex + 1; 


      set._values.pop();


      delete set._indexes[value];


      return true;


    } else {


      return false;


    }


  }





  function _contains(


    Set storage set,


    bytes32 value


  ) private view returns (bool) {


    return set._indexes[value] != 0;


  }





  function _length(


    Set storage set


  ) private view returns (uint256) {


    return set._values.length;


  }





  function _at(


    Set storage set,


    uint256 index


  ) private view returns (bytes32) {


    require(set._values.length > index, "EnumerableSet: index out of bounds");


    return set._values[index];


  }





  struct AddressSet {


    Set _inner;


  }





  function add(


    AddressSet storage set,


    address value


  ) internal returns (bool) {


    return _add(set._inner, bytes32(uint256(value)));


  }





  function remove(


    AddressSet storage set,


    address value


  ) internal returns (bool) {


    return _remove(set._inner, bytes32(uint256(value)));


  }





  function contains(


    AddressSet storage set,


    address value


  ) internal view returns (bool) {


    return _contains(set._inner, bytes32(uint256(value)));


  }





  function length(


    AddressSet storage set


  ) internal view returns (uint256) {


    return _length(set._inner);


  }





  function at(


    AddressSet storage set,


    uint256 index


  ) internal view returns (address) {


    return address(uint256(_at(set._inner, index)));


  }





  struct UintSet {


    Set _inner;


  }





  function add(


    UintSet storage set,


    uint256 value


  ) internal returns (bool) {


    return _add(set._inner, bytes32(value));


  }





  function remove(


    UintSet storage set,


    uint256 value


  ) internal returns (bool) {


    return _remove(set._inner, bytes32(value));


  }





  function contains(


    UintSet storage set,


    uint256 value


  ) internal view returns (bool) {


    return _contains(set._inner, bytes32(value));


  }





  function length(


    UintSet storage set


  ) internal view returns (uint256) {


    return _length(set._inner);


  }





  function at(


    UintSet storage set,


    uint256 index


  ) internal view returns (uint256) {


    return uint256(_at(set._inner, index));


  }


}

interface IERC20 {


  function initialSupply()


  external view returns (uint256);





  function totalSupply()


  external view returns (uint256);





  function totalSupplyCap()


  external view returns (uint256);





  function balanceOf(


    address account


  ) external view returns (uint256);





  function transfer(


    address recipient,


    uint256 amount


  ) external returns (bool);





  function allowance(


    address owner,


    address spender


  ) external view returns (uint256);





  function approve(


    address spender,


    uint256 amount


  ) external returns (bool);





  function transferFrom(


    address sender,


    address recipient,


    uint256 amount


  ) external returns (bool);





  event Transfer(


    address indexed from,


    address indexed to,


    uint256 value


  );





  event Approval(


    address indexed owner,


    address indexed spender,


    uint256 value


  );


}

contract Minteable {


  


  


  bool private _mintingEnabled;





  


  


  


  


  bytes32 public constant ROLE_MINTER = keccak256("MINTER");





  


  


  


  


  event MintingEnabled(address indexed _from);


  event MintingDisabled(address indexed _from);





  


  


  


  


  


  


  


  


  modifier isMintable(


    uint256 _amount,


    bool _hasRole


  ) {


    require(


      _hasRole,


      "MC:500"


    );





    require(


      _amount > 0,


      "MC:30"


    );





    _enableMinting();





    require(


      mintingEnabled(),


      "MC:110"


    );


    _;


  }





  


  


  constructor()


  internal {


    _mintingEnabled = false;


  }





  


  


  


  


  function mintingEnabled()


  public view returns (bool) {


    return _mintingEnabled;


  }





  


  


  


  function _enableMinting()


  internal virtual {


    _mintingEnabled = true;


    emit MintingEnabled(msg.sender);


  }





  


  


  


  function _disableMinting()


  internal virtual {


    _mintingEnabled = false;


    emit MintingDisabled(msg.sender);


  }


}

abstract contract Roleplay {


  using EnumerableSet for EnumerableSet.AddressSet;





  


  


  struct RoleData {


    EnumerableSet.AddressSet members;


    bytes32 ownerRole;


  }





  mapping (bytes32 => RoleData) private _roles;





  


  


  


  


  bytes32 public constant ROLE_OWNER = 0x00;





  


  


  


  


  bytes32 public constant ROLE_MANAGER = keccak256("MANAGER");





  


  


  


  event RoleGranted(bytes32 indexed _role, address indexed _from, address indexed _sender);


  event RoleRevoked(bytes32 indexed role, address indexed _from, address indexed _sender);





  


  


  


  


  


  modifier onlyOwner() {


    require(


      hasRole(ROLE_OWNER, msg.sender),


      "RPC:500"


    );


    _;


  }





  


  


  


  


  


  


  


  


  function hasRole(


    bytes32 _role,


    address _account


  ) public view returns (bool) {


    return _roles[_role].members.contains(_account);


  }





  


  


  


  


  


  


  


  function getRoleMembersLength(


    bytes32 _role


  ) public view returns (uint256) {


    return _roles[_role].members.length();


  }








  


  


  


  


  


  


  


  


  function exposeRoleMember(


    bytes32 _role,


    uint256 _id


  ) public view returns (address) {


    return _roles[_role].members.at(_id);


  }





  


  


  


  


  


  


  


  


  function transferOwnerRole(


    address _to


  ) public virtual onlyOwner() {


    _grantRole(ROLE_OWNER, _to);


    _revokeRole(ROLE_OWNER, msg.sender);


  }





  


  


  


  


  


  


  


  


  function grantManagerRole(


    address _to


  ) public virtual onlyOwner() {


    _grantRole(ROLE_MANAGER, _to);


  }





  


  


  


  


  


  


  


  


  


  


  function grantRole(


    bytes32 _role,


    address _to


  ) public virtual {


    require(


      hasRole(ROLE_MANAGER, msg.sender),


      "RPC:510"


    );





    require(


      _role != ROLE_OWNER,


      "RPC:520"


    );





    if (!hasRole(ROLE_OWNER, msg.sender)) {


      require(


        _role == keccak256("CHAIRPERSON"),


        "RPC:530"


      );


    }





    _grantRole(_role, _to);


  }





  


  


  


  


  


  


  


  


  


  


  function revokeRole(


    bytes32 _role,


    address _to


  ) public virtual {


    require(


      hasRole(ROLE_MANAGER, msg.sender),


      "RPC:550"


    );





    require(


      _role != ROLE_OWNER,


      "RPC:540"


    );





    if (!hasRole(ROLE_OWNER, msg.sender)) {


      require(


        _role == keccak256("CHAIRPERSON"),


        "RPC:530"


      );


    }





    _revokeRole(_role, _to);


  }





  


  


  


  


  


  function renounceRole(


    bytes32 _role


  ) public virtual {


    require(


      _role != ROLE_OWNER,


      "RPC:540"


    );





    require(


      hasRole(_role, msg.sender),


      "RPC:570"


    );





    _revokeRole(_role, msg.sender);


  }





  function _setupRole(


    bytes32 _role,


    address _to


  ) internal virtual {


    _grantRole(_role, _to);


  }





  function _grantRole(


    bytes32 _role,


    address _to


  ) private {


    if (_roles[_role].members.add(_to)) {


      emit RoleGranted(_role, _to, msg.sender);


    }


  }





  function _revokeRole(


    bytes32 _role,


    address _to


  ) private {


    if (_roles[_role].members.remove(_to)) {


      emit RoleRevoked(_role, _to, msg.sender);


    }


  }


}

library SafeMath {


  function add(


    uint256 a,


    uint256 b


  ) internal pure returns (uint256) {


    uint256 c = a + b;


    require(c >= a, "SafeMath: addition overflow");





    return c;


  }





  function sub(


    uint256 a,


    uint256 b


  ) internal pure returns (uint256) {


    return sub(a, b, "SafeMath: subtraction overflow");


  }





  function sub(


    uint256 a,


    uint256 b,


    string memory errorMessage


  ) internal pure returns (uint256) {


    require(b <= a, errorMessage);


    uint256 c = a - b;





    return c;


  }





  function mul(


    uint256 a,


    uint256 b


  ) internal pure returns (uint256) {


    if (a == 0) {


      return 0;


    }





    uint256 c = a * b;


    require(c / a == b, "SafeMath: multiplication overflow");





    return c;


  }





  function div(


    uint256 a,


    uint256 b


  ) internal pure returns (uint256) {


    return div(a, b, "SafeMath: division by zero");


  }





  function div(


    uint256 a,


    uint256 b,


    string memory errorMessage


  ) internal pure returns (uint256) {


    require(b > 0, errorMessage);


    uint256 c = a / b;





    return c;


  }





  function mod(


    uint256 a,


    uint256 b


  ) internal pure returns (uint256) {


    return mod(a, b, "SafeMath: modulo by zero");


  }





  function mod(


    uint256 a,


    uint256 b,


    string memory errorMessage


  ) internal pure returns (uint256) {


    require(b != 0, errorMessage);


    return a % b;


  }


}

abstract contract Stakeable is Roleplay {


  


  


  uint256 internal _totalStakedSupply;





  


  


  uint256 internal _maxRewardRatio;


  


  


  


  struct Stakeholder {


    address owner;


    uint256 stake;


    uint256 availableReward;


    uint256 totalRewardEarned;


    uint256 totalRewardSpent;


    uint256 createdAt;


    uint256 lastRewardCalculatedAt;


  }





  


  


  


  


  event Staked(address indexed _from, uint256 _amount);


  event Unstaked(address indexed _from, uint256 _amount);





  


  


  Stakeholder[] stakeholders;


  


  


  


  


  


  


  


  


  modifier isAmountNotZero(uint256 _amount) {


    require(


      _amount > 0,


      "SC:630"


    );


    _;


  }





  


  


  


  


  


  


  


  


  modifier isAmountValid(uint256 _amount, uint256 _balance) {


    require(


      (_amount * (10**8)) <= _balance,


      "SC:640"


    );


    _;


  }





  


  


  


  


  


  


  


  modifier isAbleToUnstake(uint256 _amount) {


    Stakeholder memory stakeholder = exposeStakeholder(msg.sender); 


    require(


      _amount <= stakeholder.stake,


      "SC:640"


    );


    _;


  }





  constructor() public {


    _maxRewardRatio = 10;


  }





  


  


  


  


  function totalStakedSupply()


  public view returns (uint256) {


    return _totalStakedSupply;


  }





  


  


  


  


  function maxRewardRatio()


  public view returns (uint256) {


    return _maxRewardRatio;


  }





  


  


  


  


  function exposeStakeholders()


  public view returns (Stakeholder[] memory) {


    return stakeholders;


  }





  


  


  


  


  


  


  function exposeStakeholder(


    address _owner


  ) public view returns (Stakeholder memory) {


    uint256 i = 0;


    uint256 len = stakeholders.length;


    while (i < len) {


      if (stakeholders[i].owner == _owner) {


        return stakeholders[i];


      }


      i++;


    }


  }





  


  


  


  


  


  


  function setMaxRewardRatio(


    uint256 _amount


  ) public virtual onlyOwner() {


    _maxRewardRatio = _amount;


  }





  


  


  


  


  


  


  function _createStakeholder(


    address _owner


  ) internal virtual {


    stakeholders.push(Stakeholder({


      owner: _owner,


      stake: 0,


      createdAt: now,


      availableReward: 0,


      totalRewardEarned: 0,


      totalRewardSpent: 0,


      lastRewardCalculatedAt: 0


    }));


  }





  


  


  


  


  


  


  


  


  


  


  


  


  


  


  


  


  


  


  


  function _computeReward(


    uint256 _id


  ) internal virtual {


    uint256 stake = stakeholders[_id].stake;


    uint256 lastCalculatedReward = stakeholders[_id].lastRewardCalculatedAt;


    uint256 createdAt = stakeholders[_id].createdAt;





    if (lastCalculatedReward == 0) {


      if (createdAt < now) {


        if ((now - createdAt) >= 1 days) {


          stakeholders[_id].availableReward += (((now - createdAt) / 1 days) * (


            stake <= _maxRewardRatio ?


            stake : _maxRewardRatio


          ));


          stakeholders[_id].totalRewardEarned += (((now - createdAt) / 1 days) * (


            stake <= _maxRewardRatio ?


            stake : _maxRewardRatio


          ));


          stakeholders[_id].lastRewardCalculatedAt = now;


          return;


        }


      }


    }





    if (lastCalculatedReward != 0) {


      if (lastCalculatedReward < now) {


        if ((now - lastCalculatedReward) >= 1 days) {


          stakeholders[_id].availableReward += (((now - lastCalculatedReward) / 1 days) * (


            stake <= _maxRewardRatio ?


            stake : _maxRewardRatio


          ));


          stakeholders[_id].totalRewardEarned += (((now - lastCalculatedReward) / 1 days) * (


            stake <= _maxRewardRatio ?


            stake : _maxRewardRatio


          ));


          stakeholders[_id].lastRewardCalculatedAt = now;


          return;


        }


      }


    }


  }


}

abstract contract Voteable is Roleplay {


  


  


  uint256 internal _minVoteBalance;





  


  


  struct Proposal {


    address creator;


    string name;


    string metadataURI;


    bool votingEnabled;


    uint256 positiveVote;


    uint256 negativeVote;


    address[] positiveVoters;


    address[] negativeVoters;


  }





  


  


  


  


  bytes32 public constant ROLE_CHAIRPERSON = keccak256("CHAIRPERSON");





  


  


  Proposal[] proposals;





  


  


  


  


  


  modifier isChairperson() {


    require(


      hasRole(ROLE_CHAIRPERSON, msg.sender),


      "VC:500"


    );


    _;


  }





  


  


  


  


  


  


  


  


  


  modifier isValidVoter(


    uint256 _id,


    uint256 _balance


  ) {


    require(


      _balance >= (_minVoteBalance * (10**8)),


      "VC:1010"


    );





    bool positiveVote = _checkSenderHasVoted(proposals[_id].positiveVoters, msg.sender);


    bool negativeVote = _checkSenderHasVoted(proposals[_id].negativeVoters, msg.sender);





    require(


      !positiveVote && !negativeVote,


      "VC:1020"


    );


    _;


  }





  


  


  


  


  


  


  


  modifier isVoteEnabled(


    uint256 _id


  ) {


    require(


      proposals[_id].votingEnabled,


      "VC:1030"


    );


    _;


  }





  constructor() public {


    _minVoteBalance = 100;


  }





  


  


  


  


  function minVoteBalance()


  public view returns (uint256) {


    return _minVoteBalance;


  }





  


  


  


  


  


  


  function setMinVoteBalance(


    uint256 _amount


  ) public virtual onlyOwner() {


    _minVoteBalance = _amount;


  }





  


  


  


  


  


  


  


  


  


  


  


  function createProposal(


    string memory _name,


    string memory _uri,


    bool _enable


  ) public virtual isChairperson() {


    proposals.push(


      Proposal({


        creator: msg.sender,


        name: _name,


        metadataURI: _uri,


        votingEnabled: _enable,


        positiveVote: 0,


        negativeVote: 0,


        positiveVoters: new address[](0),


        negativeVoters: new address[](0)


      })


    );


  }


  


  


  


  


  


  


  


  


  


  


  


  function enableProposal(


    uint256 _id


  ) public virtual isChairperson() {


    proposals[_id].votingEnabled ?


    proposals[_id].votingEnabled = false :


    proposals[_id].votingEnabled = true;


  }





  


  


  


  


  function exposeProposals()


  public view returns (Proposal[] memory) {


    return proposals;


  }





  


  


  


  


  


  


  


  


  


  function _checkSenderHasVoted(


    address[] memory _voters,


    address _voter


  ) private pure returns (bool) {


    uint256 i = 0;


    bool voted = false;


    uint256 len = _voters.length;


    while (i < len) {


      if (_voters[i] == _voter) {


        voted = true;


        break;


      }


      i++;


    }





    return voted;


  }


}

abstract contract ERC20 is IERC20 {


  using SafeMath for uint256;


  using Address for address;





  mapping (address => uint256) private _balances;





  mapping (address => mapping (address => uint256)) private _allowances;





  uint256 private _initialSupply;


  uint256 private _totalSupply;


  uint256 private _totalSupplyCap;





  string private _name;


  string private _symbol;


  uint8 private _decimals;





  constructor (


    string memory name,


    string memory symbol,


    uint256 totalSupplyCap,


    uint256 initialSupply


  ) public {


    _decimals = 8;





    _name = name;


    _symbol = symbol;


    _totalSupplyCap = totalSupplyCap;


    _initialSupply = initialSupply;


  }





  function name()


  public view returns (string memory) {


    return _name;


  }





  function symbol()


  public view returns (string memory) {


    return _symbol;


  }





  function decimals()


  public view returns (uint8) {


    return _decimals;


  }





  function initialSupply()


  public view override returns (uint256) {


    return _initialSupply;


  }





  function totalSupply()


  public view override returns (uint256) {


    return _totalSupply;


  }





  function totalSupplyCap()


  public view override returns (uint256) {


    return _totalSupplyCap;


  }





  function balanceOf(


    address account


  ) public view override returns (uint256) {


    return _balances[account];


  }





  function transfer(


    address recipient,


    uint256 amount


  ) public virtual override returns (bool) {


    _transfer(msg.sender, recipient, amount);


    return true;


  }





  function allowance(


    address owner,


    address spender


  ) public view virtual override returns (uint256) {


    return _allowances[owner][spender];


  }





  function approve(


    address spender,


    uint256 amount


  ) public virtual override returns (bool) {


    _approve(msg.sender, spender, (amount * (10**8)));


    return true;


  }





  function transferFrom(


    address sender,


    address recipient,


    uint256 amount


  ) public virtual override returns (bool) {


    _transfer(sender, recipient, amount);


    _approve(sender, msg.sender, _allowances[sender][msg.sender].sub((amount * (10**8)), "ERC20:490"));


    return true;


  }





  function increaseAllowance(


    address spender,


    uint256 addedValue


  ) public virtual returns (bool) {


    _approve(msg.sender, spender, _allowances[msg.sender][spender].add((addedValue * (10**8))));


    return true;


  }





  function decreaseAllowance(


    address spender,


    uint256 subtractedValue


  ) public virtual returns (bool) {


    _approve(msg.sender, spender, _allowances[msg.sender][spender].sub((subtractedValue * (10**8)), "ERC20:495"));


    return true;


  }





  function _transfer(


    address sender,


    address recipient,


    uint256 amount


  ) internal virtual {


    require(


      sender != address(0),


      "ERC20:410"


    );





    require(


      recipient != address(0),


      "ERC20:420"


    );





    require(


      amount > 0,


      "ERC20:480"


    );





    _beforeTokenTransfer(sender, recipient, amount);





    _balances[sender] = _balances[sender].sub(amount, "ERC20:470");


    _balances[recipient] = _balances[recipient].add(amount);


    emit Transfer(sender, recipient, amount);


  }





  function _mint(


    address account,


    uint256 amount


  ) internal virtual {


    require(


      account != address(0),


      "ERC20:120"


    );





    _beforeTokenTransfer(address(0), account, amount);





    _totalSupply = _totalSupply.add(amount);


    _balances[account] = _balances[account].add(amount);


    emit Transfer(address(0), account, amount);


  }





  function _burn(


    address account,


    uint256 amount


  ) internal virtual {


    require(


      account != address(0),


      "ERC20:220"


    );





    _beforeTokenTransfer(account, address(0), amount);





    _balances[account] = _balances[account].sub(amount, "ERC20:230");


    _totalSupply = _totalSupply.sub(amount);


    emit Transfer(account, address(0), amount);


  }





  function _approve(


    address owner,


    address spender,


    uint256 amount


  ) internal virtual {


    require(


      owner != address(0),


      "ERC20:450"


    );


    require(


      spender != address(0),


      "ERC20:460"


    );





    _allowances[owner][spender] = amount;


    emit Approval(owner, spender, amount);


  }





  function _setupDecimals(


    uint8 decimals_


  ) internal {


    _decimals = decimals_;


  }





  function _beforeTokenTransfer(


    address from,


    address to,


    uint256 amount


  ) internal virtual {}


}

contract Pauseable is Roleplay {


  


  


  bool private _paused;


  


  


  


  


  


  event Paused(address indexed _from);


  event Unpaused(address indexed _from);





  


  


  


  


  


  modifier whenNotPaused() {


    require(


      !_paused,


      "PC:300"


    );


    _;


  }





  


  


  


  


  


  modifier whenPaused() {


    require(


      _paused,


      "PC:310"


    );


    _;


  }





  


  


  constructor ()


  internal {


    _paused = false;


  }





  


  


  


  


  function paused()


  public view returns (bool) {


    return _paused;


  }


  


  


  


  


  function pause()


  public virtual whenNotPaused() onlyOwner() {


    _paused = true;


    emit Paused(msg.sender);


  }





  


  


  


  function unpause()


  public virtual whenPaused() onlyOwner() {


    _paused = false;


    emit Unpaused(msg.sender);


  }


}

abstract contract CreationEngineToken is 


ERC20, Roleplay, Pauseable, Minteable, Burnable {





  


  


  


  


  


  


  constructor()


  public ERC20(


    "Creation Engine Token",


    "CET",


    40000 * (10**8),


    1000 * (10**8)


  ) {


    _setupRole(ROLE_OWNER, msg.sender);


    _setupRole(ROLE_MANAGER, msg.sender);


    _mint(msg.sender, initialSupply());


  }


  


  


  


  


  


  


  


  


  function transferBatch(


    address[] memory _receivers,


    uint256 _amount


  ) public virtual {


    uint256 i = 0;


    uint256 len = _receivers.length;





    require(


      balanceOf(msg.sender) >= (_amount * len),


      "UT:470"


    );





    while (i < len) {


      transfer(_receivers[i], _amount);


      i++;


    }


  } 





  


  


  


  


  


  


  


  


  


  


  


  


  function mint(


    uint256 _amount


  ) public virtual isMintable(


    _amount,


    hasRole(ROLE_MINTER, msg.sender)


  ) {


    _mint(msg.sender, _amount);


    _disableMinting();


  }





  


  


  


  


  


  


  


  


  


  


  


  


  


  function mintTo(


    address _to,


    uint256 _amount


  ) public virtual isMintable(


    _amount,


    hasRole(ROLE_MINTER, msg.sender)


  ) {


    _mint(_to, _amount);


    _disableMinting();


  }





  


  


  


  


  


  


  


  


  


  


  


  function burn(


    uint256 _amount


  ) public virtual isBurnable(


    _amount,


    hasRole(ROLE_BURNER, msg.sender)


  ) {


    _burn(msg.sender, _amount);


    _disableBurning();


  }





  


  


  


  


  


  


  


  


  


  


  


  


  


  


  function burnFrom(


    address _from,


    uint256 _amount


  ) public virtual isBurnable(


    _amount,


    hasRole(ROLE_BURNER, msg.sender)


  ) {


    uint256 decreasedAllowance = allowance(_from, msg.sender).sub(_amount);


    _approve(_from, msg.sender, decreasedAllowance);


    _burn(_from, _amount);


    _disableBurning();


  }





  


  


  


  


  


  


  function _beforeTokenTransfer(


    address from,


    address to,


    uint256 amount


  ) internal virtual override {


    super._beforeTokenTransfer(from, to, amount);





    if (from == address(0)) {


      require(


        totalSupply().add(amount) <= totalSupplyCap(),


        "UT:20"


      );


    }





    require(


      !paused(),


      "UT:400"


    );


  }


}

abstract contract CreationEngineDAO is Voteable, CreationEngineToken {


  


  


  


  


  


  


  constructor() public {


    grantRole(ROLE_CHAIRPERSON, msg.sender);


  }





  


  


  


  


  


  


  


  


  


  


  


  


  


  


  


  


  


  function voteForProposal(


    uint256 _id,


    bool _isPositiveVote


  ) public virtual isValidVoter(


    _id,


    balanceOf(msg.sender)


  ) isVoteEnabled(


    _id


  ) {


    if (_isPositiveVote) {


      proposals[_id].positiveVote += 1;


      proposals[_id].positiveVoters.push(msg.sender);


    }





    if (!_isPositiveVote) {


      proposals[_id].negativeVote += 1;


      proposals[_id].negativeVoters.push(msg.sender);


    }


  }


}

abstract contract CreationEngineDApp is Roleplay, Stakeable, CreationEngineToken {





  


  


  


  


  


  


  


  


  


  


  


  


  


  


  


  


  


  function stake(


    uint256 _amount


  ) public virtual isAmountValid(


    _amount,


    balanceOf(msg.sender)


  ) isAmountNotZero(


    _amount


  ) {


    uint256 i = 0;


    bool isStakeholder = false;


    uint256 len = stakeholders.length;


    while (i < len) {


      if (stakeholders[i].owner == msg.sender) {


        isStakeholder = true;


        break;


      }


      i++;


    }





    if (isStakeholder) {


      stakeholders[i].stake += _amount;


      _burn(msg.sender, (_amount * (10**8)));


      _totalStakedSupply += (_amount * (10**8));


      emit Staked(msg.sender, _amount);


    }





    if (!isStakeholder) {


      _createStakeholder(msg.sender);


      stake(_amount);


    }


  }


  


  


  


  


  


  


  


  


  


  


  


  


  


  


  


  


  


  


  


  function unstake(


    uint256 _amount


  ) public virtual isAmountNotZero(


    _amount


  ) isAbleToUnstake(


    _amount


  ) {


    uint256 i = 0;


    bool isStakeholder = false;


    uint256 len = stakeholders.length;


    while (i < len) {


      if (stakeholders[i].owner == msg.sender) {


        isStakeholder = true;


        break;


      }


      i++;


    }





    require(


      isStakeholder,


      "SC:650"


    );





    if (isStakeholder) {


      if (_amount <= stakeholders[i].stake) {


        stakeholders[i].stake -= _amount;


        _mint(msg.sender, (_amount * (10**8)));


        _totalStakedSupply -= (_amount * (10**8));


        emit Unstaked(msg.sender, _amount);


      }


    }


  }


  


  


  


  


  


  


  


  


  


  


  


  function withdraw()


  public virtual {


    uint256 i = 0;


    bool isStakeholder = false;


    uint256 len = stakeholders.length;


    while (i < len) {


      if (stakeholders[i].owner == msg.sender) {


        isStakeholder = true;


        break;


      }


      i++;


    }





    require(


      isStakeholder,


      "SC:650"


    );





    if (isStakeholder) {


      _computeReward(i);


    }


  }





  


  


  


  


  


  


  


  


  


  function spend(


    uint256 _amount,


    address _target


  ) public virtual onlyOwner() {


    uint256 i = 0;


    bool isStakeholder = false;


    uint256 len = stakeholders.length;


    while (i < len) {


      if (stakeholders[i].owner == _target) {


        isStakeholder = true;


        break;


      }


      i++;


    }





    require(


      isStakeholder,


      "SC:650"


    );





    if (isStakeholder) {


      _computeReward(i);


      require(


        _amount <= stakeholders[i].availableReward,


        "SC:660"


      );





      stakeholders[i].availableReward -= _amount;


      stakeholders[i].totalRewardSpent += _amount;


    }


  }


}

contract CreationEngine is CreationEngineDAO, CreationEngineDApp {





  


  


  


  


  string public constant CREATOR = "t.me/CreationEngine";


}
