





pragma solidity ^0.6.0;


abstract contract Context {
    function _msgSender() internal view virtual returns (address payable) {
        return msg.sender;
    }

    function _msgData() internal view virtual returns (bytes memory) {
        this; 
        return msg.data;
    }
}





pragma solidity ^0.6.0;


contract Ownable is Context {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    
    constructor () internal {
        address msgSender = _msgSender();
        _owner = msgSender;
        emit OwnershipTransferred(address(0), msgSender);
    }

    
    function owner() public view returns (address) {
        return _owner;
    }

    
    modifier onlyOwner() {
        require(_owner == _msgSender(), "Ownable: caller is not the owner");
        _;
    }

    
    function renounceOwnership() public virtual onlyOwner {
        emit OwnershipTransferred(_owner, address(0));
        _owner = address(0);
    }

    
    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), "Ownable: new owner is the zero address");
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }
}





pragma solidity ^0.6.0;


library SafeMath {
    
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, "SafeMath: addition overflow");

        return c;
    }

    
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        return sub(a, b, "SafeMath: subtraction overflow");
    }

    
    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b <= a, errorMessage);
        uint256 c = a - b;

        return c;
    }

    
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        
        
        
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b, "SafeMath: multiplication overflow");

        return c;
    }

    
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        return div(a, b, "SafeMath: division by zero");
    }

    
    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b > 0, errorMessage);
        uint256 c = a / b;
        

        return c;
    }

    
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        return mod(a, b, "SafeMath: modulo by zero");
    }

    
    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b != 0, errorMessage);
        return a % b;
    }
}





pragma solidity ^0.6.0;


contract ReentrancyGuard {
    
    
    
    
    

    
    
    
    
    
    uint256 private constant _NOT_ENTERED = 1;
    uint256 private constant _ENTERED = 2;

    uint256 private _status;

    constructor () internal {
        _status = _NOT_ENTERED;
    }

    
    modifier nonReentrant() {
        
        require(_status != _ENTERED, "ReentrancyGuard: reentrant call");

        
        _status = _ENTERED;

        _;

        
        
        _status = _NOT_ENTERED;
    }
}





pragma solidity ^0.6.0;


interface IERC20 {
    
    function totalSupply() external view returns (uint256);

    
    function balanceOf(address account) external view returns (uint256);

    
    function transfer(address recipient, uint256 amount) external returns (bool);

    
    function allowance(address owner, address spender) external view returns (uint256);

    
    function approve(address spender, uint256 amount) external returns (bool);

    
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);

    
    event Transfer(address indexed from, address indexed to, uint256 value);

    
    event Approval(address indexed owner, address indexed spender, uint256 value);
}



pragma solidity 0.6.5;

interface IDigiNFT {
    function mint(
        address wallet,
        string calldata cardName,
        bool cardPhysical
    ) external returns (uint256);

    function cardName(uint256 tokenId) external view returns (string memory);
    function cardPhysical(uint256 tokenId) external view returns (bool);
    function transferFrom(address from, address to, uint256 tokenId) external;
}



pragma solidity 0.6.5;
pragma experimental ABIEncoderV2;






contract DigiAuction is Ownable, ReentrancyGuard {
    using SafeMath for uint256;
    using SafeMath for uint8;

    uint256 BIGNUMBER = 10 ** 18;

    
    uint256 public purchaseFee = 500;   
    uint256 public digiAmountRequired = 1000 * (BIGNUMBER);

    
    event CreatedAuction(uint256 auctionId, address indexed wallet, uint256 tokenId, uint256 created);
    event CanceledAuction(uint256 auctionId, address indexed wallet, uint256 tokenId, uint256 created);
    event NewHighestOffer(uint256 auctionId, address indexed wallet, uint256 amount, uint256 created);
    event DirectBuyed(uint256 auctionId, address indexed wallet, uint256 amount, uint256 created);
    event Claimed(uint256 auctionId, address indexed wallet, uint256 amount, uint256 created);
    event Log(uint256 data);

    
    address public stakeERC20;
    address public digiERC271;
    address public stableERC20;
    address[] public feesDestinators;
    uint256[] public feesPercentages;

    uint256 public auctionCount = 0;

    mapping (uint256 => Auction) public auctions;
    mapping (uint256 => bool) public claimedAuctions;
    mapping (uint256 => Offer) public highestOffers;
    mapping (uint256 => uint256) public lastAuctionByToken;

    struct Auction {
        uint256 tokenId;
        address owner;
        uint256 minPrice;
        uint256 fixedPrice;
        bool buyed;
        uint256 endDate;
    }

    struct Offer {
        address buyer;
        uint256 offer;
        uint256 date;
    }

    
    constructor(
        address _stakeERC20,
        address _digiERC271,
        address _stableERC20
    )
        public
    {
        require(address(_stakeERC20) != address(0)); 
        require(address(_digiERC271) != address(0));
        require(address(_stableERC20) != address(0));

        stakeERC20 = _stakeERC20;
        digiERC271 = _digiERC271;
        stableERC20 = _stableERC20;
    }

    
    function createAuction(
        uint256 _tokenId,
        uint256 _minPrice,
        uint256 _fixedPrice,
        uint256 _duration
    )
        public
        returns (uint256)
    {
        IDigiNFT(digiERC271).transferFrom(msg.sender, address(this), _tokenId);

        uint256 timeNow = _getTime();
        uint256 newAuction = auctionCount;
        auctionCount += 1;

        auctions[newAuction] = Auction({
            tokenId: _tokenId,
            owner: msg.sender,
            minPrice: _minPrice,
            fixedPrice: _fixedPrice,
            buyed: false,
            endDate: timeNow + _duration
        });
        lastAuctionByToken[_tokenId] = newAuction;

        emit CreatedAuction(newAuction, msg.sender, _tokenId, timeNow);

        return newAuction;
    }

    
    function participateAuction(uint256 _auctionId, uint256 _amount)
        public
        nonReentrant()
        requiredAmount(msg.sender, digiAmountRequired)
        inProgress(_auctionId)
        minPrice(_auctionId, _amount)
        newHighestOffer(_auctionId, _amount)
    {
        IERC20(stableERC20).transferFrom(msg.sender, address(this), _amount);

        _returnPreviousOffer(_auctionId);

        uint256 timeNow = _getTime();
        highestOffers[_auctionId] = Offer({
            buyer: msg.sender,
            offer: _amount,
            date: timeNow
        });

        emit NewHighestOffer(_auctionId, msg.sender, _amount, timeNow);
    }

    
    function directBuy(uint256 _auctionId)
        public
        notClaimed(_auctionId)
        inProgress(_auctionId)
    {
        require(IERC20(stableERC20).balanceOf(msg.sender) > auctions[_auctionId].fixedPrice, 'DigiAuction: User does not have enough balance');
        require(auctions[_auctionId].fixedPrice > 0, 'DigiAuction: Direct buy not available');
        
        uint amount = auctions[_auctionId].fixedPrice;
        uint256 feeAmount = amount.mul(purchaseFee).div(10000);
        uint256 amountAfterFee = amount.sub(feeAmount);

        IERC20(stableERC20).transferFrom(msg.sender, address(this), feeAmount);
        IERC20(stableERC20).transferFrom(msg.sender, auctions[_auctionId].owner, amountAfterFee);
        IDigiNFT(digiERC271).transferFrom(address(this), msg.sender, auctions[_auctionId].tokenId);
        
        uint256 timeNow = _getTime();
        auctions[_auctionId].buyed = true;

        claimedAuctions[_auctionId] = true;

        _returnPreviousOffer(_auctionId);

        emit DirectBuyed(_auctionId, msg.sender, auctions[_auctionId].fixedPrice, timeNow);
    }

    
    function claim(uint256 _auctionId)
        public
        ended(_auctionId)
        notClaimed(_auctionId)
    {
        require(highestOffers[_auctionId].buyer != address(0x0), "DigiAuction: Ended without winner");

        uint256 timeNow = _getTime();
        uint256 amount = highestOffers[_auctionId].offer;
        uint256 feeAmount = amount.mul(purchaseFee).div(10000);
        uint256 amountAfterFee = amount.sub(feeAmount);

        IERC20(stableERC20).transfer(auctions[_auctionId].owner, amountAfterFee);
        IDigiNFT(digiERC271).transferFrom(address(this), highestOffers[_auctionId].buyer, auctions[_auctionId].tokenId);

        claimedAuctions[_auctionId] = true;

        emit Claimed(_auctionId, highestOffers[_auctionId].buyer, amount, timeNow);
    }

    
    function withdrawAcumulatedFees() public {
        uint256 total = IERC20(stableERC20).balanceOf(address(this));
        
        for (uint8 i = 0; i < feesDestinators.length; i++) {
            IERC20(stableERC20).transfer(
                feesDestinators[i],
                total.mul(feesPercentages[i]).div(100)
            );
        }
    }

    
    function cancel(uint256 _auctionId)
        public
        ended(_auctionId)
    {
        require(auctions[_auctionId].owner == msg.sender, 'DigiAuction: User is not the token owner');
        require(highestOffers[_auctionId].buyer == address(0x0), "DigiAuction: Ended but has winner");

        uint256 timeNow = _getTime();

        auctions[_auctionId].endDate = timeNow;

        IDigiNFT(digiERC271).transferFrom(
            address(this),
            auctions[_auctionId].owner,
            auctions[_auctionId].tokenId
        );

        emit CanceledAuction(_auctionId, msg.sender, auctions[_auctionId].tokenId, timeNow);
    }

    
    function setFee(uint256 _purchaseFee) public onlyOwner() {
        require(_purchaseFee <= 3000, "DigiAuction: Max fee 30%");
        purchaseFee = _purchaseFee;
    }

    
    function setFeesDestinatorsWithPercentages(
        address[] memory _destinators,
        uint256[] memory _percentages
    )
        public
        onlyOwner()
    {
        require(_destinators.length == _percentages.length, "DigiAuction: Destinators and percentageslenght are not equals");

        uint256 total = 0;
        for (uint8 i = 0; i < _percentages.length; i++) {
            total += _percentages[i];
        }
        require(total == 100, "DigiAuction: Percentages sum must be 100");

        feesDestinators = _destinators;
        feesPercentages = _percentages;
    }

    
    function _returnPreviousOffer(uint256 _auctionId) internal {
        Offer memory currentOffer = highestOffers[_auctionId];
        if (currentOffer.offer > 0) {
            IERC20(stableERC20).transfer(currentOffer.buyer, currentOffer.offer);
        }
    }

    function _getTime() internal view returns (uint256) {
        return block.timestamp;
    }

    
    modifier requiredAmount(address _wallet, uint256 _amount) {
        require(
            IERC20(stakeERC20).balanceOf(_wallet) > _amount,
            'DigiAuction: User needs more token balance in order to do this action'
        );
        _;
    }

    modifier newHighestOffer(uint256 _auctionId, uint256 _amount) {
        require(
            _amount > highestOffers[_auctionId].offer,
            'DigiAuction: Amount must be higher'
        );
        _;
    }

    modifier minPrice(uint256 _auctionId, uint256 _amount) {
        require(
            _amount >= auctions[_auctionId].minPrice,
            'DigiAuction: Insufficient offer amount for this auction'
        );
        _;
    }

    modifier inProgress(uint256 _auctionId) {
        require(
            (auctions[_auctionId].endDate > _getTime()) && auctions[_auctionId].buyed == false,
            'DigiAuction: Auction closed'
        );
        _;
    }

    modifier ended(uint256 _auctionId) {
        require(
            (_getTime() > auctions[_auctionId].endDate) && auctions[_auctionId].buyed == false,
            'DigiAuction: Auction not closed'
        );
        _;
    }

    modifier notClaimed(uint256 _auctionId) {
        require(
            (claimedAuctions[_auctionId] == false),
            'DigiAuction: Already claimed'
        );
        _;
    }
}