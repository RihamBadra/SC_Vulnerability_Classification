



pragma solidity 0.7.6;






interface IERC20Permit {
  
  function permit(
    address owner,
    address spender,
    uint256 value,
    uint256 deadline,
    uint8 v,
    bytes32 r,
    bytes32 s
  ) external;

  
  function nonces(address owner) external view returns (uint256);

  
  
  function DOMAIN_SEPARATOR() external view returns (bytes32);
}



library LixirErrors {
  function require_INSUFFICIENT_BALANCE(bool cond) internal pure {
    require(cond, 'INSUFFICIENT_BALANCE');
  }

  function require_INSUFFICIENT_ALLOWANCE(bool cond) internal pure {
    require(cond, 'INSUFFICIENT_ALLOWANCE');
  }

  function require_PERMIT_EXPIRED(bool cond) internal pure {
    require(cond, 'PERMIT_EXPIRED');
  }

  function require_INVALID_SIGNATURE(bool cond) internal pure {
    require(cond, 'INVALID_SIGNATURE');
  }

  function require_XFER_ZERO_ADDRESS(bool cond) internal pure {
    require(cond, 'XFER_ZERO_ADDRESS');
  }

  function require_INSUFFICIENT_INPUT_AMOUNT(bool cond) internal pure {
    require(cond, 'INSUFFICIENT_INPUT_AMOUNT');
  }

  function require_INSUFFICIENT_OUTPUT_AMOUNT(bool cond) internal pure {
    require(cond, 'INSUFFICIENT_OUTPUT_AMOUNT');
  }
  function require_INSUFFICIENT_ETH(bool cond) internal pure {
    require(cond, 'INSUFFICIENT_ETH');
  }
  function require_MAX_SUPPLY(bool cond) internal pure {
    require(cond, 'MAX_SUPPLY');
  }
}



library LixirRoles {
  bytes32 constant gov_role = keccak256('v1_gov_role');
  bytes32 constant delegate_role = keccak256('v1_delegate_role');
  bytes32 constant vault_role = keccak256('v1_vault_role');
  bytes32 constant strategist_role = keccak256('v1_strategist_role');
  bytes32 constant pauser_role = keccak256('v1_pauser_role');
  bytes32 constant keeper_role = keccak256('v1_keeper_role');
  bytes32 constant deployer_role = keccak256('v1_deployer_role');
  bytes32 constant strategy_role = keccak256('v1_strategy_role');
  bytes32 constant vault_implementation_role =
    keccak256('v1_vault_implementation_role');
  bytes32 constant eth_vault_implementation_role =
    keccak256('v1_eth_vault_implementation_role');
  bytes32 constant factory_role = keccak256('v1_factory_role');
  bytes32 constant fee_setter_role = keccak256('fee_setter_role');
}




library Address {
    
    function isContract(address account) internal view returns (bool) {
        
        
        

        uint256 size;
        
        assembly { size := extcodesize(account) }
        return size > 0;
    }

    
    function sendValue(address payable recipient, uint256 amount) internal {
        require(address(this).balance >= amount, "Address: insufficient balance");

        
        (bool success, ) = recipient.call{ value: amount }("");
        require(success, "Address: unable to send value, recipient may have reverted");
    }

    
    function functionCall(address target, bytes memory data) internal returns (bytes memory) {
      return functionCall(target, data, "Address: low-level call failed");
    }

    
    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {
        return functionCallWithValue(target, data, 0, errorMessage);
    }

    
    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {
        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");
    }

    
    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {
        require(address(this).balance >= value, "Address: insufficient balance for call");
        require(isContract(target), "Address: call to non-contract");

        
        (bool success, bytes memory returndata) = target.call{ value: value }(data);
        return _verifyCallResult(success, returndata, errorMessage);
    }

    
    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {
        return functionStaticCall(target, data, "Address: low-level static call failed");
    }

    
    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {
        require(isContract(target), "Address: static call to non-contract");

        
        (bool success, bytes memory returndata) = target.staticcall(data);
        return _verifyCallResult(success, returndata, errorMessage);
    }

    
    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {
        return functionDelegateCall(target, data, "Address: low-level delegate call failed");
    }

    
    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {
        require(isContract(target), "Address: delegate call to non-contract");

        
        (bool success, bytes memory returndata) = target.delegatecall(data);
        return _verifyCallResult(success, returndata, errorMessage);
    }

    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {
        if (success) {
            return returndata;
        } else {
            
            if (returndata.length > 0) {
                

                
                assembly {
                    let returndata_size := mload(returndata)
                    revert(add(32, returndata), returndata_size)
                }
            } else {
                revert(errorMessage);
            }
        }
    }
}




abstract contract Context {
    function _msgSender() internal view virtual returns (address payable) {
        return msg.sender;
    }

    function _msgData() internal view virtual returns (bytes memory) {
        this; 
        return msg.data;
    }
}




library EnumerableSet {
    
    
    
    
    
    
    
    

    struct Set {
        
        bytes32[] _values;

        
        
        mapping (bytes32 => uint256) _indexes;
    }

    
    function _add(Set storage set, bytes32 value) private returns (bool) {
        if (!_contains(set, value)) {
            set._values.push(value);
            
            
            set._indexes[value] = set._values.length;
            return true;
        } else {
            return false;
        }
    }

    
    function _remove(Set storage set, bytes32 value) private returns (bool) {
        
        uint256 valueIndex = set._indexes[value];

        if (valueIndex != 0) { 
            
            
            

            uint256 toDeleteIndex = valueIndex - 1;
            uint256 lastIndex = set._values.length - 1;

            
            

            bytes32 lastvalue = set._values[lastIndex];

            
            set._values[toDeleteIndex] = lastvalue;
            
            set._indexes[lastvalue] = toDeleteIndex + 1; 

            
            set._values.pop();

            
            delete set._indexes[value];

            return true;
        } else {
            return false;
        }
    }

    
    function _contains(Set storage set, bytes32 value) private view returns (bool) {
        return set._indexes[value] != 0;
    }

    
    function _length(Set storage set) private view returns (uint256) {
        return set._values.length;
    }

   
    function _at(Set storage set, uint256 index) private view returns (bytes32) {
        require(set._values.length > index, "EnumerableSet: index out of bounds");
        return set._values[index];
    }

    

    struct Bytes32Set {
        Set _inner;
    }

    
    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {
        return _add(set._inner, value);
    }

    
    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {
        return _remove(set._inner, value);
    }

    
    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {
        return _contains(set._inner, value);
    }

    
    function length(Bytes32Set storage set) internal view returns (uint256) {
        return _length(set._inner);
    }

   
    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {
        return _at(set._inner, index);
    }

    

    struct AddressSet {
        Set _inner;
    }

    
    function add(AddressSet storage set, address value) internal returns (bool) {
        return _add(set._inner, bytes32(uint256(uint160(value))));
    }

    
    function remove(AddressSet storage set, address value) internal returns (bool) {
        return _remove(set._inner, bytes32(uint256(uint160(value))));
    }

    
    function contains(AddressSet storage set, address value) internal view returns (bool) {
        return _contains(set._inner, bytes32(uint256(uint160(value))));
    }

    
    function length(AddressSet storage set) internal view returns (uint256) {
        return _length(set._inner);
    }

   
    function at(AddressSet storage set, uint256 index) internal view returns (address) {
        return address(uint160(uint256(_at(set._inner, index))));
    }


    

    struct UintSet {
        Set _inner;
    }

    
    function add(UintSet storage set, uint256 value) internal returns (bool) {
        return _add(set._inner, bytes32(value));
    }

    
    function remove(UintSet storage set, uint256 value) internal returns (bool) {
        return _remove(set._inner, bytes32(value));
    }

    
    function contains(UintSet storage set, uint256 value) internal view returns (bool) {
        return _contains(set._inner, bytes32(value));
    }

    
    function length(UintSet storage set) internal view returns (uint256) {
        return _length(set._inner);
    }

   
    function at(UintSet storage set, uint256 index) internal view returns (uint256) {
        return uint256(_at(set._inner, index));
    }
}




interface IERC20 {
    
    function totalSupply() external view returns (uint256);

    
    function balanceOf(address account) external view returns (uint256);

    
    function transfer(address recipient, uint256 amount) external returns (bool);

    
    function allowance(address owner, address spender) external view returns (uint256);

    
    function approve(address spender, uint256 amount) external returns (bool);

    
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);

    
    event Transfer(address indexed from, address indexed to, uint256 value);

    
    event Approval(address indexed owner, address indexed spender, uint256 value);
}




library SafeMath {
    
    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        uint256 c = a + b;
        if (c < a) return (false, 0);
        return (true, c);
    }

    
    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        if (b > a) return (false, 0);
        return (true, a - b);
    }

    
    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        
        
        
        if (a == 0) return (true, 0);
        uint256 c = a * b;
        if (c / a != b) return (false, 0);
        return (true, c);
    }

    
    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        if (b == 0) return (false, 0);
        return (true, a / b);
    }

    
    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        if (b == 0) return (false, 0);
        return (true, a % b);
    }

    
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, "SafeMath: addition overflow");
        return c;
    }

    
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a, "SafeMath: subtraction overflow");
        return a - b;
    }

    
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a == 0) return 0;
        uint256 c = a * b;
        require(c / a == b, "SafeMath: multiplication overflow");
        return c;
    }

    
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b > 0, "SafeMath: division by zero");
        return a / b;
    }

    
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b > 0, "SafeMath: modulo by zero");
        return a % b;
    }

    
    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b <= a, errorMessage);
        return a - b;
    }

    
    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b > 0, errorMessage);
        return a / b;
    }

    
    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b > 0, errorMessage);
        return a % b;
    }
}





library SafeCast {
  
  
  
  function toUint160(uint256 y) internal pure returns (uint160 z) {
    require((z = uint160(y)) == y);
  }

  
  
  
  function toInt128(int256 y) internal pure returns (int128 z) {
    require((z = int128(y)) == y);
  }

  
  
  
  function toInt256(uint256 y) internal pure returns (int256 z) {
    require(y < 2**255);
    z = int256(y);
  }

  function toUint128(uint256 y) internal pure returns (uint128 z) {
    require((z = uint128(y)) == y);
  }

  function abs(int256 y) internal pure returns (uint256 z) {
    z = y < 0 ? uint256(-y) : uint256(y);
  }
}





library FixedPoint128 {
    uint256 internal constant Q128 = 0x100000000000000000000000000000000;
}






library FixedPoint96 {
    uint8 internal constant RESOLUTION = 96;
    uint256 internal constant Q96 = 0x1000000000000000000000000;
}






library FullMath {
    
    
    
    
    
    
    function mulDiv(
        uint256 a,
        uint256 b,
        uint256 denominator
    ) internal pure returns (uint256 result) {
        
        
        
        
        
        uint256 prod0; 
        uint256 prod1; 
        assembly {
            let mm := mulmod(a, b, not(0))
            prod0 := mul(a, b)
            prod1 := sub(sub(mm, prod0), lt(mm, prod0))
        }

        
        if (prod1 == 0) {
            require(denominator > 0);
            assembly {
                result := div(prod0, denominator)
            }
            return result;
        }

        
        
        require(denominator > prod1);

        
        
        

        
        
        uint256 remainder;
        assembly {
            remainder := mulmod(a, b, denominator)
        }
        
        assembly {
            prod1 := sub(prod1, gt(remainder, prod0))
            prod0 := sub(prod0, remainder)
        }

        
        
        
        uint256 twos = -denominator & denominator;
        
        assembly {
            denominator := div(denominator, twos)
        }

        
        assembly {
            prod0 := div(prod0, twos)
        }
        
        
        
        assembly {
            twos := add(div(sub(0, twos), twos), 1)
        }
        prod0 |= prod1 * twos;

        
        
        
        
        
        uint256 inv = (3 * denominator) ^ 2;
        
        
        
        inv *= 2 - denominator * inv; 
        inv *= 2 - denominator * inv; 
        inv *= 2 - denominator * inv; 
        inv *= 2 - denominator * inv; 
        inv *= 2 - denominator * inv; 
        inv *= 2 - denominator * inv; 

        
        
        
        
        
        
        result = prod0 * inv;
        return result;
    }

    
    
    
    
    
    function mulDivRoundingUp(
        uint256 a,
        uint256 b,
        uint256 denominator
    ) internal pure returns (uint256 result) {
        result = mulDiv(a, b, denominator);
        if (mulmod(a, b, denominator) > 0) {
            require(result < type(uint256).max);
            result++;
        }
    }
}





interface IUniswapV3MintCallback {
    
    
    
    
    
    
    function uniswapV3MintCallback(
        uint256 amount0Owed,
        uint256 amount1Owed,
        bytes calldata data
    ) external;
}





interface IUniswapV3PoolActions {
    
    
    
    function initialize(uint160 sqrtPriceX96) external;

    
    
    
    
    
    
    
    
    
    
    
    function mint(
        address recipient,
        int24 tickLower,
        int24 tickUpper,
        uint128 amount,
        bytes calldata data
    ) external returns (uint256 amount0, uint256 amount1);

    
    
    
    
    
    
    
    
    
    
    
    
    function collect(
        address recipient,
        int24 tickLower,
        int24 tickUpper,
        uint128 amount0Requested,
        uint128 amount1Requested
    ) external returns (uint128 amount0, uint128 amount1);

    
    
    
    
    
    
    
    
    function burn(
        int24 tickLower,
        int24 tickUpper,
        uint128 amount
    ) external returns (uint256 amount0, uint256 amount1);

    
    
    
    
    
    
    
    
    
    
    function swap(
        address recipient,
        bool zeroForOne,
        int256 amountSpecified,
        uint160 sqrtPriceLimitX96,
        bytes calldata data
    ) external returns (int256 amount0, int256 amount1);

    
    
    
    
    
    
    
    
    function flash(
        address recipient,
        uint256 amount0,
        uint256 amount1,
        bytes calldata data
    ) external;

    
    
    
    
    function increaseObservationCardinalityNext(uint16 observationCardinalityNext) external;
}






interface IUniswapV3PoolDerivedState {
    
    
    
    
    
    
    
    
    
    
    function observe(uint32[] calldata secondsAgos)
        external
        view
        returns (int56[] memory tickCumulatives, uint160[] memory secondsPerLiquidityCumulativeX128s);

    
    
    
    
    
    
    
    
    
    function snapshotCumulativesInside(int24 tickLower, int24 tickUpper)
        external
        view
        returns (
            int56 tickCumulativeInside,
            uint160 secondsPerLiquidityInsideX128,
            uint32 secondsInside
        );
}





interface IUniswapV3PoolEvents {
    
    
    
    
    event Initialize(uint160 sqrtPriceX96, int24 tick);

    
    
    
    
    
    
    
    
    event Mint(
        address sender,
        address indexed owner,
        int24 indexed tickLower,
        int24 indexed tickUpper,
        uint128 amount,
        uint256 amount0,
        uint256 amount1
    );

    
    
    
    
    
    
    
    event Collect(
        address indexed owner,
        address recipient,
        int24 indexed tickLower,
        int24 indexed tickUpper,
        uint128 amount0,
        uint128 amount1
    );

    
    
    
    
    
    
    
    
    event Burn(
        address indexed owner,
        int24 indexed tickLower,
        int24 indexed tickUpper,
        uint128 amount,
        uint256 amount0,
        uint256 amount1
    );

    
    
    
    
    
    
    
    
    event Swap(
        address indexed sender,
        address indexed recipient,
        int256 amount0,
        int256 amount1,
        uint160 sqrtPriceX96,
        uint128 liquidity,
        int24 tick
    );

    
    
    
    
    
    
    
    event Flash(
        address indexed sender,
        address indexed recipient,
        uint256 amount0,
        uint256 amount1,
        uint256 paid0,
        uint256 paid1
    );

    
    
    
    
    
    event IncreaseObservationCardinalityNext(
        uint16 observationCardinalityNextOld,
        uint16 observationCardinalityNextNew
    );

    
    
    
    
    
    event SetFeeProtocol(uint8 feeProtocol0Old, uint8 feeProtocol1Old, uint8 feeProtocol0New, uint8 feeProtocol1New);

    
    
    
    
    
    event CollectProtocol(address indexed sender, address indexed recipient, uint128 amount0, uint128 amount1);
}





interface IUniswapV3PoolImmutables {
    
    
    function factory() external view returns (address);

    
    
    function token0() external view returns (address);

    
    
    function token1() external view returns (address);

    
    
    function fee() external view returns (uint24);

    
    
    
    
    
    function tickSpacing() external view returns (int24);

    
    
    
    
    function maxLiquidityPerTick() external view returns (uint128);
}





interface IUniswapV3PoolOwnerActions {
    
    
    
    function setFeeProtocol(uint8 feeProtocol0, uint8 feeProtocol1) external;

    
    
    
    
    
    
    function collectProtocol(
        address recipient,
        uint128 amount0Requested,
        uint128 amount1Requested
    ) external returns (uint128 amount0, uint128 amount1);
}






interface IUniswapV3PoolState {
    
    
    
    
    
    
    
    
    
    
    
    
    
    function slot0()
        external
        view
        returns (
            uint160 sqrtPriceX96,
            int24 tick,
            uint16 observationIndex,
            uint16 observationCardinality,
            uint16 observationCardinalityNext,
            uint8 feeProtocol,
            bool unlocked
        );

    
    
    function feeGrowthGlobal0X128() external view returns (uint256);

    
    
    function feeGrowthGlobal1X128() external view returns (uint256);

    
    
    function protocolFees() external view returns (uint128 token0, uint128 token1);

    
    
    function liquidity() external view returns (uint128);

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    function ticks(int24 tick)
        external
        view
        returns (
            uint128 liquidityGross,
            int128 liquidityNet,
            uint256 feeGrowthOutside0X128,
            uint256 feeGrowthOutside1X128,
            int56 tickCumulativeOutside,
            uint160 secondsPerLiquidityOutsideX128,
            uint32 secondsOutside,
            bool initialized
        );

    
    function tickBitmap(int16 wordPosition) external view returns (uint256);

    
    
    
    
    
    
    
    function positions(bytes32 key)
        external
        view
        returns (
            uint128 _liquidity,
            uint256 feeGrowthInside0LastX128,
            uint256 feeGrowthInside1LastX128,
            uint128 tokensOwed0,
            uint128 tokensOwed1
        );

    
    
    
    
    
    
    
    
    function observations(uint256 index)
        external
        view
        returns (
            uint32 blockTimestamp,
            int56 tickCumulative,
            uint160 secondsPerLiquidityCumulativeX128,
            bool initialized
        );
}





library LowGasSafeMath {
    
    
    
    
    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {
        require((z = x + y) >= x);
    }

    
    
    
    
    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {
        require((z = x - y) <= x);
    }

    
    
    
    
    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {
        require(x == 0 || (z = x * y) / x == y);
    }

    
    
    
    
    function add(int256 x, int256 y) internal pure returns (int256 z) {
        require((z = x + y) >= x == (y >= 0));
    }

    
    
    
    
    function sub(int256 x, int256 y) internal pure returns (int256 z) {
        require((z = x - y) <= x == (y >= 0));
    }
}






library TickMath {
    
    int24 internal constant MIN_TICK = -887272;
    
    int24 internal constant MAX_TICK = -MIN_TICK;

    
    uint160 internal constant MIN_SQRT_RATIO = 4295128739;
    
    uint160 internal constant MAX_SQRT_RATIO = 1461446703485210103287273052203988822378723970342;

    
    
    
    
    
    function getSqrtRatioAtTick(int24 tick) internal pure returns (uint160 sqrtPriceX96) {
        uint256 absTick = tick < 0 ? uint256(-int256(tick)) : uint256(int256(tick));
        require(absTick <= uint256(MAX_TICK), 'T');

        uint256 ratio = absTick & 0x1 != 0 ? 0xfffcb933bd6fad37aa2d162d1a594001 : 0x100000000000000000000000000000000;
        if (absTick & 0x2 != 0) ratio = (ratio * 0xfff97272373d413259a46990580e213a) >> 128;
        if (absTick & 0x4 != 0) ratio = (ratio * 0xfff2e50f5f656932ef12357cf3c7fdcc) >> 128;
        if (absTick & 0x8 != 0) ratio = (ratio * 0xffe5caca7e10e4e61c3624eaa0941cd0) >> 128;
        if (absTick & 0x10 != 0) ratio = (ratio * 0xffcb9843d60f6159c9db58835c926644) >> 128;
        if (absTick & 0x20 != 0) ratio = (ratio * 0xff973b41fa98c081472e6896dfb254c0) >> 128;
        if (absTick & 0x40 != 0) ratio = (ratio * 0xff2ea16466c96a3843ec78b326b52861) >> 128;
        if (absTick & 0x80 != 0) ratio = (ratio * 0xfe5dee046a99a2a811c461f1969c3053) >> 128;
        if (absTick & 0x100 != 0) ratio = (ratio * 0xfcbe86c7900a88aedcffc83b479aa3a4) >> 128;
        if (absTick & 0x200 != 0) ratio = (ratio * 0xf987a7253ac413176f2b074cf7815e54) >> 128;
        if (absTick & 0x400 != 0) ratio = (ratio * 0xf3392b0822b70005940c7a398e4b70f3) >> 128;
        if (absTick & 0x800 != 0) ratio = (ratio * 0xe7159475a2c29b7443b29c7fa6e889d9) >> 128;
        if (absTick & 0x1000 != 0) ratio = (ratio * 0xd097f3bdfd2022b8845ad8f792aa5825) >> 128;
        if (absTick & 0x2000 != 0) ratio = (ratio * 0xa9f746462d870fdf8a65dc1f90e061e5) >> 128;
        if (absTick & 0x4000 != 0) ratio = (ratio * 0x70d869a156d2a1b890bb3df62baf32f7) >> 128;
        if (absTick & 0x8000 != 0) ratio = (ratio * 0x31be135f97d08fd981231505542fcfa6) >> 128;
        if (absTick & 0x10000 != 0) ratio = (ratio * 0x9aa508b5b7a84e1c677de54f3e99bc9) >> 128;
        if (absTick & 0x20000 != 0) ratio = (ratio * 0x5d6af8dedb81196699c329225ee604) >> 128;
        if (absTick & 0x40000 != 0) ratio = (ratio * 0x2216e584f5fa1ea926041bedfe98) >> 128;
        if (absTick & 0x80000 != 0) ratio = (ratio * 0x48a170391f7dc42444e8fa2) >> 128;

        if (tick > 0) ratio = type(uint256).max / ratio;

        
        
        
        sqrtPriceX96 = uint160((ratio >> 32) + (ratio % (1 << 32) == 0 ? 0 : 1));
    }

    
    
    
    
    
    function getTickAtSqrtRatio(uint160 sqrtPriceX96) internal pure returns (int24 tick) {
        
        require(sqrtPriceX96 >= MIN_SQRT_RATIO && sqrtPriceX96 < MAX_SQRT_RATIO, 'R');
        uint256 ratio = uint256(sqrtPriceX96) << 32;

        uint256 r = ratio;
        uint256 msb = 0;

        assembly {
            let f := shl(7, gt(r, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF))
            msb := or(msb, f)
            r := shr(f, r)
        }
        assembly {
            let f := shl(6, gt(r, 0xFFFFFFFFFFFFFFFF))
            msb := or(msb, f)
            r := shr(f, r)
        }
        assembly {
            let f := shl(5, gt(r, 0xFFFFFFFF))
            msb := or(msb, f)
            r := shr(f, r)
        }
        assembly {
            let f := shl(4, gt(r, 0xFFFF))
            msb := or(msb, f)
            r := shr(f, r)
        }
        assembly {
            let f := shl(3, gt(r, 0xFF))
            msb := or(msb, f)
            r := shr(f, r)
        }
        assembly {
            let f := shl(2, gt(r, 0xF))
            msb := or(msb, f)
            r := shr(f, r)
        }
        assembly {
            let f := shl(1, gt(r, 0x3))
            msb := or(msb, f)
            r := shr(f, r)
        }
        assembly {
            let f := gt(r, 0x1)
            msb := or(msb, f)
        }

        if (msb >= 128) r = ratio >> (msb - 127);
        else r = ratio << (127 - msb);

        int256 log_2 = (int256(msb) - 128) << 64;

        assembly {
            r := shr(127, mul(r, r))
            let f := shr(128, r)
            log_2 := or(log_2, shl(63, f))
            r := shr(f, r)
        }
        assembly {
            r := shr(127, mul(r, r))
            let f := shr(128, r)
            log_2 := or(log_2, shl(62, f))
            r := shr(f, r)
        }
        assembly {
            r := shr(127, mul(r, r))
            let f := shr(128, r)
            log_2 := or(log_2, shl(61, f))
            r := shr(f, r)
        }
        assembly {
            r := shr(127, mul(r, r))
            let f := shr(128, r)
            log_2 := or(log_2, shl(60, f))
            r := shr(f, r)
        }
        assembly {
            r := shr(127, mul(r, r))
            let f := shr(128, r)
            log_2 := or(log_2, shl(59, f))
            r := shr(f, r)
        }
        assembly {
            r := shr(127, mul(r, r))
            let f := shr(128, r)
            log_2 := or(log_2, shl(58, f))
            r := shr(f, r)
        }
        assembly {
            r := shr(127, mul(r, r))
            let f := shr(128, r)
            log_2 := or(log_2, shl(57, f))
            r := shr(f, r)
        }
        assembly {
            r := shr(127, mul(r, r))
            let f := shr(128, r)
            log_2 := or(log_2, shl(56, f))
            r := shr(f, r)
        }
        assembly {
            r := shr(127, mul(r, r))
            let f := shr(128, r)
            log_2 := or(log_2, shl(55, f))
            r := shr(f, r)
        }
        assembly {
            r := shr(127, mul(r, r))
            let f := shr(128, r)
            log_2 := or(log_2, shl(54, f))
            r := shr(f, r)
        }
        assembly {
            r := shr(127, mul(r, r))
            let f := shr(128, r)
            log_2 := or(log_2, shl(53, f))
            r := shr(f, r)
        }
        assembly {
            r := shr(127, mul(r, r))
            let f := shr(128, r)
            log_2 := or(log_2, shl(52, f))
            r := shr(f, r)
        }
        assembly {
            r := shr(127, mul(r, r))
            let f := shr(128, r)
            log_2 := or(log_2, shl(51, f))
            r := shr(f, r)
        }
        assembly {
            r := shr(127, mul(r, r))
            let f := shr(128, r)
            log_2 := or(log_2, shl(50, f))
        }

        int256 log_sqrt10001 = log_2 * 255738958999603826347141; 

        int24 tickLow = int24((log_sqrt10001 - 3402992956809132418596140100660247210) >> 128);
        int24 tickHi = int24((log_sqrt10001 + 291339464771989622907027621153398088495) >> 128);

        tick = tickLow == tickHi ? tickLow : getSqrtRatioAtTick(tickHi) <= sqrtPriceX96 ? tickHi : tickLow;
    }
}





library UnsafeMath {
    
    
    
    
    
    function divRoundingUp(uint256 x, uint256 y) internal pure returns (uint256 z) {
        assembly {
            z := add(div(x, y), gt(mod(x, y), 0))
        }
    }
}




library PoolAddress {
    bytes32 internal constant POOL_INIT_CODE_HASH = 0xe34f199b19b2b4f47f68442619d555527d244f78a3297ea89325f843f87b8b54;

    
    struct PoolKey {
        address token0;
        address token1;
        uint24 fee;
    }

    
    
    
    
    
    function getPoolKey(
        address tokenA,
        address tokenB,
        uint24 fee
    ) internal pure returns (PoolKey memory) {
        if (tokenA > tokenB) (tokenA, tokenB) = (tokenB, tokenA);
        return PoolKey({token0: tokenA, token1: tokenB, fee: fee});
    }

    
    
    
    
    function computeAddress(address factory, PoolKey memory key) internal pure returns (address pool) {
        require(key.token0 < key.token1);
        pool = address(
            uint256(
                keccak256(
                    abi.encodePacked(
                        hex'ff',
                        factory,
                        keccak256(abi.encode(key.token0, key.token1, key.fee)),
                        POOL_INIT_CODE_HASH
                    )
                )
            )
        );
    }
}



library PositionKey {
    
    function compute(
        address owner,
        int24 tickLower,
        int24 tickUpper
    ) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(owner, tickLower, tickUpper));
    }
}



library TransferHelper {
    
    
    
    
    
    
    function safeTransferFrom(
        address token,
        address from,
        address to,
        uint256 value
    ) internal {
        (bool success, bytes memory data) =
            token.call(abi.encodeWithSelector(IERC20.transferFrom.selector, from, to, value));
        require(success && (data.length == 0 || abi.decode(data, (bool))), 'STF');
    }

    
    
    
    
    
    function safeTransfer(
        address token,
        address to,
        uint256 value
    ) internal {
        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(IERC20.transfer.selector, to, value));
        require(success && (data.length == 0 || abi.decode(data, (bool))), 'ST');
    }

    
    
    
    
    
    function safeApprove(
        address token,
        address to,
        uint256 value
    ) internal {
        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(IERC20.approve.selector, to, value));
        require(success && (data.length == 0 || abi.decode(data, (bool))), 'SA');
    }

    
    
    
    
    function safeTransferETH(address to, uint256 value) internal {
        (bool success, ) = to.call{value: value}(new bytes(0));
        require(success, 'STE');
    }
}



interface ILixirVaultToken is IERC20, IERC20Permit {}




abstract contract AccessControl is Context {
    using EnumerableSet for EnumerableSet.AddressSet;
    using Address for address;

    struct RoleData {
        EnumerableSet.AddressSet members;
        bytes32 adminRole;
    }

    mapping (bytes32 => RoleData) private _roles;

    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;

    
    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);

    
    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);

    
    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);

    
    function hasRole(bytes32 role, address account) public view returns (bool) {
        return _roles[role].members.contains(account);
    }

    
    function getRoleMemberCount(bytes32 role) public view returns (uint256) {
        return _roles[role].members.length();
    }

    
    function getRoleMember(bytes32 role, uint256 index) public view returns (address) {
        return _roles[role].members.at(index);
    }

    
    function getRoleAdmin(bytes32 role) public view returns (bytes32) {
        return _roles[role].adminRole;
    }

    
    function grantRole(bytes32 role, address account) public virtual {
        require(hasRole(_roles[role].adminRole, _msgSender()), "AccessControl: sender must be an admin to grant");

        _grantRole(role, account);
    }

    
    function revokeRole(bytes32 role, address account) public virtual {
        require(hasRole(_roles[role].adminRole, _msgSender()), "AccessControl: sender must be an admin to revoke");

        _revokeRole(role, account);
    }

    
    function renounceRole(bytes32 role, address account) public virtual {
        require(account == _msgSender(), "AccessControl: can only renounce roles for self");

        _revokeRole(role, account);
    }

    
    function _setupRole(bytes32 role, address account) internal virtual {
        _grantRole(role, account);
    }

    
    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {
        emit RoleAdminChanged(role, _roles[role].adminRole, adminRole);
        _roles[role].adminRole = adminRole;
    }

    function _grantRole(bytes32 role, address account) private {
        if (_roles[role].members.add(account)) {
            emit RoleGranted(role, account, _msgSender());
        }
    }

    function _revokeRole(bytes32 role, address account) private {
        if (_roles[role].members.remove(account)) {
            emit RoleRevoked(role, account, _msgSender());
        }
    }
}




abstract contract Initializable {

    
    bool private _initialized;

    
    bool private _initializing;

    
    modifier initializer() {
        require(_initializing || _isConstructor() || !_initialized, "Initializable: contract is already initialized");

        bool isTopLevelCall = !_initializing;
        if (isTopLevelCall) {
            _initializing = true;
            _initialized = true;
        }

        _;

        if (isTopLevelCall) {
            _initializing = false;
        }
    }

    
    function _isConstructor() private view returns (bool) {
        return !Address.isContract(address(this));
    }
}




abstract contract Pausable is Context {
    
    event Paused(address account);

    
    event Unpaused(address account);

    bool private _paused;

    
    constructor () {
        _paused = false;
    }

    
    function paused() public view virtual returns (bool) {
        return _paused;
    }

    
    modifier whenNotPaused() {
        require(!paused(), "Pausable: paused");
        _;
    }

    
    modifier whenPaused() {
        require(paused(), "Pausable: not paused");
        _;
    }

    
    function _pause() internal virtual whenNotPaused {
        _paused = true;
        emit Paused(_msgSender());
    }

    
    function _unpause() internal virtual whenPaused {
        _paused = false;
        emit Unpaused(_msgSender());
    }
}





library SqrtPriceMath {
    using LowGasSafeMath for uint256;
    using SafeCast for uint256;

    
    
    
    
    
    
    
    
    
    
    
    function getNextSqrtPriceFromAmount0RoundingUp(
        uint160 sqrtPX96,
        uint128 liquidity,
        uint256 amount,
        bool add
    ) internal pure returns (uint160) {
        
        if (amount == 0) return sqrtPX96;
        uint256 numerator1 = uint256(liquidity) << FixedPoint96.RESOLUTION;

        if (add) {
            uint256 product;
            if ((product = amount * sqrtPX96) / amount == sqrtPX96) {
                uint256 denominator = numerator1 + product;
                if (denominator >= numerator1)
                    
                    return uint160(FullMath.mulDivRoundingUp(numerator1, sqrtPX96, denominator));
            }

            return uint160(UnsafeMath.divRoundingUp(numerator1, (numerator1 / sqrtPX96).add(amount)));
        } else {
            uint256 product;
            
            
            require((product = amount * sqrtPX96) / amount == sqrtPX96 && numerator1 > product);
            uint256 denominator = numerator1 - product;
            return FullMath.mulDivRoundingUp(numerator1, sqrtPX96, denominator).toUint160();
        }
    }

    
    
    
    
    
    
    
    
    
    
    function getNextSqrtPriceFromAmount1RoundingDown(
        uint160 sqrtPX96,
        uint128 liquidity,
        uint256 amount,
        bool add
    ) internal pure returns (uint160) {
        
        
        if (add) {
            uint256 quotient =
                (
                    amount <= type(uint160).max
                        ? (amount << FixedPoint96.RESOLUTION) / liquidity
                        : FullMath.mulDiv(amount, FixedPoint96.Q96, liquidity)
                );

            return uint256(sqrtPX96).add(quotient).toUint160();
        } else {
            uint256 quotient =
                (
                    amount <= type(uint160).max
                        ? UnsafeMath.divRoundingUp(amount << FixedPoint96.RESOLUTION, liquidity)
                        : FullMath.mulDivRoundingUp(amount, FixedPoint96.Q96, liquidity)
                );

            require(sqrtPX96 > quotient);
            
            return uint160(sqrtPX96 - quotient);
        }
    }

    
    
    
    
    
    
    
    function getNextSqrtPriceFromInput(
        uint160 sqrtPX96,
        uint128 liquidity,
        uint256 amountIn,
        bool zeroForOne
    ) internal pure returns (uint160 sqrtQX96) {
        require(sqrtPX96 > 0);
        require(liquidity > 0);

        
        return
            zeroForOne
                ? getNextSqrtPriceFromAmount0RoundingUp(sqrtPX96, liquidity, amountIn, true)
                : getNextSqrtPriceFromAmount1RoundingDown(sqrtPX96, liquidity, amountIn, true);
    }

    
    
    
    
    
    
    
    function getNextSqrtPriceFromOutput(
        uint160 sqrtPX96,
        uint128 liquidity,
        uint256 amountOut,
        bool zeroForOne
    ) internal pure returns (uint160 sqrtQX96) {
        require(sqrtPX96 > 0);
        require(liquidity > 0);

        
        return
            zeroForOne
                ? getNextSqrtPriceFromAmount1RoundingDown(sqrtPX96, liquidity, amountOut, false)
                : getNextSqrtPriceFromAmount0RoundingUp(sqrtPX96, liquidity, amountOut, false);
    }

    
    
    
    
    
    
    
    
    function getAmount0Delta(
        uint160 sqrtRatioAX96,
        uint160 sqrtRatioBX96,
        uint128 liquidity,
        bool roundUp
    ) internal pure returns (uint256 amount0) {
        if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);

        uint256 numerator1 = uint256(liquidity) << FixedPoint96.RESOLUTION;
        uint256 numerator2 = sqrtRatioBX96 - sqrtRatioAX96;

        require(sqrtRatioAX96 > 0);

        return
            roundUp
                ? UnsafeMath.divRoundingUp(
                    FullMath.mulDivRoundingUp(numerator1, numerator2, sqrtRatioBX96),
                    sqrtRatioAX96
                )
                : FullMath.mulDiv(numerator1, numerator2, sqrtRatioBX96) / sqrtRatioAX96;
    }

    
    
    
    
    
    
    
    function getAmount1Delta(
        uint160 sqrtRatioAX96,
        uint160 sqrtRatioBX96,
        uint128 liquidity,
        bool roundUp
    ) internal pure returns (uint256 amount1) {
        if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);

        return
            roundUp
                ? FullMath.mulDivRoundingUp(liquidity, sqrtRatioBX96 - sqrtRatioAX96, FixedPoint96.Q96)
                : FullMath.mulDiv(liquidity, sqrtRatioBX96 - sqrtRatioAX96, FixedPoint96.Q96);
    }

    
    
    
    
    
    function getAmount0Delta(
        uint160 sqrtRatioAX96,
        uint160 sqrtRatioBX96,
        int128 liquidity
    ) internal pure returns (int256 amount0) {
        return
            liquidity < 0
                ? -getAmount0Delta(sqrtRatioAX96, sqrtRatioBX96, uint128(-liquidity), false).toInt256()
                : getAmount0Delta(sqrtRatioAX96, sqrtRatioBX96, uint128(liquidity), true).toInt256();
    }

    
    
    
    
    
    function getAmount1Delta(
        uint160 sqrtRatioAX96,
        uint160 sqrtRatioBX96,
        int128 liquidity
    ) internal pure returns (int256 amount1) {
        return
            liquidity < 0
                ? -getAmount1Delta(sqrtRatioAX96, sqrtRatioBX96, uint128(-liquidity), false).toInt256()
                : getAmount1Delta(sqrtRatioAX96, sqrtRatioBX96, uint128(liquidity), true).toInt256();
    }
}







interface IUniswapV3Pool is
    IUniswapV3PoolImmutables,
    IUniswapV3PoolState,
    IUniswapV3PoolDerivedState,
    IUniswapV3PoolActions,
    IUniswapV3PoolOwnerActions,
    IUniswapV3PoolEvents
{

}




interface IWETH9 is IERC20 {
    
    function deposit() external payable;

    
    function withdraw(uint256) external;
}





library LiquidityAmounts {
    
    
    
    function toUint128(uint256 x) private pure returns (uint128 y) {
        require((y = uint128(x)) == x);
    }

    
    
    
    
    
    
    function getLiquidityForAmount0(
        uint160 sqrtRatioAX96,
        uint160 sqrtRatioBX96,
        uint256 amount0
    ) internal pure returns (uint128 liquidity) {
        if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);
        uint256 intermediate = FullMath.mulDiv(sqrtRatioAX96, sqrtRatioBX96, FixedPoint96.Q96);
        return toUint128(FullMath.mulDiv(amount0, intermediate, sqrtRatioBX96 - sqrtRatioAX96));
    }

    
    
    
    
    
    
    function getLiquidityForAmount1(
        uint160 sqrtRatioAX96,
        uint160 sqrtRatioBX96,
        uint256 amount1
    ) internal pure returns (uint128 liquidity) {
        if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);
        return toUint128(FullMath.mulDiv(amount1, FixedPoint96.Q96, sqrtRatioBX96 - sqrtRatioAX96));
    }

    
    
    
    
    
    
    
    
    function getLiquidityForAmounts(
        uint160 sqrtRatioX96,
        uint160 sqrtRatioAX96,
        uint160 sqrtRatioBX96,
        uint256 amount0,
        uint256 amount1
    ) internal pure returns (uint128 liquidity) {
        if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);

        if (sqrtRatioX96 <= sqrtRatioAX96) {
            liquidity = getLiquidityForAmount0(sqrtRatioAX96, sqrtRatioBX96, amount0);
        } else if (sqrtRatioX96 < sqrtRatioBX96) {
            uint128 liquidity0 = getLiquidityForAmount0(sqrtRatioX96, sqrtRatioBX96, amount0);
            uint128 liquidity1 = getLiquidityForAmount1(sqrtRatioAX96, sqrtRatioX96, amount1);

            liquidity = liquidity0 < liquidity1 ? liquidity0 : liquidity1;
        } else {
            liquidity = getLiquidityForAmount1(sqrtRatioAX96, sqrtRatioBX96, amount1);
        }
    }

    
    
    
    
    
    function getAmount0ForLiquidity(
        uint160 sqrtRatioAX96,
        uint160 sqrtRatioBX96,
        uint128 liquidity
    ) internal pure returns (uint256 amount0) {
        if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);

        return
            FullMath.mulDiv(
                uint256(liquidity) << FixedPoint96.RESOLUTION,
                sqrtRatioBX96 - sqrtRatioAX96,
                sqrtRatioBX96
            ) / sqrtRatioAX96;
    }

    
    
    
    
    
    function getAmount1ForLiquidity(
        uint160 sqrtRatioAX96,
        uint160 sqrtRatioBX96,
        uint128 liquidity
    ) internal pure returns (uint256 amount1) {
        if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);

        return FullMath.mulDiv(liquidity, sqrtRatioBX96 - sqrtRatioAX96, FixedPoint96.Q96);
    }

    
    
    
    
    
    
    
    
    function getAmountsForLiquidity(
        uint160 sqrtRatioX96,
        uint160 sqrtRatioAX96,
        uint160 sqrtRatioBX96,
        uint128 liquidity
    ) internal pure returns (uint256 amount0, uint256 amount1) {
        if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);

        if (sqrtRatioX96 <= sqrtRatioAX96) {
            amount0 = getAmount0ForLiquidity(sqrtRatioAX96, sqrtRatioBX96, liquidity);
        } else if (sqrtRatioX96 < sqrtRatioBX96) {
            amount0 = getAmount0ForLiquidity(sqrtRatioX96, sqrtRatioBX96, liquidity);
            amount1 = getAmount1ForLiquidity(sqrtRatioAX96, sqrtRatioX96, liquidity);
        } else {
            amount1 = getAmount1ForLiquidity(sqrtRatioAX96, sqrtRatioBX96, liquidity);
        }
    }
}




abstract contract EIP712Initializable is Initializable {
  
  bytes32 private _HASHED_NAME;
  bytes32 private immutable _HASHED_VERSION;
  bytes32 private immutable _TYPE_HASH;

  constructor(string memory version) {
    _HASHED_VERSION = keccak256(bytes(version));
    _TYPE_HASH = keccak256(
      'EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)'
    );
  }

  

  
  function __EIP712__initialize(string memory name) internal initializer {
    _HASHED_NAME = keccak256(bytes(name));
  }

  
  function _domainSeparatorV4() internal view virtual returns (bytes32) {
    return
      keccak256(
        abi.encode(
          _TYPE_HASH,
          _HASHED_NAME,
          _HASHED_VERSION,
          _getChainId(),
          address(this)
        )
      );
  }

  
  function _hashTypedDataV4(bytes32 structHash)
    internal
    view
    virtual
    returns (bytes32)
  {
    return
      keccak256(abi.encodePacked('\x19\x01', _domainSeparatorV4(), structHash));
  }

  function _getChainId() private view returns (uint256 chainId) {
    
    
    
    this;

    
    assembly {
      chainId := chainid()
    }
  }
}



interface ILixirVault is ILixirVaultToken {
  function initialize(
    string memory name,
    string memory symbol,
    address _token0,
    address _token1,
    address _strategist,
    address _keeper,
    address _strategy
  ) external;

  function token0() external view returns (IERC20);

  function token1() external view returns (IERC20);

  function activeFee() external view returns (uint24);

  function activePool() external view returns (IUniswapV3Pool);

  function strategist() external view returns (address);

  function strategy() external view returns (address);

  function keeper() external view returns (address);

  function setKeeper(address _keeper) external;

  function setStrategist(address _strategist) external;

  function setStrategy(address _strategy) external;

  function setPerformanceFee(uint24 newFee) external;

  function emergencyExit() external;

  function unpause() external;

  function mainPosition()
    external
    view
    returns (int24 tickLower, int24 tickUpper);

  function rangePosition()
    external
    view
    returns (int24 tickLower, int24 tickUpper);

  function rebalance(
    int24 mainTickLower,
    int24 mainTickUpper,
    int24 rangeTickLower0,
    int24 rangeTickUpper0,
    int24 rangeTickLower1,
    int24 rangeTickUpper1,
    uint24 fee
  ) external;

  function withdraw(
    uint256 shares,
    uint256 amount0Min,
    uint256 amount1Min,
    address receiver,
    uint256 deadline
  ) external returns (uint256 amount0Out, uint256 amount1Out);

  function withdrawFrom(
    address withdrawer,
    uint256 shares,
    uint256 amount0Min,
    uint256 amount1Min,
    address recipient,
    uint256 deadline
  ) external returns (uint256 amount0Out, uint256 amount1Out);

  function deposit(
    uint256 amount0Desired,
    uint256 amount1Desired,
    uint256 amount0Min,
    uint256 amount1Min,
    address recipient,
    uint256 deadline
  )
    external
    returns (
      uint256 shares,
      uint256 amount0,
      uint256 amount1
    );

  function calculateTotalsFromTick(int24 virtualTick)
    external
    view
    returns (
      uint256 total0,
      uint256 total1,
      uint128 mL,
      uint128 rL
    );
}




contract LixirRegistry is AccessControl {
  address public immutable uniV3Factory;
  IWETH9 public immutable weth9;

  
  bytes32 public constant gov_role = keccak256('v1_gov_role');
  
  bytes32 public constant delegate_role = keccak256('v1_delegate_role');
  
  bytes32 public constant strategist_role = keccak256('v1_strategist_role');
  
  bytes32 public constant pauser_role = keccak256('v1_pauser_role');
  
  bytes32 public constant keeper_role = keccak256('v1_keeper_role');
  
  bytes32 public constant deployer_role = keccak256('v1_deployer_role');
  
  bytes32 public constant vault_role = keccak256('v1_vault_role');
  
  bytes32 public constant strategy_role = keccak256('v1_strategy_role');
  bytes32 public constant vault_implementation_role =
    keccak256('v1_vault_implementation_role');
  bytes32 public constant eth_vault_implementation_role =
    keccak256('v1_eth_vault_implementation_role');
  
  bytes32 public constant factory_role = keccak256('v1_factory_role');
  
  bytes32 public constant fee_setter_role = keccak256('fee_setter_role');

  address public feeTo;

  address public emergencyReturn;

  uint24 public constant PERFORMANCE_FEE_PRECISION = 1e6;

  event FeeToChanged(address indexed previousFeeTo, address indexed newFeeTo);

  event EmergencyReturnChanged(
    address indexed previousEmergencyReturn,
    address indexed newEmergencyReturn
  );

  constructor(
    address _governance,
    address _delegate,
    address _uniV3Factory,
    address _weth9
  ) {
    uniV3Factory = _uniV3Factory;
    weth9 = IWETH9(_weth9);
    _setupRole(gov_role, _governance);
    _setupRole(delegate_role, _delegate);
    
    _setRoleAdmin(gov_role, gov_role);
    _setRoleAdmin(delegate_role, gov_role);
    _setRoleAdmin(strategist_role, delegate_role);
    _setRoleAdmin(fee_setter_role, delegate_role);
    _setRoleAdmin(pauser_role, delegate_role);
    _setRoleAdmin(keeper_role, delegate_role);
    _setRoleAdmin(deployer_role, delegate_role);
    _setRoleAdmin(factory_role, delegate_role);
    _setRoleAdmin(strategy_role, delegate_role);
    _setRoleAdmin(vault_implementation_role, delegate_role);
    _setRoleAdmin(eth_vault_implementation_role, delegate_role);
    _setRoleAdmin(vault_role, factory_role);
  }

  function addRole(bytes32 role, bytes32 roleAdmin) public {
    require(isGovOrDelegate(msg.sender));
    require(getRoleAdmin(role) == bytes32(0) && getRoleMemberCount(role) == 0);
    _setRoleAdmin(role, roleAdmin);
  }

  function isGovOrDelegate(address account) public view returns (bool) {
    return hasRole(gov_role, account) || hasRole(delegate_role, account);
  }

  function setFeeTo(address _feeTo) external {
    require(isGovOrDelegate(msg.sender));
    address previous = feeTo;
    feeTo = _feeTo;
    emit FeeToChanged(previous, _feeTo);
  }

  function setEmergencyReturn(address _emergencyReturn) external {
    require(isGovOrDelegate(msg.sender));
    address previous = emergencyReturn;
    emergencyReturn = _emergencyReturn;
    emit EmergencyReturnChanged(previous, _emergencyReturn);
  }
}




abstract contract LixirBase {
  LixirRegistry public immutable registry;

  constructor(address _registry) {
    registry = LixirRegistry(_registry);
  }

  modifier onlyRole(bytes32 role) {
    require(registry.hasRole(role, msg.sender));
    _;
  }
  modifier onlyGovOrDelegate {
    require(registry.isGovOrDelegate(msg.sender));
    _;
  }
  modifier hasRole(bytes32 role, address account) {
    require(registry.hasRole(role, account));
    _;
  }
}




contract LixirVaultToken is ILixirVaultToken, EIP712Initializable {
  using SafeMath for uint256;

  

  uint8 private constant _DECIMALS = 18;

  mapping(address => uint256) private _balance;
  mapping(address => mapping(address => uint256)) _allowance;
  uint256 private _totalSupply;

  string private _name;
  string private _symbol;

  mapping(address => uint256) private _nonces;

  
  bytes32 private immutable _PERMIT_TYPE_HASH =
    keccak256(
      'Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)'
    );

  constructor() EIP712Initializable('1') {}

  

  function __LixirVaultToken__initialize(
    string memory tokenName,
    string memory tokenSymbol
  ) internal initializer {
    __EIP712__initialize(tokenName);
    _name = tokenName;
    _symbol = tokenSymbol;
  }

  

  function allowance(address owner, address spender)
    public
    view
    override
    returns (uint256)
  {
    return _allowance[owner][spender];
  }

  function balanceOf(address account) external view override returns (uint256) {
    return _balance[account];
  }

  function approve(address spender, uint256 amount)
    external
    override
    returns (bool)
  {
    _setAllowance(msg.sender, spender, amount);

    return true;
  }

  function increaseApproval(address spender, uint256 amount)
    external
    returns (bool)
  {
    _setAllowance(
      msg.sender,
      spender,
      _allowance[msg.sender][spender].add(amount)
    );

    return true;
  }

  function decreaseApproval(address spender, uint256 amount)
    external
    returns (bool)
  {
    uint256 currentAllowance = _allowance[msg.sender][spender];

    if (amount >= currentAllowance) {
      _setAllowance(msg.sender, spender, 0);
    } else {
      _setAllowance(msg.sender, spender, currentAllowance.sub(amount));
    }

    return true;
  }

  function transfer(address recipient, uint256 amount)
    external
    override
    returns (bool)
  {
    _move(msg.sender, recipient, amount);

    return true;
  }

  function transferFrom(
    address sender,
    address recipient,
    uint256 amount
  ) external override returns (bool) {
    uint256 currentAllowance = _allowance[sender][msg.sender];
    LixirErrors.require_INSUFFICIENT_ALLOWANCE(
      msg.sender == sender || currentAllowance >= amount
    );
    _move(sender, recipient, amount);

    if (msg.sender != sender && currentAllowance != uint256(-1)) {
      
      _setAllowance(sender, msg.sender, currentAllowance - amount);
    }

    return true;
  }

  function permit(
    address owner,
    address spender,
    uint256 value,
    uint256 deadline,
    uint8 v,
    bytes32 r,
    bytes32 s
  ) public virtual override {
    
    LixirErrors.require_PERMIT_EXPIRED(block.timestamp <= deadline);

    uint256 nonce = _nonces[owner];

    bytes32 structHash =
      keccak256(
        abi.encode(_PERMIT_TYPE_HASH, owner, spender, value, nonce, deadline)
      );

    bytes32 hash = _hashTypedDataV4(structHash);

    address signer = ecrecover(hash, v, r, s);
    LixirErrors.require_INVALID_SIGNATURE(signer != address(0));

    _nonces[owner] = nonce + 1;
    _setAllowance(owner, spender, value);
  }

  

  function name() public view returns (string memory) {
    return _name;
  }

  function symbol() public view returns (string memory) {
    return _symbol;
  }

  function decimals() public pure returns (uint8) {
    return _DECIMALS;
  }

  function totalSupply() public view override returns (uint256) {
    return _totalSupply;
  }

  function nonces(address owner) external view override returns (uint256) {
    return _nonces[owner];
  }

  
  function DOMAIN_SEPARATOR() external view override returns (bytes32) {
    return _domainSeparatorV4();
  }

  

  function _beforeMintCallback(address recipient, uint256 amount)
    internal
    virtual
  {}

  function _mintPoolTokens(address recipient, uint256 amount) internal {
    _beforeMintCallback(recipient, amount);
    _balance[recipient] = _balance[recipient].add(amount);
    _totalSupply = _totalSupply.add(amount);
    emit Transfer(address(0), recipient, amount);
  }

  function _burnPoolTokens(address sender, uint256 amount) internal {
    uint256 currentBalance = _balance[sender];
    LixirErrors.require_INSUFFICIENT_BALANCE(currentBalance >= amount);

    _balance[sender] = currentBalance - amount;
    _totalSupply = _totalSupply.sub(amount);
    emit Transfer(sender, address(0), amount);
  }

  function _move(
    address sender,
    address recipient,
    uint256 amount
  ) internal {
    uint256 currentBalance = _balance[sender];
    LixirErrors.require_INSUFFICIENT_BALANCE(currentBalance >= amount);
    
    
    LixirErrors.require_XFER_ZERO_ADDRESS(recipient != address(0));

    _balance[sender] = currentBalance - amount;
    _balance[recipient] = _balance[recipient].add(amount);

    emit Transfer(sender, recipient, amount);
  }

  function _setAllowance(
    address owner,
    address spender,
    uint256 amount
  ) internal {
    _allowance[owner][spender] = amount;
    emit Approval(owner, spender, amount);
  }
}



contract LixirVault is
  ILixirVault,
  LixirVaultToken,
  LixirBase,
  IUniswapV3MintCallback,
  Pausable
{
  using LowGasSafeMath for uint256;
  using SafeCast for uint256;
  using SafeCast for int256;
  using SafeCast for uint128;

  IERC20 public override token0;
  IERC20 public override token1;

  uint24 public override activeFee;
  IUniswapV3Pool public override activePool;

  address public override strategy;
  address public override strategist;
  address public override keeper;

  Position public override mainPosition;
  Position public override rangePosition;

  uint24 public performanceFee;

  uint24 immutable PERFORMANCE_FEE_PRECISION;

  address immutable uniV3Factory;

  event Deposit(
    address indexed depositor,
    address indexed recipient,
    uint256 shares,
    uint256 amount0In,
    uint256 amount1In,
    uint256 total0,
    uint256 total1
  );

  event Withdraw(
    address indexed withdrawer,
    address indexed recipient,
    uint256 shares,
    uint256 amount0Out,
    uint256 amount1Out
  );

  event Rebalance(
    int24 mainTickLower,
    int24 mainTickUpper,
    int24 rangeTickLower,
    int24 rangeTickUpper,
    uint24 newFee,
    uint256 total0,
    uint256 total1
  );

  event PerformanceFeeSet(uint24 oldFee, uint24 newFee);

  event StrategySet(address oldStrategy, address newStrategy);

  struct DepositPositionData {
    uint128 LDelta;
    int24 tickLower;
    int24 tickUpper;
  }

  enum POSITION {MAIN, RANGE}

  
  struct Position {
    
    int24 tickLower;
    int24 tickUpper;
  }

  constructor(address _registry) LixirBase(_registry) {
    PERFORMANCE_FEE_PRECISION = LixirRegistry(_registry)
      .PERFORMANCE_FEE_PRECISION();
    uniV3Factory = LixirRegistry(_registry).uniV3Factory();
  }

  
  function initialize(
    string memory name,
    string memory symbol,
    address _token0,
    address _token1,
    address _strategist,
    address _keeper,
    address _strategy
  )
    public
    virtual
    override
    hasRole(LixirRoles.strategist_role, _strategist)
    hasRole(LixirRoles.keeper_role, _keeper)
    hasRole(LixirRoles.strategy_role, _strategy)
    initializer
  {
    require(_token0 < _token1);
    __LixirVaultToken__initialize(name, symbol);
    token0 = IERC20(_token0);
    token1 = IERC20(_token1);
    strategist = _strategist;
    keeper = _keeper;
    strategy = _strategy;
  }

  modifier onlyStrategist() {
    require(msg.sender == strategist);
    _;
  }

  modifier onlyStrategy() {
    require(msg.sender == strategy);
    _;
  }

  modifier notExpired(uint256 deadline) {
    require(block.timestamp <= deadline, 'Expired');
    _;
  }

  
  function _depositStepOne(
    uint256 amount0Desired,
    uint256 amount1Desired,
    uint256 amount0Min,
    uint256 amount1Min,
    address recipient
  )
    internal
    returns (
      DepositPositionData memory mainData,
      DepositPositionData memory rangeData,
      uint256 shares,
      uint256 amount0In,
      uint256 amount1In,
      uint256 total0,
      uint256 total1
    )
  {
    uint256 _totalSupply = totalSupply();

    mainData = DepositPositionData({
      LDelta: 0,
      tickLower: mainPosition.tickLower,
      tickUpper: mainPosition.tickUpper
    });

    rangeData = DepositPositionData({
      LDelta: 0,
      tickLower: rangePosition.tickLower,
      tickUpper: rangePosition.tickUpper
    });

    if (_totalSupply == 0) {
      (shares, mainData.LDelta, amount0In, amount1In) = calculateInitialDeposit(
        amount0Desired,
        amount1Desired
      );
      total0 = amount0In;
      total1 = amount1In;
    } else {
      uint128 mL;
      uint128 rL;
      {
        (uint160 sqrtRatioX96, int24 tick) = getSqrtRatioX96AndTick();
        (total0, total1, mL, rL) = _calculateTotals(
          sqrtRatioX96,
          tick,
          mainData,
          rangeData
        );
      }

      (shares, amount0In, amount1In) = calcSharesAndAmounts(
        amount0Desired,
        amount1Desired,
        total0,
        total1,
        _totalSupply
      );
      mainData.LDelta = uint128(FullMath.mulDiv(mL, shares, _totalSupply));
      rangeData.LDelta = uint128(FullMath.mulDiv(rL, shares, _totalSupply));
    }

    LixirErrors.require_INSUFFICIENT_OUTPUT_AMOUNT(
      amount0Min <= amount0In && amount1Min <= amount1In
    );

    _mintPoolTokens(recipient, shares);
  }

  
  function _depositStepTwo(
    DepositPositionData memory mainData,
    DepositPositionData memory rangeData,
    address recipient,
    uint256 shares,
    uint256 amount0In,
    uint256 amount1In,
    uint256 total0,
    uint256 total1
  ) internal {
    uint128 mLDelta = mainData.LDelta;
    if (0 < mLDelta) {
      activePool.mint(
        address(this),
        mainData.tickLower,
        mainData.tickUpper,
        mLDelta,
        ''
      );
    }
    uint128 rLDelta = rangeData.LDelta;
    if (0 < rLDelta) {
      activePool.mint(
        address(this),
        rangeData.tickLower,
        rangeData.tickUpper,
        rLDelta,
        ''
      );
    }
    emit Deposit(
      address(msg.sender),
      address(recipient),
      shares,
      amount0In,
      amount1In,
      total0,
      total1
    );
  }

  
  function deposit(
    uint256 amount0Desired,
    uint256 amount1Desired,
    uint256 amount0Min,
    uint256 amount1Min,
    address recipient,
    uint256 deadline
  )
    external
    override
    whenNotPaused
    notExpired(deadline)
    returns (
      uint256 shares,
      uint256 amount0In,
      uint256 amount1In
    )
  {
    DepositPositionData memory mainData;
    DepositPositionData memory rangeData;
    uint256 total0;
    uint256 total1;
    (
      mainData,
      rangeData,
      shares,
      amount0In,
      amount1In,
      total0,
      total1
    ) = _depositStepOne(
      amount0Desired,
      amount1Desired,
      amount0Min,
      amount1Min,
      recipient
    );
    if (0 < amount0In) {
      
      TransferHelper.safeTransferFrom(
        address(token0),
        msg.sender,
        address(this),
        amount0In
      );
    }
    if (0 < amount1In) {
      
      TransferHelper.safeTransferFrom(
        address(token1),
        msg.sender,
        address(this),
        amount1In
      );
    }
    _depositStepTwo(
      mainData,
      rangeData,
      recipient,
      shares,
      amount0In,
      amount1In,
      total0,
      total1
    );
  }

  function _withdrawStep(
    address withdrawer,
    uint256 shares,
    uint256 amount0Min,
    uint256 amount1Min,
    address recipient
  ) internal returns (uint256 amount0Out, uint256 amount1Out) {
    uint256 _totalSupply = totalSupply();
    _burnPoolTokens(withdrawer, shares); 

    (, int24 tick, , , , , ) = activePool.slot0();

    
    
    if (shares == _totalSupply) {
      if (!paused()) {
        burnCollectPositions();
      }
      amount0Out = token0.balanceOf(address(this));
      amount1Out = token1.balanceOf(address(this));
    } else {
      {
        uint256 e0 = token0.balanceOf(address(this));
        amount0Out = e0 > 0 ? FullMath.mulDiv(e0, shares, _totalSupply) : 0;
        uint256 e1 = token1.balanceOf(address(this));
        amount1Out = e1 > 0 ? FullMath.mulDiv(e1, shares, _totalSupply) : 0;
      }
      if (!paused()) {
        {
          (uint256 ma0Out, uint256 ma1Out) =
            burnAndCollect(mainPosition, tick, shares, _totalSupply);
          amount0Out = amount0Out.add(ma0Out);
          amount1Out = amount1Out.add(ma1Out);
        }
        {
          (uint256 ra0Out, uint256 ra1Out) =
            burnAndCollect(rangePosition, tick, shares, _totalSupply);
          amount0Out = amount0Out.add(ra0Out);
          amount1Out = amount1Out.add(ra1Out);
        }
      }
    }
    LixirErrors.require_INSUFFICIENT_OUTPUT_AMOUNT(
      amount0Min <= amount0Out && amount1Min <= amount1Out
    );
    emit Withdraw(
      address(msg.sender),
      address(recipient),
      shares,
      amount0Out,
      amount1Out
    );
  }

  modifier canSpend(address withdrawer, uint256 shares) {
    uint256 currentAllowance = _allowance[withdrawer][msg.sender];
    LixirErrors.require_INSUFFICIENT_ALLOWANCE(
      msg.sender == withdrawer || currentAllowance >= shares
    );

    if (msg.sender != withdrawer && currentAllowance != uint256(-1)) {
      
      _setAllowance(withdrawer, msg.sender, currentAllowance - shares);
    }
    _;
  }

  
  function withdrawFrom(
    address withdrawer,
    uint256 shares,
    uint256 amount0Min,
    uint256 amount1Min,
    address recipient,
    uint256 deadline
  )
    external
    override
    canSpend(withdrawer, shares)
    returns (uint256 amount0Out, uint256 amount1Out)
  {
    (amount0Out, amount1Out) = _withdraw(
      withdrawer,
      shares,
      amount0Min,
      amount1Min,
      recipient,
      deadline
    );
  }

  
  function withdraw(
    uint256 shares,
    uint256 amount0Min,
    uint256 amount1Min,
    address recipient,
    uint256 deadline
  ) external override returns (uint256 amount0Out, uint256 amount1Out) {
    (amount0Out, amount1Out) = _withdraw(
      msg.sender,
      shares,
      amount0Min,
      amount1Min,
      recipient,
      deadline
    );
  }

  function _withdraw(
    address withdrawer,
    uint256 shares,
    uint256 amount0Min,
    uint256 amount1Min,
    address recipient,
    uint256 deadline
  )
    internal
    notExpired(deadline)
    returns (uint256 amount0Out, uint256 amount1Out)
  {
    (amount0Out, amount1Out) = _withdrawStep(
      withdrawer,
      shares,
      amount0Min,
      amount1Min,
      recipient
    );
    if (0 < amount0Out) {
      TransferHelper.safeTransfer(address(token0), recipient, amount0Out);
    }
    if (0 < amount1Out) {
      TransferHelper.safeTransfer(address(token1), recipient, amount1Out);
    }
  }

  function setPerformanceFee(uint24 newFee)
    external
    override
    onlyRole(LixirRoles.fee_setter_role)
  {
    require(newFee < PERFORMANCE_FEE_PRECISION);
    emit PerformanceFeeSet(performanceFee, newFee);
    performanceFee = newFee;
  }

  function _setPool(uint24 fee) internal {
    activePool = IUniswapV3Pool(
      PoolAddress.computeAddress(
        uniV3Factory,
        PoolAddress.getPoolKey(address(token0), address(token1), fee)
      )
    );
    require(Address.isContract(address(activePool)));
    activeFee = fee;
  }

  function setKeeper(address _keeper)
    external
    override
    onlyStrategist
    hasRole(LixirRoles.keeper_role, _keeper)
  {
    keeper = _keeper;
  }

  function setStrategy(address _strategy)
    external
    override
    onlyStrategist
    hasRole(LixirRoles.strategy_role, _strategy)
  {
    emit StrategySet(strategy, _strategy);
    strategy = _strategy;
  }

  function setStrategist(address _strategist)
    external
    override
    onlyGovOrDelegate
    hasRole(LixirRoles.strategist_role, _strategist)
  {
    strategist = _strategist;
  }

  function emergencyExit()
    external
    override
    whenNotPaused
    onlyRole(LixirRoles.pauser_role)
  {
    burnCollectPositions();
    _pause();
  }

  function unpause() external override whenPaused onlyGovOrDelegate {
    _unpause();
  }

  
  function rebalance(
    int24 mainTickLower,
    int24 mainTickUpper,
    int24 rangeTickLower0,
    int24 rangeTickUpper0,
    int24 rangeTickLower1,
    int24 rangeTickUpper1,
    uint24 fee
  ) external override onlyStrategy whenNotPaused {
    require(
      TickMath.MIN_TICK <= mainTickLower &&
        mainTickUpper <= TickMath.MAX_TICK &&
        mainTickLower < mainTickUpper &&
        TickMath.MIN_TICK <= rangeTickLower0 &&
        rangeTickUpper0 <= TickMath.MAX_TICK &&
        rangeTickLower0 < rangeTickUpper0 &&
        TickMath.MIN_TICK <= rangeTickLower1 &&
        rangeTickUpper1 <= TickMath.MAX_TICK &&
        rangeTickLower1 < rangeTickUpper1
    );
    
    
    if (address(activePool) != address(0)) {
      _takeFee();
      burnCollectPositions();
    }
    
    if (fee != activeFee) {
      _setPool(fee);
    }
    uint256 total0 = token0.balanceOf(address(this));
    uint256 total1 = token1.balanceOf(address(this));
    Position memory mainData = Position(mainTickLower, mainTickUpper);
    Position memory rangeData0 = Position(rangeTickLower0, rangeTickUpper0);
    Position memory rangeData1 = Position(rangeTickLower1, rangeTickUpper1);

    mintPositions(total0, total1, mainData, rangeData0, rangeData1);

    emit Rebalance(
      mainTickLower,
      mainTickUpper,
      rangePosition.tickLower,
      rangePosition.tickUpper,
      fee,
      total0,
      total1
    );
  }

  function mintPositions(
    uint256 amount0,
    uint256 amount1,
    Position memory mainData,
    Position memory rangeData0,
    Position memory rangeData1
  ) internal {
    (uint160 sqrtRatioX96, ) = getSqrtRatioX96AndTick();
    mainPosition.tickLower = mainData.tickLower;
    mainPosition.tickUpper = mainData.tickUpper;

    if (0 < amount0 || 0 < amount1) {
      uint128 mL =
        LiquidityAmounts.getLiquidityForAmounts(
          sqrtRatioX96,
          TickMath.getSqrtRatioAtTick(mainData.tickLower),
          TickMath.getSqrtRatioAtTick(mainData.tickUpper),
          amount0,
          amount1
        );

      if (0 < mL) {
        activePool.mint(
          address(this),
          mainData.tickLower,
          mainData.tickUpper,
          mL,
          ''
        );
      }
    }
    amount0 = token0.balanceOf(address(this));
    amount1 = token1.balanceOf(address(this));
    uint128 rL;
    Position memory rangeData;
    if (0 < amount0 || 0 < amount1) {
      uint128 rL0 =
        LiquidityAmounts.getLiquidityForAmount0(
          TickMath.getSqrtRatioAtTick(rangeData0.tickLower),
          TickMath.getSqrtRatioAtTick(rangeData0.tickUpper),
          amount0
        );
      uint128 rL1 =
        LiquidityAmounts.getLiquidityForAmount1(
          TickMath.getSqrtRatioAtTick(rangeData1.tickLower),
          TickMath.getSqrtRatioAtTick(rangeData1.tickUpper),
          amount1
        );

      
      if (rL1 < rL0) {
        rL = rL0;
        rangeData = rangeData0;
      } else if (0 < rL1) {
        rangeData = rangeData1;
        rL = rL1;
      }
    } else {
      rangeData = Position(0, 0);
    }

    rangePosition.tickLower = rangeData.tickLower;
    rangePosition.tickUpper = rangeData.tickUpper;

    if (0 < rL) {
      activePool.mint(
        address(this),
        rangeData.tickLower,
        rangeData.tickUpper,
        rL,
        ''
      );
    }
  }

  function _takeFee() internal {
    uint24 _perfFee = performanceFee;
    address _feeTo = registry.feeTo();
    if (_feeTo != address(0) && 0 < _perfFee) {
      (uint160 sqrtRatioX96, int24 tick) = getSqrtRatioX96AndTick();
      (
        ,
        uint256 total0,
        uint256 total1,
        uint256 tokensOwed0,
        uint256 tokensOwed1
      ) =
        calculatePositionInfo(
          tick,
          sqrtRatioX96,
          mainPosition.tickLower,
          mainPosition.tickUpper
        );
      {
        (
          ,
          uint256 total0Range,
          uint256 total1Range,
          uint256 tokensOwed0Range,
          uint256 tokensOwed1Range
        ) =
          calculatePositionInfo(
            tick,
            sqrtRatioX96,
            rangePosition.tickLower,
            rangePosition.tickUpper
          );
        total0 = total0.add(total0Range).add(token0.balanceOf(address(this)));
        total1 = total1.add(total1Range).add(token1.balanceOf(address(this)));
        tokensOwed0 = tokensOwed0.add(tokensOwed0Range);
        tokensOwed1 = tokensOwed1.add(tokensOwed1Range);
      }

      uint256 _totalSupply = totalSupply();

      uint256 price =
        FullMath.mulDiv(sqrtRatioX96, sqrtRatioX96, FixedPoint96.Q96);

      total1 = total1.add(FullMath.mulDiv(total0, price, FixedPoint96.Q96));

      if (total1 > 0) {
        tokensOwed1 = tokensOwed1.add(
          FullMath.mulDiv(tokensOwed0, price, FixedPoint96.Q96)
        );
        uint256 shares =
          FullMath.mulDiv(
            FullMath.mulDiv(tokensOwed1, _totalSupply, total1),
            performanceFee,
            PERFORMANCE_FEE_PRECISION
          );
        if (shares > 0) {
          _mintPoolTokens(_feeTo, shares);
        }
      }
    }
  }

  
  function burnCollectPositions() internal {
    uint128 mL = positionLiquidity(mainPosition);
    uint128 rL = positionLiquidity(rangePosition);

    if (0 < mL) {
      activePool.burn(mainPosition.tickLower, mainPosition.tickUpper, mL);
      activePool.collect(
        address(this),
        mainPosition.tickLower,
        mainPosition.tickUpper,
        type(uint128).max,
        type(uint128).max
      );
    }
    if (0 < rL) {
      activePool.burn(rangePosition.tickLower, rangePosition.tickUpper, rL);
      activePool.collect(
        address(this),
        rangePosition.tickLower,
        rangePosition.tickUpper,
        type(uint128).max,
        type(uint128).max
      );
    }
  }

  
  function burnAndCollect(
    Position storage position,
    int24 tick,
    uint256 shares,
    uint256 _totalSupply
  ) internal returns (uint256 amount0Out, uint256 amount1Out) {
    int24 tickLower = position.tickLower;
    int24 tickUpper = position.tickUpper;
    
    (uint128 liquidity, uint256 tokensOwed0, uint256 tokensOwed1) =
      liquidityAndTokensOwed(tick, tickLower, tickUpper);

    uint128 LDelta =
      FullMath.mulDiv(shares, liquidity, _totalSupply).toUint128();

    amount0Out = FullMath.mulDiv(tokensOwed0, shares, _totalSupply);
    amount1Out = FullMath.mulDiv(tokensOwed1, shares, _totalSupply);

    if (0 < LDelta) {
      (uint256 burnt0Out, uint256 burnt1Out) =
        activePool.burn(tickLower, tickUpper, LDelta);
      amount0Out = amount0Out.add(burnt0Out);
      amount1Out = amount1Out.add(burnt1Out);
    }
    if (0 < amount0Out || 0 < amount1Out) {
      activePool.collect(
        address(this),
        tickLower,
        tickUpper,
        amount0Out.toUint128(),
        amount1Out.toUint128()
      );
    }
  }

  

  
  function calcSharesAndAmounts(
    uint256 amount0Desired,
    uint256 amount1Desired,
    uint256 total0,
    uint256 total1,
    uint256 _totalSupply
  )
    internal
    pure
    returns (
      uint256 shares,
      uint256 amount0In,
      uint256 amount1In
    )
  {
    (bool roundedSharesFrom0, uint256 sharesFrom0) =
      0 < total0
        ? mulDivRoundingUp(amount0Desired, _totalSupply, total0)
        : (false, 0);
    (bool roundedSharesFrom1, uint256 sharesFrom1) =
      0 < total1
        ? mulDivRoundingUp(amount1Desired, _totalSupply, total1)
        : (false, 0);
    uint8 realSharesOffsetFor0 = roundedSharesFrom0 ? 1 : 2;
    uint8 realSharesOffsetFor1 = roundedSharesFrom1 ? 1 : 2;
    if (
      realSharesOffsetFor0 < sharesFrom0 &&
      (total1 == 0 || sharesFrom0 < sharesFrom1)
    ) {
      shares = sharesFrom0 - 1 - realSharesOffsetFor0;
      amount0In = amount0Desired;
      amount1In = FullMath.mulDivRoundingUp(sharesFrom0, total1, _totalSupply);
      LixirErrors.require_INSUFFICIENT_OUTPUT_AMOUNT(
        amount1In <= amount1Desired
      );
    } else {
      LixirErrors.require_INSUFFICIENT_INPUT_AMOUNT(
        realSharesOffsetFor1 < sharesFrom1
      );
      shares = sharesFrom1 - 1 - realSharesOffsetFor1;
      amount0In = FullMath.mulDivRoundingUp(sharesFrom1, total0, _totalSupply);
      LixirErrors.require_INSUFFICIENT_OUTPUT_AMOUNT(
        amount0In <= amount0Desired
      );
      amount1In = amount1Desired;
    }
  }

  function mulDivRoundingUp(
    uint256 a,
    uint256 b,
    uint256 denominator
  ) internal pure returns (bool rounded, uint256 result) {
    result = FullMath.mulDiv(a, b, denominator);
    if (mulmod(a, b, denominator) > 0) {
      require(result < type(uint256).max);
      result++;
      rounded = true;
    }
  }

  
  function calculateInitialDeposit(
    uint256 amount0Desired,
    uint256 amount1Desired
  )
    internal
    view
    returns (
      uint256 shares,
      uint128 mLDelta,
      uint256 amount0In,
      uint256 amount1In
    )
  {
    (uint160 sqrtRatioX96, int24 tick) = getSqrtRatioX96AndTick();
    uint160 sqrtRatioLowerX96 =
      TickMath.getSqrtRatioAtTick(mainPosition.tickLower);
    uint160 sqrtRatioUpperX96 =
      TickMath.getSqrtRatioAtTick(mainPosition.tickUpper);

    mLDelta = LiquidityAmounts.getLiquidityForAmounts(
      sqrtRatioX96,
      sqrtRatioLowerX96,
      sqrtRatioUpperX96,
      amount0Desired,
      amount1Desired
    );

    LixirErrors.require_INSUFFICIENT_INPUT_AMOUNT(0 < mLDelta);

    (amount0In, amount1In) = getAmountsForLiquidity(
      sqrtRatioX96,
      sqrtRatioLowerX96,
      sqrtRatioUpperX96,
      mLDelta.toInt128()
    );
    shares = mLDelta;
  }

  
  function getSqrtRatioX96AndTick()
    internal
    view
    returns (uint160 _sqrtRatioX96, int24 _tick)
  {
    (_sqrtRatioX96, _tick, , , , , ) = activePool.slot0();
  }

  
  function calculateTokensOwed(
    int24 realTick,
    int24 tickLower,
    int24 tickUpper,
    uint256 feeGrowthInside0LastX128,
    uint256 feeGrowthInside1LastX128,
    uint128 liquidity,
    uint128 tokensOwed0Last,
    uint128 tokensOwed1Last
  ) internal view returns (uint128 tokensOwed0, uint128 tokensOwed1) {
    
    (uint256 feeGrowthInside0X128, uint256 feeGrowthInside1X128) =
      getFeeGrowthInsideTicks(realTick, tickLower, tickUpper);
    tokensOwed0 = uint128(
      tokensOwed0Last +
        FullMath.mulDiv(
          feeGrowthInside0X128 - feeGrowthInside0LastX128,
          liquidity,
          FixedPoint128.Q128
        )
    );
    tokensOwed1 = uint128(
      tokensOwed1Last +
        FullMath.mulDiv(
          feeGrowthInside1X128 - feeGrowthInside1LastX128,
          liquidity,
          FixedPoint128.Q128
        )
    );
  }

  function _positionDataHelper(
    int24 realTick,
    int24 tickLower,
    int24 tickUpper
  )
    internal
    view
    returns (
      uint128 liquidity,
      uint256 feeGrowthInside0LastX128,
      uint256 feeGrowthInside1LastX128,
      uint128 tokensOwed0,
      uint128 tokensOwed1
    )
  {
    (
      liquidity,
      feeGrowthInside0LastX128,
      feeGrowthInside1LastX128,
      tokensOwed0,
      tokensOwed1
    ) = activePool.positions(
      PositionKey.compute(address(this), tickLower, tickUpper)
    );

    if (liquidity == 0) {
      return (
        0,
        feeGrowthInside0LastX128,
        feeGrowthInside1LastX128,
        tokensOwed0,
        tokensOwed1
      );
    }

    (tokensOwed0, tokensOwed1) = calculateTokensOwed(
      realTick,
      tickLower,
      tickUpper,
      feeGrowthInside0LastX128,
      feeGrowthInside1LastX128,
      liquidity,
      tokensOwed0,
      tokensOwed1
    );
  }

  
  function liquidityAndTokensOwed(
    int24 tick,
    int24 tickLower,
    int24 tickUpper
  )
    internal
    view
    returns (
      uint128 liquidity,
      uint128 tokensOwed0,
      uint128 tokensOwed1
    )
  {
    (liquidity, , , tokensOwed0, tokensOwed1) = _positionDataHelper(
      tick,
      tickLower,
      tickUpper
    );
  }

  function calculateTotals()
    external
    view
    returns (
      uint256 total0,
      uint256 total1,
      uint128 mL,
      uint128 rL
    )
  {
    (uint160 sqrtRatioX96, int24 tick) = getSqrtRatioX96AndTick();
    return
      _calculateTotals(
        sqrtRatioX96,
        tick,
        DepositPositionData(0, mainPosition.tickLower, mainPosition.tickUpper),
        DepositPositionData(0, rangePosition.tickLower, rangePosition.tickUpper)
      );
  }

  
  function calculateTotalsFromTick(int24 virtualTick)
    external
    view
    override
    returns (
      uint256 total0,
      uint256 total1,
      uint128 mL,
      uint128 rL
    )
  {
    uint160 sqrtRatioX96 = TickMath.getSqrtRatioAtTick(virtualTick);
    (, int24 realTick) = getSqrtRatioX96AndTick();
    return
      _calculateTotalsFromTick(
        sqrtRatioX96,
        realTick,
        DepositPositionData(0, mainPosition.tickLower, mainPosition.tickUpper),
        DepositPositionData(0, rangePosition.tickLower, rangePosition.tickUpper)
      );
  }

  
  function _calculateTotalsFromTick(
    uint160 sqrtRatioX96,
    int24 realTick,
    DepositPositionData memory mainData,
    DepositPositionData memory rangeData
  )
    internal
    view
    returns (
      uint256 total0,
      uint256 total1,
      uint128 mL,
      uint128 rL
    )
  {
    (mL, total0, total1) = calculatePositionTotals(
      realTick,
      sqrtRatioX96,
      mainData.tickLower,
      mainData.tickUpper
    );
    {
      uint256 rt0;
      uint256 rt1;
      (rL, rt0, rt1) = calculatePositionTotals(
        realTick,
        sqrtRatioX96,
        rangeData.tickLower,
        rangeData.tickUpper
      );
      total0 = total0.add(rt0);
      total1 = total1.add(rt1);
    }
    total0 = total0.add(token0.balanceOf(address(this)));
    total1 = total1.add(token1.balanceOf(address(this)));
  }

  function _calculateTotals(
    uint160 sqrtRatioX96,
    int24 tick,
    DepositPositionData memory mainData,
    DepositPositionData memory rangeData
  )
    internal
    view
    returns (
      uint256 total0,
      uint256 total1,
      uint128 mL,
      uint128 rL
    )
  {
    return _calculateTotalsFromTick(sqrtRatioX96, tick, mainData, rangeData);
  }

  
  function calculatePositionTotals(
    int24 realTick,
    uint160 sqrtRatioX96,
    int24 tickLower,
    int24 tickUpper
  )
    internal
    view
    returns (
      uint128 liquidity,
      uint256 total0,
      uint256 total1
    )
  {
    uint256 tokensOwed0;
    uint256 tokensOwed1;
    (
      liquidity,
      total0,
      total1,
      tokensOwed0,
      tokensOwed1
    ) = calculatePositionInfo(realTick, sqrtRatioX96, tickLower, tickUpper);
    total0 = total0.add(tokensOwed0);
    total1 = total1.add(tokensOwed1);
  }

  function calculatePositionInfo(
    int24 realTick,
    uint160 sqrtRatioX96,
    int24 tickLower,
    int24 tickUpper
  )
    internal
    view
    returns (
      uint128 liquidity,
      uint256 total0,
      uint256 total1,
      uint256 tokensOwed0,
      uint256 tokensOwed1
    )
  {
    uint256 feeGrowthInside0LastX128;
    uint256 feeGrowthInside1LastX128;
    (
      liquidity,
      feeGrowthInside0LastX128,
      feeGrowthInside1LastX128,
      tokensOwed0,
      tokensOwed1
    ) = _positionDataHelper(realTick, tickLower, tickUpper);

    uint160 sqrtPriceLower = TickMath.getSqrtRatioAtTick(tickLower);
    uint160 sqrtPriceUpper = TickMath.getSqrtRatioAtTick(tickUpper);
    (uint256 amount0, uint256 amount1) =
      getAmountsForLiquidity(
        sqrtRatioX96,
        sqrtPriceLower,
        sqrtPriceUpper,
        liquidity.toInt128()
      );
  }

  
  function getFeeGrowthInsideTicks(
    int24 tick,
    int24 tickLower,
    int24 tickUpper
  )
    internal
    view
    returns (uint256 feeGrowthInside0X128, uint256 feeGrowthInside1X128)
  {
    
    uint256 feeGrowthGlobal0X128 = activePool.feeGrowthGlobal0X128();
    uint256 feeGrowthGlobal1X128 = activePool.feeGrowthGlobal1X128();
    (
      ,
      ,
      uint256 feeGrowthOutside0X128Lower,
      uint256 feeGrowthOutside1X128Lower,
      ,
      ,
      ,

    ) = activePool.ticks(tickLower);
    (
      ,
      ,
      uint256 feeGrowthOutside0X128Upper,
      uint256 feeGrowthOutside1X128Upper,
      ,
      ,
      ,

    ) = activePool.ticks(tickUpper);

    
    uint256 feeGrowthBelow0X128;
    uint256 feeGrowthBelow1X128;
    if (tick >= tickLower) {
      feeGrowthBelow0X128 = feeGrowthOutside0X128Lower;
      feeGrowthBelow1X128 = feeGrowthOutside1X128Lower;
    } else {
      feeGrowthBelow0X128 = feeGrowthGlobal0X128 - feeGrowthOutside0X128Lower;
      feeGrowthBelow1X128 = feeGrowthGlobal1X128 - feeGrowthOutside1X128Lower;
    }

    
    uint256 feeGrowthAbove0X128;
    uint256 feeGrowthAbove1X128;
    if (tick < tickUpper) {
      feeGrowthAbove0X128 = feeGrowthOutside0X128Upper;
      feeGrowthAbove1X128 = feeGrowthOutside1X128Upper;
    } else {
      feeGrowthAbove0X128 = feeGrowthGlobal0X128 - feeGrowthOutside0X128Upper;
      feeGrowthAbove1X128 = feeGrowthGlobal1X128 - feeGrowthOutside1X128Upper;
    }

    feeGrowthInside0X128 =
      feeGrowthGlobal0X128 -
      feeGrowthBelow0X128 -
      feeGrowthAbove0X128;
    feeGrowthInside1X128 =
      feeGrowthGlobal1X128 -
      feeGrowthBelow1X128 -
      feeGrowthAbove1X128;
  }

  
  function positionLiquidity(Position storage position)
    internal
    view
    returns (uint128 _liquidity)
  {
    (_liquidity, , , , ) = activePool.positions(
      PositionKey.compute(address(this), position.tickLower, position.tickUpper)
    );
  }

  function getAmountsForLiquidity(
    uint160 sqrtPriceX96,
    uint160 sqrtPriceX96Lower,
    uint160 sqrtPriceX96Upper,
    int128 liquidityDelta
  ) internal pure returns (uint256 amount0, uint256 amount1) {
    if (sqrtPriceX96 <= sqrtPriceX96Lower) {
      
      
      amount0 = SqrtPriceMath
        .getAmount0Delta(sqrtPriceX96Lower, sqrtPriceX96Upper, liquidityDelta)
        .abs();
    } else if (sqrtPriceX96 < sqrtPriceX96Upper) {
      amount0 = SqrtPriceMath
        .getAmount0Delta(sqrtPriceX96, sqrtPriceX96Upper, liquidityDelta)
        .abs();
      amount1 = SqrtPriceMath
        .getAmount1Delta(sqrtPriceX96Lower, sqrtPriceX96, liquidityDelta)
        .abs();
    } else {
      
      
      amount1 = SqrtPriceMath
        .getAmount1Delta(sqrtPriceX96Lower, sqrtPriceX96Upper, liquidityDelta)
        .abs();
    }
  }

  
  function uniswapV3MintCallback(
    uint256 amount0Owed,
    uint256 amount1Owed,
    bytes calldata
  ) external virtual override {
    require(msg.sender == address(activePool));
    if (amount0Owed > 0) {
      TransferHelper.safeTransfer(address(token0), msg.sender, amount0Owed);
    }
    if (amount1Owed > 0) {
      TransferHelper.safeTransfer(address(token1), msg.sender, amount1Owed);
    }
  }
}