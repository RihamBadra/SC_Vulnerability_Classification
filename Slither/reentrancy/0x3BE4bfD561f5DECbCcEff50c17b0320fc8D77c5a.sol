pragma solidity 0.6.6;

abstract contract Context {

    function _msgSender() internal view virtual returns (address payable) {

        return msg.sender;

    }



    function _msgData() internal view virtual returns (bytes memory) {

        this; 

        return msg.data;

    }

}

interface IPEPE {

    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);

    function transfer(address recipient, uint256 amount) external returns (bool);

}

contract RPEPEBLU is Context {

    using SafeMath for uint256;

    

    

    address private _RarePepeV2;

    uint256 private _totalStakedAmount;

    mapping(address => uint256) private _stakedAmount;

    address[] private _stakers;



    

    event Staked(address account, uint256 amount);

    event Unstaked(address account, uint256 amount);

    

    constructor(address RarePepeV2) public {

        _RarePepeV2 = RarePepeV2;

    }

    

    

    function stake(uint256 amount) external {

        require(amount > 0, "Staking amount must be more than zero");

        

        require(IPEPE(_RarePepeV2).transferFrom(_msgSender(), address(this), amount), "It has failed to transfer tokens from staker to contract.");

        

        if (_stakedAmount[_msgSender()] == 0) {

            _stakers.push(_msgSender());

        }

        

        uint256 burnedAmount = amount.ceil(100).mul(100).div(4000);

        uint256 realStakedAmount = amount.sub(burnedAmount);

        

        _totalStakedAmount = _totalStakedAmount.add(realStakedAmount);

        

        _stakedAmount[_msgSender()] = _stakedAmount[_msgSender()].add(realStakedAmount);

        emit Staked(_msgSender(), realStakedAmount);

    }



    

    function unstake(uint256 amount) public {

        require(_stakedAmount[_msgSender()] > 0, "No running stake.");

        require(amount > 0, "Unstaking amount must be more than zero.");

        require(_stakedAmount[_msgSender()] >= amount, "Staked amount must be ustaking amount or more.");

        

        require(IPEPE(_RarePepeV2).transfer(_msgSender(), amount), "It has failed to transfer tokens from contract to staker.");

        

        _totalStakedAmount = _totalStakedAmount.sub(amount);

        

        _stakedAmount[_msgSender()] = _stakedAmount[_msgSender()].sub(amount);

        

        if (_stakedAmount[_msgSender()] == 0) {

            for (uint256 i=0; i < _stakers.length; i++) {

                if (_stakers[i] == _msgSender()) {

                    _stakers[i] = _stakers[_stakers.length.sub(1)];

                    _stakers.pop();

                    break;

                }

            }

        }

        emit Unstaked(_msgSender(), amount);

    }

    

    

    function getTotalStakedAmount() external view returns (uint256) {

        return _totalStakedAmount;

    }



    

    function getStakedAmount(address account) external view returns (uint256) {

        return _stakedAmount[account];

    }



    

    function getStakers() external view returns (address[] memory) {

        return _stakers;

    }

}

library SafeMath {

    

    function add(uint256 a, uint256 b) internal pure returns (uint256) {

        uint256 c = a + b;

        require(c >= a, "SafeMath: addition overflow");



        return c;

    }



    

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {

        return sub(a, b, "SafeMath: subtraction overflow");

    }



    

    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {

        require(b <= a, errorMessage);

        uint256 c = a - b;



        return c;

    }



    

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {

        

        

        

        if (a == 0) {

            return 0;

        }



        uint256 c = a * b;

        require(c / a == b, "SafeMath: multiplication overflow");



        return c;

    }



    

    function div(uint256 a, uint256 b) internal pure returns (uint256) {

        return div(a, b, "SafeMath: division by zero");

    }



    

    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {

        require(b > 0, errorMessage);

        uint256 c = a / b;

        



        return c;

    }



    

    function mod(uint256 a, uint256 b) internal pure returns (uint256) {

        return mod(a, b, "SafeMath: modulo by zero");

    }



    

    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {

        require(b != 0, errorMessage);

        return a % b;

    }



    function ceil(uint256 a, uint256 m) internal pure returns (uint256) {

        uint256 c = add(a, m);

        uint256 d = sub(c, 1);

        return mul(div(d,m),m);

    }

}
