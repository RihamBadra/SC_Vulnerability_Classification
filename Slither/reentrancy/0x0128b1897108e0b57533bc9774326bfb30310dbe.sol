





pragma solidity ^0.8.0;


abstract contract Context {
    function _msgSender() internal view virtual returns (address) {
        return msg.sender;
    }

    function _msgData() internal view virtual returns (bytes calldata) {
        return msg.data;
    }
}




pragma solidity ^0.8.0;



abstract contract Ownable is Context {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    
    constructor() {
        _setOwner(_msgSender());
    }

    
    function owner() public view virtual returns (address) {
        return _owner;
    }

    
    modifier onlyOwner() {
        require(owner() == _msgSender(), "Ownable: caller is not the owner");
        _;
    }

    
    function renounceOwnership() public virtual onlyOwner {
        _setOwner(address(0));
    }

    
    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), "Ownable: new owner is the zero address");
        _setOwner(newOwner);
    }

    function _setOwner(address newOwner) private {
        address oldOwner = _owner;
        _owner = newOwner;
        emit OwnershipTransferred(oldOwner, newOwner);
    }
}




pragma solidity ^0.8.0;



abstract contract Pausable is Context {
    
    event Paused(address account);

    
    event Unpaused(address account);

    bool private _paused;

    
    constructor() {
        _paused = false;
    }

    
    function paused() public view virtual returns (bool) {
        return _paused;
    }

    
    modifier whenNotPaused() {
        require(!paused(), "Pausable: paused");
        _;
    }

    
    modifier whenPaused() {
        require(paused(), "Pausable: not paused");
        _;
    }

    
    function _pause() internal virtual whenNotPaused {
        _paused = true;
        emit Paused(_msgSender());
    }

    
    function _unpause() internal virtual whenPaused {
        _paused = false;
        emit Unpaused(_msgSender());
    }
}




pragma solidity ^0.8.0;


library MerkleProof {
    
    function verify(
        bytes32[] memory proof,
        bytes32 root,
        bytes32 leaf
    ) internal pure returns (bool) {
        bytes32 computedHash = leaf;

        for (uint256 i = 0; i < proof.length; i++) {
            bytes32 proofElement = proof[i];

            if (computedHash <= proofElement) {
                
                computedHash = keccak256(abi.encodePacked(computedHash, proofElement));
            } else {
                
                computedHash = keccak256(abi.encodePacked(proofElement, computedHash));
            }
        }

        
        return computedHash == root;
    }
}




pragma solidity ^0.8.0;


interface IERC165 {
    
    function supportsInterface(bytes4 interfaceId) external view returns (bool);
}




pragma solidity ^0.8.0;



abstract contract ERC165 is IERC165 {
    
    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {
        return interfaceId == type(IERC165).interfaceId;
    }
}



pragma solidity ^0.8.9;


interface INFTExtension is IERC165 {
}

interface INFTURIExtension is INFTExtension {
    function tokenURI(uint256 tokenId) external view returns (string memory);
}




pragma solidity ^0.8.0;



interface IERC721 is IERC165 {
    
    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);

    
    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);

    
    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);

    
    function balanceOf(address owner) external view returns (uint256 balance);

    
    function ownerOf(uint256 tokenId) external view returns (address owner);

    
    function safeTransferFrom(
        address from,
        address to,
        uint256 tokenId
    ) external;

    
    function transferFrom(
        address from,
        address to,
        uint256 tokenId
    ) external;

    
    function approve(address to, uint256 tokenId) external;

    
    function getApproved(uint256 tokenId) external view returns (address operator);

    
    function setApprovalForAll(address operator, bool _approved) external;

    
    function isApprovedForAll(address owner, address operator) external view returns (bool);

    
    function safeTransferFrom(
        address from,
        address to,
        uint256 tokenId,
        bytes calldata data
    ) external;
}



pragma solidity ^0.8.9;


interface IAvatarNFT {
    function DEVELOPER() external pure returns (string memory _url);
    function DEVELOPER_ADDRESS() external pure returns (address payable _dev);

    
    function saleStarted() external view returns (bool);
    function isExtensionAllowed(address extension) external view returns (bool);

    
    function data(uint256 tokenId) external view returns (bytes32);

    
    
    function mintExternal(uint256 nTokens, address to, bytes32 data) external payable;

    
    function addExtension(address extension) external;
    function revokeExtension(address extension) external;
    function withdraw() external;
}


interface IMetaverseNFT is IAvatarNFT {
    
    
    function royaltyInfo(uint256 tokenId, uint256 salePrice) external view returns (address receiver, uint256 royaltyAmount);
    function totalSupply() external view returns (uint256);

    
    function setRoyaltyReceiver(address receiver) external;
    function setRoyaltyFee(uint256 fee) external;
}



pragma solidity ^0.8.9;




contract NFTExtension is INFTExtension, ERC165 {
    IMetaverseNFT public immutable nft;

    constructor(address _nft) {
        nft = IMetaverseNFT(_nft);
    }

    function beforeMint() internal view {
        require(nft.isExtensionAllowed(address(this)), "NFTExtension: this contract is not allowed to be used as an extension");
    }

    function supportsInterface(bytes4 interfaceId) public override(IERC165, ERC165) view returns (bool) {
        return interfaceId == type(INFTExtension).interfaceId || super.supportsInterface(interfaceId);
    }

}



pragma solidity ^0.8.9;


abstract contract SaleControl is Ownable {

    uint256 public constant __SALE_NEVER_STARTS = 2**256 - 1;

    uint256 public startTimestamp = __SALE_NEVER_STARTS;

    modifier whenSaleStarted {
        require(saleStarted(), "Sale not started yet");
        _;
    }

    function updateStartTimestamp(uint256 _startTimestamp) public onlyOwner {
        startTimestamp = _startTimestamp;
    }

    function startSale() public onlyOwner {
        startTimestamp = block.timestamp;
    }

    function stopSale() public onlyOwner {
        startTimestamp = __SALE_NEVER_STARTS;
    }

    function saleStarted() public view returns (bool) {
        return block.timestamp >= startTimestamp;
    }
}



pragma solidity ^0.8.9;






contract WhitelistMerkleTreeExtension is NFTExtension, Ownable, SaleControl {

    uint256 public price;
    uint256 public maxPerAddress;

    bytes32 public whitelistRoot;

    mapping (address => uint256) public claimedByAddress;

    constructor(address _nft, bytes32 _whitelistRoot, uint256 _price, uint256 _maxPerAddress) NFTExtension(_nft) SaleControl() {
        stopSale();

        price = _price;
        maxPerAddress = _maxPerAddress;
        whitelistRoot = _whitelistRoot;
    }

    function updateMaxPerAddress(uint256 _maxPerAddress) public onlyOwner {
        maxPerAddress = _maxPerAddress;
    }

    function updateWhitelistRoot(bytes32 _whitelistRoot) public onlyOwner {
        whitelistRoot = _whitelistRoot;
    }

    function mint(uint256 nTokens, bytes32[] memory proof) external whenSaleStarted payable {
        super.beforeMint();

        require(isWhitelisted(whitelistRoot, msg.sender, proof), "Not whitelisted");

        require(claimedByAddress[msg.sender] + nTokens <= maxPerAddress, "Cannot claim more per address");

        require(msg.value >= nTokens * price, "Not enough ETH to mint");

        nft.mintExternal{ value: msg.value }(nTokens, msg.sender, bytes32(0x0));

        claimedByAddress[msg.sender] += nTokens;
    }

    function isWhitelisted(bytes32 root, address receiver, bytes32[] memory proof) public pure returns (bool) {
        bytes32 leaf = keccak256(abi.encodePacked(receiver));

        return MerkleProof.verify(proof, root, leaf);
    }

}