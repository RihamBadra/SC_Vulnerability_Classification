


pragma solidity 0.8.10;





abstract contract ERC20 {
    
    constructor(
        ERC20 _asset,
        string memory _name,
        string memory _symbol,
        IConvexBooster _convexBooster,
        IConvexBaseRewardPool _convexRewards,
        address _rewardsDestination,
        ERC20[] memory _rewardTokens
    )
        ERC4626(_asset, _name, _symbol)
        RewardsClaimer(_rewardsDestination, _rewardTokens)
    {
        convexBooster = _convexBooster;
        convexRewards = _convexRewards;

        pid = _convexRewards.pid();

        _asset.approve(address(_convexBooster), type(uint256).max);
    }

    function updateRewardTokens() public {
        uint256 len = convexRewards.extraRewardsLength();
        require(len < 5, "exceed max rewards");
        delete rewardTokens;
        bool cvxReward;

        for (uint256 i = 0; i < len; i++) {
            rewardTokens.push(convexRewards.extraRewards(i).rewardToken());
            if (convexRewards.extraRewards(i).rewardToken() == CVX) cvxReward = true;
        }
        if (!cvxReward) rewardTokens.push(CVX);
        rewardTokens.push(convexRewards.rewardToken());
    }

    function afterDeposit(uint256 amount, uint256) internal override {
        require(convexBooster.deposit(pid, amount, true), "deposit error");
    }

    function beforeWithdraw(uint256 amount, uint256) internal override {
        require(convexRewards.withdrawAndUnwrap(amount, false), "withdraw error");
    }

    function beforeClaim() internal override {
        require(convexRewards.getReward(address(this), true), "rewards error");
    }

    
    
    function totalAssets() public view override returns (uint256) {
        return convexRewards.balanceOf(address(this));
    }
}