

pragma solidity 0.6.6;

library SafeMath {
    
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, "SafeMath: addition overflow");

        return c;
    }

    
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        return sub(a, b, "SafeMath: subtraction overflow");
    }

    
    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b <= a, errorMessage);
        uint256 c = a - b;

        return c;
    }

    
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        
        
        
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b, "SafeMath: multiplication overflow");

        return c;
    }

    
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        return div(a, b, "SafeMath: division by zero");
    }

    
    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        
        require(b > 0, errorMessage);
        uint256 c = a / b;
        

        return c;
    }

    
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        return mod(a, b, "SafeMath: modulo by zero");
    }

    
    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b != 0, errorMessage);
        return a % b;
    }
}

interface IToken {

  function totalSupply() external view returns (uint256);

  function balanceOf(address account) external view returns (uint256);

  function name() external view returns (string memory);

  function symbol() external view returns (string memory);

  function decimals() external view returns (uint8);

  function intervalLength() external returns (uint256);
  
  function owner() external view returns (address);
  
  function burn(uint256 _amount) external;
  
  function renounceMinter() external;
  
  function mint(address account, uint256 amount) external returns (bool);

  function lock(
    address recipient,
    uint256 amount,
    uint256 blocks,
    bool deposit
  ) external returns (bool);

  function approve(address spender, uint256 amount) external returns (bool);
  
  function transfer(address to, uint256 amount) external returns (bool success);

}

interface IDutchAuction {
  function auctionEnded() external view returns (bool);

  function finaliseAuction() external;
}


interface IDutchSwapFactory {
  function deployDutchAuction(
    address _token,
    uint256 _tokenSupply,
    uint256 _startDate,
    uint256 _endDate,
    address _paymentCurrency,
    uint256 _startPrice,
    uint256 _minimumPrice,
    address _wallet
  ) external returns (address dutchAuction);
}

interface IPriceOracle {

  function consult(uint256 amountIn) external view returns (uint256 amountOut);

  function update() external;
}

contract AuctionManager {
  using SafeMath for uint256;

  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

  
  uint256 constant ACCURACY = 1e4;
  
  uint256 public sellThreshold;
  
  uint256 public dilutionBound;
  
  
  
  uint256 public priceSpan;
  
  uint256 public auctionDuration;

  IToken private strudel;
  IToken private vBtc;
  IToken private gStrudel;
  IPriceOracle private btcPriceOracle;
  IPriceOracle private vBtcPriceOracle;
  IPriceOracle private strudelPriceOracle;
  IDutchSwapFactory private auctionFactory;

  IDutchAuction public currentAuction;
  mapping(address => uint256) public lockTimeForAuction;

  constructor(
    address _strudelAddr,
    address _gStrudel,
    address _vBtcAddr,
    address _btcPriceOracle,
    address _vBtcPriceOracle,
    address _strudelPriceOracle,
    address _auctionFactory
  ) public {
    strudel = IToken(_strudelAddr);
    gStrudel = IToken(_gStrudel);
    vBtc = IToken(_vBtcAddr);
    btcPriceOracle = IPriceOracle(_btcPriceOracle);
    vBtcPriceOracle = IPriceOracle(_vBtcPriceOracle);
    strudelPriceOracle = IPriceOracle(_strudelPriceOracle);
    auctionFactory = IDutchSwapFactory(_auctionFactory);
    sellThreshold = 9500; 
    dilutionBound = 70; 
    priceSpan = 2500; 
    auctionDuration = 84600; 
  }

  function min(uint256 a, uint256 b) internal pure returns (uint256) {
    return a < b ? a : b;
  }

  function _getDiff(uint256 a, uint256 b) internal pure returns (uint256) {
    if (a > b) {
      return a - b;
    }
    return b - a;
  }

  function decimals() public view returns (uint8) {
      return gStrudel.decimals();
  }

  
  function totalSupply() public view returns (uint256) {
      return gStrudel.totalSupply();
  }

  
  function balanceOf(address account) public view returns (uint256) {
      return gStrudel.balanceOf(account);
  }

  
  modifier onlyOwner() {
    require(strudel.owner() == msg.sender, "Ownable: caller is not the owner");
    _;
  }

  function updateOracles() public {
    try btcPriceOracle.update() {
      
    } catch Error(string memory) {
      
    } catch (bytes memory) {
      
    }
    try vBtcPriceOracle.update() {
      
    } catch Error(string memory) {
      
    } catch (bytes memory) {
      
    }
    try strudelPriceOracle.update() {
      
    } catch Error(string memory) {
      
    } catch (bytes memory) {
      
    }
  }

  function rotateAuctions() external {
    if (address(currentAuction) != address(0)) {
      require(currentAuction.auctionEnded(), "previous auction hasn't ended");
      try currentAuction.finaliseAuction() {
        
      } catch Error(string memory) {
        
      } catch (bytes memory) {
        
      }
      uint256 studelReserves = strudel.balanceOf(address(this));
      if (studelReserves > 0) {
        strudel.burn(studelReserves);
      }
    }

    updateOracles();

    
    uint256 btcPriceInEth = btcPriceOracle.consult(1e18);
    uint256 vBtcPriceInEth = vBtcPriceOracle.consult(1e18);
    uint256 strudelPriceInEth = strudelPriceOracle.consult(1e18);

    
    uint256 vBtcOutstandingSupply = vBtc.totalSupply();
    uint256 strudelSupply = strudel.totalSupply();
    uint256 vBtcAmount = vBtc.balanceOf(address(this));
    vBtcOutstandingSupply -= vBtcAmount;

    
    uint256 imbalance = _getDiff(btcPriceInEth, vBtcPriceInEth).mul(vBtcOutstandingSupply);

    uint256 cap = strudelSupply.mul(dilutionBound).mul(strudelPriceInEth).div(ACCURACY);
    
    imbalance = min(
      cap,
      imbalance
    );

    
    if (imbalance.div(strudelPriceInEth) < strudelSupply.mul(dilutionBound).div(52).div(ACCURACY)) {
      
      currentAuction = IDutchAuction(address(0));
      return;
    }

    
    uint256 priceRelation = btcPriceInEth.mul(ACCURACY).div(vBtcPriceInEth);
    if (priceRelation < ACCURACY.mul(ACCURACY).div(sellThreshold)) {
      
      vBtcAmount = min(vBtcAmount, imbalance.div(vBtcPriceInEth));
      
      imbalance = vBtcPriceInEth.mul(1e18).div(strudelPriceInEth);
      
      vBtc.approve(address(auctionFactory), vBtcAmount);
      currentAuction = IDutchAuction(
        auctionFactory.deployDutchAuction(
          address(vBtc),
          vBtcAmount,
          now,
          now + auctionDuration,
          address(strudel),
          imbalance.mul(ACCURACY.add(priceSpan)).div(ACCURACY), 
          imbalance.mul(ACCURACY.sub(priceSpan)).div(ACCURACY), 
          address(this)
        )
      );
    } else {

      
      vBtcAmount = strudelPriceInEth.mul(1e18).div(vBtcPriceInEth);
      
      currentAuction = IDutchAuction(
        auctionFactory.deployDutchAuction(
          address(this),
          imbalance.div(strudelPriceInEth), 
          now,
          now + auctionDuration,
          address(vBtc),
          vBtcAmount.mul(ACCURACY.add(priceSpan)).div(ACCURACY), 
          vBtcAmount.mul(ACCURACY.sub(priceSpan)).div(ACCURACY), 
          address(this)
        )
      );

      
      
      lockTimeForAuction[address(currentAuction)] = gStrudel.intervalLength().mul(52).mul(imbalance).div(cap);
    }
  }

  function setSellThreshold(uint256 _threshold) external onlyOwner {
    require(_threshold >= 6000, "threshold below 60% minimum");
    require(_threshold <= 12000, "threshold above 120% maximum");
    sellThreshold = _threshold;
  }

  function setDulutionBound(uint256 _dilutionBound) external onlyOwner {
    require(_dilutionBound <= 1000, "dilution bound above 10% max value");
    dilutionBound = _dilutionBound;
  }

  function setPriceSpan(uint256 _priceSpan) external onlyOwner {
    require(_priceSpan > 1000, "price span should have at least 10%");
    require(_priceSpan < ACCURACY, "price span larger accuracy");
    priceSpan = _priceSpan;
  }

  function setAuctionDuration(uint256 _auctionDuration) external onlyOwner {
    require(_auctionDuration >= 3600, "auctions should run at laest for 1 hour");
    require(_auctionDuration <= 604800, "auction duration should be less than week");
    auctionDuration = _auctionDuration;
  }

  function renounceMinter() external onlyOwner {
    strudel.renounceMinter();
  }

  function swipe(address tokenAddr) external onlyOwner {
    IToken token = IToken(tokenAddr);
    token.transfer(strudel.owner(), token.balanceOf(address(this)));
  }

  
  
  

  function transferFrom(address, address, uint256) public pure returns (bool) {
    return true;
  }

  function approve(address, uint256) public pure returns (bool) {
    return true;
  }

  function transfer(address to, uint256 amount) public returns (bool success) {
    
    address auction = msg.sender;
    require(lockTimeForAuction[auction] > 0, "Caller is not our auction");

    
    if (to == address(this)) return true;

    uint256 blocks = lockTimeForAuction[auction];
    strudel.mint(address(this), amount);
    strudel.approve(address(gStrudel), amount);
    gStrudel.lock(to, amount, blocks, false);
    return true;
  }
}