





pragma solidity >=0.6.0 <0.8.0;


library SafeMath {
    
    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        uint256 c = a + b;
        if (c < a) return (false, 0);
        return (true, c);
    }

    
    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        if (b > a) return (false, 0);
        return (true, a - b);
    }

    
    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        
        
        
        if (a == 0) return (true, 0);
        uint256 c = a * b;
        if (c / a != b) return (false, 0);
        return (true, c);
    }

    
    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        if (b == 0) return (false, 0);
        return (true, a / b);
    }

    
    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        if (b == 0) return (false, 0);
        return (true, a % b);
    }

    
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, "SafeMath: addition overflow");
        return c;
    }

    
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a, "SafeMath: subtraction overflow");
        return a - b;
    }

    
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a == 0) return 0;
        uint256 c = a * b;
        require(c / a == b, "SafeMath: multiplication overflow");
        return c;
    }

    
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b > 0, "SafeMath: division by zero");
        return a / b;
    }

    
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b > 0, "SafeMath: modulo by zero");
        return a % b;
    }

    
    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b <= a, errorMessage);
        return a - b;
    }

    
    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b > 0, errorMessage);
        return a / b;
    }

    
    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b > 0, errorMessage);
        return a % b;
    }
}




pragma solidity >=0.6.0 <0.8.0;


interface IERC20 {
    
    function totalSupply() external view returns (uint256);

    
    function balanceOf(address account) external view returns (uint256);

    
    function transfer(address recipient, uint256 amount) external returns (bool);

    
    function allowance(address owner, address spender) external view returns (uint256);

    
    function approve(address spender, uint256 amount) external returns (bool);

    
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);

    
    event Transfer(address indexed from, address indexed to, uint256 value);

    
    event Approval(address indexed owner, address indexed spender, uint256 value);
}




pragma solidity >=0.6.0 <0.8.0;


abstract contract Context {
    function _msgSender() internal view virtual returns (address payable) {
        return msg.sender;
    }

    function _msgData() internal view virtual returns (bytes memory) {
        this; 
        return msg.data;
    }
}




pragma solidity >=0.6.0 <0.8.0;


abstract contract Ownable is Context {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    
    constructor () internal {
        address msgSender = _msgSender();
        _owner = msgSender;
        emit OwnershipTransferred(address(0), msgSender);
    }

    
    function owner() public view virtual returns (address) {
        return _owner;
    }

    
    modifier onlyOwner() {
        require(owner() == _msgSender(), "Ownable: caller is not the owner");
        _;
    }

    
    function renounceOwnership() public virtual onlyOwner {
        emit OwnershipTransferred(_owner, address(0));
        _owner = address(0);
    }

    
    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), "Ownable: new owner is the zero address");
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }
}



pragma solidity 0.7.5;


abstract contract Owned is Ownable {
    constructor(address _owner) {
        transferOwnership(_owner);
    }
}



pragma solidity 0.7.5;















contract LinearVesting is Owned {
    using SafeMath for uint256;

    IERC20 public umbToken;

    uint256 public totalVestingAmount;
    uint256 public paidSoFar;

    mapping(address => Reward) public rewards;

    struct Reward {
        uint256 total;
        uint256 duration;
        uint256 paid;
        uint256 startTime;
    }

    

    constructor(address _owner, address _token) Owned(_owner) {
        require(_token != address(0x0), "empty _token");

        umbToken = IERC20(_token);
    }

    

    function balanceOf(address _address) public view returns (uint256) {
        Reward memory reward = rewards[_address];

        if (block.timestamp <= reward.startTime) {
            return 0;
        }

        if (block.timestamp >= reward.startTime.add(reward.duration)) {
            return reward.total - reward.paid;
        }

        return reward.total.mul(block.timestamp - reward.startTime).div(reward.duration) - reward.paid;
    }

    

    function claim() external {
        _claim(msg.sender);
    }

    function claimFor(address[] calldata _participants) external {
        for (uint i = 0; i < _participants.length; i++) {
            _claim(_participants[i]);
        }
    }

    

    function _claim(address _participant) internal {
        uint256 balance = balanceOf(_participant);
        require(balance != 0, "you have no tokens to claim");

        
        rewards[_participant].paid += balance;
        paidSoFar += balance;

        
        require(umbToken.transfer(_participant, balance), "umb.transfer failed");

        emit LogClaimed(_participant, balance);
    }

    function addRewards(
        address[] calldata _participants,
        uint256[] calldata _rewards,
        uint256[] calldata _durations,
        uint256[] calldata _startTimes
    )
    external onlyOwner {
        require(_participants.length != 0, "there is no _participants");
        require(_participants.length == _rewards.length, "_participants count must match _rewards count");
        require(_participants.length == _durations.length, "_participants count must match _durations count");
        require(_participants.length == _startTimes.length, "_participants count must match _startTimes count");

        uint256 sum = totalVestingAmount;

        for (uint256 i = 0; i < _participants.length; i++) {
            require(_participants[i] != address(0x0), "empty participant");
            require(_durations[i] != 0, "empty duration");
            require(_durations[i] < 5 * 365 days, "duration too long");
            require(_rewards[i] != 0, "empty reward");
            require(_startTimes[i] != 0, "empty startTime");

            uint256 total = rewards[_participants[i]].total;

            if (total < _rewards[i]) {
                
                sum = sum.add(_rewards[i] - total);
            } else {
                
                sum = sum.sub(total - _rewards[i]);
            }

            if (total != 0) {
                require(rewards[_participants[i]].startTime == _startTimes[i], "can't change start time");
                require(_rewards[i] >= balanceOf(_participants[i]), "can't take what's already done");
            }

            rewards[_participants[i]] = Reward(_rewards[i], _durations[i], 0, _startTimes[i]);
        }

        emit LogSetup(totalVestingAmount, sum);
        totalVestingAmount = sum;
    }

    

    event LogSetup(uint256 prevSum, uint256 newSum);
    event LogClaimed(address indexed recipient, uint256 amount);
}