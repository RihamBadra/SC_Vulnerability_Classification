





pragma solidity ^0.8.9;


interface IERC20 {
    
    function totalSupply() external returns (uint256 totalSupply);

    
    function balanceOf(address account) external returns (uint256);

    
    function transfer(address recipient, uint256 amount) external returns (bool);

    
    function allowance(address owner, address spender) external returns (uint256);

    
    function approve(address spender, uint256 amount) external returns (bool);

    
    function transferFrom(
        address sender,
        address recipient,
        uint256 amount
    ) external returns (bool);

    
    event Transfer(address indexed from, address indexed to, uint256 value);

    
    event Approval(address indexed owner, address indexed spender, uint256 value);

    
    event Burn(address indexed owner, uint256 value);


}





pragma solidity ^0.8.9;



interface IERC20Metadata is IERC20 {
    
    function name() external view returns (string memory);

    
    function symbol() external view returns (string memory);

    
    function decimals() external view returns (uint8);
}





pragma solidity ^0.8.9;




contract ERC20 is IERC20, IERC20Metadata {
    mapping(address => uint256) private _balances;

    mapping(address => mapping(address => uint256)) private _allowances;

    uint256 private _totalSupply;

    string private _name;
    string private _symbol;
    uint8 private _decimals;

    
    constructor(
        string memory name_, 
        string memory symbol_, 
        uint8 decimals_, 
        uint256 supply_, 
        address mintAddress_
        ) {
            _name = name_;
            _symbol = symbol_;
            _decimals = decimals_;
            _balances[mintAddress_] = supply_;
            _totalSupply = supply_;
    }

    
    function name() public view virtual override returns (string memory name_) {
        return _name;
    }

    
    function symbol() public view virtual override returns (string memory symbol_) {
        return _symbol;
    }

    
    function decimals() public view virtual override returns (uint8 decimals_) {
        return _decimals;
    }

    
    function totalSupply() public view virtual override returns (uint256 totalSupply_) {
        return _totalSupply;
    }

    
    function balanceOf(address account) public view virtual override returns (uint256 balance_) {
        return _balances[account];
    }

    
    function transfer(address _recipient, uint256 _amount) public virtual override returns (bool _success) {
        _transfer(msg.sender, _recipient, _amount);
        return true;
    }

    
    function allowance(address owner, address spender) public view virtual override returns (uint256 allowance_) {
        return _allowances[owner][spender];
    }

    
    function approve(address spender, uint256 amount) public virtual override returns (bool result_) {
        _approve(msg.sender, spender, amount);
        return true;
    }

    
    function transferFrom(
        address sender,
        address recipient,
        uint256 amount
    ) public virtual override returns (bool result) {
        _transfer(sender, recipient, amount);

        uint256 currentAllowance = _allowances[sender][msg.sender];
        require(currentAllowance >= amount, "ERC20:transferFrom: transfer amount exceeds allowance");
        _approve(sender, msg.sender, currentAllowance - amount);

        return true;
    }

    
    function _transfer(
        address sender,
        address recipient,
        uint256 amount
    ) internal virtual {
        require(sender != address(0), "ERC20:_transfer: cannot transfer from the zero address");
        uint256 senderBalance = _balances[sender];
        require(senderBalance >= amount, "ERC20:_tranfser: amount exceeds balance");

        if (recipient == address(0)) {
            _balances[sender] = senderBalance - amount;
            _totalSupply = _totalSupply - amount;
            emit Burn(sender, amount);
            emit Transfer(sender, address(0), amount);

        } else if (recipient != address(0)) {

            _balances[sender] = senderBalance - amount;
            _balances[recipient] += amount;
            emit Transfer(sender, recipient, amount);
        }
    }

    
    function _approve(
        address owner,
        address spender,
        uint256 amount
    ) internal virtual {
        require(spender != address(0), "ERC20:_approve: cannot approve to the zero address");

        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }

}



pragma solidity ^0.8.9;

contract HoffCoinConfig is ERC20 {

    string internal constant TOKEN_SYMBOL = "HOFF";
    string internal constant TOKEN_NAME = "Hoff Coin";
    uint8 internal constant TOKEN_DECIMALS = 8;
    uint256 internal constant TOTAL_SUPPLY = 1000000000000000000;
    address internal constant INITIAL_MINT_ADDRESS = 0x8B1382A3BeC340cA91571293616f18c476949463;

    constructor(
        string memory _name,
        string memory _symbol,
        uint8 _decimals,
        uint256 _totalSupply,
        address _mintAddress)
        ERC20(
            _name,
            _symbol,
            _decimals,
            _totalSupply,
            _mintAddress)
    {}
}


contract HoffCoin is HoffCoinConfig {

    constructor()
        HoffCoinConfig(
            TOKEN_SYMBOL,
            TOKEN_NAME,
            TOKEN_DECIMALS,
            TOTAL_SUPPLY,
            INITIAL_MINT_ADDRESS
        )
    {}
}