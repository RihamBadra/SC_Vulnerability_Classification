pragma solidity 0.5.17;

contract IFactRegistry {

    

    function isValid(bytes32 fact)

        external view

        returns(bool);

}

contract IMerkleVerifier {

    uint256 constant internal MAX_N_MERKLE_VERIFIER_QUERIES =  128;



    function verify(

        uint256 channelPtr,

        uint256 queuePtr,

        bytes32 root,

        uint256 n)

        internal view

        returns (bytes32 hash);

}

contract IQueryableFactRegistry is IFactRegistry {



    

    function hasRegisteredFact()

        external view

        returns(bool);



}

contract IStarkVerifier {



    function verifyProof(

        uint256[] memory proofParams,

        uint256[] memory proof,

        uint256[] memory publicInput

    )

        internal;

}

contract MemoryMap {

    

    uint256 constant internal CHANNEL_STATE_SIZE = 3;

    uint256 constant internal MAX_N_QUERIES =  48;

    uint256 constant internal FRI_QUEUE_SIZE = MAX_N_QUERIES;



    uint256 constant internal MAX_SUPPORTED_MAX_FRI_STEP = 4;



    uint256 constant internal MM_EVAL_DOMAIN_SIZE =                          0x0;

    uint256 constant internal MM_BLOW_UP_FACTOR =                            0x1;

    uint256 constant internal MM_LOG_EVAL_DOMAIN_SIZE =                      0x2;

    uint256 constant internal MM_PROOF_OF_WORK_BITS =                        0x3;

    uint256 constant internal MM_EVAL_DOMAIN_GENERATOR =                     0x4;

    uint256 constant internal MM_PUBLIC_INPUT_PTR =                          0x5;

    uint256 constant internal MM_TRACE_COMMITMENT =                          0x6;

    uint256 constant internal MM_OODS_COMMITMENT =                           0x7;

    uint256 constant internal MM_N_UNIQUE_QUERIES =                          0x8;

    uint256 constant internal MM_CHANNEL =                                   0x9; 

    uint256 constant internal MM_MERKLE_QUEUE =                              0xc; 

    uint256 constant internal MM_FRI_QUEUE =                                0x6c; 

    uint256 constant internal MM_FRI_QUERIES_DELIMITER =                    0xfc;

    uint256 constant internal MM_FRI_CTX =                                  0xfd; 

    uint256 constant internal MM_FRI_STEPS_PTR =                           0x125;

    uint256 constant internal MM_FRI_EVAL_POINTS =                         0x126; 

    uint256 constant internal MM_FRI_COMMITMENTS =                         0x130; 

    uint256 constant internal MM_FRI_LAST_LAYER_DEG_BOUND =                0x13a;

    uint256 constant internal MM_FRI_LAST_LAYER_PTR =                      0x13b;

    uint256 constant internal MM_CONSTRAINT_POLY_ARGS_START =              0x13c;

    uint256 constant internal MM_PERIODIC_COLUMN__CONSTS0_A =              0x13c;

    uint256 constant internal MM_PERIODIC_COLUMN__CONSTS1_A =              0x13d;

    uint256 constant internal MM_PERIODIC_COLUMN__CONSTS2_A =              0x13e;

    uint256 constant internal MM_PERIODIC_COLUMN__CONSTS3_A =              0x13f;

    uint256 constant internal MM_PERIODIC_COLUMN__CONSTS4_A =              0x140;

    uint256 constant internal MM_PERIODIC_COLUMN__CONSTS5_A =              0x141;

    uint256 constant internal MM_PERIODIC_COLUMN__CONSTS6_A =              0x142;

    uint256 constant internal MM_PERIODIC_COLUMN__CONSTS7_A =              0x143;

    uint256 constant internal MM_PERIODIC_COLUMN__CONSTS8_A =              0x144;

    uint256 constant internal MM_PERIODIC_COLUMN__CONSTS9_A =              0x145;

    uint256 constant internal MM_PERIODIC_COLUMN__CONSTS0_B =              0x146;

    uint256 constant internal MM_PERIODIC_COLUMN__CONSTS1_B =              0x147;

    uint256 constant internal MM_PERIODIC_COLUMN__CONSTS2_B =              0x148;

    uint256 constant internal MM_PERIODIC_COLUMN__CONSTS3_B =              0x149;

    uint256 constant internal MM_PERIODIC_COLUMN__CONSTS4_B =              0x14a;

    uint256 constant internal MM_PERIODIC_COLUMN__CONSTS5_B =              0x14b;

    uint256 constant internal MM_PERIODIC_COLUMN__CONSTS6_B =              0x14c;

    uint256 constant internal MM_PERIODIC_COLUMN__CONSTS7_B =              0x14d;

    uint256 constant internal MM_PERIODIC_COLUMN__CONSTS8_B =              0x14e;

    uint256 constant internal MM_PERIODIC_COLUMN__CONSTS9_B =              0x14f;

    uint256 constant internal MM_MAT00 =                                   0x150;

    uint256 constant internal MM_MAT01 =                                   0x151;

    uint256 constant internal MM_TRACE_LENGTH =                            0x152;

    uint256 constant internal MM_MAT10 =                                   0x153;

    uint256 constant internal MM_MAT11 =                                   0x154;

    uint256 constant internal MM_INPUT_VALUE_A =                           0x155;

    uint256 constant internal MM_OUTPUT_VALUE_A =                          0x156;

    uint256 constant internal MM_INPUT_VALUE_B =                           0x157;

    uint256 constant internal MM_OUTPUT_VALUE_B =                          0x158;

    uint256 constant internal MM_TRACE_GENERATOR =                         0x159;

    uint256 constant internal MM_OODS_POINT =                              0x15a;

    uint256 constant internal MM_COEFFICIENTS =                            0x15b; 

    uint256 constant internal MM_OODS_VALUES =                             0x18b; 

    uint256 constant internal MM_CONSTRAINT_POLY_ARGS_END =                0x1a1;

    uint256 constant internal MM_COMPOSITION_OODS_VALUES =                 0x1a1; 

    uint256 constant internal MM_OODS_EVAL_POINTS =                        0x1a3; 

    uint256 constant internal MM_OODS_COEFFICIENTS =                       0x1d3; 

    uint256 constant internal MM_TRACE_QUERY_RESPONSES =                   0x1eb; 

    uint256 constant internal MM_COMPOSITION_QUERY_RESPONSES =             0x5ab; 

    uint256 constant internal MM_CONTEXT_SIZE =                            0x60b;

}

contract MerkleVerifier is IMerkleVerifier {



    function getHashMask() internal pure returns(uint256) {

        

        return 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF000000000000000000000000;

    }



    

    function verify(

        uint256 channelPtr,

        uint256 queuePtr,

        bytes32 root,

        uint256 n)

        internal view

        returns (bytes32 hash)

    {

        uint256 lhashMask = getHashMask();

        require(n <= MAX_N_MERKLE_VERIFIER_QUERIES, "TOO_MANY_MERKLE_QUERIES");



        assembly {

            

            

            let hashesPtr := add(queuePtr, 0x20)

            let queueSize := mul(n, 0x40)

            let slotSize := 0x40



            

            let rdIdx := 0

            let wrIdx := 0 



            

            let index := mload(add(rdIdx, queuePtr))

            let proofPtr := mload(channelPtr)



            

            for { } gt(index, 1) { } {

                let siblingIndex := xor(index, 1)

                

                let sibblingOffset := mulmod(siblingIndex, 0x20, 0x40)



                

                

                

                mstore(xor(0x20, sibblingOffset), mload(add(rdIdx, hashesPtr)))

                rdIdx := addmod(rdIdx, slotSize, queueSize)



                

                

                

                let newHashPtr := proofPtr

                proofPtr := add(proofPtr, 0x20)



                

                

                

                

                mstore(add(wrIdx, queuePtr), div(index, 2))



                

                index := mload(add(rdIdx, queuePtr))

                if eq(index, siblingIndex) {

                    

                    newHashPtr := add(rdIdx, hashesPtr)

                    

                    proofPtr := sub(proofPtr, 0x20)

                    rdIdx := addmod(rdIdx, slotSize, queueSize)



                    

                    

                    

                    

                    index := mload(add(rdIdx, queuePtr))

                }



                mstore(sibblingOffset, mload(newHashPtr))



                

                mstore(add(wrIdx, hashesPtr), and(lhashMask, keccak256(0x00, 0x40)))

                wrIdx := addmod(wrIdx, slotSize, queueSize)

            }

            hash := mload(add(rdIdx, hashesPtr))



            

            mstore(channelPtr, proofPtr)

        }

        

        require(hash == root, "INVALID_MERKLE_PROOF");

    }

}

contract MimcConstraintPoly {

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    



    function() external {

        uint256 res;

        assembly {

            let PRIME := 0x30000003000000010000000000000001

            

            calldatacopy(0x0, 0x0,  0xca0)

            let point :=  mload(0x3c0)

            

            mstore(0xca0, mul(2,  mload(0x2c0)))

            function expmod(base, exponent, modulus) -> res {

              let p :=  0x10c0

              mstore(p, 0x20)                 

              mstore(add(p, 0x20), 0x20)      

              mstore(add(p, 0x40), 0x20)      

              mstore(add(p, 0x60), base)      

              mstore(add(p, 0x80), exponent)  

              mstore(add(p, 0xa0), modulus)   

              

              if iszero(staticcall(not(0), 0x05, p, 0xc0, p, 0x20)) {

                revert(0, 0)

              }

              res := mload(p)

            }



            function degreeAdjustment(compositionPolynomialDegreeBound, constraintDegree, numeratorDegree,

                                       denominatorDegree) -> res {

              res := sub(sub(compositionPolynomialDegreeBound, 1),

                         sub(add(constraintDegree, numeratorDegree), denominatorDegree))

            }



            {

              



              

              mstore(0xf40, expmod(point,  mload(0x2c0), PRIME))



              

              mstore(0xf60, expmod( mload(0x3a0), sub( mload(0x2c0), 1), PRIME))



            }



            {

              



              

              

              mstore(0xfe0,

                     addmod( mload(0xf40), sub(PRIME, 1), PRIME))



              

              

              mstore(0x1000,

                     addmod(point, sub(PRIME, 1), PRIME))



              

              

              mstore(0x1020,

                     addmod(point, sub(PRIME,  mload(0xf60)), PRIME))



            }



            {

              



              

              

              

              

              

              let productsToValuesOffset := 0x60

              let prod := 1

              let partialProductEndPtr := 0xfe0

              for { let partialProductPtr := 0xf80 }

                  lt(partialProductPtr, partialProductEndPtr)

                  { partialProductPtr := add(partialProductPtr, 0x20) } {

                  mstore(partialProductPtr, prod)

                  

                  prod := mulmod(prod,

                                 mload(add(partialProductPtr, productsToValuesOffset)),

                                 PRIME)

              }



              let firstPartialProductPtr := 0xf80

              

              let prodInv := expmod(prod, sub(PRIME, 2), PRIME)



              if eq(prodInv, 0) {

                  

                  

                  

                  

                  



                  mstore(0, 0x08c379a000000000000000000000000000000000000000000000000000000000)

                  mstore(0x4, 0x20)

                  mstore(0x24, 0x1e)

                  mstore(0x44, "Batch inverse product is zero.")

                  revert(0, 0x62)

              }



              

              

              

              let currentPartialProductPtr := 0xfe0

              for { } gt(currentPartialProductPtr, firstPartialProductPtr) { } {

                  currentPartialProductPtr := sub(currentPartialProductPtr, 0x20)

                  

                  mstore(currentPartialProductPtr,

                         mulmod(mload(currentPartialProductPtr), prodInv, PRIME))

                  

                  prodInv := mulmod(prodInv,

                                     mload(add(currentPartialProductPtr, productsToValuesOffset)),

                                     PRIME)

              }

            }



            {

              



              

              

              mstore(0x1040,

                     addmod(point, sub(PRIME,  mload(0xf60)), PRIME))



              

              

              mstore(0x1060,

                     expmod(point, degreeAdjustment( mload(0xca0), mul(3, sub( mload(0x2c0), 1)), 0,  mload(0x2c0)), PRIME))



              

              

              mstore(0x1080,

                     expmod(point, degreeAdjustment( mload(0xca0), mul(3, sub( mload(0x2c0), 1)), 1,  mload(0x2c0)), PRIME))



              

              

              mstore(0x10a0,

                     expmod(point, degreeAdjustment( mload(0xca0), sub( mload(0x2c0), 1), 0, 1), PRIME))



            }



            {

              



              {

              

              let val := addmod(

                mulmod(

                   mload(0x280),

                  addmod(

                     mload(0x9e0),

                    sub(PRIME,  mload(0x0)),

                    PRIME),

                  PRIME),

                mulmod(

                   mload(0x2a0),

                  addmod(

                     mload(0xb40),

                    sub(PRIME,  mload(0x140)),

                    PRIME),

                  PRIME),

                PRIME)

              mstore(0xcc0, val)

              }





              {

              

              let val := addmod(

                mulmod(

                   mload(0x2e0),

                  addmod(

                     mload(0x9e0),

                    sub(PRIME,  mload(0x0)),

                    PRIME),

                  PRIME),

                mulmod(

                   mload(0x300),

                  addmod(

                     mload(0xb40),

                    sub(PRIME,  mload(0x140)),

                    PRIME),

                  PRIME),

                PRIME)

              mstore(0xce0, val)

              }





              {

              

              let val := addmod(

                mulmod(

                   mload(0x280),

                  addmod(

                     mload(0xa20),

                    sub(PRIME,  mload(0x20)),

                    PRIME),

                  PRIME),

                mulmod(

                   mload(0x2a0),

                  addmod(

                     mload(0xb80),

                    sub(PRIME,  mload(0x160)),

                    PRIME),

                  PRIME),

                PRIME)

              mstore(0xd00, val)

              }





              {

              

              let val := addmod(

                mulmod(

                   mload(0x2e0),

                  addmod(

                     mload(0xa20),

                    sub(PRIME,  mload(0x20)),

                    PRIME),

                  PRIME),

                mulmod(

                   mload(0x300),

                  addmod(

                     mload(0xb80),

                    sub(PRIME,  mload(0x160)),

                    PRIME),

                  PRIME),

                PRIME)

              mstore(0xd20, val)

              }





              {

              

              let val := addmod(

                mulmod(

                   mload(0x280),

                  addmod(

                     mload(0xa40),

                    sub(PRIME,  mload(0x40)),

                    PRIME),

                  PRIME),

                mulmod(

                   mload(0x2a0),

                  addmod(

                     mload(0xba0),

                    sub(PRIME,  mload(0x180)),

                    PRIME),

                  PRIME),

                PRIME)

              mstore(0xd40, val)

              }





              {

              

              let val := addmod(

                mulmod(

                   mload(0x2e0),

                  addmod(

                     mload(0xa40),

                    sub(PRIME,  mload(0x40)),

                    PRIME),

                  PRIME),

                mulmod(

                   mload(0x300),

                  addmod(

                     mload(0xba0),

                    sub(PRIME,  mload(0x180)),

                    PRIME),

                  PRIME),

                PRIME)

              mstore(0xd60, val)

              }





              {

              

              let val := addmod(

                mulmod(

                   mload(0x280),

                  addmod(

                     mload(0xa60),

                    sub(PRIME,  mload(0x60)),

                    PRIME),

                  PRIME),

                mulmod(

                   mload(0x2a0),

                  addmod(

                     mload(0xbc0),

                    sub(PRIME,  mload(0x1a0)),

                    PRIME),

                  PRIME),

                PRIME)

              mstore(0xd80, val)

              }





              {

              

              let val := addmod(

                mulmod(

                   mload(0x2e0),

                  addmod(

                     mload(0xa60),

                    sub(PRIME,  mload(0x60)),

                    PRIME),

                  PRIME),

                mulmod(

                   mload(0x300),

                  addmod(

                     mload(0xbc0),

                    sub(PRIME,  mload(0x1a0)),

                    PRIME),

                  PRIME),

                PRIME)

              mstore(0xda0, val)

              }





              {

              

              let val := addmod(

                mulmod(

                   mload(0x280),

                  addmod(

                     mload(0xa80),

                    sub(PRIME,  mload(0x80)),

                    PRIME),

                  PRIME),

                mulmod(

                   mload(0x2a0),

                  addmod(

                     mload(0xbe0),

                    sub(PRIME,  mload(0x1c0)),

                    PRIME),

                  PRIME),

                PRIME)

              mstore(0xdc0, val)

              }





              {

              

              let val := addmod(

                mulmod(

                   mload(0x2e0),

                  addmod(

                     mload(0xa80),

                    sub(PRIME,  mload(0x80)),

                    PRIME),

                  PRIME),

                mulmod(

                   mload(0x300),

                  addmod(

                     mload(0xbe0),

                    sub(PRIME,  mload(0x1c0)),

                    PRIME),

                  PRIME),

                PRIME)

              mstore(0xde0, val)

              }





              {

              

              let val := addmod(

                mulmod(

                   mload(0x280),

                  addmod(

                     mload(0xaa0),

                    sub(PRIME,  mload(0xa0)),

                    PRIME),

                  PRIME),

                mulmod(

                   mload(0x2a0),

                  addmod(

                     mload(0xc00),

                    sub(PRIME,  mload(0x1e0)),

                    PRIME),

                  PRIME),

                PRIME)

              mstore(0xe00, val)

              }





              {

              

              let val := addmod(

                mulmod(

                   mload(0x2e0),

                  addmod(

                     mload(0xaa0),

                    sub(PRIME,  mload(0xa0)),

                    PRIME),

                  PRIME),

                mulmod(

                   mload(0x300),

                  addmod(

                     mload(0xc00),

                    sub(PRIME,  mload(0x1e0)),

                    PRIME),

                  PRIME),

                PRIME)

              mstore(0xe20, val)

              }





              {

              

              let val := addmod(

                mulmod(

                   mload(0x280),

                  addmod(

                     mload(0xac0),

                    sub(PRIME,  mload(0xc0)),

                    PRIME),

                  PRIME),

                mulmod(

                   mload(0x2a0),

                  addmod(

                     mload(0xc20),

                    sub(PRIME,  mload(0x200)),

                    PRIME),

                  PRIME),

                PRIME)

              mstore(0xe40, val)

              }





              {

              

              let val := addmod(

                mulmod(

                   mload(0x2e0),

                  addmod(

                     mload(0xac0),

                    sub(PRIME,  mload(0xc0)),

                    PRIME),

                  PRIME),

                mulmod(

                   mload(0x300),

                  addmod(

                     mload(0xc20),

                    sub(PRIME,  mload(0x200)),

                    PRIME),

                  PRIME),

                PRIME)

              mstore(0xe60, val)

              }





              {

              

              let val := addmod(

                mulmod(

                   mload(0x280),

                  addmod(

                     mload(0xae0),

                    sub(PRIME,  mload(0xe0)),

                    PRIME),

                  PRIME),

                mulmod(

                   mload(0x2a0),

                  addmod(

                     mload(0xc40),

                    sub(PRIME,  mload(0x220)),

                    PRIME),

                  PRIME),

                PRIME)

              mstore(0xe80, val)

              }





              {

              

              let val := addmod(

                mulmod(

                   mload(0x2e0),

                  addmod(

                     mload(0xae0),

                    sub(PRIME,  mload(0xe0)),

                    PRIME),

                  PRIME),

                mulmod(

                   mload(0x300),

                  addmod(

                     mload(0xc40),

                    sub(PRIME,  mload(0x220)),

                    PRIME),

                  PRIME),

                PRIME)

              mstore(0xea0, val)

              }





              {

              

              let val := addmod(

                mulmod(

                   mload(0x280),

                  addmod(

                     mload(0xb00),

                    sub(PRIME,  mload(0x100)),

                    PRIME),

                  PRIME),

                mulmod(

                   mload(0x2a0),

                  addmod(

                     mload(0xc60),

                    sub(PRIME,  mload(0x240)),

                    PRIME),

                  PRIME),

                PRIME)

              mstore(0xec0, val)

              }





              {

              

              let val := addmod(

                mulmod(

                   mload(0x2e0),

                  addmod(

                     mload(0xb00),

                    sub(PRIME,  mload(0x100)),

                    PRIME),

                  PRIME),

                mulmod(

                   mload(0x300),

                  addmod(

                     mload(0xc60),

                    sub(PRIME,  mload(0x240)),

                    PRIME),

                  PRIME),

                PRIME)

              mstore(0xee0, val)

              }





              {

              

              let val := addmod(

                mulmod(

                   mload(0x280),

                  addmod(

                     mload(0xb20),

                    sub(PRIME,  mload(0x120)),

                    PRIME),

                  PRIME),

                mulmod(

                   mload(0x2a0),

                  addmod(

                     mload(0xc80),

                    sub(PRIME,  mload(0x260)),

                    PRIME),

                  PRIME),

                PRIME)

              mstore(0xf00, val)

              }





              {

              

              let val := addmod(

                mulmod(

                   mload(0x2e0),

                  addmod(

                     mload(0xb20),

                    sub(PRIME,  mload(0x120)),

                    PRIME),

                  PRIME),

                mulmod(

                   mload(0x300),

                  addmod(

                     mload(0xc80),

                    sub(PRIME,  mload(0x260)),

                    PRIME),

                  PRIME),

                PRIME)

              mstore(0xf20, val)

              }





              {

              

              let val := addmod(

                 mload(0xa20),

                sub(

                  PRIME,

                  mulmod(

                    mulmod(

                       mload(0xcc0),

                       mload(0xcc0),

                      PRIME),

                     mload(0xcc0),

                    PRIME)),

                PRIME)



              

              

              

              

              

              val := mulmod(val, mload(0xf80), PRIME)



              

              res := addmod(res,

                            mulmod(val,

                                   add( mload(0x3e0),

                                       mulmod( mload(0x400),

                                              mload(0x1060),

                      PRIME)),

                      PRIME),

                      PRIME)

              }



              {

              

              let val := addmod(

                 mload(0xb80),

                sub(

                  PRIME,

                  mulmod(

                    mulmod(

                       mload(0xce0),

                       mload(0xce0),

                      PRIME),

                     mload(0xce0),

                    PRIME)),

                PRIME)



              

              

              

              

              

              val := mulmod(val, mload(0xf80), PRIME)



              

              res := addmod(res,

                            mulmod(val,

                                   add( mload(0x420),

                                       mulmod( mload(0x440),

                                              mload(0x1060),

                      PRIME)),

                      PRIME),

                      PRIME)

              }



              {

              

              let val := addmod(

                 mload(0xa40),

                sub(

                  PRIME,

                  mulmod(

                    mulmod(

                       mload(0xd00),

                       mload(0xd00),

                      PRIME),

                     mload(0xd00),

                    PRIME)),

                PRIME)



              

              

              

              

              

              val := mulmod(val, mload(0xf80), PRIME)



              

              res := addmod(res,

                            mulmod(val,

                                   add( mload(0x460),

                                       mulmod( mload(0x480),

                                              mload(0x1060),

                      PRIME)),

                      PRIME),

                      PRIME)

              }



              {

              

              let val := addmod(

                 mload(0xba0),

                sub(

                  PRIME,

                  mulmod(

                    mulmod(

                       mload(0xd20),

                       mload(0xd20),

                      PRIME),

                     mload(0xd20),

                    PRIME)),

                PRIME)



              

              

              

              

              

              val := mulmod(val, mload(0xf80), PRIME)



              

              res := addmod(res,

                            mulmod(val,

                                   add( mload(0x4a0),

                                       mulmod( mload(0x4c0),

                                              mload(0x1060),

                      PRIME)),

                      PRIME),

                      PRIME)

              }



              {

              

              let val := addmod(

                 mload(0xa60),

                sub(

                  PRIME,

                  mulmod(

                    mulmod(

                       mload(0xd40),

                       mload(0xd40),

                      PRIME),

                     mload(0xd40),

                    PRIME)),

                PRIME)



              

              

              

              

              

              val := mulmod(val, mload(0xf80), PRIME)



              

              res := addmod(res,

                            mulmod(val,

                                   add( mload(0x4e0),

                                       mulmod( mload(0x500),

                                              mload(0x1060),

                      PRIME)),

                      PRIME),

                      PRIME)

              }



              {

              

              let val := addmod(

                 mload(0xbc0),

                sub(

                  PRIME,

                  mulmod(

                    mulmod(

                       mload(0xd60),

                       mload(0xd60),

                      PRIME),

                     mload(0xd60),

                    PRIME)),

                PRIME)



              

              

              

              

              

              val := mulmod(val, mload(0xf80), PRIME)



              

              res := addmod(res,

                            mulmod(val,

                                   add( mload(0x520),

                                       mulmod( mload(0x540),

                                              mload(0x1060),

                      PRIME)),

                      PRIME),

                      PRIME)

              }



              {

              

              let val := addmod(

                 mload(0xa80),

                sub(

                  PRIME,

                  mulmod(

                    mulmod(

                       mload(0xd80),

                       mload(0xd80),

                      PRIME),

                     mload(0xd80),

                    PRIME)),

                PRIME)



              

              

              

              

              

              val := mulmod(val, mload(0xf80), PRIME)



              

              res := addmod(res,

                            mulmod(val,

                                   add( mload(0x560),

                                       mulmod( mload(0x580),

                                              mload(0x1060),

                      PRIME)),

                      PRIME),

                      PRIME)

              }



              {

              

              let val := addmod(

                 mload(0xbe0),

                sub(

                  PRIME,

                  mulmod(

                    mulmod(

                       mload(0xda0),

                       mload(0xda0),

                      PRIME),

                     mload(0xda0),

                    PRIME)),

                PRIME)



              

              

              

              

              

              val := mulmod(val, mload(0xf80), PRIME)



              

              res := addmod(res,

                            mulmod(val,

                                   add( mload(0x5a0),

                                       mulmod( mload(0x5c0),

                                              mload(0x1060),

                      PRIME)),

                      PRIME),

                      PRIME)

              }



              {

              

              let val := addmod(

                 mload(0xaa0),

                sub(

                  PRIME,

                  mulmod(

                    mulmod(

                       mload(0xdc0),

                       mload(0xdc0),

                      PRIME),

                     mload(0xdc0),

                    PRIME)),

                PRIME)



              

              

              

              

              

              val := mulmod(val, mload(0xf80), PRIME)



              

              res := addmod(res,

                            mulmod(val,

                                   add( mload(0x5e0),

                                       mulmod( mload(0x600),

                                              mload(0x1060),

                      PRIME)),

                      PRIME),

                      PRIME)

              }



              {

              

              let val := addmod(

                 mload(0xc00),

                sub(

                  PRIME,

                  mulmod(

                    mulmod(

                       mload(0xde0),

                       mload(0xde0),

                      PRIME),

                     mload(0xde0),

                    PRIME)),

                PRIME)



              

              

              

              

              

              val := mulmod(val, mload(0xf80), PRIME)



              

              res := addmod(res,

                            mulmod(val,

                                   add( mload(0x620),

                                       mulmod( mload(0x640),

                                              mload(0x1060),

                      PRIME)),

                      PRIME),

                      PRIME)

              }



              {

              

              let val := addmod(

                 mload(0xac0),

                sub(

                  PRIME,

                  mulmod(

                    mulmod(

                       mload(0xe00),

                       mload(0xe00),

                      PRIME),

                     mload(0xe00),

                    PRIME)),

                PRIME)



              

              

              

              

              

              val := mulmod(val, mload(0xf80), PRIME)



              

              res := addmod(res,

                            mulmod(val,

                                   add( mload(0x660),

                                       mulmod( mload(0x680),

                                              mload(0x1060),

                      PRIME)),

                      PRIME),

                      PRIME)

              }



              {

              

              let val := addmod(

                 mload(0xc20),

                sub(

                  PRIME,

                  mulmod(

                    mulmod(

                       mload(0xe20),

                       mload(0xe20),

                      PRIME),

                     mload(0xe20),

                    PRIME)),

                PRIME)



              

              

              

              

              

              val := mulmod(val, mload(0xf80), PRIME)



              

              res := addmod(res,

                            mulmod(val,

                                   add( mload(0x6a0),

                                       mulmod( mload(0x6c0),

                                              mload(0x1060),

                      PRIME)),

                      PRIME),

                      PRIME)

              }



              {

              

              let val := addmod(

                 mload(0xae0),

                sub(

                  PRIME,

                  mulmod(

                    mulmod(

                       mload(0xe40),

                       mload(0xe40),

                      PRIME),

                     mload(0xe40),

                    PRIME)),

                PRIME)



              

              

              

              

              

              val := mulmod(val, mload(0xf80), PRIME)



              

              res := addmod(res,

                            mulmod(val,

                                   add( mload(0x6e0),

                                       mulmod( mload(0x700),

                                              mload(0x1060),

                      PRIME)),

                      PRIME),

                      PRIME)

              }



              {

              

              let val := addmod(

                 mload(0xc40),

                sub(

                  PRIME,

                  mulmod(

                    mulmod(

                       mload(0xe60),

                       mload(0xe60),

                      PRIME),

                     mload(0xe60),

                    PRIME)),

                PRIME)



              

              

              

              

              

              val := mulmod(val, mload(0xf80), PRIME)



              

              res := addmod(res,

                            mulmod(val,

                                   add( mload(0x720),

                                       mulmod( mload(0x740),

                                              mload(0x1060),

                      PRIME)),

                      PRIME),

                      PRIME)

              }



              {

              

              let val := addmod(

                 mload(0xb00),

                sub(

                  PRIME,

                  mulmod(

                    mulmod(

                       mload(0xe80),

                       mload(0xe80),

                      PRIME),

                     mload(0xe80),

                    PRIME)),

                PRIME)



              

              

              

              

              

              val := mulmod(val, mload(0xf80), PRIME)



              

              res := addmod(res,

                            mulmod(val,

                                   add( mload(0x760),

                                       mulmod( mload(0x780),

                                              mload(0x1060),

                      PRIME)),

                      PRIME),

                      PRIME)

              }



              {

              

              let val := addmod(

                 mload(0xc60),

                sub(

                  PRIME,

                  mulmod(

                    mulmod(

                       mload(0xea0),

                       mload(0xea0),

                      PRIME),

                     mload(0xea0),

                    PRIME)),

                PRIME)



              

              

              

              

              

              val := mulmod(val, mload(0xf80), PRIME)



              

              res := addmod(res,

                            mulmod(val,

                                   add( mload(0x7a0),

                                       mulmod( mload(0x7c0),

                                              mload(0x1060),

                      PRIME)),

                      PRIME),

                      PRIME)

              }



              {

              

              let val := addmod(

                 mload(0xb20),

                sub(

                  PRIME,

                  mulmod(

                    mulmod(

                       mload(0xec0),

                       mload(0xec0),

                      PRIME),

                     mload(0xec0),

                    PRIME)),

                PRIME)



              

              

              

              

              

              val := mulmod(val, mload(0xf80), PRIME)



              

              res := addmod(res,

                            mulmod(val,

                                   add( mload(0x7e0),

                                       mulmod( mload(0x800),

                                              mload(0x1060),

                      PRIME)),

                      PRIME),

                      PRIME)

              }



              {

              

              let val := addmod(

                 mload(0xc80),

                sub(

                  PRIME,

                  mulmod(

                    mulmod(

                       mload(0xee0),

                       mload(0xee0),

                      PRIME),

                     mload(0xee0),

                    PRIME)),

                PRIME)



              

              

              

              

              

              val := mulmod(val, mload(0xf80), PRIME)



              

              res := addmod(res,

                            mulmod(val,

                                   add( mload(0x820),

                                       mulmod( mload(0x840),

                                              mload(0x1060),

                      PRIME)),

                      PRIME),

                      PRIME)

              }



              {

              

              let val := addmod(

                 mload(0xa00),

                sub(

                  PRIME,

                  mulmod(

                    mulmod(

                       mload(0xf00),

                       mload(0xf00),

                      PRIME),

                     mload(0xf00),

                    PRIME)),

                PRIME)



              

              

              val := mulmod(val, mload(0x1040), PRIME)

              

              

              val := mulmod(val, mload(0xf80), PRIME)



              

              res := addmod(res,

                            mulmod(val,

                                   add( mload(0x860),

                                       mulmod( mload(0x880),

                                              mload(0x1080),

                      PRIME)),

                      PRIME),

                      PRIME)

              }



              {

              

              let val := addmod(

                 mload(0xb60),

                sub(

                  PRIME,

                  mulmod(

                    mulmod(

                       mload(0xf20),

                       mload(0xf20),

                      PRIME),

                     mload(0xf20),

                    PRIME)),

                PRIME)



              

              

              val := mulmod(val, mload(0x1040), PRIME)

              

              

              val := mulmod(val, mload(0xf80), PRIME)



              

              res := addmod(res,

                            mulmod(val,

                                   add( mload(0x8a0),

                                       mulmod( mload(0x8c0),

                                              mload(0x1080),

                      PRIME)),

                      PRIME),

                      PRIME)

              }



              {

              

              let val := addmod( mload(0x9e0), sub(PRIME,  mload(0x320)), PRIME)



              

              

              

              

              

              val := mulmod(val, mload(0xfa0), PRIME)



              

              res := addmod(res,

                            mulmod(val,

                                   add( mload(0x8e0),

                                       mulmod( mload(0x900),

                                              mload(0x10a0),

                      PRIME)),

                      PRIME),

                      PRIME)

              }



              {

              

              let val := addmod( mload(0xb20), sub(PRIME,  mload(0x340)), PRIME)



              

              

              

              

              

              val := mulmod(val, mload(0xfc0), PRIME)



              

              res := addmod(res,

                            mulmod(val,

                                   add( mload(0x920),

                                       mulmod( mload(0x940),

                                              mload(0x10a0),

                      PRIME)),

                      PRIME),

                      PRIME)

              }



              {

              

              let val := addmod( mload(0xb40), sub(PRIME,  mload(0x360)), PRIME)



              

              

              

              

              

              val := mulmod(val, mload(0xfa0), PRIME)



              

              res := addmod(res,

                            mulmod(val,

                                   add( mload(0x960),

                                       mulmod( mload(0x980),

                                              mload(0x10a0),

                      PRIME)),

                      PRIME),

                      PRIME)

              }



              {

              

              let val := addmod( mload(0xc80), sub(PRIME,  mload(0x380)), PRIME)



              

              

              

              

              

              val := mulmod(val, mload(0xfc0), PRIME)



              

              res := addmod(res,

                            mulmod(val,

                                   add( mload(0x9a0),

                                       mulmod( mload(0x9c0),

                                              mload(0x10a0),

                      PRIME)),

                      PRIME),

                      PRIME)

              }



            mstore(0, res)

            return(0, 0x20)

            }

        }

    }

}

contract PeriodicColumnContract {

    function compute(uint256 x) external pure returns (uint256 result);

}

contract PrimeFieldElement6 {

    uint256 internal constant K_MODULUS = 0x30000003000000010000000000000001;

    uint256 internal constant K_MODULUS_MASK = 0x3fffffffffffffffffffffffffffffff;

    uint256 internal constant K_MONTGOMERY_R = 0xffffff0fffffffafffffffffffffffb;

    uint256 internal constant K_MONTGOMERY_R_INV = 0x9000001200000096000000600000001;

    uint256 internal constant GENERATOR_VAL = 3;

    uint256 internal constant ONE_VAL = 1;

    uint256 internal constant GEN1024_VAL = 0x2361be682e1cc2d366e86e194024739f;



    function fromMontgomery(uint256 val) internal pure returns (uint256 res) {

        

        assembly {

            res := mulmod(

                val,

                0x9000001200000096000000600000001,

                0x30000003000000010000000000000001

            )

        }

        return res;

    }



    function fromMontgomeryBytes(bytes32 bs) internal pure returns (uint256) {

        

        

        uint256 res = uint256(bs);

        return fromMontgomery(res);

    }



    function toMontgomeryInt(uint256 val) internal pure returns (uint256 res) {

        

        assembly {

            res := mulmod(

                val,

                0xffffff0fffffffafffffffffffffffb,

                0x30000003000000010000000000000001

            )

        }

        return res;

    }



    function fmul(uint256 a, uint256 b) internal pure returns (uint256 res) {

        

        assembly {

            res := mulmod(a, b, 0x30000003000000010000000000000001)

        }

        return res;

    }



    function fadd(uint256 a, uint256 b) internal pure returns (uint256 res) {

        

        assembly {

            res := addmod(a, b, 0x30000003000000010000000000000001)

        }

        return res;

    }



    function fsub(uint256 a, uint256 b) internal pure returns (uint256 res) {

        

        assembly {

            res := addmod(

                a,

                sub(0x30000003000000010000000000000001, b),

                0x30000003000000010000000000000001

            )

        }

        return res;

    }



    function fpow(uint256 val, uint256 exp) internal returns (uint256) {

        return expmod(val, exp, K_MODULUS);

    }



    function expmod(uint256 base, uint256 exponent, uint256 modulus)

        internal

        returns (uint256 res)

    {

        assembly {

            let p := mload(0x40)

            mstore(p, 0x20) 

            mstore(add(p, 0x20), 0x20) 

            mstore(add(p, 0x40), 0x20) 

            mstore(add(p, 0x60), base) 

            mstore(add(p, 0x80), exponent) 

            mstore(add(p, 0xa0), modulus) 

            

            if iszero(call(not(0), 0x05, 0, p, 0xc0, p, 0x20)) {

                revert(0, 0)

            }

            res := mload(p)

        }

    }



    function inverse(uint256 val) internal returns (uint256) {

        return expmod(val, K_MODULUS - 2, K_MODULUS);

    }

}

contract Prng is PrimeFieldElement6 {

    function storePrng(uint256 statePtr, bytes32 digest, uint256 counter)

        internal pure {

        assembly {

            mstore(statePtr, digest)

            mstore(add(statePtr, 0x20), counter)

        }

    }



    function loadPrng(uint256 statePtr)

        internal pure

        returns (bytes32, uint256) {

        bytes32 digest;

        uint256 counter;



        assembly {

            digest := mload(statePtr)

            counter := mload(add(statePtr, 0x20))

        }



        return (digest, counter);

    }



    function initPrng(uint256 prngPtr, bytes32 publicInputHash)

        internal pure

    {

        storePrng(prngPtr,  publicInputHash, 0);

    }



    

    function getRandomBytesInner(bytes32 digest, uint256 counter)

        internal pure

        returns (bytes32, uint256, bytes32)

    {

        

        bytes32 randomBytes = keccak256(abi.encodePacked(digest, counter));



        return (digest, counter + 1, randomBytes);

    }



    

    function getRandomBytes(uint256 prngPtr)

        internal pure

        returns (bytes32 randomBytes)

    {

        bytes32 digest;

        uint256 counter;

        (digest, counter) = loadPrng(prngPtr);



        

        (digest, counter, randomBytes) = getRandomBytesInner(digest, counter);



        storePrng(prngPtr, digest, counter);

        return randomBytes;

    }



    function mixSeedWithBytes(uint256 prngPtr, bytes memory dataBytes)

        internal pure

    {

        bytes32 digest;



        assembly {

            digest := mload(prngPtr)

        }

        initPrng(prngPtr, keccak256(abi.encodePacked(digest, dataBytes)));

    }



    function getPrngDigest(uint256 prngPtr)

        internal pure

        returns (bytes32 digest)

    {

        assembly {

           digest := mload(prngPtr)

        }

    }

}

contract PublicInputOffsets {

    

    uint256 internal constant OFFSET_LOG_TRACE_LENGTH = 0;

    uint256 internal constant OFFSET_VDF_OUTPUT_X = 1;

    uint256 internal constant OFFSET_VDF_OUTPUT_Y = 2;

    uint256 internal constant OFFSET_VDF_INPUT_X = 3;

    uint256 internal constant OFFSET_VDF_INPUT_Y = 4;

    

    

    uint256 internal constant OFFSET_N_ITER = 0;

}

contract StarkParameters is PrimeFieldElement6 {

    uint256 constant internal N_COEFFICIENTS = 48;

    uint256 constant internal MASK_SIZE = 22;

    uint256 constant internal N_ROWS_IN_MASK = 2;

    uint256 constant internal N_COLUMNS_IN_MASK = 20;

    uint256 constant internal CONSTRAINTS_DEGREE_BOUND = 2;

    uint256 constant internal N_OODS_VALUES = MASK_SIZE + CONSTRAINTS_DEGREE_BOUND;

    uint256 constant internal N_OODS_COEFFICIENTS = N_OODS_VALUES;

    uint256 constant internal MAX_FRI_STEP = 3;

}

contract VerifierChannel is Prng {



    

    uint256 constant internal CHANNEL_STATE_SIZE = 3;



    event LogValue(bytes32 val);



    event SendRandomnessEvent(uint256 val);



    event ReadFieldElementEvent(uint256 val);



    event ReadHashEvent(bytes32 val);



    function getPrngPtr(uint256 channelPtr)

        internal pure

        returns (uint256)

    {

        return channelPtr + 0x20;

    }



    function initChannel(uint256 channelPtr, uint256 proofPtr, bytes32 publicInputHash)

        internal pure

    {

        assembly {

            

            mstore(channelPtr, add(proofPtr, 0x20))

        }



        initPrng(getPrngPtr(channelPtr), publicInputHash);

    }



    function sendFieldElements(uint256 channelPtr, uint256 nElements, uint256 targetPtr)

        internal pure

    {

        require(nElements < 0x1000000, "Overflow protection failed.");

        assembly {

            let PRIME := 0x30000003000000010000000000000001

            let PRIME_MON_R_INV := 0x9000001200000096000000600000001

            let PRIME_MASK := 0x3fffffffffffffffffffffffffffffff

            let digestPtr := add(channelPtr, 0x20)

            let counterPtr := add(channelPtr, 0x40)



            let endPtr := add(targetPtr, mul(nElements, 0x20))

            for { } lt(targetPtr, endPtr) { targetPtr := add(targetPtr, 0x20) } {

                



                let fieldElement := PRIME

                

                for { } iszero(lt(fieldElement, PRIME)) { } {

                    

                    fieldElement := and(keccak256(digestPtr, 0x40), PRIME_MASK)

                    

                    mstore(counterPtr, add(mload(counterPtr), 1))

                }

                

                mstore(targetPtr, mulmod(fieldElement, PRIME_MON_R_INV, PRIME))

                

                

            }

        }

    }



    

    function sendRandomQueries(

        uint256 channelPtr, uint256 count, uint256 mask, uint256 queriesOutPtr, uint256 stride)

        internal pure returns (uint256)

    {

        uint256 val;

        uint256 shift = 0;

        uint256 endPtr = queriesOutPtr;

        for (uint256 i = 0; i < count; i++) {

            if (shift == 0) {

                val = uint256(getRandomBytes(getPrngPtr(channelPtr)));

                shift = 0x100;

            }

            shift -= 0x40;

            uint256 queryIdx = (val >> shift) & mask;

            



            uint256 ptr = endPtr;

            uint256 curr;

            



            while (ptr > queriesOutPtr) {

                assembly {

                    curr := mload(sub(ptr, stride))

                }



                if (queryIdx >= curr) {

                    break;

                }



                assembly {

                    mstore(ptr, curr)

                }

                ptr -= stride;

            }



            if (queryIdx != curr) {

                assembly {

                    mstore(ptr, queryIdx)

                }

                endPtr += stride;

            } else {

                

                while (ptr < endPtr) {

                    assembly {

                        mstore(ptr, mload(add(ptr, stride)))

                        ptr := add(ptr, stride)

                    }

                }

            }

        }



        return (endPtr - queriesOutPtr) / stride;

    }



    function readBytes(uint256 channelPtr, bool mix)

        internal pure

        returns (bytes32)

    {

        uint256 proofPtr;

        bytes32 val;



        assembly {

            proofPtr := mload(channelPtr)

            val := mload(proofPtr)

            mstore(channelPtr, add(proofPtr, 0x20))

        }

        if (mix) {

            

            assembly {

                let digestPtr := add(channelPtr, 0x20)

                let counterPtr := add(digestPtr, 0x20)

                mstore(counterPtr, val)

                

                mstore(digestPtr, keccak256(digestPtr, 0x40))

                

                mstore(counterPtr, 0)

            }

        }



        return val;

    }



    function readHash(uint256 channelPtr, bool mix)

        internal pure

        returns (bytes32)

    {

        bytes32 val = readBytes(channelPtr, mix);

        



        return val;

    }



    function readFieldElement(uint256 channelPtr, bool mix)

        internal pure returns (uint256) {

        uint256 val = fromMontgomery(uint256(readBytes(channelPtr, mix)));

        



        return val;

    }



    function verifyProofOfWork(uint256 channelPtr, uint256 proofOfWorkBits) internal pure {

        if (proofOfWorkBits == 0) {

            return;

        }



        uint256 proofOfWorkDigest;

        assembly {

            

            mstore(0, 0x0123456789abcded000000000000000000000000000000000000000000000000)

            let digest := mload(add(channelPtr, 0x20))

            mstore(0x8, digest)

            mstore8(0x28, proofOfWorkBits)

            mstore(0, keccak256(0, 0x29))



            let proofPtr := mload(channelPtr)

            mstore(0x20, mload(proofPtr))

            

            proofOfWorkDigest := keccak256(0, 0x28)



            mstore(0, digest)

            

            mstore(add(channelPtr, 0x20), keccak256(0, 0x28))

            

            mstore(add(channelPtr, 0x40), 0)



            mstore(channelPtr, add(proofPtr, 0x8))

        }



        uint256 proofOfWorkThreshold = uint256(1) << (256 - proofOfWorkBits);

        require(proofOfWorkDigest < proofOfWorkThreshold, "Proof of work check failed.");

    }

}

contract FactRegistry is IQueryableFactRegistry {

    

    mapping (bytes32 => bool) private verifiedFact;



    

    bool anyFactRegistered;



    

    function isValid(bytes32 fact)

        external view

        returns(bool)

    {

        return verifiedFact[fact];

    }



    function registerFact(

        bytes32 factHash

        )

        internal

    {

        

        verifiedFact[factHash] = true;



        

        if (!anyFactRegistered) {

            anyFactRegistered = true;

        }

    }



    

    function hasRegisteredFact()

        external view

        returns(bool)

    {

        return anyFactRegistered;

    }



}

contract FriLayer is MerkleVerifier, PrimeFieldElement6 {

    event LogGas(string name, uint256 val);



    uint256 constant internal FRI_MAX_FRI_STEP = 4;

    uint256 constant internal MAX_COSET_SIZE = 2**FRI_MAX_FRI_STEP;

    

    uint256 constant internal FRI_GROUP_GEN =

    0x1388a7fd3b4b9599dc4b0691d6a5fcba;



    uint256 constant internal FRI_GROUP_SIZE = 0x20 * MAX_COSET_SIZE;

    uint256 constant internal FRI_CTX_TO_COSET_EVALUATIONS_OFFSET = 0;

    uint256 constant internal FRI_CTX_TO_FRI_GROUP_OFFSET = FRI_GROUP_SIZE;

    uint256 constant internal FRI_CTX_TO_FRI_HALF_INV_GROUP_OFFSET =

    FRI_CTX_TO_FRI_GROUP_OFFSET + FRI_GROUP_SIZE;



    uint256 constant internal FRI_CTX_SIZE =

    FRI_CTX_TO_FRI_HALF_INV_GROUP_OFFSET + (FRI_GROUP_SIZE / 2);



    function nextLayerElementFromTwoPreviousLayerElements(

        uint256 fX, uint256 fMinusX, uint256 evalPoint, uint256 xInv)

        internal pure

        returns (uint256 res)

    {

        

        

        

        

        

        

        

        

        

        

        

        assembly {

            

            let PRIME := 0x30000003000000010000000000000001

            

            

            res := addmod(add(fX, fMinusX),

                   mulmod(mulmod(evalPoint, xInv, PRIME),

                   add(fX, sub(PRIME, fMinusX)), PRIME), PRIME)

        }

    }



    

    function do2FriSteps(

        uint256 friHalfInvGroupPtr, uint256 evaluationsOnCosetPtr, uint256 cosetOffset_,

        uint256 friEvalPoint)

    internal pure returns (uint256 nextLayerValue, uint256 nextXInv) {

        assembly {

            let PRIME := 0x30000003000000010000000000000001

            let friEvalPointDivByX := mulmod(friEvalPoint, cosetOffset_, PRIME)



            let f0 := mload(evaluationsOnCosetPtr)

            {

                let f1 := mload(add(evaluationsOnCosetPtr, 0x20))



                

                f0 := add(add(f0, f1),

                             mulmod(friEvalPointDivByX,

                                    add(f0, sub(PRIME, f1)),

                                    PRIME))

            }



            let f2 := mload(add(evaluationsOnCosetPtr, 0x40))

            {

                let f3 := mload(add(evaluationsOnCosetPtr, 0x60))

                f2 := addmod(add(f2, f3),

                             mulmod(add(f2, sub(PRIME, f3)),

                                    mulmod(mload(add(friHalfInvGroupPtr, 0x20)),

                                           friEvalPointDivByX,

                                           PRIME),

                                    PRIME),

                             PRIME)

            }



            {

                let newXInv := mulmod(cosetOffset_, cosetOffset_, PRIME)

                nextXInv := mulmod(newXInv, newXInv, PRIME)

            }



            

            nextLayerValue := addmod(add(f0, f2),

                          mulmod(mulmod(friEvalPointDivByX, friEvalPointDivByX, PRIME),

                                 add(f0, sub(PRIME, f2)),

                                 PRIME),

                          PRIME)

        }

    }



    

    function do3FriSteps(

        uint256 friHalfInvGroupPtr, uint256 evaluationsOnCosetPtr, uint256 cosetOffset_,

        uint256 friEvalPoint)

    internal pure returns (uint256 nextLayerValue, uint256 nextXInv) {

        assembly {

            let PRIME := 0x30000003000000010000000000000001

            let MPRIME := 0x300000030000000100000000000000010

            let f0 := mload(evaluationsOnCosetPtr)



            let friEvalPointDivByX := mulmod(friEvalPoint, cosetOffset_, PRIME)

            let friEvalPointDivByXSquared := mulmod(friEvalPointDivByX, friEvalPointDivByX, PRIME)

            let imaginaryUnit := mload(add(friHalfInvGroupPtr, 0x20))



            {

                let f1 := mload(add(evaluationsOnCosetPtr, 0x20))



                

                f0 := add(add(f0, f1),

                          mulmod(friEvalPointDivByX,

                                 add(f0, sub(PRIME, f1)),

                                 PRIME))

            }

            {

                let f2 := mload(add(evaluationsOnCosetPtr, 0x40))

                {

                    let f3 := mload(add(evaluationsOnCosetPtr, 0x60))



                    

                    f2 := add(add(f2, f3),

                              mulmod(add(f2, sub(PRIME, f3)),

                                     mulmod(friEvalPointDivByX, imaginaryUnit, PRIME),

                                     PRIME))

                }



                

                f0 := add(add(f0, f2),

                          mulmod(friEvalPointDivByXSquared,

                                 add(f0, sub(MPRIME, f2)),

                                 PRIME))

            }

            {

                let f4 := mload(add(evaluationsOnCosetPtr, 0x80))

                {

                    let friEvalPointDivByX2 := mulmod(friEvalPointDivByX,

                                                    mload(add(friHalfInvGroupPtr, 0x40)), PRIME)

                    {

                        let f5 := mload(add(evaluationsOnCosetPtr, 0xa0))



                        

                        f4 := add(add(f4, f5),

                                  mulmod(friEvalPointDivByX2,

                                         add(f4, sub(PRIME, f5)),

                                         PRIME))

                    }



                    let f6 := mload(add(evaluationsOnCosetPtr, 0xc0))

                    {

                        let f7 := mload(add(evaluationsOnCosetPtr, 0xe0))



                        

                        f6 := add(add(f6, f7),

                                  mulmod(add(f6, sub(PRIME, f7)),

                                         

                                         

                                         mulmod(friEvalPointDivByX2, imaginaryUnit, PRIME),

                                         PRIME))

                    }



                    

                    f4 := add(add(f4, f6),

                              mulmod(mulmod(friEvalPointDivByX2, friEvalPointDivByX2, PRIME),

                                     add(f4, sub(MPRIME, f6)),

                                     PRIME))

                }



                

                nextLayerValue :=

                   addmod(add(f0, f4),

                          mulmod(mulmod(friEvalPointDivByXSquared, friEvalPointDivByXSquared, PRIME),

                                 add(f0, sub(MPRIME, f4)),

                                 PRIME),

                          PRIME)

            }



            {

                let xInv2 := mulmod(cosetOffset_, cosetOffset_, PRIME)

                let xInv4 := mulmod(xInv2, xInv2, PRIME)

                nextXInv := mulmod(xInv4, xInv4, PRIME)

            }





        }

    }



    

    function do4FriSteps(

        uint256 friHalfInvGroupPtr, uint256 evaluationsOnCosetPtr, uint256 cosetOffset_,

        uint256 friEvalPoint)

    internal pure returns (uint256 nextLayerValue, uint256 nextXInv) {

        assembly {

            let friEvalPointDivByXTessed

            let PRIME := 0x30000003000000010000000000000001

            let MPRIME := 0x300000030000000100000000000000010

            let f0 := mload(evaluationsOnCosetPtr)



            let friEvalPointDivByX := mulmod(friEvalPoint, cosetOffset_, PRIME)

            let imaginaryUnit := mload(add(friHalfInvGroupPtr, 0x20))



            {

                let f1 := mload(add(evaluationsOnCosetPtr, 0x20))



                

                f0 := add(add(f0, f1),

                          mulmod(friEvalPointDivByX,

                                 add(f0, sub(PRIME, f1)),

                                 PRIME))

            }

            {

                let f2 := mload(add(evaluationsOnCosetPtr, 0x40))

                {

                    let f3 := mload(add(evaluationsOnCosetPtr, 0x60))



                    

                    f2 := add(add(f2, f3),

                                mulmod(add(f2, sub(PRIME, f3)),

                                       mulmod(friEvalPointDivByX, imaginaryUnit, PRIME),

                                       PRIME))

                }

                {

                    let friEvalPointDivByXSquared := mulmod(friEvalPointDivByX, friEvalPointDivByX, PRIME)

                    friEvalPointDivByXTessed := mulmod(friEvalPointDivByXSquared, friEvalPointDivByXSquared, PRIME)



                    

                    f0 := add(add(f0, f2),

                              mulmod(friEvalPointDivByXSquared,

                                     add(f0, sub(MPRIME, f2)),

                                     PRIME))

                }

            }

            {

                let f4 := mload(add(evaluationsOnCosetPtr, 0x80))

                {

                    let friEvalPointDivByX2 := mulmod(friEvalPointDivByX,

                                                      mload(add(friHalfInvGroupPtr, 0x40)), PRIME)

                    {

                        let f5 := mload(add(evaluationsOnCosetPtr, 0xa0))



                        

                        f4 := add(add(f4, f5),

                                  mulmod(friEvalPointDivByX2,

                                         add(f4, sub(PRIME, f5)),

                                         PRIME))

                    }



                    let f6 := mload(add(evaluationsOnCosetPtr, 0xc0))

                    {

                        let f7 := mload(add(evaluationsOnCosetPtr, 0xe0))



                        

                        f6 := add(add(f6, f7),

                                  mulmod(add(f6, sub(PRIME, f7)),

                                         

                                         

                                         mulmod(friEvalPointDivByX2, imaginaryUnit, PRIME),

                                         PRIME))

                    }



                    

                    f4 := add(add(f4, f6),

                              mulmod(mulmod(friEvalPointDivByX2, friEvalPointDivByX2, PRIME),

                                     add(f4, sub(MPRIME, f6)),

                                     PRIME))

                }



                

                f0 := add(add(f0, f4),

                          mulmod(friEvalPointDivByXTessed,

                                 add(f0, sub(MPRIME, f4)),

                                 PRIME))

            }

            {

                let f8 := mload(add(evaluationsOnCosetPtr, 0x100))

                {

                    let friEvalPointDivByX4 := mulmod(friEvalPointDivByX,

                                                      mload(add(friHalfInvGroupPtr, 0x80)), PRIME)

                    {

                        let f9 := mload(add(evaluationsOnCosetPtr, 0x120))



                        

                        f8 := add(add(f8, f9),

                                  mulmod(friEvalPointDivByX4,

                                         add(f8, sub(PRIME, f9)),

                                         PRIME))

                    }



                    let f10 := mload(add(evaluationsOnCosetPtr, 0x140))

                    {

                        let f11 := mload(add(evaluationsOnCosetPtr, 0x160))

                        

                        f10 := add(add(f10, f11),

                                   mulmod(add(f10, sub(PRIME, f11)),

                                          

                                          

                                          mulmod(friEvalPointDivByX4, imaginaryUnit, PRIME),

                                          PRIME))

                    }



                    

                    f8 := add(add(f8, f10),

                              mulmod(mulmod(friEvalPointDivByX4, friEvalPointDivByX4, PRIME),

                                     add(f8, sub(MPRIME, f10)),

                                     PRIME))

                }

                {

                    let f12 := mload(add(evaluationsOnCosetPtr, 0x180))

                    {

                        let friEvalPointDivByX6 := mulmod(friEvalPointDivByX,

                                                          mload(add(friHalfInvGroupPtr, 0xc0)), PRIME)

                        {

                            let f13 := mload(add(evaluationsOnCosetPtr, 0x1a0))



                            

                            f12 := add(add(f12, f13),

                                       mulmod(friEvalPointDivByX6,

                                              add(f12, sub(PRIME, f13)),

                                              PRIME))

                        }



                        let f14 := mload(add(evaluationsOnCosetPtr, 0x1c0))

                        {

                            let f15 := mload(add(evaluationsOnCosetPtr, 0x1e0))



                            

                            f14 := add(add(f14, f15),

                                       mulmod(add(f14, sub(PRIME, f15)),

                                              

                                              

                                              mulmod(friEvalPointDivByX6, imaginaryUnit, PRIME),

                                              PRIME))

                        }



                        

                        f12 := add(add(f12, f14),

                                   mulmod(mulmod(friEvalPointDivByX6, friEvalPointDivByX6, PRIME),

                                          add(f12, sub(MPRIME, f14)),

                                          PRIME))

                    }



                    

                    f8 := add(add(f8, f12),

                              mulmod(mulmod(friEvalPointDivByXTessed, imaginaryUnit, PRIME),

                                     add(f8, sub(MPRIME, f12)),

                                     PRIME))

                }



                

                nextLayerValue :=

                    addmod(add(f0, f8),

                           mulmod(mulmod(friEvalPointDivByXTessed, friEvalPointDivByXTessed, PRIME),

                                  add(f0, sub(MPRIME, f8)),

                                  PRIME),

                           PRIME)

            }



            {

                let xInv2 := mulmod(cosetOffset_, cosetOffset_, PRIME)

                let xInv4 := mulmod(xInv2, xInv2, PRIME)

                let xInv8 := mulmod(xInv4, xInv4, PRIME)

                nextXInv := mulmod(xInv8, xInv8, PRIME)

            }

        }

    }



    

    function gatherCosetInputs(

        uint256 channelPtr, uint256 friCtx, uint256 friQueueHead_, uint256 cosetSize)

        internal pure returns (uint256 friQueueHead, uint256 cosetIdx, uint256 cosetOffset_) {



        uint256 evaluationsOnCosetPtr = friCtx + FRI_CTX_TO_COSET_EVALUATIONS_OFFSET;

        uint256 friGroupPtr = friCtx + FRI_CTX_TO_FRI_GROUP_OFFSET;



        friQueueHead = friQueueHead_;

        assembly {

            let queueItemIdx := mload(friQueueHead)

            

            cosetIdx := and(queueItemIdx, not(sub(cosetSize, 1)))

            let nextCosetIdx := add(cosetIdx, cosetSize)

            let PRIME := 0x30000003000000010000000000000001



            

            

            

            

            

            

            

            cosetOffset_ := mulmod(

                 mload(add(friQueueHead, 0x40)),

                     mload(add(friGroupPtr,

                                        mul(sub(queueItemIdx, cosetIdx),

                                            0x20))),

                PRIME)



            let proofPtr := mload(channelPtr)



            for { let index := cosetIdx } lt(index, nextCosetIdx) { index := add(index, 1) } {

                

                

                

                let fieldElementPtr := proofPtr

                proofPtr := add(proofPtr, 0x20)



                

                if eq(index, queueItemIdx) {

                    

                    

                    fieldElementPtr := add(friQueueHead, 0x20)



                    

                    proofPtr := sub(proofPtr, 0x20)



                    

                    

                    friQueueHead := add(friQueueHead, 0x60)

                    queueItemIdx := mload(friQueueHead)

                }



                

                

                mstore(evaluationsOnCosetPtr, mod(mload(fieldElementPtr), PRIME))

                evaluationsOnCosetPtr := add(evaluationsOnCosetPtr, 0x20)

            }



            mstore(channelPtr, proofPtr)

        }

    }



    

    function bitReverse(uint256 num, uint256 numberOfBits)

    internal pure

        returns(uint256 numReversed)

    {

        assert((numberOfBits == 256) || (num < 2 ** numberOfBits));

        uint256 n = num;

        uint256 r = 0;

        for (uint256 k = 0; k < numberOfBits; k++) {

            r = (r * 2) | (n % 2);

            n = n / 2;

        }

        return r;

    }



    

    function initFriGroups(uint256 friCtx) internal {

        uint256 friGroupPtr = friCtx + FRI_CTX_TO_FRI_GROUP_OFFSET;

        uint256 friHalfInvGroupPtr = friCtx + FRI_CTX_TO_FRI_HALF_INV_GROUP_OFFSET;



        

        

        uint256 genFriGroup = FRI_GROUP_GEN;



        uint256 genFriGroupInv = fpow(genFriGroup, (MAX_COSET_SIZE - 1));



        uint256 lastVal = ONE_VAL;

        uint256 lastValInv = ONE_VAL;

        uint256 prime = PrimeFieldElement6.K_MODULUS;

        assembly {

            

            mstore(friHalfInvGroupPtr, lastValInv)

            

            mstore(friGroupPtr, lastVal)

            

            mstore(add(friGroupPtr, 0x20), sub(prime, lastVal))

        }



        

        

        uint256 halfCosetSize = MAX_COSET_SIZE / 2;

        for (uint256 i = 1; i < halfCosetSize; i++) {

            lastVal = fmul(lastVal, genFriGroup);

            lastValInv = fmul(lastValInv, genFriGroupInv);

            uint256 idx = bitReverse(i, FRI_MAX_FRI_STEP-1);



            assembly {

                

                mstore(add(friHalfInvGroupPtr, mul(idx, 0x20)), lastValInv)

                

                mstore(add(friGroupPtr, mul(idx, 0x40)), lastVal)

                

                mstore(add(friGroupPtr, add(mul(idx, 0x40), 0x20)), sub(prime, lastVal))

            }

        }

    }



    

    function doFriSteps(

        uint256 friCtx, uint256 friQueueTail, uint256 cosetOffset_, uint256 friEvalPoint,

        uint256 friCosetSize, uint256 index, uint256 merkleQueuePtr)

        internal pure {

        uint256 friValue;



        uint256 evaluationsOnCosetPtr = friCtx + FRI_CTX_TO_COSET_EVALUATIONS_OFFSET;

        uint256 friHalfInvGroupPtr = friCtx + FRI_CTX_TO_FRI_HALF_INV_GROUP_OFFSET;



        

        if (friCosetSize == 8) {

            (friValue, cosetOffset_) = do3FriSteps(

                friHalfInvGroupPtr, evaluationsOnCosetPtr, cosetOffset_, friEvalPoint);

        } else if (friCosetSize == 4) {

            (friValue, cosetOffset_) = do2FriSteps(

                friHalfInvGroupPtr, evaluationsOnCosetPtr, cosetOffset_, friEvalPoint);

        } else if (friCosetSize == 16) {

            (friValue, cosetOffset_) = do4FriSteps(

                friHalfInvGroupPtr, evaluationsOnCosetPtr, cosetOffset_, friEvalPoint);

        } else {

            require(false, "Only step sizes of 2, 3 or 4 are supported.");

        }



        uint256 lhashMask = getHashMask();

        assembly {

            let indexInNextStep := div(index, friCosetSize)

            mstore(merkleQueuePtr, indexInNextStep)

            mstore(add(merkleQueuePtr, 0x20), and(lhashMask, keccak256(evaluationsOnCosetPtr,

                                                                          mul(0x20,friCosetSize))))



            mstore(friQueueTail, indexInNextStep)

            mstore(add(friQueueTail, 0x20), friValue)

            mstore(add(friQueueTail, 0x40), cosetOffset_)

        }

    }



    

    function computeNextLayer(

        uint256 channelPtr, uint256 friQueuePtr, uint256 merkleQueuePtr, uint256 nQueries,

        uint256 friEvalPoint, uint256 friCosetSize, uint256 friCtx)

        internal pure returns (uint256 nLiveQueries) {

        uint256 merkleQueueTail = merkleQueuePtr;

        uint256 friQueueHead = friQueuePtr;

        uint256 friQueueTail = friQueuePtr;

        uint256 friQueueEnd = friQueueHead + (0x60 * nQueries);



        do {

            uint256 cosetOffset;

            uint256 index;

            (friQueueHead, index, cosetOffset) = gatherCosetInputs(

                channelPtr, friCtx, friQueueHead, friCosetSize);



            doFriSteps(

                friCtx, friQueueTail, cosetOffset, friEvalPoint, friCosetSize, index,

                merkleQueueTail);



            merkleQueueTail += 0x40;

            friQueueTail += 0x60;

        } while (friQueueHead < friQueueEnd);

        return (friQueueTail - friQueuePtr) / 0x60;

    }



}

contract HornerEvaluator is PrimeFieldElement6 {

    

    function hornerEval(uint256 coefsStart, uint256 point, uint256 nCoefs)

        internal pure

        returns (uint256) {

        uint256 result = 0;

        uint256 prime = PrimeFieldElement6.K_MODULUS;



        require(nCoefs % 8 == 0, "Number of polynomial coefficients must be divisible by 8");

        require(nCoefs < 4096, "No more than 4096 coefficients are supported");



        assembly {

            let coefsPtr := add(coefsStart, mul(nCoefs, 0x20))

            for { } gt(coefsPtr, coefsStart) { } {

                

                coefsPtr := sub(coefsPtr, 0x100)



                

                result :=

                    add(mload(add(coefsPtr, 0x80)), mulmod(

                    add(mload(add(coefsPtr, 0xa0)), mulmod(

                    add(mload(add(coefsPtr, 0xc0)), mulmod(

                    add(mload(add(coefsPtr, 0xe0)), mulmod(

                        result,

                    point, prime)),

                    point, prime)),

                    point, prime)),

                    point, prime))



                

                result :=

                    add(mload(coefsPtr), mulmod(

                    add(mload(add(coefsPtr, 0x20)), mulmod(

                    add(mload(add(coefsPtr, 0x40)), mulmod(

                    add(mload(add(coefsPtr, 0x60)), mulmod(

                        result,

                    point, prime)),

                    point, prime)),

                    point, prime)),

                    point, prime))

            }

        }



        

        return result % prime;

    }

}

contract MemoryAccessUtils is MemoryMap {

    function getPtr(uint256[] memory ctx, uint256 offset)

        internal pure

        returns (uint256) {

        uint256 ctxPtr;

        require(offset < MM_CONTEXT_SIZE, "Overflow protection failed");

        assembly {

            ctxPtr := add(ctx, 0x20)

        }

        return ctxPtr + offset * 0x20;

    }



    function getProofPtr(uint256[] memory proof)

        internal pure

        returns (uint256)

    {

        uint256 proofPtr;

        assembly {

            proofPtr := proof

        }

        return proofPtr;

    }



    function getChannelPtr(uint256[] memory ctx)

        internal pure

        returns (uint256) {

        uint256 ctxPtr;

        assembly {

            ctxPtr := add(ctx, 0x20)

        }

        return ctxPtr + MM_CHANNEL * 0x20;

    }



    function getQueries(uint256[] memory ctx)

        internal pure

        returns (uint256[] memory)

    {

        uint256[] memory queries;

        

        uint256 offset = 0x20 + 0x20*MM_N_UNIQUE_QUERIES;

        assembly {

            queries := add(ctx, offset)

        }

        return queries;

    }



    function getMerkleQueuePtr(uint256[] memory ctx)

        internal pure

        returns (uint256)

    {

        return getPtr(ctx, MM_MERKLE_QUEUE);

    }



    function getFriSteps(uint256[] memory ctx)

        internal pure

        returns (uint256[] memory friSteps)

    {

        uint256 friStepsPtr = getPtr(ctx, MM_FRI_STEPS_PTR);

        assembly {

            friSteps := mload(friStepsPtr)

        }

    }

}

contract MimcOods is MemoryMap, StarkParameters {

    

    

    

    

    uint256 constant internal BATCH_INVERSE_CHUNK = (2 + N_ROWS_IN_MASK);

    uint256 constant internal BATCH_INVERSE_SIZE = MAX_N_QUERIES * BATCH_INVERSE_CHUNK;



    

    function() external {

        

        

        uint256[] memory ctx;

        assembly {

            let ctxSize := mul(add(calldataload(0), 1), 0x20)

            ctx := mload(0x40)

            mstore(0x40, add(ctx, ctxSize))

            calldatacopy(ctx, 0, ctxSize)

        }

        uint256[] memory batchInverseArray = new uint256[](2 * BATCH_INVERSE_SIZE);



        oodsPrepareInverses(ctx, batchInverseArray);



        uint256 kMontgomeryRInv_ = PrimeFieldElement6.K_MONTGOMERY_R_INV;



        assembly {

            let PRIME := 0x30000003000000010000000000000001

            let kMontgomeryRInv := kMontgomeryRInv_

            let context := ctx

            let friQueue :=  add(context, 0xda0)

            let friQueueEnd := add(friQueue,  mul( mload(add(context, 0x120)), 0x60))

            let traceQueryResponses :=  add(context, 0x3d80)



            let compositionQueryResponses :=  add(context, 0xb580)



            

            

            let denominatorsPtr := add(batchInverseArray, 0x20)



            for {} lt(friQueue, friQueueEnd) {friQueue := add(friQueue, 0x60)} {

                

                

                

                let res := 0



                



                

                {

                

                let columnValue := mulmod(mload(traceQueryResponses), kMontgomeryRInv, PRIME)



                

                res := add(

                    res,

                    mulmod(mulmod( mload(denominatorsPtr),

                                   mload(add(context, 0x3a80)),

                                  PRIME),

                           add(columnValue, sub(PRIME,  mload(add(context, 0x3180)))),

                           PRIME))



                

                res := add(

                    res,

                    mulmod(mulmod( mload(add(denominatorsPtr, 0x20)),

                                   mload(add(context, 0x3aa0)),

                                  PRIME),

                           add(columnValue, sub(PRIME,  mload(add(context, 0x31a0)))),

                           PRIME))

                }



                

                {

                

                let columnValue := mulmod(mload(add(traceQueryResponses, 0x20)), kMontgomeryRInv, PRIME)



                

                res := add(

                    res,

                    mulmod(mulmod( mload(denominatorsPtr),

                                   mload(add(context, 0x3ac0)),

                                  PRIME),

                           add(columnValue, sub(PRIME,  mload(add(context, 0x31c0)))),

                           PRIME))

                }



                

                {

                

                let columnValue := mulmod(mload(add(traceQueryResponses, 0x40)), kMontgomeryRInv, PRIME)



                

                res := add(

                    res,

                    mulmod(mulmod( mload(denominatorsPtr),

                                   mload(add(context, 0x3ae0)),

                                  PRIME),

                           add(columnValue, sub(PRIME,  mload(add(context, 0x31e0)))),

                           PRIME))

                }



                

                {

                

                let columnValue := mulmod(mload(add(traceQueryResponses, 0x60)), kMontgomeryRInv, PRIME)



                

                res := add(

                    res,

                    mulmod(mulmod( mload(denominatorsPtr),

                                   mload(add(context, 0x3b00)),

                                  PRIME),

                           add(columnValue, sub(PRIME,  mload(add(context, 0x3200)))),

                           PRIME))

                }



                

                {

                

                let columnValue := mulmod(mload(add(traceQueryResponses, 0x80)), kMontgomeryRInv, PRIME)



                

                res := add(

                    res,

                    mulmod(mulmod( mload(denominatorsPtr),

                                   mload(add(context, 0x3b20)),

                                  PRIME),

                           add(columnValue, sub(PRIME,  mload(add(context, 0x3220)))),

                           PRIME))

                }



                

                {

                

                let columnValue := mulmod(mload(add(traceQueryResponses, 0xa0)), kMontgomeryRInv, PRIME)



                

                res := add(

                    res,

                    mulmod(mulmod( mload(denominatorsPtr),

                                   mload(add(context, 0x3b40)),

                                  PRIME),

                           add(columnValue, sub(PRIME,  mload(add(context, 0x3240)))),

                           PRIME))

                }



                

                {

                

                let columnValue := mulmod(mload(add(traceQueryResponses, 0xc0)), kMontgomeryRInv, PRIME)



                

                res := add(

                    res,

                    mulmod(mulmod( mload(denominatorsPtr),

                                   mload(add(context, 0x3b60)),

                                  PRIME),

                           add(columnValue, sub(PRIME,  mload(add(context, 0x3260)))),

                           PRIME))

                }



                

                {

                

                let columnValue := mulmod(mload(add(traceQueryResponses, 0xe0)), kMontgomeryRInv, PRIME)



                

                res := add(

                    res,

                    mulmod(mulmod( mload(denominatorsPtr),

                                   mload(add(context, 0x3b80)),

                                  PRIME),

                           add(columnValue, sub(PRIME,  mload(add(context, 0x3280)))),

                           PRIME))

                }



                

                {

                

                let columnValue := mulmod(mload(add(traceQueryResponses, 0x100)), kMontgomeryRInv, PRIME)



                

                res := add(

                    res,

                    mulmod(mulmod( mload(denominatorsPtr),

                                   mload(add(context, 0x3ba0)),

                                  PRIME),

                           add(columnValue, sub(PRIME,  mload(add(context, 0x32a0)))),

                           PRIME))

                }



                

                {

                

                let columnValue := mulmod(mload(add(traceQueryResponses, 0x120)), kMontgomeryRInv, PRIME)



                

                res := add(

                    res,

                    mulmod(mulmod( mload(denominatorsPtr),

                                   mload(add(context, 0x3bc0)),

                                  PRIME),

                           add(columnValue, sub(PRIME,  mload(add(context, 0x32c0)))),

                           PRIME))

                }



                

                {

                

                let columnValue := mulmod(mload(add(traceQueryResponses, 0x140)), kMontgomeryRInv, PRIME)



                

                res := add(

                    res,

                    mulmod(mulmod( mload(denominatorsPtr),

                                   mload(add(context, 0x3be0)),

                                  PRIME),

                           add(columnValue, sub(PRIME,  mload(add(context, 0x32e0)))),

                           PRIME))



                

                res := add(

                    res,

                    mulmod(mulmod( mload(add(denominatorsPtr, 0x20)),

                                   mload(add(context, 0x3c00)),

                                  PRIME),

                           add(columnValue, sub(PRIME,  mload(add(context, 0x3300)))),

                           PRIME))

                }



                

                {

                

                let columnValue := mulmod(mload(add(traceQueryResponses, 0x160)), kMontgomeryRInv, PRIME)



                

                res := add(

                    res,

                    mulmod(mulmod( mload(denominatorsPtr),

                                   mload(add(context, 0x3c20)),

                                  PRIME),

                           add(columnValue, sub(PRIME,  mload(add(context, 0x3320)))),

                           PRIME))

                }



                

                {

                

                let columnValue := mulmod(mload(add(traceQueryResponses, 0x180)), kMontgomeryRInv, PRIME)



                

                res := add(

                    res,

                    mulmod(mulmod( mload(denominatorsPtr),

                                   mload(add(context, 0x3c40)),

                                  PRIME),

                           add(columnValue, sub(PRIME,  mload(add(context, 0x3340)))),

                           PRIME))

                }



                

                {

                

                let columnValue := mulmod(mload(add(traceQueryResponses, 0x1a0)), kMontgomeryRInv, PRIME)



                

                res := add(

                    res,

                    mulmod(mulmod( mload(denominatorsPtr),

                                   mload(add(context, 0x3c60)),

                                  PRIME),

                           add(columnValue, sub(PRIME,  mload(add(context, 0x3360)))),

                           PRIME))

                }



                

                {

                

                let columnValue := mulmod(mload(add(traceQueryResponses, 0x1c0)), kMontgomeryRInv, PRIME)



                

                res := add(

                    res,

                    mulmod(mulmod( mload(denominatorsPtr),

                                   mload(add(context, 0x3c80)),

                                  PRIME),

                           add(columnValue, sub(PRIME,  mload(add(context, 0x3380)))),

                           PRIME))

                }



                

                {

                

                let columnValue := mulmod(mload(add(traceQueryResponses, 0x1e0)), kMontgomeryRInv, PRIME)



                

                res := add(

                    res,

                    mulmod(mulmod( mload(denominatorsPtr),

                                   mload(add(context, 0x3ca0)),

                                  PRIME),

                           add(columnValue, sub(PRIME,  mload(add(context, 0x33a0)))),

                           PRIME))

                }



                

                {

                

                let columnValue := mulmod(mload(add(traceQueryResponses, 0x200)), kMontgomeryRInv, PRIME)



                

                res := add(

                    res,

                    mulmod(mulmod( mload(denominatorsPtr),

                                   mload(add(context, 0x3cc0)),

                                  PRIME),

                           add(columnValue, sub(PRIME,  mload(add(context, 0x33c0)))),

                           PRIME))

                }



                

                {

                

                let columnValue := mulmod(mload(add(traceQueryResponses, 0x220)), kMontgomeryRInv, PRIME)



                

                res := add(

                    res,

                    mulmod(mulmod( mload(denominatorsPtr),

                                   mload(add(context, 0x3ce0)),

                                  PRIME),

                           add(columnValue, sub(PRIME,  mload(add(context, 0x33e0)))),

                           PRIME))

                }



                

                {

                

                let columnValue := mulmod(mload(add(traceQueryResponses, 0x240)), kMontgomeryRInv, PRIME)



                

                res := add(

                    res,

                    mulmod(mulmod( mload(denominatorsPtr),

                                   mload(add(context, 0x3d00)),

                                  PRIME),

                           add(columnValue, sub(PRIME,  mload(add(context, 0x3400)))),

                           PRIME))

                }



                

                {

                

                let columnValue := mulmod(mload(add(traceQueryResponses, 0x260)), kMontgomeryRInv, PRIME)



                

                res := add(

                    res,

                    mulmod(mulmod( mload(denominatorsPtr),

                                   mload(add(context, 0x3d20)),

                                  PRIME),

                           add(columnValue, sub(PRIME,  mload(add(context, 0x3420)))),

                           PRIME))

                }



                

                traceQueryResponses := add(traceQueryResponses, 0x280)



                



                {

                

                let columnValue := mulmod(mload(compositionQueryResponses), kMontgomeryRInv, PRIME)

                

                res := add(

                    res,

                    mulmod(mulmod( mload(add(denominatorsPtr, 0x40)),

                                   mload(add(context, 0x3d40)),

                                  PRIME),

                           add(columnValue, sub(PRIME,  mload(add(context, 0x3440)))),

                           PRIME))

                }



                {

                

                let columnValue := mulmod(mload(add(compositionQueryResponses, 0x20)), kMontgomeryRInv, PRIME)

                

                res := add(

                    res,

                    mulmod(mulmod( mload(add(denominatorsPtr, 0x40)),

                                   mload(add(context, 0x3d60)),

                                  PRIME),

                           add(columnValue, sub(PRIME,  mload(add(context, 0x3460)))),

                           PRIME))

                }



                

                compositionQueryResponses := add(compositionQueryResponses, 0x40)



                

                

                mstore(add(friQueue, 0x20), mod(res, PRIME))



                

                mstore(add(friQueue, 0x40),  mload(add(denominatorsPtr,0x60)))



                

                denominatorsPtr := add(denominatorsPtr, 0x80)

            }

            return( add(context, 0xda0), 0x1200)

        }

    }



    

    function oodsPrepareInverses(

        uint256[] memory context, uint256[] memory batchInverseArray)

        internal view {

        uint256 evalCosetOffset_ = PrimeFieldElement6.GENERATOR_VAL;

        

        

        

        

        

        uint256[2] memory expmodsAndPoints;

        assembly {

            function expmod(base, exponent, modulus) -> res {

              let p := mload(0x40)

              mstore(p, 0x20)                 

              mstore(add(p, 0x20), 0x20)      

              mstore(add(p, 0x40), 0x20)      

              mstore(add(p, 0x60), base)      

              mstore(add(p, 0x80), exponent)  

              mstore(add(p, 0xa0), modulus)   

              

              if iszero(staticcall(not(0), 0x05, p, 0xc0, p, 0x20)) {

                revert(0, 0)

              }

              res := mload(p)

            }



            let traceGenerator :=  mload(add(context, 0x2b40))

            let PRIME := 0x30000003000000010000000000000001



            



            let oodsPoint :=  mload(add(context, 0x2b60))

            {

              

              let point := sub(PRIME, oodsPoint)

              

              



              



              

              mstore(add(expmodsAndPoints, 0x0), point)



              

              point := mulmod(point, traceGenerator, PRIME)

              

              mstore(add(expmodsAndPoints, 0x20), point)

            }





            let evalPointsPtr :=  add(context, 0x3480)

            let evalPointsEndPtr := add(evalPointsPtr,

                                           mul( mload(add(context, 0x120)), 0x20))

            let productsPtr := add(batchInverseArray, 0x20)

            let valuesPtr := add(add(batchInverseArray, 0x20), 0x1800)

            let partialProduct := 1

            let minusPointPow := sub(PRIME, mulmod(oodsPoint, oodsPoint, PRIME))

            for {} lt(evalPointsPtr, evalPointsEndPtr)

                     {evalPointsPtr := add(evalPointsPtr, 0x20)} {

                let evalPoint := mload(evalPointsPtr)



                

                let shiftedEvalPoint := mulmod(evalPoint, evalCosetOffset_, PRIME)



                {

                

                let denominator := add(shiftedEvalPoint, mload(add(expmodsAndPoints, 0x0)))

                mstore(productsPtr, partialProduct)

                mstore(valuesPtr, denominator)

                partialProduct := mulmod(partialProduct, denominator, PRIME)

                }



                {

                

                let denominator := add(shiftedEvalPoint, mload(add(expmodsAndPoints, 0x20)))

                mstore(add(productsPtr, 0x20), partialProduct)

                mstore(add(valuesPtr, 0x20), denominator)

                partialProduct := mulmod(partialProduct, denominator, PRIME)

                }



                {

                

                let denominator := add(shiftedEvalPoint, minusPointPow)

                mstore(add(productsPtr, 0x40), partialProduct)

                mstore(add(valuesPtr, 0x40), denominator)

                partialProduct := mulmod(partialProduct, denominator, PRIME)

                }



                

                

                mstore(add(productsPtr, 0x60), partialProduct)

                mstore(add(valuesPtr, 0x60), evalPoint)

                partialProduct := mulmod(partialProduct, evalPoint, PRIME)



                

                productsPtr := add(productsPtr, 0x80)

                valuesPtr := add(valuesPtr, 0x80)

            }



            let productsToValuesOffset := 0x1800

            let firstPartialProductPtr := add(batchInverseArray, 0x20)

            

            let prodInv := expmod(partialProduct, sub(PRIME, 2), PRIME)



            if eq(prodInv, 0) {

                

                

                

                

                



                mstore(0, 0x08c379a000000000000000000000000000000000000000000000000000000000)

                mstore(0x4, 0x20)

                mstore(0x24, 0x1e)

                mstore(0x44, "Batch inverse product is zero.")

                revert(0, 0x62)

            }



            

            

            

            let currentPartialProductPtr := productsPtr

            

            

            

            

            let midPartialProductPtr := add(firstPartialProductPtr, 0xe0)

            for { } gt(currentPartialProductPtr, midPartialProductPtr) { } {

                currentPartialProductPtr := sub(currentPartialProductPtr, 0x20)

                

                mstore(currentPartialProductPtr,

                       mulmod(mload(currentPartialProductPtr), prodInv, PRIME))

                

                prodInv := mulmod(prodInv,

                                   mload(add(currentPartialProductPtr, productsToValuesOffset)),

                                   PRIME)



                currentPartialProductPtr := sub(currentPartialProductPtr, 0x20)

                

                mstore(currentPartialProductPtr,

                       mulmod(mload(currentPartialProductPtr), prodInv, PRIME))

                

                prodInv := mulmod(prodInv,

                                   mload(add(currentPartialProductPtr, productsToValuesOffset)),

                                   PRIME)



                currentPartialProductPtr := sub(currentPartialProductPtr, 0x20)

                

                mstore(currentPartialProductPtr,

                       mulmod(mload(currentPartialProductPtr), prodInv, PRIME))

                

                prodInv := mulmod(prodInv,

                                   mload(add(currentPartialProductPtr, productsToValuesOffset)),

                                   PRIME)



                currentPartialProductPtr := sub(currentPartialProductPtr, 0x20)

                

                mstore(currentPartialProductPtr,

                       mulmod(mload(currentPartialProductPtr), prodInv, PRIME))

                

                prodInv := mulmod(prodInv,

                                   mload(add(currentPartialProductPtr, productsToValuesOffset)),

                                   PRIME)



                currentPartialProductPtr := sub(currentPartialProductPtr, 0x20)

                

                mstore(currentPartialProductPtr,

                       mulmod(mload(currentPartialProductPtr), prodInv, PRIME))

                

                prodInv := mulmod(prodInv,

                                   mload(add(currentPartialProductPtr, productsToValuesOffset)),

                                   PRIME)



                currentPartialProductPtr := sub(currentPartialProductPtr, 0x20)

                

                mstore(currentPartialProductPtr,

                       mulmod(mload(currentPartialProductPtr), prodInv, PRIME))

                

                prodInv := mulmod(prodInv,

                                   mload(add(currentPartialProductPtr, productsToValuesOffset)),

                                   PRIME)



                currentPartialProductPtr := sub(currentPartialProductPtr, 0x20)

                

                mstore(currentPartialProductPtr,

                       mulmod(mload(currentPartialProductPtr), prodInv, PRIME))

                

                prodInv := mulmod(prodInv,

                                   mload(add(currentPartialProductPtr, productsToValuesOffset)),

                                   PRIME)



                currentPartialProductPtr := sub(currentPartialProductPtr, 0x20)

                

                mstore(currentPartialProductPtr,

                       mulmod(mload(currentPartialProductPtr), prodInv, PRIME))

                

                prodInv := mulmod(prodInv,

                                   mload(add(currentPartialProductPtr, productsToValuesOffset)),

                                   PRIME)

            }



            

            for { } gt(currentPartialProductPtr, firstPartialProductPtr) { } {

                currentPartialProductPtr := sub(currentPartialProductPtr, 0x20)

                

                mstore(currentPartialProductPtr,

                       mulmod(mload(currentPartialProductPtr), prodInv, PRIME))

                

                prodInv := mulmod(prodInv,

                                   mload(add(currentPartialProductPtr, productsToValuesOffset)),

                                   PRIME)

            }

        }

    }

}

contract Fri is MemoryMap, MemoryAccessUtils, HornerEvaluator, FriLayer {

    event LogGas(string name, uint256 val);



    function verifyLastLayer(uint256[] memory ctx, uint256 nPoints)

        internal {

        uint256 friLastLayerDegBound = ctx[MM_FRI_LAST_LAYER_DEG_BOUND];

        uint256 groupOrderMinusOne = friLastLayerDegBound * ctx[MM_BLOW_UP_FACTOR] - 1;

        uint256 coefsStart = ctx[MM_FRI_LAST_LAYER_PTR];



        for (uint256 i = 0; i < nPoints; i++) {

            uint256 point = ctx[MM_FRI_QUEUE + 3*i + 2];

            



            point = fpow(point, groupOrderMinusOne);

            require(

                hornerEval(coefsStart, point, friLastLayerDegBound) == ctx[MM_FRI_QUEUE + 3*i + 1],

                "Bad Last layer value.");

        }

    }



    

    function friVerifyLayers(

        uint256[] memory ctx)

        internal

    {



        uint256 friCtx = getPtr(ctx, MM_FRI_CTX);

        require(

            MAX_SUPPORTED_MAX_FRI_STEP == FRI_MAX_FRI_STEP,

            "Incosistent MAX_FRI_STEP between MemoryMap.sol and FriLayer.sol");

        initFriGroups(friCtx);

        

        uint256 channelPtr = getChannelPtr(ctx);

        uint256 merkleQueuePtr = getMerkleQueuePtr(ctx);



        uint256 friStep = 1;

        uint256 nLiveQueries = ctx[MM_N_UNIQUE_QUERIES];



        

        ctx[MM_FRI_QUERIES_DELIMITER] = 0;



        

        

        

        

        

        

        for (uint256 i = 0; i < nLiveQueries; i++ ) {

            ctx[MM_FRI_QUEUE + 3*i + 1] = fmul(ctx[MM_FRI_QUEUE + 3*i + 1], K_MONTGOMERY_R);

        }



        uint256 friQueue = getPtr(ctx, MM_FRI_QUEUE);



        uint256[] memory friSteps = getFriSteps(ctx);

        uint256 nFriSteps = friSteps.length;

        while (friStep < nFriSteps) {

            uint256 friCosetSize = 2**friSteps[friStep];



            nLiveQueries = computeNextLayer(

                channelPtr, friQueue, merkleQueuePtr, nLiveQueries,

                ctx[MM_FRI_EVAL_POINTS + friStep], friCosetSize, friCtx);



            

            



            

            

            

            verify(

                channelPtr, merkleQueuePtr, bytes32(ctx[MM_FRI_COMMITMENTS + friStep - 1]),

                nLiveQueries);



            

            

            

            friStep++;

        }



        verifyLastLayer(ctx, nLiveQueries);

        

    }

}

contract StarkVerifier is MemoryMap, MemoryAccessUtils, VerifierChannel, IStarkVerifier, Fri {

    

    uint256 numSecurityBits;



    

    uint256 minProofOfWorkBits;



    constructor(uint256 numSecurityBits_, uint256 minProofOfWorkBits_) public {

        numSecurityBits = numSecurityBits_;

        minProofOfWorkBits = minProofOfWorkBits_;

    }



    

    event LogBool(bool val);

    event LogDebug(uint256 val);

    address oodsContractAddress;



    function airSpecificInit(uint256[] memory publicInput)

        internal returns (uint256[] memory ctx, uint256 logTraceLength);



    uint256 constant internal PROOF_PARAMS_N_QUERIES_OFFSET = 0;

    uint256 constant internal PROOF_PARAMS_LOG_BLOWUP_FACTOR_OFFSET = 1;

    uint256 constant internal PROOF_PARAMS_PROOF_OF_WORK_BITS_OFFSET = 2;

    uint256 constant internal PROOF_PARAMS_FRI_LAST_LAYER_DEG_BOUND_OFFSET = 3;

    uint256 constant internal PROOF_PARAMS_N_FRI_STEPS_OFFSET = 4;

    uint256 constant internal PROOF_PARAMS_FRI_STEPS_OFFSET = 5;



    function validateFriParams(

        uint256[] memory friSteps, uint256 logTraceLength, uint256 logFriLastLayerDegBound)

        internal pure {

        require (friSteps[0] == 0, "Only eta0 == 0 is currently supported");



        uint256 expectedLogDegBound = logFriLastLayerDegBound;

        uint256 nFriSteps = friSteps.length;

        for (uint256 i = 1; i < nFriSteps; i++) {

            uint256 friStep = friSteps[i];

            require(friStep > 0, "Only the first fri step can be 0");

            require(friStep <= 4, "Max supported fri step is 4.");

            expectedLogDegBound += friStep;

        }



        

        

        

        require (

            expectedLogDegBound == logTraceLength, "Fri params do not match trace length");

    }



    function initVerifierParams(uint256[] memory publicInput, uint256[] memory proofParams)

        internal returns (uint256[] memory ctx) {

        require (proofParams.length > PROOF_PARAMS_FRI_STEPS_OFFSET, "Invalid proofParams.");

        require (

            proofParams.length == (

                PROOF_PARAMS_FRI_STEPS_OFFSET + proofParams[PROOF_PARAMS_N_FRI_STEPS_OFFSET]),

            "Invalid proofParams.");

        uint256 logBlowupFactor = proofParams[PROOF_PARAMS_LOG_BLOWUP_FACTOR_OFFSET];

        require (logBlowupFactor <= 16, "logBlowupFactor must be at most 16");

        require (logBlowupFactor >= 1, "logBlowupFactor must be at least 1");



        uint256 proofOfWorkBits = proofParams[PROOF_PARAMS_PROOF_OF_WORK_BITS_OFFSET];

        require (proofOfWorkBits <= 50, "proofOfWorkBits must be at most 50");

        require (proofOfWorkBits >= minProofOfWorkBits, "minimum proofOfWorkBits not satisfied");

        require (proofOfWorkBits < numSecurityBits, "Proofs may not be purely based on PoW.");



        uint256 logFriLastLayerDegBound = (

            proofParams[PROOF_PARAMS_FRI_LAST_LAYER_DEG_BOUND_OFFSET]

        );

        require (

            logFriLastLayerDegBound <= 10, "logFriLastLayerDegBound must be at most 10.");



        uint256 nFriSteps = proofParams[PROOF_PARAMS_N_FRI_STEPS_OFFSET];

        require (nFriSteps <= 10, "Too many fri steps.");

        require (nFriSteps > 1, "Not enough fri steps.");



        uint256[] memory friSteps = new uint256[](nFriSteps);

        for (uint256 i = 0; i < nFriSteps; i++) {

            friSteps[i] = proofParams[PROOF_PARAMS_FRI_STEPS_OFFSET + i];

        }



        uint256 logTraceLength;

        (ctx, logTraceLength) = airSpecificInit(publicInput);



        validateFriParams(friSteps, logTraceLength, logFriLastLayerDegBound);



        uint256 friStepsPtr = getPtr(ctx, MM_FRI_STEPS_PTR);

        assembly {

            mstore(friStepsPtr, friSteps)

        }

        ctx[MM_FRI_LAST_LAYER_DEG_BOUND] = 2**logFriLastLayerDegBound;

        ctx[MM_TRACE_LENGTH] = 2 ** logTraceLength;



        ctx[MM_BLOW_UP_FACTOR] = 2**logBlowupFactor;

        ctx[MM_PROOF_OF_WORK_BITS] = proofOfWorkBits;



        uint256 nQueries = proofParams[PROOF_PARAMS_N_QUERIES_OFFSET];

        require (nQueries > 0, "Number of queries must be at least one");

        require (nQueries <= MAX_N_QUERIES, "Too many queries.");

        require (

            nQueries * logBlowupFactor + proofOfWorkBits >= numSecurityBits,

            "Proof params do not satisfy security requirements.");



        ctx[MM_N_UNIQUE_QUERIES] = nQueries;



        

        ctx[MM_LOG_EVAL_DOMAIN_SIZE] = logTraceLength + logBlowupFactor;

        ctx[MM_EVAL_DOMAIN_SIZE] = 2**ctx[MM_LOG_EVAL_DOMAIN_SIZE];



        uint256 gen_evalDomain = fpow(GENERATOR_VAL, (K_MODULUS - 1) / ctx[MM_EVAL_DOMAIN_SIZE]);

        ctx[MM_EVAL_DOMAIN_GENERATOR] = gen_evalDomain;

        uint256 genTraceDomain = fpow(gen_evalDomain, ctx[MM_BLOW_UP_FACTOR]);

        ctx[MM_TRACE_GENERATOR] = genTraceDomain;

    }



    function getPublicInputHash(uint256[] memory publicInput) internal pure returns (bytes32);



    function oodsConsistencyCheck(uint256[] memory ctx) internal;



    function getNColumnsInTrace() internal pure returns(uint256);



    function getNColumnsInComposition() internal pure returns(uint256);



    function getMmCoefficients() internal pure returns(uint256);



    function getMmOodsValues() internal pure returns(uint256);



    function getMmOodsCoefficients() internal pure returns(uint256);



    function getNCoefficients() internal pure returns(uint256);



    function getNOodsValues() internal pure returns(uint256);



    function getNOodsCoefficients() internal pure returns(uint256);



    function hashRow(uint256[] memory ctx, uint256 offset, uint256 length)

    internal pure returns (uint256 res) {

        assembly {

            res := keccak256(add(add(ctx, 0x20), offset), length)

        }

        res &= getHashMask();

    }



    

    function adjustQueryIndicesAndPrepareEvalPoints(uint256[] memory ctx) internal {

        uint256 nUniqueQueries = ctx[MM_N_UNIQUE_QUERIES];

        uint256 friQueue = getPtr(ctx, MM_FRI_QUEUE);

        uint256 friQueueEnd = friQueue + nUniqueQueries * 0x60;

        uint256 evalPointsPtr = getPtr(ctx, MM_OODS_EVAL_POINTS);

        uint256 log_evalDomainSize = ctx[MM_LOG_EVAL_DOMAIN_SIZE];

        uint256 evalDomainSize = ctx[MM_EVAL_DOMAIN_SIZE];

        uint256 evalDomainGenerator = ctx[MM_EVAL_DOMAIN_GENERATOR];



        assembly {

            

            function bitReverse(value, numberOfBits) -> res {

                

                

                

                res := value

                

                res := or(mul(and(res, 0x5555555555555555), 0x4),

                        and(res, 0xaaaaaaaaaaaaaaaa))

                

                res := or(mul(and(res, 0x6666666666666666), 0x10),

                        and(res, 0x19999999999999998))

                

                res := or(mul(and(res, 0x7878787878787878), 0x100),

                        and(res, 0x78787878787878780))

                

                res := or(mul(and(res, 0x7f807f807f807f80), 0x10000),

                        and(res, 0x7f807f807f807f8000))

                

                res := or(mul(and(res, 0x7fff80007fff8000), 0x100000000),

                        and(res, 0x7fff80007fff80000000))

                

                res := or(mul(and(res, 0x7fffffff80000000), 0x10000000000000000),

                        and(res, 0x7fffffff8000000000000000))

                

                res := div(res, exp(2, sub(127, numberOfBits)))

            }



            function expmod(base, exponent, modulus) -> res {

                let p := mload(0x40)

                mstore(p, 0x20)                 

                mstore(add(p, 0x20), 0x20)      

                mstore(add(p, 0x40), 0x20)      

                mstore(add(p, 0x60), base)      

                mstore(add(p, 0x80), exponent)  

                mstore(add(p, 0xa0), modulus)   

                

                if iszero(call(not(0), 0x05, 0, p, 0xc0, p, 0x20)) {

                    revert(0, 0)

                }

                res := mload(p)

            }



            let PRIME := 0x30000003000000010000000000000001



            for {} lt(friQueue, friQueueEnd) {friQueue := add(friQueue, 0x60)} {

                let queryIdx := mload(friQueue)

                

                let adjustedQueryIdx := add(queryIdx, evalDomainSize)

                mstore(friQueue, adjustedQueryIdx)



                

                mstore(evalPointsPtr, expmod(evalDomainGenerator,

                                             bitReverse(queryIdx, log_evalDomainSize),

                                             PRIME))

                evalPointsPtr := add(evalPointsPtr, 0x20)

            }

        }

    }



    function readQueryResponsesAndDecommit(

        uint256[] memory ctx, uint256 nColumns, uint256 proofDataPtr, bytes32 merkleRoot)

         internal view {

        require(nColumns <= getNColumnsInTrace() + getNColumnsInComposition(), "Too many columns.");



        uint256 nUniqueQueries = ctx[MM_N_UNIQUE_QUERIES];

        uint256 channelPtr = getPtr(ctx, MM_CHANNEL);

        uint256 friQueue = getPtr(ctx, MM_FRI_QUEUE);

        uint256 friQueueEnd = friQueue + nUniqueQueries * 0x60;

        uint256 merkleQueuePtr = getPtr(ctx, MM_MERKLE_QUEUE);

        uint256 rowSize = 0x20 * nColumns;

        uint256 lhashMask = getHashMask();



        assembly {

            let proofPtr := mload(channelPtr)

            let merklePtr := merkleQueuePtr



            for {} lt(friQueue, friQueueEnd) {friQueue := add(friQueue, 0x60)} {

                let merkleLeaf := and(keccak256(proofPtr, rowSize), lhashMask)

                if eq(rowSize, 0x20) {

                    

                    merkleLeaf := mload(proofPtr)

                }



                

                mstore(merklePtr, mload(friQueue))

                mstore(add(merklePtr, 0x20), merkleLeaf)

                merklePtr := add(merklePtr, 0x40)



                

                

                for {let proofDataChunk_end := add(proofPtr, rowSize)}

                        lt(proofPtr, proofDataChunk_end)

                        {proofPtr := add(proofPtr, 0x20)} {

                    mstore(proofDataPtr, mload(proofPtr))

                    proofDataPtr := add(proofDataPtr, 0x20)

                }

            }



            mstore(channelPtr, proofPtr)

        }



        verify(channelPtr, merkleQueuePtr, merkleRoot, nUniqueQueries);

    }



    

    function computeFirstFriLayer(uint256[] memory ctx) internal {

        adjustQueryIndicesAndPrepareEvalPoints(ctx);

        

        readQueryResponsesAndDecommit(

            ctx, getNColumnsInTrace(), getPtr(ctx, MM_TRACE_QUERY_RESPONSES),

            bytes32(ctx[MM_TRACE_COMMITMENT]));

        



        readQueryResponsesAndDecommit(

            ctx, getNColumnsInComposition(), getPtr(ctx, MM_COMPOSITION_QUERY_RESPONSES),

            bytes32(ctx[MM_OODS_COMMITMENT]));



        



        address oodsAddress = oodsContractAddress;

        uint256 friQueue = getPtr(ctx, MM_FRI_QUEUE);

        uint256 returnDataSize = MAX_N_QUERIES * 0x60;

        assembly {

            

            if iszero(staticcall(not(0), oodsAddress, ctx,

                                  mul(add(mload(ctx), 1), 0x20),

                                 friQueue, returnDataSize)) {

              returndatacopy(0, 0, returndatasize)

              revert(0, returndatasize)

            }

        }

        

    }



    

    function readLastFriLayer(uint256[] memory ctx)

        internal pure

    {

        uint256 lmmChannel = MM_CHANNEL;

        uint256 friLastLayerDegBound = ctx[MM_FRI_LAST_LAYER_DEG_BOUND];

        uint256 lastLayerPtr;

        uint256 badInput = 0;



        assembly {

            let primeMinusOne := 0x30000003000000010000000000000000

            let channelPtr := add(add(ctx, 0x20), mul(lmmChannel, 0x20))

            lastLayerPtr := mload(channelPtr)



            

            let length := mul(friLastLayerDegBound, 0x20)

            let lastLayerEnd := add(lastLayerPtr, length)

            for { let coefsPtr := lastLayerPtr } lt(coefsPtr, lastLayerEnd)

                { coefsPtr := add(coefsPtr, 0x20) } {

                badInput := or(badInput, gt(mload(coefsPtr), primeMinusOne))

            }



            

            

            

            

            let newDigestPtr := sub(lastLayerPtr, 0x20)

            let digestPtr := add(channelPtr, 0x20)

            

            mstore(newDigestPtr, mload(digestPtr))



            

            mstore(digestPtr, keccak256(newDigestPtr, add(length, 0x20)))

            

            mstore(add(channelPtr, 0x40), 0)



            

            mstore(channelPtr, lastLayerEnd)

        }



        require(badInput == 0, "Invalid field element.");

        ctx[MM_FRI_LAST_LAYER_PTR] = lastLayerPtr;

    }



    function verifyProof(

        uint256[] memory proofParams, uint256[] memory proof, uint256[] memory publicInput)

        internal {

        

        uint256[] memory ctx = initVerifierParams(publicInput, proofParams);

        uint256 channelPtr = getChannelPtr(ctx);



        initChannel(channelPtr,  getProofPtr(proof), getPublicInputHash(publicInput));

        



        

        ctx[MM_TRACE_COMMITMENT] = uint256(readHash(channelPtr, true));

        VerifierChannel.sendFieldElements(

            channelPtr, getNCoefficients(), getPtr(ctx, getMmCoefficients()));

        



        ctx[MM_OODS_COMMITMENT] = uint256(readHash(channelPtr, true));



        

        VerifierChannel.sendFieldElements(channelPtr, 1, getPtr(ctx, MM_OODS_POINT));



        

        uint256 lmmOodsValues = getMmOodsValues();

        for (uint256 i = lmmOodsValues; i < lmmOodsValues+getNOodsValues(); i++) {

            ctx[i] = VerifierChannel.readFieldElement(channelPtr, true);

        }

        

        oodsConsistencyCheck(ctx);

        

        VerifierChannel.sendFieldElements(

            channelPtr, getNOodsCoefficients(), getPtr(ctx, getMmOodsCoefficients()));

        

        ctx[MM_FRI_COMMITMENTS] = uint256(VerifierChannel.readHash(channelPtr, true));



        uint256 nFriSteps = getFriSteps(ctx).length;

        uint256 fri_evalPointPtr = getPtr(ctx, MM_FRI_EVAL_POINTS);

        for (uint256 i = 1; i < nFriSteps - 1; i++) {

            VerifierChannel.sendFieldElements(channelPtr, 1, fri_evalPointPtr + i * 0x20);

            ctx[MM_FRI_COMMITMENTS + i] = uint256(VerifierChannel.readHash(channelPtr, true));

        }



        

        VerifierChannel.sendFieldElements(

            channelPtr, 1, getPtr(ctx, MM_FRI_EVAL_POINTS + nFriSteps - 1));



        

        readLastFriLayer(ctx);



        

        

        VerifierChannel.verifyProofOfWork(channelPtr, ctx[MM_PROOF_OF_WORK_BITS]);

        ctx[MM_N_UNIQUE_QUERIES] = VerifierChannel.sendRandomQueries(

            channelPtr, ctx[MM_N_UNIQUE_QUERIES], ctx[MM_EVAL_DOMAIN_SIZE] - 1,

            getPtr(ctx, MM_FRI_QUEUE), 0x60);

        



        computeFirstFriLayer(ctx);



        friVerifyLayers(ctx);

    }

}

contract MimcVerifier is StarkParameters, StarkVerifier, FactRegistry, PublicInputOffsets{



    MimcConstraintPoly constraintPoly;

    PeriodicColumnContract[20] constantsCols;

    uint256 internal constant PUBLIC_INPUT_SIZE = 5;



    constructor(

        address[] memory auxPolynomials,

        MimcOods oodsContract,

        uint256 numSecurityBits_,

        uint256 minProofOfWorkBits_)

        StarkVerifier(

            numSecurityBits_,

            minProofOfWorkBits_

        )

        public {

        constraintPoly = MimcConstraintPoly(auxPolynomials[0]);

        for (uint256 i = 0; i < 20; i++) {

            constantsCols[i] = PeriodicColumnContract(auxPolynomials[i+1]);

        }

        oodsContractAddress = address(oodsContract);

    }



    function verifyProofAndRegister(

        uint256[] calldata proofParams,

        uint256[] calldata proof,

        uint256[] calldata publicInput

    )

        external

    {

        verifyProof(proofParams, proof, publicInput);

        registerFact(

            keccak256(

                abi.encodePacked(

                    10 * 2**publicInput[OFFSET_LOG_TRACE_LENGTH] - 1,

                    publicInput[OFFSET_VDF_OUTPUT_X],

                    publicInput[OFFSET_VDF_OUTPUT_Y],

                    publicInput[OFFSET_VDF_INPUT_X],

                    publicInput[OFFSET_VDF_INPUT_Y]

                )

            )

        );

    }



    function getNColumnsInTrace() internal pure returns (uint256) {

        return N_COLUMNS_IN_MASK;

    }



    function getNColumnsInComposition() internal pure returns (uint256) {

        return CONSTRAINTS_DEGREE_BOUND;

    }



    function getMmCoefficients() internal pure returns (uint256) {

        return MM_COEFFICIENTS;

    }



    function getMmOodsValues() internal pure returns (uint256) {

        return MM_OODS_VALUES;

    }



    function getMmOodsCoefficients() internal pure returns (uint256) {

        return MM_OODS_COEFFICIENTS;

    }



    function getNCoefficients() internal pure returns (uint256) {

        return N_COEFFICIENTS;

    }



    function getNOodsValues() internal pure returns (uint256) {

        return N_OODS_VALUES;

    }



    function getNOodsCoefficients() internal pure returns (uint256) {

        return N_OODS_COEFFICIENTS;

    }



    function airSpecificInit(uint256[] memory publicInput)

        internal returns (uint256[] memory ctx, uint256 logTraceLength)

    {

        require(publicInput.length == PUBLIC_INPUT_SIZE,

            "INVALID_PUBLIC_INPUT_LENGTH"

        );

        ctx = new uint256[](MM_CONTEXT_SIZE);



        

        

        

        ctx[MM_INPUT_VALUE_A] = publicInput[OFFSET_VDF_OUTPUT_X];

        ctx[MM_INPUT_VALUE_B] = publicInput[OFFSET_VDF_OUTPUT_Y];

        ctx[MM_OUTPUT_VALUE_A] = publicInput[OFFSET_VDF_INPUT_X];

        ctx[MM_OUTPUT_VALUE_B] = publicInput[OFFSET_VDF_INPUT_Y];



        

        ctx[MM_MAT00] = 0x109bbc181e07a285856e0d8bde02619;

        ctx[MM_MAT01] = 0x1eb8859b1b789cd8a80927a32fdf41f7;

        ctx[MM_MAT10] = 0xdc8eaac802c8f9cb9dff6ed0728012d;

        ctx[MM_MAT11] = 0x2c18506f35eab63b58143a34181c89e;



        logTraceLength = publicInput[OFFSET_LOG_TRACE_LENGTH];

        require(logTraceLength <= 50, "logTraceLength must not exceed 50.");

    }



    function getPublicInputHash(uint256[] memory publicInput)

        internal pure

        returns (bytes32) {

        return keccak256(

            abi.encodePacked(

                uint64(2 ** publicInput[OFFSET_LOG_TRACE_LENGTH]),

                publicInput[OFFSET_VDF_OUTPUT_X],

                publicInput[OFFSET_VDF_OUTPUT_Y],

                publicInput[OFFSET_VDF_INPUT_X],

                publicInput[OFFSET_VDF_INPUT_Y])

        );

    }



    

    function oodsConsistencyCheck(uint256[] memory ctx)

        internal {

        uint256 oodsPoint = ctx[MM_OODS_POINT];

        uint256 nRows = 256;

        uint256 zPointPow = fpow(oodsPoint, ctx[MM_TRACE_LENGTH] / nRows);



        ctx[MM_PERIODIC_COLUMN__CONSTS0_A] = constantsCols[0].compute(zPointPow);

        ctx[MM_PERIODIC_COLUMN__CONSTS1_A] = constantsCols[1].compute(zPointPow);

        ctx[MM_PERIODIC_COLUMN__CONSTS2_A] = constantsCols[2].compute(zPointPow);

        ctx[MM_PERIODIC_COLUMN__CONSTS3_A] = constantsCols[3].compute(zPointPow);

        ctx[MM_PERIODIC_COLUMN__CONSTS4_A] = constantsCols[4].compute(zPointPow);

        ctx[MM_PERIODIC_COLUMN__CONSTS5_A] = constantsCols[5].compute(zPointPow);

        ctx[MM_PERIODIC_COLUMN__CONSTS6_A] = constantsCols[6].compute(zPointPow);

        ctx[MM_PERIODIC_COLUMN__CONSTS7_A] = constantsCols[7].compute(zPointPow);

        ctx[MM_PERIODIC_COLUMN__CONSTS8_A] = constantsCols[8].compute(zPointPow);

        ctx[MM_PERIODIC_COLUMN__CONSTS9_A] = constantsCols[9].compute(zPointPow);



        ctx[MM_PERIODIC_COLUMN__CONSTS0_B] = constantsCols[10].compute(zPointPow);

        ctx[MM_PERIODIC_COLUMN__CONSTS1_B] = constantsCols[11].compute(zPointPow);

        ctx[MM_PERIODIC_COLUMN__CONSTS2_B] = constantsCols[12].compute(zPointPow);

        ctx[MM_PERIODIC_COLUMN__CONSTS3_B] = constantsCols[13].compute(zPointPow);

        ctx[MM_PERIODIC_COLUMN__CONSTS4_B] = constantsCols[14].compute(zPointPow);

        ctx[MM_PERIODIC_COLUMN__CONSTS5_B] = constantsCols[15].compute(zPointPow);

        ctx[MM_PERIODIC_COLUMN__CONSTS6_B] = constantsCols[16].compute(zPointPow);

        ctx[MM_PERIODIC_COLUMN__CONSTS7_B] = constantsCols[17].compute(zPointPow);

        ctx[MM_PERIODIC_COLUMN__CONSTS8_B] = constantsCols[18].compute(zPointPow);

        ctx[MM_PERIODIC_COLUMN__CONSTS9_B] = constantsCols[19].compute(zPointPow);



        uint256 compositionFromTraceValue;

        address lconstraintPoly = address(constraintPoly);

        uint256 offset = 0x20 * (1 + MM_CONSTRAINT_POLY_ARGS_START);

        uint256 size = 0x20 * (MM_CONSTRAINT_POLY_ARGS_END - MM_CONSTRAINT_POLY_ARGS_START);

        assembly {

            

            let p := mload(0x40)

            if iszero(staticcall(not(0), lconstraintPoly, add(ctx, offset), size, p, 0x20)) {

              returndatacopy(0, 0, returndatasize)

              revert(0, returndatasize)

            }

            compositionFromTraceValue := mload(p)

        }



        uint256 claimedComposition = fadd(

            ctx[MM_OODS_VALUES + MASK_SIZE],

            fmul(oodsPoint, ctx[MM_OODS_VALUES + MASK_SIZE + 1]));



        require(

            compositionFromTraceValue == claimedComposition,

            "claimedComposition does not match trace");

    }

}
