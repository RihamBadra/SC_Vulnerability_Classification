pragma solidity 0.5.15;

contract IFactRegistry {

    

    function isValid(bytes32 fact)

        external view

        returns(bool);

}

contract IMerkleVerifier {

    uint256 constant internal MAX_N_MERKLE_VERIFIER_QUERIES =  128;



    function verify(

        uint256 channelPtr,

        uint256 queuePtr,

        bytes32 root,

        uint256 n)

        internal view

        returns (bytes32 hash);

}

contract IQueryableFactRegistry is IFactRegistry {



    

    function hasRegisteredFact()

        external view

        returns(bool);



}

contract MerkleVerifier is IMerkleVerifier {



    function getHashMask() internal pure returns(uint256) {

        

        return 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF000000000000000000000000;

    }



    

    function verify(

        uint256 channelPtr,

        uint256 queuePtr,

        bytes32 root,

        uint256 n)

        internal view

        returns (bytes32 hash)

    {

        uint256 lhashMask = getHashMask();

        require(n <= MAX_N_MERKLE_VERIFIER_QUERIES, "TOO_MANY_MERKLE_QUERIES");



        assembly {

            

            

            let hashesPtr := add(queuePtr, 0x20)

            let queueSize := mul(n, 0x40)

            let slotSize := 0x40



            

            let rdIdx := 0

            let wrIdx := 0 



            

            let index := mload(add(rdIdx, queuePtr))

            let proofPtr := mload(channelPtr)



            

            for { } gt(index, 1) { } {

                let siblingIndex := xor(index, 1)

                

                let sibblingOffset := mulmod(siblingIndex, 0x20, 0x40)



                

                

                

                mstore(xor(0x20, sibblingOffset), mload(add(rdIdx, hashesPtr)))

                rdIdx := addmod(rdIdx, slotSize, queueSize)



                

                

                

                let newHashPtr := proofPtr

                proofPtr := add(proofPtr, 0x20)



                

                

                

                

                mstore(add(wrIdx, queuePtr), div(index, 2))



                

                index := mload(add(rdIdx, queuePtr))

                if eq(index, siblingIndex) {

                    

                    newHashPtr := add(rdIdx, hashesPtr)

                    

                    proofPtr := sub(proofPtr, 0x20)

                    rdIdx := addmod(rdIdx, slotSize, queueSize)



                    

                    

                    

                    

                    index := mload(add(rdIdx, queuePtr))

                }



                mstore(sibblingOffset, mload(newHashPtr))



                

                mstore(add(wrIdx, hashesPtr), and(lhashMask, keccak256(0x00, 0x40)))

                wrIdx := addmod(wrIdx, slotSize, queueSize)

            }

            hash := mload(add(rdIdx, hashesPtr))



            

            mstore(channelPtr, proofPtr)

        }

        

        require(hash == root, "INVALID_MERKLE_PROOF");

    }

}

contract FactRegistry is IQueryableFactRegistry {

    

    mapping (bytes32 => bool) private verifiedFact;



    

    bool anyFactRegistered;



    

    function isValid(bytes32 fact)

        external view

        returns(bool)

    {

        return _factCheck(fact);

    }





    

    function _factCheck(bytes32 fact)

        internal view

        returns(bool)

    {

        return verifiedFact[fact];

    }



    function registerFact(

        bytes32 factHash

        )

        internal

    {

        

        verifiedFact[factHash] = true;



        

        if (!anyFactRegistered) {

            anyFactRegistered = true;

        }

    }



    

    function hasRegisteredFact()

        external view

        returns(bool)

    {

        return anyFactRegistered;

    }



}

contract MerkleStatementContract is MerkleVerifier, FactRegistry {

    

    

    function verifyMerkle(

        uint256[] memory merkleView,

        uint256[] memory initialMerkleQueue,

        uint256 height,

        uint256 expectedRoot

        )

        public

    {

        require(height < 200, "Height must be < 200.");

        require(

            initialMerkleQueue.length <= MAX_N_MERKLE_VERIFIER_QUERIES * 2,

            "TOO_MANY_MERKLE_QUERIES");



        uint256 merkleQueuePtr;

        uint256 channelPtr;

        uint256 nQueries;

        uint256 dataToHashPtr;

        uint256 badInput = 0;



        assembly {

            

            let merkleViewPtr := add(merkleView, 0x20)

            

            channelPtr := mload(0x40) 

            

            

            mstore(channelPtr, merkleViewPtr)

            

            merkleQueuePtr := add(initialMerkleQueue, 0x20)

            

            nQueries := div(mload(initialMerkleQueue), 0x2)

            

            let initialMerkleQueueEndPtr := add(merkleQueuePtr, mul(nQueries, 0x40))

            

            dataToHashPtr := add(channelPtr, 0x20) 



            

            

            



            

            let idxLowerLimit := shl(height, 1)

            for { } lt(merkleQueuePtr, initialMerkleQueueEndPtr) { } {

                let curIdx := mload(merkleQueuePtr)

                

                badInput := or(badInput, lt(curIdx, idxLowerLimit))



                

                idxLowerLimit := add(curIdx, 1)



                

                mstore(dataToHashPtr, curIdx)

                mstore(add(dataToHashPtr, 0x20), mload(add(merkleQueuePtr, 0x20)))



                dataToHashPtr := add(dataToHashPtr, 0x40)

                merkleQueuePtr := add(merkleQueuePtr, 0x40)

            }



            

            

            

            

            badInput := or(badInput, gt(idxLowerLimit, shl(height, 2)))



            

            merkleQueuePtr := add(initialMerkleQueue, 0x20)

            

            

            mstore(0x40, add(dataToHashPtr, 0x20))

        }

        require(badInput == 0, "INVALID_MERKLE_INDICES");

        bytes32 resRoot = verify(channelPtr, merkleQueuePtr, bytes32(expectedRoot), nQueries);

        bytes32 factHash;

        assembly {

            

            mstore(dataToHashPtr, resRoot)

            

            dataToHashPtr := add(channelPtr, 0x20)

            factHash := keccak256(dataToHashPtr, add(mul(nQueries, 0x40), 0x20))

        }



        registerFact(factHash);

    }

}
