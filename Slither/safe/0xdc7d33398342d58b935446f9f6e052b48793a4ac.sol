pragma solidity 0.5.16;

interface IParams {

    function isLiquidation(uint256 price) external view returns (bool);

}

interface IEsm {

    function shutdown() external;



    function isClosed() external view returns (bool);

}

contract Owned {

    address public owner;

    address public nominatedOwner;



    constructor(address _owner) public {

        require(_owner != address(0), "Owner address cannot be 0");

        owner = _owner;

        emit OwnerChanged(address(0), _owner);

    }



    function nominateNewOwner(address _owner) external onlyOwner {

        nominatedOwner = _owner;

        emit OwnerNominated(_owner);

    }



    function acceptOwnership() external {

        require(

            msg.sender == nominatedOwner,

            "You must be nominated before you can accept ownership"

        );

        emit OwnerChanged(owner, nominatedOwner);

        owner = nominatedOwner;

        nominatedOwner = address(0);

    }



    modifier onlyOwner {

        require(

            msg.sender == owner,

            "Only the contract owner may perform this action"

        );

        _;

    }



    event OwnerNominated(address newOwner);

    event OwnerChanged(address oldOwner, address newOwner);

}

library SafeMath {

    

    function add(uint256 a, uint256 b) internal pure returns (uint256) {

        uint256 c = a + b;

        require(c >= a, "SafeMath: addition overflow");



        return c;

    }



    

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {

        return sub(a, b, "SafeMath: subtraction overflow");

    }



    

    function sub(

        uint256 a,

        uint256 b,

        string memory errorMessage

    ) internal pure returns (uint256) {

        require(b <= a, errorMessage);

        uint256 c = a - b;



        return c;

    }



    

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {

        

        

        

        if (a == 0) {

            return 0;

        }



        uint256 c = a * b;

        require(c / a == b, "SafeMath: multiplication overflow");



        return c;

    }



    

    function div(uint256 a, uint256 b) internal pure returns (uint256) {

        return div(a, b, "SafeMath: division by zero");

    }



    

    function div(

        uint256 a,

        uint256 b,

        string memory errorMessage

    ) internal pure returns (uint256) {

        

        require(b > 0, errorMessage);

        uint256 c = a / b;

        



        return c;

    }



    

    function mod(uint256 a, uint256 b) internal pure returns (uint256) {

        return mod(a, b, "SafeMath: modulo by zero");

    }



    

    function mod(

        uint256 a,

        uint256 b,

        string memory errorMessage

    ) internal pure returns (uint256) {

        require(b != 0, errorMessage);

        return a % b;

    }

}

contract WhiteList is Owned {

    

    mapping(address => uint256) public whiter;



    

    event AppendWhiter(address adder);



    

    event RemoveWhiter(address remover);



    

    constructor() internal {

        appendWhiter(owner);

    }



    modifier onlyWhiter() {

        require(isWhiter(), "WhiteList: msg.sender not in whilteList.");

        _;

    }



    

    function appendWhiter(address account) public onlyOwner {

        require(account != address(0), "WhiteList: address not zero");

        require(

            !isWhiter(account),

            "WhiteListe: the account exsit whilteList yet"

        );

        whiter[account] = 1;

        emit AppendWhiter(account);

    }



    

    function removeWhiter(address account) public onlyOwner {

        require(

            isWhiter(account),

            "WhiteListe: the account not exist whilteList"

        );

        delete whiter[account];

        emit RemoveWhiter(account);

    }



    

    function isWhiter(address account) public view returns (bool) {

        return whiter[account] == 1;

    }



    

    function isWhiter() public view returns (bool) {

        return isWhiter(msg.sender);

    }

}

contract Oracle is Owned, WhiteList {

    using SafeMath for uint256;



    

    uint256 public val;

    

    uint256 public time;



    

    bytes32 name;



    

    event OracleUpdate(uint256 val, uint256 time);



    

    IParams public params;



    

    IEsm public esm;



    

    constructor(address _params, address _esm) public Owned(msg.sender) {

        params = IParams(_params);

        esm = IEsm(_esm);

        name = "OIN-USDT";

    }



    

    function poke(uint256 price) public onlyWhiter {

        require(!esm.isClosed(), "System closed yet.");



        val = price;

        time = block.timestamp;



        if (params.isLiquidation(price)) {

            esm.shutdown();

        } else {

            emit OracleUpdate(val, time);

        }

    }



    

    function peek() public view returns (uint256) {

        return val;

    }

}
