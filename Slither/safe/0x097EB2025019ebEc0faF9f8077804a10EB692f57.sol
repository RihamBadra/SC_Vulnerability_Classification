

pragma solidity ^0.8.0;







library SafeMath {
    
    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        unchecked {
            uint256 c = a + b;
            if (c < a) return (false, 0);
            return (true, c);
        }
    }

    
    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        unchecked {
            if (b > a) return (false, 0);
            return (true, a - b);
        }
    }

    
    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        unchecked {
            
            
            
            if (a == 0) return (true, 0);
            uint256 c = a * b;
            if (c / a != b) return (false, 0);
            return (true, c);
        }
    }

    
    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        unchecked {
            if (b == 0) return (false, 0);
            return (true, a / b);
        }
    }

    
    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        unchecked {
            if (b == 0) return (false, 0);
            return (true, a % b);
        }
    }

    
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        return a + b;
    }

    
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        return a - b;
    }

    
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        return a * b;
    }

    
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        return a / b;
    }

    
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        return a % b;
    }

    
    function sub(
        uint256 a,
        uint256 b,
        string memory errorMessage
    ) internal pure returns (uint256) {
        unchecked {
            require(b <= a, errorMessage);
            return a - b;
        }
    }

    
    function div(
        uint256 a,
        uint256 b,
        string memory errorMessage
    ) internal pure returns (uint256) {
        unchecked {
            require(b > 0, errorMessage);
            return a / b;
        }
    }

    
    function mod(
        uint256 a,
        uint256 b,
        string memory errorMessage
    ) internal pure returns (uint256) {
        unchecked {
            require(b > 0, errorMessage);
            return a % b;
        }
    }
}



abstract contract Context {
    function _msgSender() internal view virtual returns (address) {
        return msg.sender;
    }

    function _msgData() internal view virtual returns (bytes calldata) {
        return msg.data;
    }
}



abstract contract Ownable is Context {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    
    constructor() {
        _setOwner(_msgSender());
    }

    
    function owner() public view virtual returns (address) {
        return _owner;
    }

    
    modifier onlyOwner() {
        require(owner() == _msgSender(), "Ownable: caller is not the owner");
        _;
    }

    
    function renounceOwnership() public virtual onlyOwner {
        _setOwner(address(0));
    }

    
    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), "Ownable: new owner is the zero address");
        _setOwner(newOwner);
    }

    function _setOwner(address newOwner) private {
        address oldOwner = _owner;
        _owner = newOwner;
        emit OwnershipTransferred(oldOwner, newOwner);
    }
}

contract Poster is Ownable{
    address public poster;
    event PosterChanged(address originalPoster, address newPoster);

    modifier onlyPoster(){
        require(poster == _msgSender(), "not poster");
        _;
    }

    function setPoster(address _poster) public onlyOwner{
        require(_poster != address(0), "address should not be 0");
        emit PosterChanged(poster, _poster);
        poster = _poster;
    }
}

contract MiningNFTMintingLimitationData is Poster{
    using SafeMath for uint256;

    uint256 public totalMintLimitationInTiB;
    
    mapping(string=>uint) public minerMintAmountLimitation; 

    event TotalLimitationChanged(uint256 originalLimitation, uint256 newLimitation);
    event MinerMintAmountLimitationChanged(string minerId, uint256 originalLimitation, uint256 newLimitation);

    function setTotalMintLimitationInTiB(uint256 _totalMintLimitationInTiB) public onlyPoster{
        require(_totalMintLimitationInTiB > 0, "value should be >0");
        uint256 originalLimitation = totalMintLimitationInTiB;
        totalMintLimitationInTiB = _totalMintLimitationInTiB;
        emit TotalLimitationChanged(originalLimitation, totalMintLimitationInTiB);
    }

    
    function increaseTotalLimitation(uint256 _limitationDelta) public onlyPoster{
        uint256 originalLimitation = totalMintLimitationInTiB;
        totalMintLimitationInTiB = totalMintLimitationInTiB.add(_limitationDelta);
        emit TotalLimitationChanged(originalLimitation, totalMintLimitationInTiB);
    }

    function decreaseTotalLimitation(uint256 _limitationDelta) public onlyPoster{
        uint256 originalLimitation = totalMintLimitationInTiB;
        if(_limitationDelta <= totalMintLimitationInTiB){
            totalMintLimitationInTiB = totalMintLimitationInTiB.sub(_limitationDelta);
        }else{
            totalMintLimitationInTiB = 0;
        }
        
        emit TotalLimitationChanged(originalLimitation, totalMintLimitationInTiB);
    }

    function increaseMinerLimitation(string memory _minerId, uint256 _minerLimitationDelta) public onlyPoster{
        uint256 originalLimitation = minerMintAmountLimitation[_minerId];
        minerMintAmountLimitation[_minerId] = minerMintAmountLimitation[_minerId].add(_minerLimitationDelta);
        increaseTotalLimitation(_minerLimitationDelta);
        emit MinerMintAmountLimitationChanged(_minerId, originalLimitation, minerMintAmountLimitation[_minerId]);
    }

    function decreaseMinerLimitation(string memory _minerId, uint256 _minerLimitationDelta) public onlyPoster{
        uint originalLimitation = minerMintAmountLimitation[_minerId];
        if(_minerLimitationDelta <= originalLimitation ){
            minerMintAmountLimitation[_minerId] = originalLimitation.sub(_minerLimitationDelta);
        }else{
            minerMintAmountLimitation[_minerId] = 0;
            _minerLimitationDelta = originalLimitation;
        }
        
        emit MinerMintAmountLimitationChanged(_minerId, originalLimitation, minerMintAmountLimitation[_minerId]);
        decreaseTotalLimitation(_minerLimitationDelta);
    }

    function setMinerMintAmountLimitationBatch(string[] memory minerIds, uint256[] memory limitations) public onlyPoster{
        require(minerIds.length==limitations.length, "array length not equal");
        for(uint i=0; i<minerIds.length; i++){
            uint256 originalLimitation = minerMintAmountLimitation[minerIds[i]];
            totalMintLimitationInTiB = totalMintLimitationInTiB.sub(originalLimitation).add(limitations[i]);
            emit TotalLimitationChanged(originalLimitation, totalMintLimitationInTiB);

            minerMintAmountLimitation[minerIds[i]] = limitations[i];
            emit MinerMintAmountLimitationChanged(minerIds[i], originalLimitation, limitations[i]);
        }
    }

    function setMinerMintAmountLimitation(string memory _minerId, uint256 _limitation) public onlyPoster{
        uint256 originalLimitation = minerMintAmountLimitation[_minerId];
        totalMintLimitationInTiB = totalMintLimitationInTiB.sub(originalLimitation).add(_limitation);
        minerMintAmountLimitation[_minerId] = _limitation;
        emit MinerMintAmountLimitationChanged(_minerId, originalLimitation, _limitation);
        emit TotalLimitationChanged(originalLimitation, totalMintLimitationInTiB);
    }

}