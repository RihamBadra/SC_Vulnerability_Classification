

pragma solidity 0.6.0;

contract ParkCryption {
  
  string public name = "ParkCryption";
  string public symbol = "PARK";
  uint8 public decimals = 18;
  address public _owner;
  uint256 public initialSupply = 1000000000000000000000000000;
  uint256 public totalSupply;
  
  
  mapping (address => uint256) public _balances;
  mapping (address => mapping (address => uint256)) public _allowed;
  
  
  event Transfer(
    address indexed from,
    address indexed to,
    uint256 value
  );
  
  
  event Approval(
    address indexed owner,
    address indexed spender,
    uint256 value
  );
  
  
  modifier onlyOwner() {
    require(isOwner());
    _;
  }
  
  
  constructor() public {
    _owner = msg.sender;
    _mint(msg.sender, initialSupply);
  }
  
  
  function balanceOf(address owner) external view returns (uint256) {
    return _balances[owner];
  }
  
  
  function isOwner() public view returns(bool) {
    return msg.sender == _owner;
  }
  
  
  function transfer(address to, uint256 value) external returns (bool success) {
    _transfer(msg.sender, to, value);
    return true;
  }
  
  
  
  
  
  
  function transferFrom(address from, address to, uint256 value)
    external
    returns (bool success)
  {
    require(value <= _allowed[from][msg.sender]);
    _allowed[from][msg.sender] -= value; 
    _transfer(from, to, value);
    return true;
  }
  
  
  function _transfer(address from, address to, uint256 value) internal {
    require(value <= _balances[from]);
    require(to != address(0));
    _balances[from] -= value;
    _balances[to] += value;
    emit Transfer(from, to, value);
  }
  
  
  function approve(address spender, uint256 value) external onlyOwner returns (bool success) {
    require(spender != address(0));
    _allowed[msg.sender][spender] = value;
    emit Approval(msg.sender, spender, value);
    return true;
  }
  
  
  function allowance(address owner, address spender) external onlyOwner view returns (uint256) {
    return _allowed[owner][spender];
  }
  
  
  
  
  function increaseAllowance(address spender, uint256 addedValue)
    external
    onlyOwner
    returns (bool)
  {
    require(spender != address(0));
    _allowed[msg.sender][spender] = (
      _allowed[msg.sender][spender] + addedValue);
    emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);
    return true;
  }

  
  
  
  function decreaseAllowance(address spender, uint256 subtractedValue)
    external
    onlyOwner
    returns (bool)
  {
    require(spender != address(0));
    _allowed[msg.sender][spender] = (
      _allowed[msg.sender][spender] - subtractedValue);
    emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);
    return true;
  }
  
  
  function _mint(address account, uint256 value) internal {
    require(account != address(0));
    _balances[account] = value;      
    totalSupply = value;
    emit Transfer(address(0), account, value);
  }
  
}