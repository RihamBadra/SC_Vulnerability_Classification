





pragma solidity =0.6.7;






















abstract contract SAFEEngineLike_7 {
    function coinBalance(address) virtual public view returns (uint256);
    function collateralTypes(bytes32) virtual public view returns (
        uint256 debtAmount,        
        uint256 accumulatedRate,   
        uint256 safetyPrice,       
        uint256 debtCeiling,       
        uint256 debtFloor,         
        uint256 liquidationPrice   
    );
    function safes(bytes32,address) virtual public view returns (
        uint256 lockedCollateral, 
        uint256 generatedDebt     
    );
    function globalDebt() virtual public returns (uint256);
    function transferInternalCoins(address src, address dst, uint256 rad) virtual external;
    function approveSAFEModification(address) virtual external;
    function transferCollateral(bytes32 collateralType, address src, address dst, uint256 wad) virtual external;
    function confiscateSAFECollateralAndDebt(bytes32 collateralType, address safe, address collateralSource, address debtDestination, int256 deltaCollateral, int256 deltaDebt) virtual external;
    function createUnbackedDebt(address debtDestination, address coinDestination, uint256 rad) virtual external;
    function disableContract() virtual external;
}
abstract contract LiquidationEngineLike_2 {
    function collateralTypes(bytes32) virtual public view returns (
        address collateralAuctionHouse,
        uint256 liquidationPenalty,     
        uint256 liquidationQuantity     
    );
    function disableContract() virtual external;
}
abstract contract StabilityFeeTreasuryLike {
    function disableContract() virtual external;
}
abstract contract AccountingEngineLike_2 {
    function disableContract() virtual external;
}
abstract contract CoinSavingsAccountLike {
    function disableContract() virtual external;
}
abstract contract CollateralAuctionHouseLike_1 {
    function bidAmount(uint256 id) virtual public view returns (uint256);
    function raisedAmount(uint256 id) virtual public view returns (uint256);
    function remainingAmountToSell(uint256 id) virtual public view returns (uint256);
    function forgoneCollateralReceiver(uint256 id) virtual public view returns (address);
    function amountToRaise(uint256 id) virtual public view returns (uint256);
    function terminateAuctionPrematurely(uint256 auctionId) virtual external;
}
abstract contract OracleLike_2 {
    function read() virtual public view returns (uint256);
}
abstract contract OracleRelayerLike_2 {
    function redemptionPrice() virtual public returns (uint256);
    function collateralTypes(bytes32) virtual public view returns (
        OracleLike_2 orcl,
        uint256 safetyCRatio,
        uint256 liquidationCRatio
    );
    function disableContract() virtual external;
}



contract GlobalSettlement {
    
    mapping (address => uint256) public authorizedAccounts;
    
    function addAuthorization(address account) external isAuthorized {
        authorizedAccounts[account] = 1;
        emit AddAuthorization(account);
    }
    
    function removeAuthorization(address account) external isAuthorized {
        authorizedAccounts[account] = 0;
        emit RemoveAuthorization(account);
    }
    
    modifier isAuthorized {
        require(authorizedAccounts[msg.sender] == 1, "GlobalSettlement/account-not-authorized");
        _;
    }

    
    SAFEEngineLike_7           public safeEngine;
    LiquidationEngineLike_2    public liquidationEngine;
    AccountingEngineLike_2     public accountingEngine;
    OracleRelayerLike_2        public oracleRelayer;
    CoinSavingsAccountLike   public coinSavingsAccount;
    StabilityFeeTreasuryLike public stabilityFeeTreasury;

    
    uint256  public contractEnabled;
    
    uint256  public shutdownTime;
    
    uint256  public shutdownCooldown;
    
    uint256  public outstandingCoinSupply;                                      

    
    mapping (bytes32 => uint256) public finalCoinPerCollateralPrice;            
    
    mapping (bytes32 => uint256) public collateralShortfall;                    
    
    mapping (bytes32 => uint256) public collateralTotalDebt;                    
    
    mapping (bytes32 => uint256) public collateralCashPrice;                    

    
    mapping (address => uint256)                      public coinBag;           
    
    mapping (bytes32 => mapping (address => uint256)) public coinsUsedToRedeem; 

    
    event AddAuthorization(address account);
    event RemoveAuthorization(address account);
    event ModifyParameters(bytes32 parameter, uint256 data);
    event ModifyParameters(bytes32 parameter, address data);
    event ShutdownSystem();
    event FreezeCollateralType(bytes32 indexed collateralType, uint256 finalCoinPerCollateralPrice);
    event FastTrackAuction(bytes32 indexed collateralType, uint256 auctionId, uint256 collateralTotalDebt);
    event ProcessSAFE(bytes32 indexed collateralType, address safe, uint256 collateralShortfall);
    event FreeCollateral(bytes32 indexed collateralType, address sender, int256 collateralAmount);
    event SetOutstandingCoinSupply(uint256 outstandingCoinSupply);
    event CalculateCashPrice(bytes32 indexed collateralType, uint256 collateralCashPrice);
    event PrepareCoinsForRedeeming(address indexed sender, uint256 coinBag);
    event RedeemCollateral(bytes32 indexed collateralType, address indexed sender, uint256 coinsAmount, uint256 collateralAmount);

    
    constructor() public {
        authorizedAccounts[msg.sender] = 1;
        contractEnabled = 1;
        emit AddAuthorization(msg.sender);
    }

    
    function addition(uint256 x, uint256 y) internal pure returns (uint256 z) {
        z = x + y;
        require(z >= x, "GlobalSettlement/add-overflow");
    }
    function subtract(uint256 x, uint256 y) internal pure returns (uint256 z) {
        require((z = x - y) <= x, "GlobalSettlement/sub-underflow");
    }
    function multiply(uint256 x, uint256 y) internal pure returns (uint256 z) {
        require(y == 0 || (z = x * y) / y == x, "GlobalSettlement/mul-overflow");
    }
    function minimum(uint256 x, uint256 y) internal pure returns (uint256 z) {
        return x <= y ? x : y;
    }
    uint256 constant WAD = 10 ** 18;
    uint256 constant RAY = 10 ** 27;
    function rmultiply(uint256 x, uint256 y) internal pure returns (uint256 z) {
        z = multiply(x, y) / RAY;
    }
    function rdivide(uint256 x, uint256 y) internal pure returns (uint256 z) {
        require(y > 0, "GlobalSettlement/rdiv-by-zero");
        z = multiply(x, RAY) / y;
    }
    function wdivide(uint256 x, uint256 y) internal pure returns (uint256 z) {
        require(y > 0, "GlobalSettlement/wdiv-by-zero");
        z = multiply(x, WAD) / y;
    }

    
    
    function modifyParameters(bytes32 parameter, address data) external isAuthorized {
        require(contractEnabled == 1, "GlobalSettlement/contract-not-enabled");
        if (parameter == "safeEngine") safeEngine = SAFEEngineLike_7(data);
        else if (parameter == "liquidationEngine") liquidationEngine = LiquidationEngineLike_2(data);
        else if (parameter == "accountingEngine") accountingEngine = AccountingEngineLike_2(data);
        else if (parameter == "oracleRelayer") oracleRelayer = OracleRelayerLike_2(data);
        else if (parameter == "coinSavingsAccount") coinSavingsAccount = CoinSavingsAccountLike(data);
        else if (parameter == "stabilityFeeTreasury") stabilityFeeTreasury = StabilityFeeTreasuryLike(data);
        else revert("GlobalSettlement/modify-unrecognized-parameter");
        emit ModifyParameters(parameter, data);
    }
    
    function modifyParameters(bytes32 parameter, uint256 data) external isAuthorized {
        require(contractEnabled == 1, "GlobalSettlement/contract-not-enabled");
        if (parameter == "shutdownCooldown") shutdownCooldown = data;
        else revert("GlobalSettlement/modify-unrecognized-parameter");
        emit ModifyParameters(parameter, data);
    }

    
    
    function shutdownSystem() external isAuthorized {
        require(contractEnabled == 1, "GlobalSettlement/contract-not-enabled");
        contractEnabled = 0;
        shutdownTime = now;
        safeEngine.disableContract();
        liquidationEngine.disableContract();
        
        if (address(stabilityFeeTreasury) != address(0)) {
          stabilityFeeTreasury.disableContract();
        }
        accountingEngine.disableContract();
        oracleRelayer.disableContract();
        if (address(coinSavingsAccount) != address(0)) {
          coinSavingsAccount.disableContract();
        }
        emit ShutdownSystem();
    }
    
    function freezeCollateralType(bytes32 collateralType) external {
        require(contractEnabled == 0, "GlobalSettlement/contract-still-enabled");
        require(finalCoinPerCollateralPrice[collateralType] == 0, "GlobalSettlement/final-collateral-price-already-defined");
        (collateralTotalDebt[collateralType],,,,,) = safeEngine.collateralTypes(collateralType);
        (OracleLike_2 orcl,,) = oracleRelayer.collateralTypes(collateralType);
        
        finalCoinPerCollateralPrice[collateralType] = wdivide(oracleRelayer.redemptionPrice(), uint256(orcl.read()));
        emit FreezeCollateralType(collateralType, finalCoinPerCollateralPrice[collateralType]);
    }
    
    function fastTrackAuction(bytes32 collateralType, uint256 auctionId) external {
        require(finalCoinPerCollateralPrice[collateralType] != 0, "GlobalSettlement/final-collateral-price-not-defined");

        (address auctionHouse_,,)       = liquidationEngine.collateralTypes(collateralType);
        CollateralAuctionHouseLike_1 collateralAuctionHouse = CollateralAuctionHouseLike_1(auctionHouse_);
        (, uint256 accumulatedRate,,,,) = safeEngine.collateralTypes(collateralType);

        uint256 bidAmount                 = collateralAuctionHouse.bidAmount(auctionId);
        uint256 raisedAmount              = collateralAuctionHouse.raisedAmount(auctionId);
        uint256 collateralToSell          = collateralAuctionHouse.remainingAmountToSell(auctionId);
        address forgoneCollateralReceiver = collateralAuctionHouse.forgoneCollateralReceiver(auctionId);
        uint256 amountToRaise             = collateralAuctionHouse.amountToRaise(auctionId);

        safeEngine.createUnbackedDebt(address(accountingEngine), address(accountingEngine), subtract(amountToRaise, raisedAmount));
        safeEngine.createUnbackedDebt(address(accountingEngine), address(this), bidAmount);
        safeEngine.approveSAFEModification(address(collateralAuctionHouse));
        collateralAuctionHouse.terminateAuctionPrematurely(auctionId);

        uint256 debt_ = subtract(amountToRaise, raisedAmount) / accumulatedRate;
        collateralTotalDebt[collateralType] = addition(collateralTotalDebt[collateralType], debt_);
        require(int256(collateralToSell) >= 0 && int256(debt_) >= 0, "GlobalSettlement/overflow");
        safeEngine.confiscateSAFECollateralAndDebt(collateralType, forgoneCollateralReceiver, address(this), address(accountingEngine), int256(collateralToSell), int256(debt_));
        emit FastTrackAuction(collateralType, auctionId, collateralTotalDebt[collateralType]);
    }
    
    function processSAFE(bytes32 collateralType, address safe) external {
        require(finalCoinPerCollateralPrice[collateralType] != 0, "GlobalSettlement/final-collateral-price-not-defined");
        (, uint256 accumulatedRate,,,,) = safeEngine.collateralTypes(collateralType);
        (uint256 safeCollateral, uint256 safeDebt) = safeEngine.safes(collateralType, safe);

        uint256 amountOwed = rmultiply(rmultiply(safeDebt, accumulatedRate), finalCoinPerCollateralPrice[collateralType]);
        uint256 minCollateral = minimum(safeCollateral, amountOwed);
        collateralShortfall[collateralType] = addition(
            collateralShortfall[collateralType],
            subtract(amountOwed, minCollateral)
        );

        require(minCollateral <= 2**255 && safeDebt <= 2**255, "GlobalSettlement/overflow");
        safeEngine.confiscateSAFECollateralAndDebt(
            collateralType,
            safe,
            address(this),
            address(accountingEngine),
            -int256(minCollateral),
            -int256(safeDebt)
        );

        emit ProcessSAFE(collateralType, safe, collateralShortfall[collateralType]);
    }
    
    function freeCollateral(bytes32 collateralType) external {
        require(contractEnabled == 0, "GlobalSettlement/contract-still-enabled");
        (uint256 safeCollateral, uint256 safeDebt) = safeEngine.safes(collateralType, msg.sender);
        require(safeDebt == 0, "GlobalSettlement/safe-debt-not-zero");
        require(safeCollateral <= 2**255, "GlobalSettlement/overflow");
        safeEngine.confiscateSAFECollateralAndDebt(
          collateralType,
          msg.sender,
          msg.sender,
          address(accountingEngine),
          -int256(safeCollateral),
          0
        );
        emit FreeCollateral(collateralType, msg.sender, -int256(safeCollateral));
    }
    
    function setOutstandingCoinSupply() external {
        require(contractEnabled == 0, "GlobalSettlement/contract-still-enabled");
        require(outstandingCoinSupply == 0, "GlobalSettlement/outstanding-coin-supply-not-zero");
        require(safeEngine.coinBalance(address(accountingEngine)) == 0, "GlobalSettlement/surplus-not-zero");
        require(now >= addition(shutdownTime, shutdownCooldown), "GlobalSettlement/shutdown-cooldown-not-finished");
        outstandingCoinSupply = safeEngine.globalDebt();
        emit SetOutstandingCoinSupply(outstandingCoinSupply);
    }
    
    function calculateCashPrice(bytes32 collateralType) external {
        require(outstandingCoinSupply != 0, "GlobalSettlement/outstanding-coin-supply-zero");
        require(collateralCashPrice[collateralType] == 0, "GlobalSettlement/collateral-cash-price-already-defined");

        (, uint256 accumulatedRate,,,,) = safeEngine.collateralTypes(collateralType);
        uint256 redemptionAdjustedDebt = rmultiply(
          rmultiply(collateralTotalDebt[collateralType], accumulatedRate), finalCoinPerCollateralPrice[collateralType]
        );
        collateralCashPrice[collateralType] =
          multiply(subtract(redemptionAdjustedDebt, collateralShortfall[collateralType]), RAY) / (outstandingCoinSupply / RAY);

        emit CalculateCashPrice(collateralType, collateralCashPrice[collateralType]);
    }
    
    function prepareCoinsForRedeeming(uint256 coinAmount) external {
        require(outstandingCoinSupply != 0, "GlobalSettlement/outstanding-coin-supply-zero");
        safeEngine.transferInternalCoins(msg.sender, address(accountingEngine), multiply(coinAmount, RAY));
        coinBag[msg.sender] = addition(coinBag[msg.sender], coinAmount);
        emit PrepareCoinsForRedeeming(msg.sender, coinBag[msg.sender]);
    }
    
    function redeemCollateral(bytes32 collateralType, uint256 coinsAmount) external {
        require(collateralCashPrice[collateralType] != 0, "GlobalSettlement/collateral-cash-price-not-defined");
        uint256 collateralAmount = rmultiply(coinsAmount, collateralCashPrice[collateralType]);
        safeEngine.transferCollateral(
          collateralType,
          address(this),
          msg.sender,
          collateralAmount
        );
        coinsUsedToRedeem[collateralType][msg.sender] = addition(coinsUsedToRedeem[collateralType][msg.sender], coinsAmount);
        require(coinsUsedToRedeem[collateralType][msg.sender] <= coinBag[msg.sender], "GlobalSettlement/insufficient-bag-balance");
        emit RedeemCollateral(collateralType, msg.sender, coinsAmount, collateralAmount);
    }
}