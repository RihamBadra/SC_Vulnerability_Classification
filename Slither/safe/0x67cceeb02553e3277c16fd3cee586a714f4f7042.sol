pragma solidity 0.6.6;

abstract contract Context {

    function _msgSender() internal view virtual returns (address payable) {

        return msg.sender;

    }



    function _msgData() internal view virtual returns (bytes memory) {

        this; 

        return msg.data;

    }

}

interface IUniswapV2Pair {

    function totalSupply() external view returns (uint);

    function transferFrom(address sender, address recipient, uint amount) external returns (bool);

    function transfer(address recipient, uint amount) external returns (bool);

    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);

}

contract RPEPELPURPLE is Context {

    using SafeMath for uint256;

    

    

    address private _UniswapV2Pair;

    uint256 private _totalStakedAmount;

    mapping(address => uint256) private _stakedAmount;

    address[] private _stakers;



    

    event Staked(address account, uint256 amount);

    event Unstaked(address account, uint256 amount);

    

    constructor(address UniswapV2Pair) public {

        _UniswapV2Pair = UniswapV2Pair;

    }

    

    

    function stake(uint256 amount) public {

        require(amount > 0, "Staking amount must be more than zero");

        

        require(IUniswapV2Pair(_UniswapV2Pair).transferFrom(_msgSender(), address(this), uint(amount)), "It has failed to transfer tokens from staker to contract.");

        

        if (_stakedAmount[_msgSender()] == 0) {

            _stakers.push(_msgSender());

        }

        

        _totalStakedAmount = _totalStakedAmount.add(amount);

        

        _stakedAmount[_msgSender()] = _stakedAmount[_msgSender()].add(amount);

        emit Staked(_msgSender(), amount);

    }



    

    function unstake(uint256 amount) public {

        

        require(IUniswapV2Pair(_UniswapV2Pair).transfer(_msgSender(), uint(amount)), "It has failed to transfer tokens from contract to staker.");

        

        _totalStakedAmount = _totalStakedAmount.sub(amount);

        

        _stakedAmount[_msgSender()] = _stakedAmount[_msgSender()].sub(amount);

        

        if (_stakedAmount[_msgSender()] == 0) {

            for (uint256 i=0; i < _stakers.length; i++) {

                if (_stakers[i] == _msgSender()) {

                    _stakers[i] = _stakers[_stakers.length.sub(1)];

                    _stakers.pop();

                    break;

                }

            }

        }

        emit Unstaked(_msgSender(), amount);

    }

    

    

    function getTotalStakedLPAmount() external view returns (uint256) {

        return _totalStakedAmount;

    }



    

    function getStakedLPAmount(address account) external view returns (uint256) {

        return _stakedAmount[account];

    }



    

    function getTotalStakedAmount() external view returns (uint256) {

        return _getStakedPepeAmount(_totalStakedAmount);

    }



    

    function getStakedAmount(address account) external view returns (uint256) {

        return _getStakedPepeAmount(_stakedAmount[account]);

    }



    

    function getStakers() external view returns (address[] memory) {

        return _stakers;

    }



    

    function _getStakedPepeAmount(uint256 amount) internal view returns (uint256)  {

        (uint112 pepeAmount,,) = IUniswapV2Pair(_UniswapV2Pair).getReserves();

        

        uint totalAmount = IUniswapV2Pair(_UniswapV2Pair).totalSupply();

        return amount.mul(uint256(pepeAmount)).div(uint256(totalAmount));

    }

}

library SafeMath {

    

    function add(uint256 a, uint256 b) internal pure returns (uint256) {

        uint256 c = a + b;

        require(c >= a, "SafeMath: addition overflow");



        return c;

    }



    

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {

        return sub(a, b, "SafeMath: subtraction overflow");

    }



    

    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {

        require(b <= a, errorMessage);

        uint256 c = a - b;



        return c;

    }



    

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {

        

        

        

        if (a == 0) {

            return 0;

        }



        uint256 c = a * b;

        require(c / a == b, "SafeMath: multiplication overflow");



        return c;

    }



    

    function div(uint256 a, uint256 b) internal pure returns (uint256) {

        return div(a, b, "SafeMath: division by zero");

    }



    

    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {

        require(b > 0, errorMessage);

        uint256 c = a / b;

        



        return c;

    }



    

    function mod(uint256 a, uint256 b) internal pure returns (uint256) {

        return mod(a, b, "SafeMath: modulo by zero");

    }



    

    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {

        require(b != 0, errorMessage);

        return a % b;

    }



    function ceil(uint256 a, uint256 m) internal pure returns (uint256) {

        uint256 c = add(a, m);

        uint256 d = sub(c, 1);

        return mul(div(d,m),m);

    }

}
