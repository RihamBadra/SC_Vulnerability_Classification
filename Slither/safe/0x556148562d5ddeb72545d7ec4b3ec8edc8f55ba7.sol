pragma solidity 0.7.1;

library Address {


    


    function isContract(address account) internal view returns (bool) {


        


        


        


        bytes32 codehash;


        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;


        


        assembly { codehash := extcodehash(account) }


        return (codehash != accountHash && codehash != 0x0);


    }





    


    function sendValue(address payable recipient, uint256 amount) internal {


        require(address(this).balance >= amount, "Address: insufficient balance");





        


        (bool success, ) = recipient.call{ value: amount }("");


        require(success, "Address: unable to send value, recipient may have reverted");


    }


}

abstract contract Context {


    


    


    constructor () { }





    function _msgSender() internal view virtual returns (address payable) {


        return msg.sender;


    }





    function _msgData() internal view virtual returns (bytes memory) {


        this; 


        return msg.data;


    }


}

interface IERC20 {


  function totalSupply() external view returns (uint256);





  function balanceOf(address who) external view returns (uint256);





  function allowance(address owner, address spender)


    external view returns (uint256);





  function transfer(address to, uint256 value) external returns (bool);





  function approve(address spender, uint256 value)


    external returns (bool);





  function transferFrom(address from, address to, uint256 value)


    external returns (bool);





  event Transfer(


    address indexed from,


    address indexed to,


    uint256 value


  );





  event Approval(


    address indexed owner,


    address indexed spender,


    uint256 value


  );


}

contract Ownable is Context {


    address private _owner;





    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);





    


    constructor () {


        address msgSender = _msgSender();


        _owner = msgSender;


        emit OwnershipTransferred(address(0), msgSender);


    }





    


    function owner() public view returns (address) {


        return _owner;


    }





    


    modifier onlyOwner() {


        require(_owner == _msgSender(), "Ownable: caller is not the owner");


        _;


    }





    


    function renounceOwnership() public virtual onlyOwner {


        emit OwnershipTransferred(_owner, address(0));


        _owner = address(0);


    }





    


    function transferOwnership(address newOwner) public virtual onlyOwner {


        require(newOwner != address(0), "Ownable: new owner is the zero address");


        emit OwnershipTransferred(_owner, newOwner);


        _owner = newOwner;


    }


}

interface PRDX_staking {


    function stake(address staker, uint256 amount) external returns (bool success);


}

interface PRDX_prediction {


    function predict(address user, uint256 amount, uint256 price, uint256 phase) external returns (bool success);


}

interface PRDX_tokendistr {


    function sell_PRDX(address user, uint256 amount) external returns (bool success); 


}

contract PredixNetwork is Context, IERC20, Ownable {


    using SafeMath for uint256;


    using Address for address;





    mapping (address => uint256) private _balances;





    mapping (address => mapping (address => uint256)) private _allowances;





    uint256 private _totalSupply;





    string private _name;


    string private _symbol;


    uint8 private _decimals;


    


    


    address public staking_addr ; 


    address public prediction_addr ;


    address public tokendistr_addr ; 


    


    


    PRDX_staking staking_contract = PRDX_staking(staking_addr) ; 


    PRDX_prediction prediction_contract = PRDX_prediction(prediction_addr) ; 


    PRDX_tokendistr tokendistr_contract = PRDX_tokendistr(tokendistr_addr) ;





    


    constructor () {


        _name = "Predix Network";


        _symbol = "PRDX";


        _decimals = 18;


        _mint(msg.sender, 1.6 * 1e6 * 10**_decimals); 


    }


    


    


    function set_staking_address(address addr) public onlyOwner {


        staking_addr = addr ; 


        staking_contract = PRDX_staking(staking_addr) ;


    }


    


    


    function set_prediction_address(address addr) public onlyOwner {


        prediction_addr = addr ; 


        prediction_contract = PRDX_prediction(prediction_addr) ;


    }


    


    


    function set_tokendistr_address(address addr) public onlyOwner {


        tokendistr_addr = addr ; 


        tokendistr_contract = PRDX_tokendistr(tokendistr_addr) ; 


    }


    


    


    function approveAndPredict(uint256 amount, uint256 price, uint256 phase) public returns (bool success) {


        require(balanceOf(msg.sender) >= amount, "Prediction amount exceeds user token balance") ; 


        _approve(msg.sender, prediction_addr, amount) ; 


        


        require(prediction_contract.predict(msg.sender, amount, price, phase)) ; 


        


        return true ; 


    }


    


    


    function approveAndStake(uint256 amount) public returns (bool success) {


        require(balanceOf(msg.sender) >= amount, "Staking amount exceeds user token balance") ;


        _approve(msg.sender, staking_addr, amount) ; 


        


        require(staking_contract.stake(msg.sender, amount)) ; 


        


        return true ; 


    }


    


    


    function approveAndSell(uint256 amount) public returns (bool success) {


        require(balanceOf(msg.sender) >= amount, "Sell amount exceeds user token balance") ;


        _approve(msg.sender, tokendistr_addr, amount) ; 


        


        require(tokendistr_contract.sell_PRDX(msg.sender, amount)) ; 


        return true ; 


    }


    





    


    function name() public view returns (string memory) {


        return _name;


    }





    


    function symbol() public view returns (string memory) {


        return _symbol;


    }





    


    function decimals() public view returns (uint8) {


        return _decimals;


    }





    


    function totalSupply() public view override returns (uint256) {


        return _totalSupply;


    }





    


    function balanceOf(address account) public view override returns (uint256) {


        return _balances[account];


    }





    


    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {


        _transfer(_msgSender(), recipient, amount);


        return true;


    }





    


    function allowance(address owner, address spender) public view virtual override returns (uint256) {


        return _allowances[owner][spender];


    }





    


    function approve(address spender, uint256 amount) public virtual override returns (bool) {


        _approve(_msgSender(), spender, amount);


        return true;


    }





    


    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {


        _transfer(sender, recipient, amount);


        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount));


        return true;


    }





    


    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {


        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));


        return true;


    }





    


    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {


        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue));


        return true;


    }





    


    function _transfer(address sender, address recipient, uint256 amount) internal virtual {


        require(sender != address(0), "ERC20: transfer from the zero address");


        require(recipient != address(0), "ERC20: transfer to the zero address");





        _beforeTokenTransfer(sender, recipient, amount);





        _balances[sender] = _balances[sender].sub(amount);


        _balances[recipient] = _balances[recipient].add(amount);


        emit Transfer(sender, recipient, amount);


    }





    


    function _mint(address account, uint256 amount) internal virtual {


        require(account != address(0), "ERC20: mint to the zero address");





        _beforeTokenTransfer(address(0), account, amount);





        _totalSupply = _totalSupply.add(amount);


        _balances[account] = _balances[account].add(amount);


        emit Transfer(address(0), account, amount);


    }





    


    function _burn(uint256 amount) public {


        require(msg.sender != address(0), "ERC20: burn from the zero address");





        _beforeTokenTransfer(msg.sender, address(0), amount);





        _balances[msg.sender] = _balances[msg.sender].sub(amount);


        _totalSupply = _totalSupply.sub(amount);


        emit Transfer(msg.sender, address(0), amount);


    }





    


    function _approve(address owner, address spender, uint256 amount) internal virtual {


        require(owner != address(0), "ERC20: approve from the zero address");


        require(spender != address(0), "ERC20: approve to the zero address");





        _allowances[owner][spender] = amount;


        emit Approval(owner, spender, amount);


    }





    


    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }


}

library SafeMath {





  


  function mul(uint256 a, uint256 b) internal pure returns (uint256) {


    


    


    


    if (a == 0) {


      return 0;


    }





    uint256 c = a * b;


    require(c / a == b);





    return c;


  }





  


  function div(uint256 a, uint256 b) internal pure returns (uint256) {


    require(b > 0); 


    uint256 c = a / b;


    





    return c;


  }





  


  function sub(uint256 a, uint256 b) internal pure returns (uint256) {


    require(b <= a);


    uint256 c = a - b;





    return c;


  }





  


  function add(uint256 a, uint256 b) internal pure returns (uint256) {


    uint256 c = a + b;


    require(c >= a);





    return c;


  }





  


  function mod(uint256 a, uint256 b) internal pure returns (uint256) {


    require(b != 0);


    return a % b;


  }


}
