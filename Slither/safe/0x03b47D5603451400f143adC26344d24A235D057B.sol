



pragma solidity 0.8.7;





interface INFTSet {
    function init(
        address owner,
        string memory name,
        string memory symbol
    ) external;
}




abstract contract Context {
    function _msgSender() internal view virtual returns (address) {
        return msg.sender;
    }

    function _msgData() internal view virtual returns (bytes calldata) {
        return msg.data;
    }
}



contract ProxyFactoryInitializable {
    event ProxyCreated(address indexed proxy, bytes returnData);

    function deployMinimal(address _logic, bytes memory _data) internal returns (address proxy, bytes memory returnData) {
        
        bytes20 targetBytes = bytes20(_logic);
        assembly {
            let clone := mload(0x40)
            mstore(clone, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)
            mstore(add(clone, 0x14), targetBytes)
            mstore(add(clone, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)
            proxy := create(0, clone, 0x37)
        }

        if (_data.length > 0) {
            bool success = false;
            (success, returnData) = proxy.call(_data);
            if (!success) {
                string memory _revertMsg = _getRevertMsg(returnData);
                revert(_revertMsg);
            }
        }

        emit ProxyCreated(address(proxy), returnData);
    }

    
    
    
    
    function _getRevertMsg(bytes memory _res) internal pure returns (string memory) {
        
        if (_res.length < 68) return "Transaction reverted silently";
        bytes memory revertData = slice(_res, 4, _res.length - 4); 
        return abi.decode(revertData, (string)); 
    }

    function slice(
        bytes memory _bytes,
        uint256 _start,
        uint256 _length
    ) internal pure returns (bytes memory) {
        require(_length + 31 >= _length, "slice_overflow");
        require(_start + _length >= _start, "slice_overflow");
        require(_bytes.length >= _start + _length, "slice_outOfBounds");

        bytes memory tempBytes;

        assembly {
            switch iszero(_length)
            case 0 {
                
                
                tempBytes := mload(0x40)

                
                
                
                
                
                
                
                
                let lengthmod := and(_length, 31)

                
                
                
                
                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))
                let end := add(mc, _length)

                for {
                    
                    
                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)
                } lt(mc, end) {
                    mc := add(mc, 0x20)
                    cc := add(cc, 0x20)
                } {
                    mstore(mc, mload(cc))
                }

                mstore(tempBytes, _length)

                
                
                mstore(0x40, and(add(mc, 31), not(31)))
            }
            
            default {
                tempBytes := mload(0x40)

                mstore(0x40, add(tempBytes, 0x20))
            }
        }

        return tempBytes;
    }
}




abstract contract Ownable is Context {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    
    constructor() {
        _setOwner(_msgSender());
    }

    
    function owner() public view virtual returns (address) {
        return _owner;
    }

    
    modifier onlyOwner() {
        require(owner() == _msgSender(), "Ownable: caller is not the owner");
        _;
    }

    
    function renounceOwnership() public virtual onlyOwner {
        _setOwner(address(0));
    }

    
    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), "Ownable: new owner is the zero address");
        _setOwner(newOwner);
    }

    function _setOwner(address newOwner) private {
        address oldOwner = _owner;
        _owner = newOwner;
        emit OwnershipTransferred(oldOwner, newOwner);
    }
}



contract NFTSetFactory is Ownable, ProxyFactoryInitializable {
    address public defaultLogic;

    constructor(address _defaultLogic) {
        _setDefaultLogic(_defaultLogic);
    }

    function _setDefaultLogic(address _defaultLogic) internal onlyOwner {
        defaultLogic = _defaultLogic;
    }

    function setDefaultLogic(address _defaultLogic) external onlyOwner {
        _setDefaultLogic(_defaultLogic);
    }

    function create(string memory name, string memory symbol) external returns (address proxy, bytes memory returnData) {
        bytes memory data = abi.encodeWithSelector(INFTSet(defaultLogic).init.selector, _msgSender(), name, symbol);

        (proxy, returnData) = deployMinimal(defaultLogic, data);
    }
}