pragma solidity 0.7.4;

contract LYNCToken {





    


    using SafeMath for uint256;





    


    string constant public name = "LYNC Network";


    string constant public symbol = "LYNC";


    uint8 constant public decimals = 18;





    


    address public owner;


    address public rewardPoolAddress;





    


    uint256 public maxTokenSupply = 1e24;   


    uint256 public feePercent = 1;          


    uint256 public feePercentMax = 10;      





    


    event Transfer(address indexed _from, address indexed _to, uint256 _tokens);


    event Approval(address indexed _owner,address indexed _spender, uint256 _tokens);


    event TranserFee(uint256 _tokens);


    event UpdateFee(uint256 _fee);


    event RewardPoolUpdated(address indexed _rewardPoolAddress, address indexed _newRewardPoolAddress);


    event OwnershipTransferred(address indexed _previousOwner, address indexed _newOwner);


    event OwnershipRenounced(address indexed _previousOwner, address indexed _newOwner);





    


    mapping(address => uint256) public balanceOf;


    mapping(address => mapping(address => uint256)) private allowances;





    


    constructor () {


        owner = msg.sender;


        rewardPoolAddress = address(this);


        balanceOf[msg.sender] = maxTokenSupply;


        emit Transfer(address(0), msg.sender, maxTokenSupply);


    }





    


    function totalSupply() public view returns (uint256) {


        return maxTokenSupply;


    }





    


    function transfer(address _to, uint256 _tokens) public returns (bool) {


        transferWithFee(msg.sender, _to, _tokens);


        return true;


    }





    


    function transferFrom(address _from, address _to, uint256 _tokens) public returns (bool) {


        require(_tokens <= balanceOf[_from], "Not enough tokens in the approved address balance");


        require(_tokens <= allowances[_from][msg.sender], "token amount is larger than the current allowance");


        transferWithFee(_from, _to, _tokens);


        allowances[_from][msg.sender] = allowances[_from][msg.sender].sub(_tokens);


        return true;


    }





    


    function approve(address _spender, uint256 _tokens) public returns (bool) {


        allowances[msg.sender][_spender] = _tokens;


        emit Approval(msg.sender, _spender, _tokens);


        return true;


    }





    


    function allowance(address _owner, address _spender) public view returns (uint256) {


        return allowances[_owner][_spender];


    }





    


    function transferWithFee(address _from, address _to, uint256 _tokens) internal returns (bool) {


        require(balanceOf[_from] >= _tokens, "Not enough tokens in the senders balance");


        uint256 _feeAmount = (_tokens.mul(feePercent)).div(100);


        balanceOf[_from] = balanceOf[_from].sub(_tokens);


        balanceOf[_to] = balanceOf[_to].add(_tokens.sub(_feeAmount));


        balanceOf[rewardPoolAddress] = balanceOf[rewardPoolAddress].add(_feeAmount);


        emit Transfer(_from, _to, _tokens.sub(_feeAmount));


        emit Transfer(_from, rewardPoolAddress, _feeAmount);


        emit TranserFee(_tokens);


        return true;


    }





    


    function updateFee(uint256 _updateFee) public onlyOwner {


        require(_updateFee <= feePercentMax, "Transaction fee cannot be greater than 10%");


        feePercent = _updateFee;


        emit UpdateFee(_updateFee);


    }





    


    function updateRewardPool(address _newRewardPoolAddress) public onlyOwner {


        require(_newRewardPoolAddress != address(0), "New reward pool address cannot be a zero address");


        rewardPoolAddress = _newRewardPoolAddress;


        emit RewardPoolUpdated(rewardPoolAddress, _newRewardPoolAddress);


    }





    


    function rewardPoolBalanceTransfer() public onlyOwner returns (bool) {


        uint256 _currentBalance = balanceOf[address(this)];


        transferWithFee(address(this), rewardPoolAddress, _currentBalance);


        return true;


    }





    


    function transferOwnership(address _newOwner) public onlyOwner {


        require(_newOwner != address(0), "New owner cannot be a zero address");


        emit OwnershipTransferred(owner, _newOwner);


        owner = _newOwner;


    }





    


    function renounceOwnership() public onlyOwner {


        emit OwnershipRenounced(owner, address(0));


        owner = address(0);


    }





    


    modifier onlyOwner() {


        require(owner == msg.sender, "Only current owner can call this function");


        _;


    }


}

contract LYNCTokenLock {





    


    using SafeMath for uint256;





    address public owner;


    address public contractAddress;


    uint256 public oneDay = 86400;      


    uint256 public currentLockTimer;    





    LYNCToken public tokenContract;





    


    event OwnershipTransferred(address indexed _previousOwner, address indexed _newOwner);


    event OwnershipRenounced(address indexed _previousOwner, address indexed _newOwner);





    


    constructor(LYNCToken _tokenContract) {


        owner = msg.sender;


        tokenContract = _tokenContract;


        contractAddress = address(this);


        currentLockTimer = block.timestamp;


    }





    


    function withdrawTokens(uint256 _numberOfTokens) public onlyOwner {


        require(block.timestamp > currentLockTimer, "Tokens are currently locked even to the contract admin");


        require(tokenContract.transfer(msg.sender, _numberOfTokens));


    }





    


    function increaseLock(uint256 _numberOfDays) public onlyOwner {


        uint256 _increaseLockDays = _numberOfDays.mul(oneDay);


        currentLockTimer = currentLockTimer.add(_increaseLockDays);


    }





    


    function transferOwnership(address _newOwner) public onlyOwner {


        require(_newOwner != address(0), "New owner cannot be a zero address");


        emit OwnershipTransferred(owner, _newOwner);


        owner = _newOwner;


    }





    


    function renounceOwnership() public onlyOwner {


        emit OwnershipRenounced(owner, address(0));


        owner = address(0);


    }





    


    modifier onlyOwner() {


        require(owner == msg.sender, "Only current owner can call this function");


        _;


    }


}

library SafeMath {


    


    function add(uint256 a, uint256 b) internal pure returns (uint256) {


        uint256 c = a + b;


        require(c >= a, "SafeMath: addition overflow");





        return c;


    }





    


    function sub(uint256 a, uint256 b) internal pure returns (uint256) {


        return sub(a, b, "SafeMath: subtraction overflow");


    }





    


    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {


        require(b <= a, errorMessage);


        uint256 c = a - b;





        return c;


    }





    


    function mul(uint256 a, uint256 b) internal pure returns (uint256) {


        


        


        


        if (a == 0) {


            return 0;


        }





        uint256 c = a * b;


        require(c / a == b, "SafeMath: multiplication overflow");





        return c;


    }





    


    function div(uint256 a, uint256 b) internal pure returns (uint256) {


        return div(a, b, "SafeMath: division by zero");


    }





    


    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {


        


        require(b > 0, errorMessage);


        uint256 c = a / b;


        





        return c;


    }





    


    function mod(uint256 a, uint256 b) internal pure returns (uint256) {


        return mod(a, b, "SafeMath: modulo by zero");


    }





    


    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {


        require(b != 0, errorMessage);


        return a % b;


    }


}
