pragma solidity 0.6.12;

abstract contract Context {

    function _msgSender() internal view virtual returns (address payable) {

        return msg.sender;

    }



    function _msgData() internal view virtual returns (bytes memory) {

        this; 

        return msg.data;

    }

}

interface IContractRegistry {



	event ContractAddressUpdated(string contractName, address addr, bool managedContract);

	event ManagerChanged(string role, address newManager);

	event ContractRegistryUpdated(address newContractRegistry);



	



	

	

	function setContract(string calldata contractName, address addr, bool managedContract) external ;



	

	function getContract(string calldata contractName) external view returns (address);



	

	function getManagedContracts() external view returns (address[] memory);



	function setManager(string calldata role, address manager) external ;



	function getManager(string calldata role) external view returns (address);



	function lockContracts() external ;



	function unlockContracts() external ;



	function setNewContractRegistry(IContractRegistry newRegistry) external ;



	function getPreviousContractRegistry() external view returns (address);



}

interface IElections {

	

	

	event StakeChanged(address indexed addr, uint256 selfStake, uint256 delegatedStake, uint256 effectiveStake);

	event GuardianStatusUpdated(address indexed guardian, bool readyToSync, bool readyForCommittee);



	

	event GuardianVotedUnready(address indexed guardian);

	event VoteUnreadyCasted(address indexed voter, address indexed subject, uint256 expiration);

	event GuardianVotedOut(address indexed guardian);

	event VoteOutCasted(address indexed voter, address indexed subject);



	



	

	function readyToSync() external;



	

	function readyForCommittee() external;



	

	function canJoinCommittee(address guardian) external view returns (bool);



	

	function getEffectiveStake(address guardian) external view returns (uint effectiveStake);



	

	

	function getCommittee() external view returns (address[] memory committee, uint256[] memory weights, address[] memory orbsAddrs, bool[] memory certification, bytes4[] memory ips);



	



	

	function voteUnready(address subject, uint expiration) external;



	function getVoteUnreadyVote(address voter, address subject) external view returns (bool valid, uint256 expiration);



	

	

	function getVoteUnreadyStatus(address subject) external view returns (

		address[] memory committee,

		uint256[] memory weights,

		bool[] memory certification,

		bool[] memory votes,

		bool subjectInCommittee,

		bool subjectInCertifiedCommittee

	);



	



	

	function voteOut(address subject) external;



	

	function getVoteOutVote(address voter) external view returns (address);



	

	

	function getVoteOutStatus(address subject) external view returns (bool votedOut, uint votedStake, uint totalDelegatedStake);



	



	

	

	

	function delegatedStakeChange(address delegate, uint256 selfStake, uint256 delegatedStake, uint256 totalDelegatedStake) external ;



	

	

	function guardianUnregistered(address guardian) external ;



	

	

	function guardianCertificationChanged(address guardian, bool isCertified) external ;





	



	event VoteUnreadyTimeoutSecondsChanged(uint32 newValue, uint32 oldValue);

	event VoteOutPercentMilleThresholdChanged(uint32 newValue, uint32 oldValue);

	event VoteUnreadyPercentMilleThresholdChanged(uint32 newValue, uint32 oldValue);

	event MinSelfStakePercentMilleChanged(uint32 newValue, uint32 oldValue);



	

	

	function setMinSelfStakePercentMille(uint32 minSelfStakePercentMille) external ;



	

	function getMinSelfStakePercentMille() external view returns (uint32);



	

	

	function setVoteOutPercentMilleThreshold(uint32 voteUnreadyPercentMilleThreshold) external ;



	

	function getVoteOutPercentMilleThreshold() external view returns (uint32);



	

	

	function setVoteUnreadyPercentMilleThreshold(uint32 voteUnreadyPercentMilleThreshold) external ;



	

	function getVoteUnreadyPercentMilleThreshold() external view returns (uint32);



	

	function getSettings() external view returns (

		uint32 minSelfStakePercentMille,

		uint32 voteUnreadyPercentMilleThreshold,

		uint32 voteOutPercentMilleThreshold

	);



	function initReadyForCommittee(address[] calldata guardians) external ;



}

interface IGuardiansRegistration {

	event GuardianRegistered(address indexed guardian);

	event GuardianUnregistered(address indexed guardian);

	event GuardianDataUpdated(address indexed guardian, bool isRegistered, bytes4 ip, address orbsAddr, string name, string website);

	event GuardianMetadataChanged(address indexed guardian, string key, string newValue, string oldValue);



	



    

	function registerGuardian(bytes4 ip, address orbsAddr, string calldata name, string calldata website) external;



    

	function updateGuardian(bytes4 ip, address orbsAddr, string calldata name, string calldata website) external;



	

	function updateGuardianIp(bytes4 ip) external ;



    

    function setMetadata(string calldata key, string calldata value) external;



    

    function getMetadata(address guardian, string calldata key) external view returns (string memory);



    

	function unregisterGuardian() external;



    

	function getGuardianData(address guardian) external view returns (bytes4 ip, address orbsAddr, string memory name, string memory website, uint registrationTime, uint lastUpdateTime);



	

	function getGuardiansOrbsAddress(address[] calldata guardianAddrs) external view returns (address[] memory orbsAddrs);



	

	function getGuardianIp(address guardian) external view returns (bytes4 ip);



	

	function getGuardianIps(address[] calldata guardian) external view returns (bytes4[] memory ips);



	

	function isRegistered(address guardian) external view returns (bool);



	

	function getGuardianAddresses(address[] calldata orbsAddrs) external view returns (address[] memory guardianAddrs);



	

	function resolveGuardianAddress(address guardianOrOrbsAddress) external view returns (address guardianAddress);



	



	function migrateGuardians(address[] calldata guardiansToMigrate, IGuardiansRegistration previousContract) external ;



}

interface ILockable {



    event Locked();

    event Unlocked();



    function lock() external ;

    function unlock() external ;

    function isLocked() view external returns (bool);



}

contract Initializable {



    address private _initializationAdmin;



    event InitializationComplete();



    constructor() public{

        _initializationAdmin = msg.sender;

    }



    modifier onlyInitializationAdmin() {

        require(msg.sender == initializationAdmin(), "sender is not the initialization admin");



        _;

    }



    



    function initializationAdmin() public view returns (address) {

        return _initializationAdmin;

    }



    function initializationComplete() external onlyInitializationAdmin {

        _initializationAdmin = address(0);

        emit InitializationComplete();

    }



    function isInitializationComplete() public view returns (bool) {

        return _initializationAdmin == address(0);

    }



}

contract WithClaimableRegistryManagement is Context {

    address private _registryAdmin;

    address private _pendingRegistryAdmin;



    event RegistryManagementTransferred(address indexed previousRegistryAdmin, address indexed newRegistryAdmin);



    

    constructor () internal {

        address msgSender = _msgSender();

        _registryAdmin = msgSender;

        emit RegistryManagementTransferred(address(0), msgSender);

    }



    

    function registryAdmin() public view returns (address) {

        return _registryAdmin;

    }



    

    modifier onlyRegistryAdmin() {

        require(isRegistryAdmin(), "WithClaimableRegistryManagement: caller is not the registryAdmin");

        _;

    }



    

    function isRegistryAdmin() public view returns (bool) {

        return _msgSender() == _registryAdmin;

    }



    

    function renounceRegistryManagement() public onlyRegistryAdmin {

        emit RegistryManagementTransferred(_registryAdmin, address(0));

        _registryAdmin = address(0);

    }



    

    function _transferRegistryManagement(address newRegistryAdmin) internal {

        require(newRegistryAdmin != address(0), "RegistryAdmin: new registryAdmin is the zero address");

        emit RegistryManagementTransferred(_registryAdmin, newRegistryAdmin);

        _registryAdmin = newRegistryAdmin;

    }



    

    modifier onlyPendingRegistryAdmin() {

        require(msg.sender == _pendingRegistryAdmin, "Caller is not the pending registryAdmin");

        _;

    }

    

    function transferRegistryManagement(address newRegistryAdmin) public onlyRegistryAdmin {

        _pendingRegistryAdmin = newRegistryAdmin;

    }



    

    function claimRegistryManagement() external onlyPendingRegistryAdmin {

        _transferRegistryManagement(_pendingRegistryAdmin);

        _pendingRegistryAdmin = address(0);

    }



    

    function pendingRegistryAdmin() public view returns (address) {

       return _pendingRegistryAdmin;  

    }

}

contract ContractRegistryAccessor is WithClaimableRegistryManagement, Initializable {



    IContractRegistry private contractRegistry;



    constructor(IContractRegistry _contractRegistry, address _registryAdmin) public {

        require(address(_contractRegistry) != address(0), "_contractRegistry cannot be 0");

        setContractRegistry(_contractRegistry);

        _transferRegistryManagement(_registryAdmin);

    }



    modifier onlyAdmin {

        require(isAdmin(), "sender is not an admin (registryManger or initializationAdmin)");



        _;

    }



    function isManager(string memory role) internal view returns (bool) {

        IContractRegistry _contractRegistry = contractRegistry;

        return isAdmin() || _contractRegistry != IContractRegistry(0) && contractRegistry.getManager(role) == msg.sender;

    }



    function isAdmin() internal view returns (bool) {

        return msg.sender == registryAdmin() || msg.sender == initializationAdmin() || msg.sender == address(contractRegistry);

    }



    function getProtocolContract() internal view returns (address) {

        return contractRegistry.getContract("protocol");

    }



    function getStakingRewardsContract() internal view returns (address) {

        return contractRegistry.getContract("stakingRewards");

    }



    function getFeesAndBootstrapRewardsContract() internal view returns (address) {

        return contractRegistry.getContract("feesAndBootstrapRewards");

    }



    function getCommitteeContract() internal view returns (address) {

        return contractRegistry.getContract("committee");

    }



    function getElectionsContract() internal view returns (address) {

        return contractRegistry.getContract("elections");

    }



    function getDelegationsContract() internal view returns (address) {

        return contractRegistry.getContract("delegations");

    }



    function getGuardiansRegistrationContract() internal view returns (address) {

        return contractRegistry.getContract("guardiansRegistration");

    }



    function getCertificationContract() internal view returns (address) {

        return contractRegistry.getContract("certification");

    }



    function getStakingContract() internal view returns (address) {

        return contractRegistry.getContract("staking");

    }



    function getSubscriptionsContract() internal view returns (address) {

        return contractRegistry.getContract("subscriptions");

    }



    function getStakingRewardsWallet() internal view returns (address) {

        return contractRegistry.getContract("stakingRewardsWallet");

    }



    function getBootstrapRewardsWallet() internal view returns (address) {

        return contractRegistry.getContract("bootstrapRewardsWallet");

    }



    function getGeneralFeesWallet() internal view returns (address) {

        return contractRegistry.getContract("generalFeesWallet");

    }



    function getCertifiedFeesWallet() internal view returns (address) {

        return contractRegistry.getContract("certifiedFeesWallet");

    }



    function getStakingContractHandler() internal view returns (address) {

        return contractRegistry.getContract("stakingContractHandler");

    }



    



    event ContractRegistryAddressUpdated(address addr);



    function setContractRegistry(IContractRegistry newContractRegistry) public onlyAdmin {

        require(newContractRegistry.getPreviousContractRegistry() == address(contractRegistry), "new contract registry must provide the previous contract registry");

        contractRegistry = newContractRegistry;

        emit ContractRegistryAddressUpdated(address(newContractRegistry));

    }



    function getContractRegistry() public view returns (IContractRegistry) {

        return contractRegistry;

    }



}

contract Lockable is ILockable, ContractRegistryAccessor {



    bool public locked;



    constructor(IContractRegistry _contractRegistry, address _registryAdmin) ContractRegistryAccessor(_contractRegistry, _registryAdmin) public {}



    modifier onlyLockOwner() {

        require(msg.sender == registryAdmin() || msg.sender == address(getContractRegistry()), "caller is not a lock owner");



        _;

    }



    function lock() external override onlyLockOwner {

        locked = true;

        emit Locked();

    }



    function unlock() external override onlyLockOwner {

        locked = false;

        emit Unlocked();

    }



    function isLocked() external override view returns (bool) {

        return locked;

    }



    modifier onlyWhenActive() {

        require(!locked, "contract is locked for this operation");



        _;

    }

}

contract ManagedContract is Lockable {



    constructor(IContractRegistry _contractRegistry, address _registryAdmin) Lockable(_contractRegistry, _registryAdmin) public {}



    modifier onlyMigrationManager {

        require(isManager("migrationManager"), "sender is not the migration manager");



        _;

    }



    modifier onlyFunctionalManager {

        require(isManager("functionalManager"), "sender is not the functional manager");



        _;

    }



    function refreshContracts() virtual external {}



}

contract GuardiansRegistration is IGuardiansRegistration, ManagedContract {



	struct Guardian {

		address orbsAddr;

		bytes4 ip;

		uint32 registrationTime;

		uint32 lastUpdateTime;

		string name;

		string website;

	}

	mapping(address => Guardian) guardians;

	mapping(address => address) orbsAddressToGuardianAddress;

	mapping(bytes4 => address) public ipToGuardian;

	mapping(address => mapping(string => string)) guardianMetadata;



	constructor(IContractRegistry _contractRegistry, address _registryAdmin) ManagedContract(_contractRegistry, _registryAdmin) public {}



	modifier onlyRegisteredGuardian {

		require(isRegistered(msg.sender), "Guardian is not registered");



		_;

	}



	



    

	function registerGuardian(bytes4 ip, address orbsAddr, string calldata name, string calldata website) external override onlyWhenActive {

		require(!isRegistered(msg.sender), "registerGuardian: Guardian is already registered");



		guardians[msg.sender].registrationTime = uint32(block.timestamp);

		emit GuardianRegistered(msg.sender);



		_updateGuardian(msg.sender, ip, orbsAddr, name, website);

	}



    

	function updateGuardian(bytes4 ip, address orbsAddr, string calldata name, string calldata website) external override onlyRegisteredGuardian onlyWhenActive {

		_updateGuardian(msg.sender, ip, orbsAddr, name, website);

	}



	function updateGuardianIp(bytes4 ip) external override onlyWhenActive {

		address guardianAddr = resolveGuardianAddress(msg.sender);

		Guardian memory data = guardians[guardianAddr];

		_updateGuardian(guardianAddr, ip, data.orbsAddr, data.name, data.website);

	}



    

    function setMetadata(string calldata key, string calldata value) external override onlyRegisteredGuardian onlyWhenActive {

		_setMetadata(msg.sender, key, value);

	}



	function getMetadata(address guardian, string calldata key) external override view returns (string memory) {

		return guardianMetadata[guardian][key];

	}



	

	function unregisterGuardian() external override onlyRegisteredGuardian onlyWhenActive {

		delete orbsAddressToGuardianAddress[guardians[msg.sender].orbsAddr];

		delete ipToGuardian[guardians[msg.sender].ip];

		Guardian memory guardian = guardians[msg.sender];

		delete guardians[msg.sender];



		electionsContract.guardianUnregistered(msg.sender);

		emit GuardianDataUpdated(msg.sender, false, guardian.ip, guardian.orbsAddr, guardian.name, guardian.website);

		emit GuardianUnregistered(msg.sender);

	}



    

	function getGuardianData(address guardian) external override view returns (bytes4 ip, address orbsAddr, string memory name, string memory website, uint registrationTime, uint lastUpdateTime) {

		Guardian memory v = guardians[guardian];

		return (v.ip, v.orbsAddr, v.name, v.website, v.registrationTime, v.lastUpdateTime);

	}



	function getGuardiansOrbsAddress(address[] calldata guardianAddrs) external override view returns (address[] memory orbsAddrs) {

		orbsAddrs = new address[](guardianAddrs.length);

		for (uint i = 0; i < guardianAddrs.length; i++) {

			orbsAddrs[i] = guardians[guardianAddrs[i]].orbsAddr;

		}

	}



	function getGuardianIp(address guardian) external override view returns (bytes4 ip) {

		return guardians[guardian].ip;

	}



	function getGuardianIps(address[] calldata guardianAddrs) external override view returns (bytes4[] memory ips) {

		ips = new bytes4[](guardianAddrs.length);

		for (uint i = 0; i < guardianAddrs.length; i++) {

			ips[i] = guardians[guardianAddrs[i]].ip;

		}

	}



	function isRegistered(address guardian) public override view returns (bool) {

		return guardians[guardian].registrationTime != 0;

	}



	function resolveGuardianAddress(address guardianOrOrbsAddress) public override view returns (address guardianAddress) {

		if (isRegistered(guardianOrOrbsAddress)) {

			guardianAddress = guardianOrOrbsAddress;

		} else {

			guardianAddress = orbsAddressToGuardianAddress[guardianOrOrbsAddress];

		}



		require(guardianAddress != address(0), "Cannot resolve address");

	}



	

	function getGuardianAddresses(address[] calldata orbsAddrs) external override view returns (address[] memory guardianAddrs) {

		guardianAddrs = new address[](orbsAddrs.length);

		for (uint i = 0; i < orbsAddrs.length; i++) {

			guardianAddrs[i] = orbsAddressToGuardianAddress[orbsAddrs[i]];

		}

	}



	



	function migrateGuardians(address[] calldata guardiansToMigrate, IGuardiansRegistration previousContract) external override onlyInitializationAdmin {

		require(previousContract != IGuardiansRegistration(0), "previousContract must not be the zero address");



		for (uint i = 0; i < guardiansToMigrate.length; i++) {

			require(guardiansToMigrate[i] != address(0), "guardian must not be the zero address");

			migrateGuardianData(previousContract, guardiansToMigrate[i]);

			migrateGuardianMetadata(previousContract, guardiansToMigrate[i]);

		}

	}



	



	function _updateGuardian(address guardianAddr, bytes4 ip, address orbsAddr, string memory name, string memory website) private {

		require(orbsAddr != address(0), "orbs address must be non zero");

		require(orbsAddr != guardianAddr, "orbs address must be different than the guardian address");

		require(!isRegistered(orbsAddr), "orbs address must not be a guardian address of a registered guardian");

		require(bytes(name).length != 0, "name must be given");



		delete ipToGuardian[guardians[guardianAddr].ip];

		require(ipToGuardian[ip] == address(0), "ip is already in use");

		ipToGuardian[ip] = guardianAddr;



		delete orbsAddressToGuardianAddress[guardians[guardianAddr].orbsAddr];

		require(orbsAddressToGuardianAddress[orbsAddr] == address(0), "orbs address is already in use");

		orbsAddressToGuardianAddress[orbsAddr] = guardianAddr;



		guardians[guardianAddr].orbsAddr = orbsAddr;

		guardians[guardianAddr].ip = ip;

		guardians[guardianAddr].name = name;

		guardians[guardianAddr].website = website;

		guardians[guardianAddr].lastUpdateTime = uint32(block.timestamp);



        emit GuardianDataUpdated(guardianAddr, true, ip, orbsAddr, name, website);

    }



	function _setMetadata(address guardian, string memory key, string memory value) private {

		string memory oldValue = guardianMetadata[guardian][key];

		guardianMetadata[guardian][key] = value;

		emit GuardianMetadataChanged(guardian, key, value, oldValue);

	}



	function migrateGuardianData(IGuardiansRegistration previousContract, address guardianAddress) private {

		(bytes4 ip, address orbsAddr, string memory name, string memory website, uint registrationTime, uint lastUpdateTime) = previousContract.getGuardianData(guardianAddress);

		guardians[guardianAddress] = Guardian({

			orbsAddr: orbsAddr,

			ip: ip,

			name: name,

			website: website,

			registrationTime: uint32(registrationTime),

			lastUpdateTime: uint32(lastUpdateTime)

		});

		orbsAddressToGuardianAddress[orbsAddr] = guardianAddress;

		ipToGuardian[ip] = guardianAddress;



		emit GuardianDataUpdated(guardianAddress, true, ip, orbsAddr, name, website);

	}



	string public constant ID_FORM_URL_METADATA_KEY = "ID_FORM_URL";

	function migrateGuardianMetadata(IGuardiansRegistration previousContract, address guardianAddress) private {

		string memory rewardsFreqMetadata = previousContract.getMetadata(guardianAddress, ID_FORM_URL_METADATA_KEY);

		if (bytes(rewardsFreqMetadata).length > 0) {

			_setMetadata(guardianAddress, ID_FORM_URL_METADATA_KEY, rewardsFreqMetadata);

		}

	}



	



	IElections electionsContract;

	function refreshContracts() external override {

		electionsContract = IElections(getElectionsContract());

	}



}
