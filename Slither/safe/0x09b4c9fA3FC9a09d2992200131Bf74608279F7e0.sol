






pragma solidity ^0.8.0;


abstract contract Context {
    function _msgSender() internal view virtual returns (address) {
        return msg.sender;
    }

    function _msgData() internal view virtual returns (bytes calldata) {
        return msg.data;
    }
}





pragma solidity ^0.8.0;


abstract contract Ownable is Context {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    
    constructor() {
        _setOwner(_msgSender());
    }

    
    function owner() public view virtual returns (address) {
        return _owner;
    }

    
    modifier onlyOwner() {
        require(owner() == _msgSender(), "Ownable: caller is not the owner");
        _;
    }

    
    function renounceOwnership() public virtual onlyOwner {
        _setOwner(address(0));
    }

    
    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), "Ownable: new owner is the zero address");
        _setOwner(newOwner);
    }

    function _setOwner(address newOwner) private {
        address oldOwner = _owner;
        _owner = newOwner;
        emit OwnershipTransferred(oldOwner, newOwner);
    }
}





pragma solidity ^0.8.0;


interface IERC165 {
    
    function supportsInterface(bytes4 interfaceId) external view returns (bool);
}





pragma solidity ^0.8.0;


interface IERC721 is IERC165 {
    
    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);

    
    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);

    
    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);

    
    function balanceOf(address owner) external view returns (uint256 balance);

    
    function ownerOf(uint256 tokenId) external view returns (address owner);

    
    function safeTransferFrom(
        address from,
        address to,
        uint256 tokenId
    ) external;

    
    function transferFrom(
        address from,
        address to,
        uint256 tokenId
    ) external;

    
    function approve(address to, uint256 tokenId) external;

    
    function getApproved(uint256 tokenId) external view returns (address operator);

    
    function setApprovalForAll(address operator, bool _approved) external;

    
    function isApprovedForAll(address owner, address operator) external view returns (bool);

    
    function safeTransferFrom(
        address from,
        address to,
        uint256 tokenId,
        bytes calldata data
    ) external;
}





pragma solidity ^0.8.0;


library MerkleProof {
    
    function verify(
        bytes32[] memory proof,
        bytes32 root,
        bytes32 leaf
    ) internal pure returns (bool) {
        bytes32 computedHash = leaf;

        for (uint256 i = 0; i < proof.length; i++) {
            bytes32 proofElement = proof[i];

            if (computedHash <= proofElement) {
                
                computedHash = keccak256(abi.encodePacked(computedHash, proofElement));
            } else {
                
                computedHash = keccak256(abi.encodePacked(proofElement, computedHash));
            }
        }

        
        return computedHash == root;
    }
}




pragma solidity ^0.8.0;



contract RingDrop is Ownable {
  bytes32 public merkleRoot;

  address public rings;

  bool public paused;

  mapping(address => bool) public claimed;

  event RingClaimed(address sender, uint256 tokenId);

  constructor(bytes32 _root, address _rings) {
    merkleRoot = _root;
    rings = _rings;
  }

  function setMerkleRoot(bytes32 root) public onlyOwner {
    merkleRoot = root;
  }

  function setRings(address _rings) public onlyOwner {
    rings = _rings;
  }

  function setPaused(bool _paused) public onlyOwner {
    paused = _paused;
  }

  function claimRing(bytes32[] memory proof, uint256 tokenId) public {
    require(!paused, "paused");
    require(claimed[msg.sender] == false, "sender already claimed");

    address tokenOwner = IERC721(rings).ownerOf(tokenId);
    require(tokenOwner == owner(), "token not available");
    
    require(
      MerkleProof.verify(
        proof,
        merkleRoot,
        keccak256(abi.encodePacked(msg.sender))
      ),
      "bad proof"
    );


    claimed[msg.sender] = true;
    IERC721(rings).transferFrom(tokenOwner, msg.sender, tokenId);

    emit RingClaimed(msg.sender, tokenId);
  }
}