pragma solidity 0.5.15;

contract IFactRegistry {

    

    function isValid(bytes32 fact)

        external view

        returns(bool);

}

contract IQueryableFactRegistry is IFactRegistry {



    

    function hasRegisteredFact()

        external view

        returns(bool);



}

contract Identity {



    

    function identify()

        external pure

        returns(string memory);

}

contract FactRegistry is IQueryableFactRegistry {

    

    mapping (bytes32 => bool) private verifiedFact;



    

    bool anyFactRegistered;



    

    function isValid(bytes32 fact)

        external view

        returns(bool)

    {

        return _factCheck(fact);

    }





    

    function _factCheck(bytes32 fact)

        internal view

        returns(bool)

    {

        return verifiedFact[fact];

    }



    function registerFact(

        bytes32 factHash

        )

        internal

    {

        

        verifiedFact[factHash] = true;



        

        if (!anyFactRegistered) {

            anyFactRegistered = true;

        }

    }



    

    function hasRegisteredFact()

        external view

        returns(bool)

    {

        return anyFactRegistered;

    }



}

contract Committee is FactRegistry, Identity {



    uint256 constant SIGNATURE_LENGTH = 32 * 2 + 1; 

    uint256 public signaturesRequired;

    mapping (address => bool) public isMember;



    

    

    

    constructor (address[] memory committeeMembers, uint256 numSignaturesRequired)

        public

    {

        require(numSignaturesRequired <= committeeMembers.length, "TOO_MANY_REQUIRED_SIGNATURES");

        for (uint256 idx = 0; idx < committeeMembers.length; idx++) {

            require(!isMember[committeeMembers[idx]], "NON_UNIQUE_COMMITTEE_MEMBERS");

            isMember[committeeMembers[idx]] = true;

        }

        signaturesRequired = numSignaturesRequired;

    }



    function identify()

        external pure

        returns(string memory)

    {

        return "StarkWare_Committee_2019_1";

    }



    

    

    

    

    

    

    

    

    

    

    

    

    

    function verifyAvailabilityProof(

        bytes32 claimHash,

        bytes calldata availabilityProofs

    )

        external

    {

        require(

            availabilityProofs.length >= signaturesRequired * SIGNATURE_LENGTH,

            "INVALID_AVAILABILITY_PROOF_LENGTH");



        uint256 offset = 0;

        address prevRecoveredAddress = address(0);

        for (uint256 proofIdx = 0; proofIdx < signaturesRequired; proofIdx++) {

            bytes32 r = bytesToBytes32(availabilityProofs, offset);

            bytes32 s = bytesToBytes32(availabilityProofs, offset + 32);

            uint8 v = uint8(availabilityProofs[offset + 64]);

            offset += SIGNATURE_LENGTH;

            address recovered = ecrecover(

                claimHash,

                v,

                r,

                s

            );

            

            

            require(isMember[recovered], "AVAILABILITY_PROVER_NOT_IN_COMMITTEE");

            require(recovered > prevRecoveredAddress, "NON_SORTED_SIGNATURES");

            prevRecoveredAddress = recovered;

        }

        registerFact(claimHash);

    }



    function bytesToBytes32(bytes memory array, uint256 offset)

        private pure

        returns (bytes32 result) {

        

        uint256 actualOffset = offset + 32;



        

        

        assembly {

            result := mload(add(array, actualOffset))

        }

    }

}
