pragma solidity 0.6.8;
pragma experimental ABIEncoderV2;

interface IERC20 {

    

    function totalSupply() external view returns (uint256);



    

    function balanceOf(address account) external view returns (uint256);



    

    function transfer(address recipient, uint256 amount) external returns (bool);



    

    function allowance(address owner, address spender) external view returns (uint256);



    

    function approve(address spender, uint256 amount) external returns (bool);



    

    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);



    

    event Transfer(address indexed from, address indexed to, uint256 value);



    

    event Approval(address indexed owner, address indexed spender, uint256 value);

}

library MerkleProof {

    

    function verify(bytes32[] memory proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {

        bytes32 computedHash = leaf;



        for (uint256 i = 0; i < proof.length; i++) {

            bytes32 proofElement = proof[i];



            if (computedHash <= proofElement) {

                

                computedHash = keccak256(abi.encodePacked(computedHash, proofElement));

            } else {

                

                computedHash = keccak256(abi.encodePacked(proofElement, computedHash));

            }

        }



        

        return computedHash == root;

    }

}

abstract contract Context {

    function _msgSender() internal view virtual returns (address payable) {

        return msg.sender;

    }



    function _msgData() internal view virtual returns (bytes memory) {

        this; 

        return msg.data;

    }

}

contract Ownable is Context {

    address private _owner;



    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);



    

    constructor () internal {

        address msgSender = _msgSender();

        _owner = msgSender;

        emit OwnershipTransferred(address(0), msgSender);

    }



    

    function owner() public view returns (address) {

        return _owner;

    }



    

    modifier onlyOwner() {

        require(_owner == _msgSender(), "Ownable: caller is not the owner");

        _;

    }



    

    function renounceOwnership() public virtual onlyOwner {

        emit OwnershipTransferred(_owner, address(0));

        _owner = address(0);

    }



    

    function transferOwnership(address newOwner) public virtual onlyOwner {

        require(newOwner != address(0), "Ownable: new owner is the zero address");

        emit OwnershipTransferred(_owner, newOwner);

        _owner = newOwner;

    }

}

contract MerkleRedeem is Ownable {



    IERC20 public token;



    event Claimed(address _claimant, uint256 _balance);



    

    mapping(uint => bytes32) public weekMerkleRoots;

    mapping(uint => mapping(address => bool)) public claimed;



    constructor(

        address _token

    ) public {

        token = IERC20(_token);

    }



    function disburse(

        address _liquidityProvider,

        uint _balance

    )

        private

    {

        if (_balance > 0) {

            emit Claimed(_liquidityProvider, _balance);

            require(token.transfer(_liquidityProvider, _balance), "ERR_TRANSFER_FAILED");

        }

    }



    function claimWeek(

        address _liquidityProvider,

        uint _week,

        uint _claimedBalance,

        bytes32[] memory _merkleProof

    )

        public

    {

        require(!claimed[_week][_liquidityProvider]);

        require(verifyClaim(_liquidityProvider, _week, _claimedBalance, _merkleProof), 'Incorrect merkle proof');



        claimed[_week][_liquidityProvider] = true;

        disburse(_liquidityProvider, _claimedBalance);

    }



    struct Claim {

        uint week;

        uint balance;

        bytes32[] merkleProof;

    }



    function claimWeeks(

        address _liquidityProvider,

        Claim[] memory claims

    )

        public

    {

        uint totalBalance = 0;

        Claim memory claim ;

        for(uint i = 0; i < claims.length; i++) {

            claim = claims[i];



            require(!claimed[claim.week][_liquidityProvider]);

            require(verifyClaim(_liquidityProvider, claim.week, claim.balance, claim.merkleProof), 'Incorrect merkle proof');



            totalBalance += claim.balance;

            claimed[claim.week][_liquidityProvider] = true;

        }

        disburse(_liquidityProvider, totalBalance);

    }



    function claimStatus(

        address _liquidityProvider,

        uint _begin,

        uint _end

    )

        external

        view

        returns (bool[] memory)

    {

        uint size = 1 + _end - _begin;

        bool[] memory arr = new bool[](size);

        for(uint i = 0; i < size; i++) {

            arr[i] = claimed[_begin + i][_liquidityProvider];

        }

        return arr;

    }



    function merkleRoots(

        uint _begin,

        uint _end

    ) 

        external

        view 

        returns (bytes32[] memory)

    {

        uint size = 1 + _end - _begin;

        bytes32[] memory arr = new bytes32[](size);

        for(uint i = 0; i < size; i++) {

            arr[i] = weekMerkleRoots[_begin + i];

        }

        return arr;

    }



    function verifyClaim(

        address _liquidityProvider,

        uint _week,

        uint _claimedBalance,

        bytes32[] memory _merkleProof

    )

        public

        view

        returns (bool valid)

    {

        bytes32 leaf = keccak256(abi.encodePacked(_liquidityProvider, _claimedBalance));

        return MerkleProof.verify(_merkleProof, weekMerkleRoots[_week], leaf);

    }



    function seedAllocations(

        uint _week,

        bytes32 _merkleRoot,

        uint _totalAllocation

    )

        external

        onlyOwner

    {

        require(weekMerkleRoots[_week] == bytes32(0), "cannot rewrite merkle root");

        weekMerkleRoots[_week] = _merkleRoot;



        require(token.transferFrom(msg.sender, address(this), _totalAllocation), "ERR_TRANSFER_FAILED");

    }

}
