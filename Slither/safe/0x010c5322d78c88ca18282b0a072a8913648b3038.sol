pragma solidity 0.6.5;
pragma experimental ABIEncoderV2;

struct UserInfo {

    uint256 amount;

    uint256 rewardDebt;

}

struct PoolInfo {

    address lpToken;

    uint256 allocPoint;

    uint256 lastRewardBlock;

    uint256 accSushiPerShare;

}

interface ProtocolAdapter {



    

    function adapterType() external pure returns (string memory);



    

    function tokenType() external pure returns (string memory);



    

    function getBalance(address token, address account) external view returns (uint256);

}

interface MasterChef {

    function poolLength() external view returns (uint256);

    function poolInfo(uint256) external view returns (PoolInfo memory);

    function userInfo(uint256, address) external view returns (UserInfo memory);

    function pendingSashimi(uint256, address) external view returns (uint256);

}

contract SashimiStakingAdapter is ProtocolAdapter {



    string public constant override adapterType = "Asset";



    string public constant override tokenType = "ERC20";



    address internal constant SASHIMI = 0xC28E27870558cF22ADD83540d2126da2e4b464c2;

    address internal constant MASTER_CHEF = 0x1DaeD74ed1dD7C9Dabbe51361ac90A69d851234D;



    

    function getBalance(address token, address account) external view override returns (uint256) {

        uint256 length = MasterChef(MASTER_CHEF).poolLength();



        if (token == SASHIMI) {

            uint256 totalRewards = 0;



            for(uint256 i = 0; i < length; i++) {

                totalRewards += MasterChef(MASTER_CHEF).pendingSashimi(i, account);

            }



            return totalRewards;

        } else {

            for(uint256 i = 0; i < length; i++) {

                UserInfo memory user = MasterChef(MASTER_CHEF).userInfo(i, account);

                PoolInfo memory pool = MasterChef(MASTER_CHEF).poolInfo(i);



                if (pool.lpToken == token) {

                    return user.amount;

                }

            }



            return 0;

        }

    }

}
