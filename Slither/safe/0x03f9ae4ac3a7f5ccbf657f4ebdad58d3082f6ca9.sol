




pragma solidity >=0.8.3 <0.9.0;


interface ERC721TokenReceiver {
  function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes calldata _data) external returns(bytes4);
}


contract ERC721Token {
    
    event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);
  
    
    event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);

    
    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);

    uint256 internal count = 0;
    uint256 internal burned = 0;
    mapping (uint256 => address) internal owners;
    mapping (uint256 => string) internal tokenURIs;
    mapping (uint256 => address) internal approveds;
    mapping (address => mapping (address => bool)) internal operators;
    
    
    mapping (address => uint256) internal balances;
    
    
    mapping (string => bool) internal usedTokenURIs;
    
    
    constructor() {}
    
    function mint(string calldata _tokenURI) public returns (uint256) {
        uint256 oldCount = count;
        count++;
        require(count > oldCount && bytes(_tokenURI).length > 0 && usedTokenURIs[_tokenURI] != true);

        owners[count] = msg.sender;
        balances[msg.sender]++;
        tokenURIs[count] = _tokenURI;
        usedTokenURIs[_tokenURI] = true;
        emit Transfer(address(0), msg.sender, count);
        return count;
    }
    
    function burn(uint256 _tokenId) public {
        address _owner = owners[_tokenId];
        require(
            _owner != address(0) && 
            (msg.sender == _owner || operators[_owner][msg.sender] || msg.sender == approveds[_tokenId])
        );
        owners[_tokenId] = address(0);
        balances[_owner]--;
        approveds[_tokenId] = address(0);
        burned++;
        emit Transfer(_owner, address(0), _tokenId);
    }

    function name() public pure returns (string memory) {
        return "NFTs 4 All";
    }

    function symbol() public pure returns (string memory) {
        return "";
    }
    
    function decimals() public pure returns (uint8) {
        return 0;
    }
    
    function totalSupply() public view returns (uint256) {
        return count - burned;
    }

    
    function tokenURI(uint256 _tokenId) public view returns (string memory) {
        string memory _tokenURI = tokenURIs[_tokenId];
        require(bytes(_tokenURI).length != 0);
        return _tokenURI;
    }

    
    function balanceOf(address _owner) public view returns (uint256) {
        require(_owner != address(0));
        return balances[_owner];
    }

    
    function ownerOf(uint256 _tokenId) public view returns (address) {
        address _owner = owners[_tokenId];
        require(_owner != address(0));
        return _owner;
    }

    
    function approve(address _approved, uint256 _tokenId) public {
        address _owner = owners[_tokenId];
        require(_owner != address(0) && (msg.sender == _owner || operators[_owner][msg.sender]));
        approveds[_tokenId] = _approved;
        emit Approval(_owner, _approved, _tokenId);
    }
    
    
    function getApproved(uint256 _tokenId) public view returns (address) {
        address _owner = owners[_tokenId];
        require(_owner != address(0));
        address _approved = approveds[_tokenId];
        return _approved;
    }

    
    function transferFrom(address _from, address _to, uint256 _tokenId) public {
        address _owner = owners[_tokenId];
        require(
            _owner != address(0) && 
            (msg.sender == _owner || operators[_owner][msg.sender] || msg.sender == approveds[_tokenId]) &&
            _from == _owner && 
            _to != address(0)
        );
        owners[_tokenId] = _to;
        balances[_from]--;
        balances[_to]++;
        approveds[_tokenId] = address(0);
        emit Transfer(_from, _to, _tokenId);
    }

    
    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes calldata _data) public {
        _safeTransferFrom(_from, _to, _tokenId, _data);
    }
    
    
    function safeTransferFrom(address _from, address _to, uint256 _tokenId) public {
        _safeTransferFrom(_from, _to, _tokenId, "");
    }

    function _safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes memory _data) private {
        transferFrom(_from, _to, _tokenId);
        
        if (isContract(_to)) {
            bytes4 retval = ERC721TokenReceiver(_to).onERC721Received(msg.sender, _from, _tokenId, _data);
            
            
            require(retval == 0x150b7a02);
        }
    }

    
    function setApprovalForAll(address _operator, bool _approved) public {
        operators[msg.sender][_operator] = _approved;
        emit ApprovalForAll(msg.sender, _operator, _approved);
    }
    
    
    function isApprovedForAll(address _owner, address _operator) public view returns (bool) {
        return operators[_owner][_operator];
    }
    
    
    function supportsInterface(bytes4 _interfaceID) public pure returns (bool) {
        
        
        return _interfaceID == 0x80ac58cd || _interfaceID == 0x01ffc9a7;
    }
    
    
    function isContract(address _addr) private view returns (bool addressCheck) {
        
        
        
        
        
        
        
        bytes32 codehash;
        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;
        assembly { codehash := extcodehash(_addr) } 
        addressCheck = (codehash != 0x0 && codehash != accountHash);
    }

}


